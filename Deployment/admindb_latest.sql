/*

	REFERENCE:
		- License, documentation, and source code at: 
			https://github.com/overachiever-productions/s4/

	NOTES:
		- This script will either install/deploy S4 version 12.0.4707.7 or upgrade a PREVIOUSLY deployed version of S4 to 12.0.4707.7.
		- This script will create a new, admindb, if one is not already present on the server where this code is being run.

	Deployment Steps/Overview: 
		1. Create admindb if not already present.
		2. Create core S4 tables (and/or ALTER as needed + import data from any previous versions as needed). 
		3. Cleanup any code/objects from previous versions of S4 installed and no longer needed. 
		4. Deploy S4 version 12.0.4707.7 code to admindb (overwriting any previous versions). 
		5. Report on current + any previous versions of S4 installed. 

*/

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 1. Create admindb if/as needed: 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SET NOCOUNT ON;

USE [master];
GO

IF NOT EXISTS (SELECT NULL FROM master.sys.databases WHERE [name] = 'admindb') BEGIN
	CREATE DATABASE [admindb];  -- TODO: look at potentially defining growth size details - based upon what is going on with model/etc. 

	ALTER AUTHORIZATION ON DATABASE::[admindb] TO sa;

	ALTER DATABASE [admindb] SET RECOVERY SIMPLE;  -- i.e., treat like master/etc. 
END;
GO

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 2. Core Tables:
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

USE [admindb];
GO

IF OBJECT_ID('version_history', 'U') IS NULL BEGIN

	CREATE TABLE dbo.version_history (
		version_id int IDENTITY(1,1) NOT NULL, 
		version_number varchar(20) NOT NULL, 
		[description] nvarchar(200) NULL, 
		deployed datetime NOT NULL CONSTRAINT DF_version_info_deployed DEFAULT GETDATE(), 
		CONSTRAINT PK_version_info PRIMARY KEY CLUSTERED (version_id)
	);

	EXEC sys.sp_addextendedproperty
		@name = 'S4',
		@value = 'TRUE',
		@level0type = 'Schema',
		@level0name = 'dbo',
		@level1type = 'Table',
		@level1name = 'version_history';
END;

DECLARE @CurrentVersion varchar(20) = N'12.0.4707.7';

-- Add previous details if any are present: 
DECLARE @version sysname; 
DECLARE @objectId int;
DECLARE @createDate datetime;
SELECT @objectId = [object_id], @createDate = create_date FROM master.sys.objects WHERE [name] = N'dba_DatabaseBackups_Log';
SELECT @version = CAST([value] AS sysname) FROM master.sys.extended_properties WHERE major_id = @objectId AND [name] = 'Version';

IF NULLIF(@version,'') IS NOT NULL BEGIN
	IF NOT EXISTS (SELECT NULL FROM dbo.version_history WHERE [version_number] = @version) BEGIN
		INSERT INTO dbo.version_history (version_number, [description], deployed)
		VALUES ( @version, N'Found during deployment of ' + @CurrentVersion + N'.', @createDate);
	END;
END;
GO

-----------------------------------
USE [admindb];
GO

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

IF OBJECT_ID('dbo.backup_log','U') IS NULL BEGIN
	CREATE TABLE dbo.backup_log  (
		backup_id int IDENTITY(1,1) NOT NULL,
		execution_id uniqueidentifier NOT NULL,
		backup_date date NOT NULL CONSTRAINT DF_backup_log_log_date DEFAULT (GETDATE()),
		[database] sysname NOT NULL, 
		backup_type sysname NOT NULL,
		backup_path nvarchar(1000) NOT NULL, 
		copy_path nvarchar(1000) NULL, 
		offsite_path nvarchar(1000) NULL,
		backup_start datetime NOT NULL, 
		backup_end datetime NULL, 
		backup_succeeded bit NOT NULL CONSTRAINT DF_backup_log_backup_succeeded DEFAULT (0), 
		verification_start datetime NULL, 
		verification_end datetime NULL, 
		verification_succeeded bit NULL, 
		copy_succeeded bit NULL, 
		copy_seconds int NULL, 
		copy_details nvarchar(MAX) NULL,
		failed_copy_attempts int NULL, 
		offsite_succeeded bit NULL, 
		offsite_seconds int NULL, 
		offsite_details nvarchar(MAX) NULL,
		failed_offsite_attempts int NULL,
		error_details nvarchar(MAX) NULL, 
		CONSTRAINT PK_backup_log PRIMARY KEY CLUSTERED (backup_id)
	);	
END;
GO

---------------------------------------------------------------------------
-- Copy previous log data (v3 and below) if this is a new v4 install. 
---------------------------------------------------------------------------

DECLARE @objectId int;
SELECT @objectId = [object_id] FROM master.sys.objects WHERE [name] = N'dba_DatabaseBackups_Log';

IF @objectId IS NOT NULL BEGIN 
		
	DECLARE @loadSQL nvarchar(MAX) = N'
    SELECT 
		BackupId,
        ExecutionId,
        BackupDate,
        [Database],
        BackupType,
        BackupPath,
        CopyToPath,
        BackupStart,
        BackupEnd,
        BackupSucceeded,
        VerificationCheckStart,
        VerificationCheckEnd,
        VerificationCheckSucceeded,
        CopyDetails,
		0,     --FailedCopyAttempts,
        ErrorDetails
	FROM 
		master.dbo.dba_DatabaseBackups_Log
	WHERE 
		BackupId NOT IN (SELECT backup_id FROM dbo.backup_log); ';


	SET IDENTITY_INSERT dbo.backup_log ON;

	    INSERT INTO dbo.backup_log (backup_id, execution_id, backup_date, [database], backup_type, backup_path, copy_path, backup_start, backup_end, backup_succeeded, verification_start,  
		    verification_end, verification_succeeded, copy_details, failed_copy_attempts, error_details)
	    EXEC sp_executesql @loadSQL;

	SET IDENTITY_INSERT dbo.backup_log OFF;
END;
GO


---------------------------------------------------------------------------
-- v7.5+ Tracking for OffSite Copies of backups.
---------------------------------------------------------------------------
IF NOT EXISTS (SELECT NULL FROM sys.columns WHERE [object_id] = OBJECT_ID('dbo.backup_log') AND [name] = N'offsite_path') BEGIN 
	BEGIN TRAN;	
	
		IF OBJECT_ID('DF_backup_log_log_date') IS NOT NULL BEGIN
			ALTER TABLE dbo.backup_log
				DROP CONSTRAINT DF_backup_log_log_date;
		END;

		IF OBJECT_ID('DF_backup_log_backup_succeeded') IS NOT NULL BEGIN
			ALTER TABLE dbo.backup_log
				DROP CONSTRAINT DF_backup_log_backup_succeeded;
		END;

		CREATE TABLE dbo.Tmp_backup_log (
			backup_id int NOT NULL IDENTITY (1, 1),
			execution_id uniqueidentifier NOT NULL,
			backup_date date NOT NULL,
			[database] sysname NOT NULL,
			backup_type sysname NOT NULL,
			backup_path nvarchar(1000) NOT NULL,
			copy_path nvarchar(1000) NULL,
			offsite_path nvarchar(1000) NULL,
			backup_start datetime NOT NULL,
			backup_end datetime NULL,
			backup_succeeded bit NOT NULL,
			verification_start datetime NULL,
			verification_end datetime NULL,
			verification_succeeded bit NULL,
			copy_succeeded bit NULL,
			copy_seconds int NULL,
			failed_copy_attempts int NULL,
			copy_details nvarchar(MAX) NULL,
			offsite_succeeded bit NULL,
			offsite_seconds int NULL,
			failed_offsite_attempts int NULL,
			offsite_details nvarchar(MAX) NULL,
			error_details nvarchar(MAX) NULL
		);

		ALTER TABLE dbo.Tmp_backup_log ADD CONSTRAINT
			DF_backup_log_log_date DEFAULT (GETDATE()) FOR backup_date;

		ALTER TABLE dbo.Tmp_backup_log ADD CONSTRAINT
			DF_backup_log_backup_succeeded DEFAULT (0) FOR backup_succeeded;

		SET IDENTITY_INSERT dbo.Tmp_backup_log ON;

			INSERT INTO dbo.Tmp_backup_log (backup_id, execution_id, backup_date, [database], backup_type, backup_path, copy_path, backup_start, backup_end, backup_succeeded, verification_start, verification_end, verification_succeeded, copy_succeeded, copy_seconds, failed_copy_attempts, copy_details, error_details)
			EXEC sp_executesql N'SELECT backup_id, execution_id, backup_date, [database], backup_type, backup_path, copy_path, backup_start, backup_end, backup_succeeded, verification_start, verification_end, verification_succeeded, copy_succeeded, copy_seconds, failed_copy_attempts, copy_details, error_details FROM dbo.backup_log; ';

		SET IDENTITY_INSERT dbo.Tmp_backup_log OFF;

		DROP TABLE dbo.backup_log;
		
		EXECUTE sp_rename N'dbo.Tmp_backup_log', N'backup_log', 'OBJECT';

		ALTER TABLE dbo.backup_log ADD CONSTRAINT
			PK_backup_log PRIMARY KEY CLUSTERED (backup_id);

	COMMIT;
END;


-----------------------------------
USE [admindb];
GO

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

IF OBJECT_ID('dbo.restore_log', 'U') IS NULL BEGIN

	CREATE TABLE dbo.restore_log  (
		restore_id int IDENTITY(1,1) NOT NULL,                                                                      -- restore_test_id until v.9                         
		execution_id uniqueidentifier NOT NULL,                                                                     -- restore_id until v 4.9            
		operation_date date NOT NULL CONSTRAINT DF_restore_log_operation_date DEFAULT (GETDATE()),
		operation_type varchar(20) NOT NULL CONSTRAINT DF_restore_log_operation_type DEFAULT ('RESTORE-TEST'),      -- added v 4.9
		[database] sysname NOT NULL, 
		restored_as sysname NOT NULL, 
		restore_start datetime NOT NULL,                                                                            -- UTC until v 4.7
		restore_end datetime NULL,                                                                                  -- UTC until v 4.7
		restore_succeeded bit NOT NULL CONSTRAINT DF_restore_log_restore_succeeded DEFAULT (0), 
		restored_files xml NULL,                                                                                    -- added v 4.6.9
		[recovery] varchar(10) NOT NULL CONSTRAINT DF_restore_log_recovery DEFAULT ('RECOVERED'),                   -- added v 4.9
		consistency_start datetime NULL,                                                                            -- UTC until v 4.7
		consistency_end datetime NULL,                                                                              -- UTC until v 4.7
		consistency_succeeded bit NULL, 
		dropped varchar(20) NOT NULL CONSTRAINT DF_restore_log_dropped DEFAULT 'NOT-DROPPED',   -- Options: NOT-DROPPED, ERROR, ATTEMPTED, DROPPED
		error_details nvarchar(MAX) NULL, 
		CONSTRAINT PK_restore_log PRIMARY KEY CLUSTERED (restore_id)
	);

    -- Copy previous log data (v3 and below) if this is a new (> v4) install... 
    DECLARE @objectId int;
    SELECT @objectId = [object_id] FROM master.sys.objects WHERE [name] = 'dba_DatabaseRestore_Log';
    IF @objectId IS NOT NULL BEGIN;

        DECLARE @importSQL nvarchar(MAX) = N'
        INSERT INTO dbo.restore_log (
            restore_id, 
            execution_id, 
            operation_date, 
            [database], 
            restored_as, 
            restore_start, 
            restore_end, 
            restore_succeeded, 
		    consistency_start, 
            consistency_end, 
            consistency_succeeded, 
            dropped, 
            error_details
        )
	    SELECT 
		    RestorationTestId,
            ExecutionId,
            TestDate,
            [Database],
            RestoredAs,
            RestoreStart,
		    RestoreEnd,
            RestoreSucceeded,
            ConsistencyCheckStart,
            ConsistencyCheckEnd,
            ConsistencyCheckSucceeded,
            Dropped,
            ErrorDetails
	    FROM 
		    master.dbo.dba_DatabaseRestore_Log
	    WHERE 
		    RestorationTestId NOT IN (SELECT restore_test_id FROM dbo.restore_log); ';


	    PRINT 'Importing Previous Data from restore log.... ';
	    SET IDENTITY_INSERT dbo.restore_log ON;

            EXEC sys.[sp_executesql] @importSQL;

	    SET IDENTITY_INSERT dbo.restore_log OFF;

    END;

END;
GO

---------------------------------------------------------------------------
-- v4.6 Make sure the admindb.dbo.restore_log.restored_files column exists ... 
---------------------------------------------------------------------------
IF NOT EXISTS (SELECT NULL FROM sys.columns WHERE [object_id] = OBJECT_ID('dbo.restore_log') AND [name] = N'restored_files') BEGIN

	BEGIN TRANSACTION;
        
        IF OBJECT_ID(N'DF_restore_log_operation_date') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_operation_date;
        END

        IF OBJECT_ID(N'DF_restore_log_test_date') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_test_date;       -- old/former name... 
        END

        IF OBJECT_ID(N'DF_restore_log_operation_type') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_operation_type;
        END

        IF OBJECT_ID(N'DF_restore_log_restore_succeeded') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_restore_succeeded;
        END;

        IF OBJECT_ID(N'DF_restore_log_recovery') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_recovery;
        END;
		
        IF OBJECT_ID(N'DF_restore_log_dropped') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_dropped;
        END;
			
		CREATE TABLE dbo.Tmp_restore_log (
		    restore_id int IDENTITY(1,1) NOT NULL,                                                                      -- restore_test_id until v4.9                         
		    execution_id uniqueidentifier NOT NULL,                                                                     -- restore_id until v 4.9            
		    operation_date date NOT NULL CONSTRAINT DF_restore_log_operation_date DEFAULT (GETDATE()),
		    operation_type varchar(20) NOT NULL CONSTRAINT DF_restore_log_operation_type DEFAULT ('RESTORE-TEST'),      -- added v 4.9
		    [database] sysname NOT NULL, 
		    restored_as sysname NOT NULL, 
		    restore_start datetime NOT NULL,                                                                            -- UTC until v 4.7
		    restore_end datetime NULL,                                                                                  -- UTC until v 4.7
		    restore_succeeded bit NOT NULL CONSTRAINT DF_restore_log_restore_succeeded DEFAULT (0), 
		    restored_files xml NULL,                                                                                    -- added v 4.6.9
		    [recovery] varchar(10) NOT NULL CONSTRAINT DF_restore_log_recovery DEFAULT ('RECOVERED'),                   -- added v 4.9
		    consistency_start datetime NULL,                                                                            -- UTC until v 4.7
		    consistency_end datetime NULL,                                                                              -- UTC until v 4.7
		    consistency_succeeded bit NULL, 
		    dropped varchar(20) NOT NULL CONSTRAINT DF_restore_log_dropped DEFAULT 'NOT-DROPPED',   -- Options: NOT-DROPPED, ERROR, ATTEMPTED, DROPPED
		    error_details nvarchar(MAX) NULL, 
		);
			
		SET IDENTITY_INSERT dbo.Tmp_restore_log ON;
			
				INSERT INTO dbo.Tmp_restore_log (restore_id, execution_id, operation_date, [database], restored_as, restore_start, restore_end, restore_succeeded, consistency_start, consistency_end, consistency_succeeded, dropped, error_details)
                EXEC sp_executesql N'SELECT restore_test_id, execution_id, test_date, [database], restored_as, restore_start, restore_end, restore_succeeded, consistency_start, consistency_end, consistency_succeeded, dropped, error_details FROM dbo.restore_log;';
			
		SET IDENTITY_INSERT dbo.Tmp_restore_log OFF;
			
		DROP TABLE dbo.restore_log;
			
		EXECUTE sp_rename N'dbo.Tmp_restore_log', N'restore_log', 'OBJECT' ;
			
		ALTER TABLE dbo.restore_log ADD CONSTRAINT
			PK_restore_log PRIMARY KEY CLUSTERED (restore_id) ON [PRIMARY];
			
	COMMIT;
END;
GO

---------------------------------------------------------------------------
-- v4.7 Process UTC to local time change 
---------------------------------------------------------------------------
DECLARE @currentVersion decimal(3,1); 
SELECT @currentVersion = MAX(CAST(LEFT(version_number, 3) AS decimal(3,1))) FROM [dbo].[version_history];

IF @currentVersion IS NOT NULL AND @currentVersion < 4.7 BEGIN 

	DECLARE @hoursDiff int; 
	SELECT @hoursDiff = DATEDIFF(HOUR, GETDATE(), GETUTCDATE());

	DECLARE @command nvarchar(MAX) = N'
	UPDATE dbo.[restore_log]
	SET 
		[restore_start] = DATEADD(HOUR, 0 - @hoursDiff, [restore_start]), 
		[restore_end] = DATEADD(HOUR, 0 - @hoursDiff, [restore_end]),
		[consistency_start] = DATEADD(HOUR, 0 - @hoursDiff, [consistency_start]),
		[consistency_end] = DATEADD(HOUR, 0 - @hoursDiff, [consistency_end])
	WHERE 
		[restore_id] > 0;
	';

	EXEC sp_executesql 
		@stmt = @command, 
		@params = N'@hoursDiff int', 
		@hoursDiff = @hoursDiff;

	PRINT 'Updated dbo.restore_log.... (UTC shift)';
END;
GO

---------------------------------------------------------------------------
-- v4.9 Add recovery column + rename first two table columns:
---------------------------------------------------------------------------
IF NOT EXISTS (SELECT NULL FROM sys.columns WHERE [object_id] = OBJECT_ID('dbo.restore_log') AND [name] = N'recovery') BEGIN 

	BEGIN TRANSACTION;

        IF OBJECT_ID(N'DF_restore_log_operation_date') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_operation_date;
        END

        IF OBJECT_ID(N'DF_restore_log_test_date') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_test_date;       -- old/former name... 
        END

        IF OBJECT_ID(N'DF_restore_log_operation_type') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_operation_type;
        END

        IF OBJECT_ID(N'DF_restore_log_restore_succeeded') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_restore_succeeded;
        END;

        IF OBJECT_ID(N'DF_restore_log_recovery') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_recovery;
        END;
		
        IF OBJECT_ID(N'DF_restore_log_dropped') IS NOT NULL BEGIN
		    ALTER TABLE dbo.restore_log
			    DROP CONSTRAINT DF_restore_log_dropped;
        END;

		CREATE TABLE dbo.Tmp_restore_log (
		    restore_id int IDENTITY(1,1) NOT NULL,                                                                      -- restore_test_id until v.9                         
		    execution_id uniqueidentifier NOT NULL,                                                                     -- restore_id until v 4.9            
		    operation_date date NOT NULL CONSTRAINT DF_restore_log_operation_date DEFAULT (GETDATE()),
		    operation_type varchar(20) NOT NULL CONSTRAINT DF_restore_log_operation_type DEFAULT ('RESTORE-TEST'),      -- added v 4.9
		    [database] sysname NOT NULL, 
		    restored_as sysname NOT NULL, 
		    restore_start datetime NOT NULL,                                                                            -- UTC until v 4.7
		    restore_end datetime NULL,                                                                                  -- UTC until v 4.7
		    restore_succeeded bit NOT NULL CONSTRAINT DF_restore_log_restore_succeeded DEFAULT (0), 
		    restored_files xml NULL,                                                                                    -- added v 4.6.9
		    [recovery] varchar(10) NOT NULL CONSTRAINT DF_restore_log_recovery DEFAULT ('RECOVERED'),                   -- added v 4.9
		    consistency_start datetime NULL,                                                                            -- UTC until v 4.7
		    consistency_end datetime NULL,                                                                              -- UTC until v 4.7
		    consistency_succeeded bit NULL, 
		    dropped varchar(20) NOT NULL CONSTRAINT DF_restore_log_dropped DEFAULT 'NOT-DROPPED',   -- Options: NOT-DROPPED, ERROR, ATTEMPTED, DROPPED
		    error_details nvarchar(MAX) NULL, 
		);

		SET IDENTITY_INSERT dbo.Tmp_restore_log ON;
			
				INSERT INTO dbo.Tmp_restore_log (restore_id, execution_id, operation_date, [database], restored_as, restore_start, restore_end, restore_succeeded, consistency_start, consistency_end, consistency_succeeded, dropped, error_details)
                EXEC sp_executesql N'SELECT restore_test_id [restore_id], execution_id, test_date [operation_date], [database], restored_as, restore_start, restore_end, restore_succeeded, consistency_start, consistency_end, consistency_succeeded, dropped, error_details FROM dbo.restore_log';
			
		SET IDENTITY_INSERT dbo.Tmp_restore_log OFF;
			
		DROP TABLE dbo.restore_log;
			
		EXECUTE sp_rename N'dbo.Tmp_restore_log', N'restore_log', 'OBJECT' ;

		ALTER TABLE dbo.restore_log ADD CONSTRAINT
			PK_restore_log PRIMARY KEY CLUSTERED (restore_id) ON [PRIMARY];

	COMMIT; 
END;
GO

-- v4.9 (standardize/cleanup):
UPDATE dbo.[restore_log] 
SET 
	[dropped] = 'LEFT-ONLINE'
WHERE 
	[dropped] = 'LEFT ONLINE';
GO

---------------------------------------------------------------------------
-- v5.0 - expand dbo.restore_log.[recovery]. S4-86.
---------------------------------------------------------------------------
IF EXISTS (SELECT NULL FROM sys.columns WHERE [object_id] = OBJECT_ID('dbo.restore_log') AND [name] = N'recovery' AND [max_length] = 10) BEGIN
	BEGIN TRAN;

		ALTER TABLE dbo.[restore_log]
			ALTER COLUMN [recovery] varchar(15) NOT NULL; 

		ALTER TABLE dbo.[restore_log]
			DROP CONSTRAINT [DF_restore_log_recovery];

		ALTER TABLE dbo.[restore_log]
			ADD CONSTRAINT [DF_restore_log_recovery] DEFAULT ('NON-RECOVERED') FOR [recovery];

	COMMIT;
END;
GO

---------------------------------------------------------------------------
-- v6.1+
---------------------------------------------------------------------------
-- S4-195- BUG: these changes may have been missed during previous updates:
IF OBJECT_ID(N'DF_restore_log_test_date') IS NOT NULL BEGIN
	ALTER TABLE dbo.restore_log DROP CONSTRAINT DF_restore_log_test_date;
END;

IF OBJECT_ID(N'DF_restore_log_operation_date') IS NULL BEGIN 
    ALTER TABLE dbo.[restore_log] ADD CONSTRAINT DF_restore_log_operation_date DEFAULT (GETDATE()) FOR [operation_date];
END;
GO

-- streamline default text: 
IF EXISTS (SELECT NULL FROM sys.[default_constraints] WHERE [name] = N'DF_restore_log_operation_type' AND [definition] <> '(''RESTORE-TEST'')') BEGIN 
    IF OBJECT_ID(N'DF_restore_log_operation_date') IS NOT NULL BEGIN
		ALTER TABLE dbo.restore_log DROP CONSTRAINT DF_restore_log_operation_type;
    END    

    IF OBJECT_ID(N'DF_restore_log_operation_date') IS NOT NULL BEGIN
        ALTER TABLE dbo.restore_log ADD CONSTRAINT DF_restore_log_operation_type DEFAULT 'RESTORE-TEST' FOR [operation_type];

        UPDATE dbo.[restore_log] SET [operation_type] = 'RESTORE-TEST' WHERE [operation_type] = 'RESTORE_TEST';
    END;
END;
GO


-----------------------------------
USE [admindb];
GO


IF OBJECT_ID('dbo.settings','U') IS NULL BEGIN

	CREATE TABLE dbo.settings (
		setting_id int IDENTITY(1,1) NOT NULL,
		setting_type sysname NOT NULL CONSTRAINT CK_settings_setting_type CHECK ([setting_type] IN (N'UNIQUE', N'COMBINED')),
		setting_key sysname NOT NULL, 
		setting_value sysname NOT NULL,
		comments nvarchar(200) NULL,
		CONSTRAINT PK_settings PRIMARY KEY NONCLUSTERED (setting_id)
	);

	CREATE CLUSTERED INDEX CLIX_settings ON dbo.[settings] ([setting_key], [setting_id]);
  END;
ELSE BEGIN 

	IF NOT EXISTS (SELECT NULL FROM sys.columns WHERE [object_id] = OBJECT_ID('dbo.settings') AND [name] = N'setting_id') BEGIN 

		BEGIN TRAN
			SELECT 
				IDENTITY(int, 1, 1) [row_id], 
				setting_key, 
				setting_value 
			INTO 
				#settings
			FROM 
				dbo.[settings];

			DROP TABLE dbo.[settings];

			CREATE TABLE dbo.settings (
				setting_id int IDENTITY(1,1) NOT NULL,
				setting_type sysname NOT NULL CONSTRAINT CK_settings_setting_type CHECK ([setting_type] IN (N'UNIQUE', N'COMBINED')),
				setting_key sysname NOT NULL, 
				setting_value sysname NOT NULL,
				comments nvarchar(200) NULL,
				CONSTRAINT PK_settings PRIMARY KEY NONCLUSTERED (setting_id)
			);

            CREATE CLUSTERED INDEX CLIX_settings ON dbo.[settings] ([setting_key], [setting_id]);

            DECLARE @insertFromOriginal nvarchar(MAX) = N'INSERT INTO dbo.settings (setting_type, setting_key, setting_value) 
			SELECT 
				N''UNIQUE'' [setting_type], 
				[setting_key], 
				[setting_value]
			FROM 
				[#settings]
			ORDER BY 
				[row_id]; ';

            EXEC sp_executesql @insertFromOriginal;
			
		COMMIT;

        IF OBJECT_ID(N'tempdb..#settings') IS NOT NULL 
            DROP TABLE [#settings];
	END;
END;
GO

-- 6.0: 'legacy enable' advanced S4 error handling from previous versions if not already defined: 
IF EXISTS (SELECT NULL FROM dbo.[version_history]) BEGIN

	IF NOT EXISTS(SELECT NULL FROM dbo.[settings] WHERE [setting_key] = N'advanced_s4_error_handling') BEGIN
		INSERT INTO dbo.[settings] (
			[setting_type],
			[setting_key],
			[setting_value],
			[comments]
		)
		VALUES (
			N'UNIQUE', 
			N'advanced_s4_error_handling', 
			N'1', 
			N'Legacy Enabled (i.e., pre-v6 install upgraded to 6/6+)' 
		);
	END;
END;


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.alert_responses','U') IS NULL BEGIN

	CREATE TABLE dbo.alert_responses (
		alert_id int IDENTITY(1,1) NOT NULL, 
		message_id int NOT NULL, 
		response nvarchar(2000) NOT NULL, 
		is_s4_response bit NOT NULL CONSTRAINT DF_alert_responses_s4_response DEFAULT (0),
		is_enabled bit NOT NULL CONSTRAINT DF_alert_responses_is_enabled DEFAULT (1),
		notes nvarchar(1000) NULL, 
		CONSTRAINT PK_alert_responses PRIMARY KEY NONCLUSTERED ([alert_id])
	);

	CREATE CLUSTERED INDEX CLIX_alert_responses_by_message_id ON dbo.[alert_responses] ([message_id]);

	SET NOCOUNT ON;

	INSERT INTO [dbo].[alert_responses] ([message_id], [response], [is_s4_response], [notes])
	VALUES 
	(7886, N'[IGNORE]', 1, N'A read operation on a large object failed while sending data to the client. Example of a common-ish error you MAY wish to ignore, etc. '), 
	(17806, N'[IGNORE]', 1, N'SSPI handshake failure '),  -- TODO: configure for '[ALLOW # in (span)]'
	(18056, N'[IGNORE]', 1, N'The client was unable to reuse a session with SPID ###, which had been reset for connection pooling. The failure ID is 8. ');			-- TODO: configure for '[ALLOW # in (span)]'
	-- 17835, N'[IGNORE]', 1, is_enabled:0? or 1?, N'Encryption is required to connect to this server but the client library does not support encryption; the connection has been closed. Please upgrade your client library. 
	-- 4014 ... severity 20: A fatal error occurred while reading the input stream from the network. The session will be terminated
	-- 17828 ... severity 20: The prelogin packet used to open the connection is structurally invalid; the connection has been closed. Please contact the vendor of the client library. 
	-- 17836 ... severity 20: Length specified in network packet payload did not match number of bytes read; the connection has been closed. Please contact the vendor of the client library.
END;
GO


-----------------------------------
USE [admindb];
GO 

IF OBJECT_ID(N'dbo.eventstore_extractions', N'U') IS NULL BEGIN 
	CREATE TABLE dbo.eventstore_extractions ( 
		extraction_id int IDENTITY(1,1) NOT NULL, 
		session_name sysname NOT NULL, 
		cet datetime2 NOT NULL, 
		lset datetime2 NULL, 
		row_count int NOT NULL CONSTRAINT DF_eventstore_extractions_row_count DEFAULT(0),
		attributes nvarchar(300) NULL, 
		error nvarchar(MAX) NULL
		CONSTRAINT PK_xestore_extractions PRIMARY KEY NONCLUSTERED (extraction_id)
	)
	WITH (DATA_COMPRESSION = PAGE);

	CREATE CLUSTERED INDEX CLIX_xestore_extractions_ByTraceAndLSET ON dbo.[eventstore_extractions] ([session_name], [extraction_id] DESC);
END;
GO


-----------------------------------
USE [admindb];
GO 

IF OBJECT_ID(N'dbo.[eventstore_settings]', N'U') IS NULL BEGIN 

	CREATE TABLE [dbo].[eventstore_settings] (
		[setting_id] int IDENTITY(1, 1) NOT NULL,
		[event_store_key] sysname NOT NULL,
		[session_name] sysname NOT NULL,
		[etl_proc_name] sysname NOT NULL,
		[target_table] sysname NOT NULL,
		[collection_enabled] bit NOT NULL,
		[etl_enabled] bit NOT NULL,
		[etl_frequency_minutes] smallint NOT NULL,
		[retention_days] smallint NOT NULL,
		[created] datetime CONSTRAINT [DF_eventstore_settings_created] DEFAULT (GETDATE()),
		[notes] nvarchar(MAX) NULL, 
		CONSTRAINT PK_eventstore_settings PRIMARY KEY CLUSTERED  ([event_store_key])
	);
END;
GO


-----------------------------------
USE [admindb];
GO 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

IF OBJECT_ID(N'dbo.kill_blocking_process_snapshots', N'U') IS NULL BEGIN 
	CREATE TABLE dbo.kill_blocking_process_snapshots (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[timestamp] datetime NOT NULL, 
		[print_only] bit NOT NULL,
		[blocked_processes] int NOT NULL, 
		[lead_blockers] int NOT NULL, 
		[blockers_to_kill] int NOT NULL, 
		[snapshot] XML NOT NULL, 
		CONSTRAINT PK_kill_blocking_process_snapshots PRIMARY KEY CLUSTERED ([row_id])
	); 

END;
GO


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 3. Cleanup and remove objects from previous versions (start by creating/adding dbo.drop_obsolete_objects and other core 'helper' code)
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.get_engine_version','FN') IS NOT NULL
	DROP FUNCTION dbo.get_engine_version;
GO

CREATE FUNCTION dbo.get_engine_version() 
RETURNS decimal(4,2)
AS
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN 
		DECLARE @output decimal(4,2);
		
		DECLARE @major sysname, @minor sysname, @full sysname;
		SELECT 
			@major = CAST(SERVERPROPERTY('ProductMajorVersion') AS sysname), 
			@minor = CAST(SERVERPROPERTY('ProductMinorVersion') AS sysname), 
			@full = CAST(SERVERPROPERTY('ProductVersion') AS sysname); 

		IF @major IS NULL BEGIN
			SELECT @major = LEFT(@full, 2);
			SELECT @minor = REPLACE((SUBSTRING(@full, LEN(@major) + 2, 2)), N'.', N'');
		END;

		SET @output = CAST((@major + N'.' + @minor) AS decimal(4,2));

		RETURN @output;
	END;
GO


-----------------------------------
USE [admindb];
GO


IF OBJECT_ID('dbo.split_string','TF') IS NOT NULL
	DROP FUNCTION dbo.split_string;
GO

CREATE FUNCTION dbo.split_string(@serialized nvarchar(MAX), @delimiter nvarchar(20), @TrimResults bit)
RETURNS @Results TABLE (row_id int IDENTITY NOT NULL, result nvarchar(MAX))
	--WITH SCHEMABINDING
AS 
	BEGIN

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	IF NULLIF(@serialized,'') IS NOT NULL AND DATALENGTH(@delimiter) >= 1 BEGIN
		IF @delimiter = N' ' BEGIN 
			-- this approach is going to be MUCH slower, but works for space delimiter... 
			DECLARE @p int; 
			DECLARE @s nvarchar(MAX);
			WHILE CHARINDEX(N' ', @serialized) > 0 BEGIN 
				SET @p = CHARINDEX(N' ', @serialized);
				SET @s = SUBSTRING(@serialized, 1, @p - 1); 
			
				INSERT INTO @Results ([result])
				VALUES(@s);

				SELECT @serialized = SUBSTRING(@serialized, @p + 1, LEN(@serialized) - @p);
			END;
			
			INSERT INTO @Results ([result])
			VALUES (@serialized);

		  END; 
		ELSE BEGIN

			DECLARE @MaxLength int = LEN(@serialized) + LEN(@delimiter);

			WITH tally (n) AS ( 
				SELECT TOP (@MaxLength) 
					ROW_NUMBER() OVER (ORDER BY o1.[name]) AS n
				FROM sys.all_objects o1 
				CROSS JOIN sys.all_objects o2
			)

			INSERT INTO @Results ([result])
			SELECT 
				SUBSTRING(@serialized, n, CHARINDEX(@delimiter, @serialized + @delimiter, n) - n) [result]
			FROM 
				tally 
			WHERE 
				n <= LEN(@serialized) AND
				LEN(@delimiter) <= LEN(@serialized) AND
				RTRIM(LTRIM(SUBSTRING(@delimiter + @serialized, n, LEN(@delimiter)))) = @delimiter
			ORDER BY 
				 n;
		END;

		IF @TrimResults = 1 BEGIN
			UPDATE @Results SET [result] = LTRIM(RTRIM([result])) WHERE DATALENGTH([result]) > 0;
		END;

	END;

	RETURN;
END

GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.get_s4_version','FN') IS NOT NULL
	DROP FUNCTION dbo.[get_s4_version];
GO

CREATE FUNCTION dbo.[get_s4_version](@DefaultValueIfNoHistoryPresent varchar(20))
RETURNS decimal(3,1)
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
    BEGIN; 
    	
		DECLARE @output decimal(3,1); 
		DECLARE @currentVersion varchar(20);

		SELECT 
			@currentVersion = [version_number] 
		FROM 
			dbo.[version_history] 
		WHERE 
			version_id = (SELECT TOP 1 [version_id] FROM dbo.[version_history] ORDER BY [version_id] DESC);

		IF @currentVersion IS NULL 
			SET @currentVersion = @DefaultValueIfNoHistoryPresent;
			
		DECLARE @majorMinor varchar(10) = N'';
		SELECT @majorMinor = @majorMinor + [result] + CASE WHEN [row_id] = 1 THEN N'.' ELSE '' END FROM dbo.[split_string](@currentVersion, N'.', 1) WHERE [row_id] < 3 ORDER BY [row_id];

		SET @output = CAST(@majorMinor AS decimal(3,1));

    	RETURN @output;
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.drop_obsolete_objects','P') IS NOT NULL
	DROP PROC dbo.drop_obsolete_objects;
GO

CREATE PROC dbo.drop_obsolete_objects
    @Directives         xml             = NULL, 
    @TargetDatabae      sysname         = NULL,
    @PrintOnly          bit             = 0
AS 
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    IF @Directives IS NULL BEGIN 
        PRINT '-- Attempt to execute dbo.drop_obsolete_objects - but @Directives was NULL.';
        RETURN -1;
    END; 

    DECLARE @typeMappings table ( 
        [type] sysname, 
        [type_description] sysname 
    ); 

    INSERT INTO @typeMappings (
        [type],
        [type_description]
    )
    VALUES
        ('U', 'TABLE'),
        ('V', 'VIEW'),
        ('P', 'PROCEDURE'),
        ('FN', 'FUNCTION'),
        ('IF', 'FUNCTION'),
        ('TF', 'FUNCTION'),
        ('D', 'CONSTRAINT'),
        ('SN', 'SYNONYM');

    DECLARE @command nvarchar(MAX) = N'';
    DECLARE @current nvarchar(MAX);
    DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
    DECLARE @tab nchar(1) = NCHAR(9);

    DECLARE walker CURSOR LOCAL FAST_FORWARD FOR
    SELECT 
        ISNULL([data].[entry].value('@schema[1]', 'sysname'), N'dbo') [schema],
        [data].[entry].value('@name[1]', 'sysname') [object_name],
        UPPER([data].[entry].value('@type[1]', 'sysname')) [type],
        [data].[entry].value('@comment[1]', 'sysname') [comment], 
        [data].[entry].value('(check/statement/.)[1]', 'nvarchar(MAX)') [statement], 
        [data].[entry].value('(check/warning/.)[1]', 'nvarchar(MAX)') [warning], 
        [data].[entry].value('(notification/content/.)[1]', 'nvarchar(MAX)') [content], 
        [data].[entry].value('(notification/heading/.)[1]', 'nvarchar(MAX)') [heading] 

    FROM 
        @Directives.nodes('//entry') [data] ([entry]);

    DECLARE @template nvarchar(MAX) = N'
{comment}IF OBJECT_ID(''{schema}.{object}'', ''{type}'') IS NOT NULL {BEGIN}
    DROP {object_type_description} [{schema}].[{object}]; {StatementCheck} {Notification}{END}';

    DECLARE @checkTemplate nvarchar(MAX) = @crlf + @crlf + @tab + N'IF EXISTS ({statement})
        PRINT ''{warning}''; ';
    DECLARE @notificationTemplate nvarchar(MAX) = @crlf + @crlf + @tab + N'SELECT ''{content}}'' AS [{heading}];';

    DECLARE @schema sysname, @object sysname, @type sysname, @comment sysname, 
        @statement nvarchar(MAX), @warning nvarchar(MAX), @content nvarchar(200), @heading nvarchar(200);

    DECLARE @typeType sysname;
    DECLARE @returnValue int;

    OPEN [walker];
    FETCH NEXT FROM [walker] INTO @schema, @object, @type, @comment, @statement, @warning, @content, @heading;

    WHILE @@FETCH_STATUS = 0 BEGIN
    
        SET @typeType = (SELECT [type_description] FROM @typeMappings WHERE [type] = @type);

        IF NULLIF(@typeType, N'') IS NULL BEGIN 
            RAISERROR(N'Undefined OBJECT_TYPE slated for DROP/REMOVAL in dbo.drop_obsolete_objects.', 16, 1);
            SET @returnValue = -1;

            GOTO Cleanup;
        END;
        
        IF NULLIF(@object, N'') IS NULL OR NULLIF(@type, N'') IS NULL BEGIN
            RAISERROR(N'Error in dbo.drop_obsolete_objects. Attributes name and type are BOTH required.', 16, 1);
            SET @returnValue = -5;
            
            GOTO Cleanup;
        END;

        SET @current = REPLACE(@template, N'{schema}', @schema);
        SET @current = REPLACE(@current, N'{object}', @object);
        SET @current = REPLACE(@current, N'{type}', @type);
        SET @current = REPLACE(@current, N'{object_type_description}', @typeType);

        IF NULLIF(@comment, N'') IS NOT NULL BEGIN 
            SET @current = REPLACE(@current, N'{comment}', N'-- ' + @comment + @crlf);
          END;
        ELSE BEGIN 
            SET @current = REPLACE(@current, N'{comment}', N'');
        END;

        DECLARE @beginEndRequired bit = 0;

        IF NULLIF(@statement, N'') IS NOT NULL BEGIN
            SET @beginEndRequired = 1;
            SET @current = REPLACE(@current, N'{StatementCheck}', REPLACE(REPLACE(@checkTemplate, N'{statement}', @statement), N'{warning}', @warning));
          END;
        ELSE BEGIN 
            SET @current = REPLACE(@current, N'{StatementCheck}', N'');
        END; 

        IF (NULLIF(@content, N'') IS NOT NULL) AND (NULLIF(@heading, N'') IS NOT NULL) BEGIN
            SET @beginEndRequired = 1;
            SET @current = REPLACE(@current, N'{Notification}', REPLACE(REPLACE(@notificationTemplate, N'{content}', @content), N'{heading}', @heading));
          END;
        ELSE BEGIN
            SET @current = REPLACE(@current, N'{Notification}', N'');
        END;

        IF @beginEndRequired = 1 BEGIN 
            SET @current = REPLACE(@current, N'{BEGIN}', N'BEGIN');
            SET @current = REPLACE(@current, N'{END}', @crlf + N'END;');
          END;
        ELSE BEGIN 
            SET @current = REPLACE(@current, N'{BEGIN}', N'');
            SET @current = REPLACE(@current, N'{END}', N'');
        END; 

        SET @command = @command + @current + @crlf;

        FETCH NEXT FROM [walker] INTO @schema, @object, @type, @comment, @statement, @warning, @content, @heading;
    END;

Cleanup:
    CLOSE [walker];
    DEALLOCATE [walker];

    IF @returnValue IS NOT NULL BEGIN 
        RETURN @returnValue;
    END;

    IF NULLIF(@TargetDatabae, N'') IS NOT NULL BEGIN 
        SET @command = N'USE ' + QUOTENAME(@TargetDatabae) + N';' + @crlf + N'' + @command;
    END;

    IF @PrintOnly = 1
        PRINT @command;
    ELSE 
        EXEC sys.[sp_executesql] @command; -- by design: let it throw errors... 

    RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
-- master db objects:
------------------------------------------------------------------------------------------------------------------------------------------------------

DECLARE @obsoleteObjects xml = CONVERT(xml, N'
<list>
    <entry schema="dbo" name="dba_DatabaseBackups_Log" type="U" comment="older table" />
    <entry schema="dbo" name="dba_DatabaseRestore_Log" type="U" comment="older table" />
    <entry schema="dbo" name="dba_SplitString" type="TF" comment="older UDF" />
    <entry schema="dbo" name="dba_CheckPaths" type="P" comment="older sproc" />
    <entry schema="dbo" name="dba_ExecuteAndFilterNonCatchableCommand" type="P" comment="older sproc" />
    <entry schema="dbo" name="dba_LoadDatabaseNames" type="P" comment="older sproc" />
    <entry schema="dbo" name="dba_RemoveBackupFiles" type="P" comment="older sproc" />
    <entry schema="dbo" name="dba_BackupDatabases" type="P" comment="older sproc" />
    <entry schema="dbo" name="dba_RestoreDatabases" type="P" comment="older sproc" />
    <entry schema="dbo" name="dba_VerifyBackupExecution" type="P" comment="older sproc" />

    <entry schema="dbo" name="dba_DatabaseBackups" type="P" comment="Potential FORMER versions of basic code (pre 1.0)." />
    <entry schema="dbo" name="dba_ExecuteNonCatchableCommand" type="P" comment="Potential FORMER versions of basic code (pre 1.0)." />
    <entry schema="dbo" name="dba_RestoreDatabases" type="P" comment="Potential FORMER versions of basic code (pre 1.0)." />
    <entry schema="dbo" name="dba_DatabaseRestore_CheckPaths" type="P" comment="Potential FORMER versions of HA monitoring (pre 1.0)." />
    
    <entry schema="dbo" name="dba_AvailabilityGroups_HealthCheck" type="P" comment="Potential FORMER versions of HA monitoring (pre 1.0)." />
    <entry schema="dbo" name="dba_Mirroring_HealthCheck" type="P" comment="Potential FORMER versions of HA monitoring (pre 1.0)." />

    <entry schema="dbo" name="dba_FilterAndSendAlerts" type="P" comment="FORMER version of alert filtering.">
        <notification>
            <content>NOTE: dbo.dba_FilterAndSendAlerts was dropped from master database - make sure to change job steps/names as needed.</content>
            <heading>WARNING - Potential Configuration Changes Required (alert filtering)</heading>
        </notification>
    </entry>
    <entry schema="dbo" name="dba_drivespace_checks" type="P" comment="FORMER disk monitoring alerts.">
        <notification>
            <content>NOTE: dbo.dba_drivespace_checks was dropped from master database - make sure to change job steps/names as needed.</content>
            <heading>WARNING - Potential Configuration Changes Required (disk-space checks)</heading>
        </notification>
    </entry>
</list>');

EXEC dbo.drop_obsolete_objects @obsoleteObjects, N'master';
GO

------------------------------------------------------------------------------------------------------------------------------------------------------
-- admindb objects:
------------------------------------------------------------------------------------------------------------------------------------------------------

DECLARE @olderObjects xml = CONVERT(xml, N'
<list>
    <entry schema="dbo" name="server_synchronization_checks" type="P" comment="v4.9 - .5.0 renamed noun_noun_check sprocs for HA monitoring to verify_noun_noun">
        <check>
            <statement>SELECT NULL FROM msdb.dbo.[sysjobsteps] WHERE [command] LIKE ''%server_synchronization_checks%''</statement>
            <warning>WARNING: v4.9 to v5.0+ name-change detected. Job Steps with calls to dbo.server_synchronization_checks were found. Please update to call dbo.verify_server_synchronization instead.</warning>
        </check>
    </entry>
    <entry schema="dbo" name="job_synchronization_checks" type="P" comment="v4.9 - .5.0 renamed noun_noun_check sprocs for HA monitoring to verify_noun_noun">
        <check>
            <statement>SELECT NULL FROM msdb.dbo.[sysjobsteps] WHERE [command] LIKE ''%job_synchronization_checks%''</statement>
            <warning>WARNING: v4.9 to v5.0+ name-change detected. Job Steps with calls to dbo.job_synchronization_checks were found. Please update to call dbo.verify_job_synchronization instead.</warning>
        </check>
    </entry>
    <entry schema="dbo" name="data_synchronization_checks" type="P" comment="v4.9 - .5.0 renamed noun_noun_check sprocs for HA monitoring to verify_noun_noun">
        <check>
            <statement>SELECT NULL FROM msdb.dbo.[sysjobsteps] WHERE [command] LIKE ''%data_synchronization_checks%''</statement>
            <warning>WARNING: v4.9 to v5.0+ name-change detected. Job Steps with calls to dbo.data_synchronization_checks were found. Please update to call dbo.verify_data_synchronization instead.</warning>
        </check>
    </entry>

    <entry schema="dbo" name="load_database_names" type="P" comment="v5.2 - S4-52, S4-78, S4-87 - changing dbo.load_database_names to dbo.list_databases." />
    
    <entry schema="dbo" name="get_time_vector" type="P" comment="v5.6 Vector Standardization (cleanup)." />
    <entry schema="dbo" name="get_vector" type="P" comment="v5.6 Vector Standardization (cleanup)." />
    <entry schema="dbo" name="get_vector_delay" type="P" comment="v5.6 Vector Standardization (cleanup)." />

    <entry schema="dbo" name="load_databases" type="P" comment="v5.8 refactor/changes." />

    <entry schema="dbo" name="script_server_logins" type="P" comment="v6.2 refactoring." />
    <entry schema="dbo" name="print_logins" type="P" comment="v6.2 refactoring." />
    <entry schema="dbo" name="script_server_configuration" type="P" comment="v6.2 refactoring." />
    <entry schema="dbo" name="print_configuration" type="P" comment="v6.2 refactoring." />

    <entry schema="dbo" name="respond_to_db_failover" type="P" comment="v6.5 refactoring (changed to dbo.process_synchronization_failover)" />

	<entry schema="dbo" name="server_trace_flags" type="U" comment="v6.6 - Direct Query for Trace Flags vs delayed/table-checks." />

	<entry schema="dbo" name="script_configuration" type="P" comment="v8.0 - Renamed to dbo.script_server_configuration - better alignment with scope." />

	<entry schema="dbo" name="fix_orphaned_logins" type="P" comment="v11.1 - Renamed from dbo.fix_orphaned_logins - which doesn''t make sense - we''re fixing USERs." />
	<entry schema="dbo" name="alter_jobstep_body" type="P" comment="v11.1 - Renamed from dbo.alter_jobstep_body - to toy with test of &lt;object&gt;-&lt;verb&gt; naming conventions for some things?" />
</list>');

EXEC dbo.drop_obsolete_objects @olderObjects, N'admindb';
GO

-----------------------------------
-- v7.0+ - Conversion of [tokens] to {tokens}. (Breaking Change - Raises warnings/alerts via SELECT statements). 
IF (SELECT admindb.dbo.get_s4_version('12.0.4707.7')) < 7.0 BEGIN

	-- Replace any 'custom' token definitions in dbo.settings: 
	DECLARE @tokenChanges table (
		setting_id int NOT NULL, 
		old_setting_key sysname NOT NULL, 
		new_setting_key sysname NOT NULL 
	);

	UPDATE [dbo].[settings]
	SET 
		[setting_key] = REPLACE(REPLACE([setting_key], N']', N'}'), N'[', N'{')
	OUTPUT 
		[Deleted].[setting_id], [Deleted].[setting_key], [Inserted].[setting_key] INTO @tokenChanges
	WHERE 
		[setting_key] LIKE N'~[%~]' ESCAPE '~';


	IF EXISTS (SELECT NULL FROM @tokenChanges) BEGIN 

		SELECT 
			N'WARNING: dbo.settings.setting_key CHANGED from pre 7.0 [token] syntax to 7.0+ {token} syntax' [WARNING], 
			[setting_id], 
			[old_setting_key], 
			[new_setting_key]
		FROM 
			@tokenChanges
	END;

	-- Raise alerts/warnings about any Job-Steps on the server with old-style [tokens] instead of {tokens}:
	DECLARE @oldTokens table ( 
		old_token_id int IDENTITY(1,1) NOT NULL, 
		token_pattern sysname NOT NULL, 
		is_custom bit DEFAULT 1
	); 

	INSERT INTO @oldTokens (
		[token_pattern], [is_custom]
	)
	VALUES
		(N'%~[ALL~]%', 0),
		(N'%~[SYSTEM~]%', 0),
		(N'%~[USER~]%', 0),
		(N'%~[READ_FROM_FILESYSTEM~]%', 0), 
		(N'%~[READ_FROM_FILE_SYSTEM~]%', 0), 
		(N'%~[DEFAULT~]%', 0);

	INSERT INTO @oldTokens (
		[token_pattern]
	)
	SELECT DISTINCT
		N'%~' + REPLACE([setting_key], N']', N'~]') + N'%'
	FROM 
		[admindb].[dbo].[settings] 
	WHERE 
		[setting_key] LIKE '~[%~]' ESCAPE '~';

	WITH matches AS ( 
		SELECT 
			js.[job_id], 
			js.[step_id], 
			js.[command], 
			js.[step_name],
			x.[token_pattern]
		FROM 
			[msdb].dbo.[sysjobsteps] js 
			INNER JOIN @oldTokens x ON js.[command] LIKE x.[token_pattern] ESCAPE N'~'
		WHERE 
			js.[subsystem] = N'TSQL'
	)

	SELECT 
		N'WARNING: SQL Server Agent Job-Step uses PRE-7.0 [tokens] which should be changed to {token} syntax instead.' [WARNING],
		j.[name] [job_name], 
		--	j.[job_id], 
		CAST(m.[step_id] AS sysname) + N' - ' + m.[step_name] [Job-Step-With-Invalid-Token],
		N'TASK: Manually Replace ' + REPLACE(REPLACE(m.[token_pattern], N'~', N''), N'%', N'') 
			+ N' with ' + REPLACE(REPLACE(( ( REPLACE(REPLACE(m.[token_pattern], N'~', N''), N'%', N'') ) ), N']', N'}'), N'[', N'{') + '.' [Task-To-Execute-Manually]
		--m.[command]
	FROM 
		[matches] m 
		INNER JOIN [msdb].dbo.[sysjobs] j ON m.[job_id] = j.[job_id];

END;

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 4. Deploy new/updated code.
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

USE [admindb];
GO

------------------------------------------------------------------------------------------------------------------------------------------------------
-- Types:
------------------------------------------------------------------------------------------------------------------------------------------------------
USE [admindb];
GO

IF TYPE_ID('dbo.backup_history_entry') IS NOT NULL BEGIN
	IF OBJECT_ID(N'dbo.log_backup_history_detail', N'P') IS NOT NULL BEGIN
		DROP PROC dbo.log_backup_history_detail;
	END;

	DROP TYPE dbo.backup_history_entry;
END; 
GO

CREATE TYPE dbo.backup_history_entry AS TABLE (
	[execution_id] uniqueidentifier NULL,
	[backup_date] date NULL,
	[database] sysname NULL,
	[backup_type] sysname NULL,
	[backup_path] nvarchar(1000) NULL,
	[copy_path] nvarchar(1000) NULL,
	[offsite_path] nvarchar(1000) NULL,
	[backup_start] datetime NULL,
	[backup_end] datetime NULL,
	[backup_succeeded] bit NULL,
	[verification_start] datetime NULL,
	[verification_end] datetime NULL,
	[verification_succeeded] bit NULL,
	[copy_succeeded] bit NULL,
	[copy_seconds] int NULL,
	[failed_copy_attempts] int NULL,
	[copy_details] nvarchar(max) NULL,
	[offsite_succeeded] bit NULL,
	[offsite_seconds] int NULL,
	[failed_offsite_attempts] int NULL,
	[offsite_details] nvarchar(max) NULL,
	[error_details] nvarchar(max) NULL
);
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
-- Advanced S4 Error-Handling Capabilities:
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.enable_advanced_capabilities','P') IS NOT NULL
	DROP PROC dbo.enable_advanced_capabilities;
GO

CREATE PROC dbo.enable_advanced_capabilities

AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @xpCmdShellValue bit; 
	DECLARE @xpCmdShellInUse bit;
	DECLARE @advancedS4 bit = 0;
	
	SELECT 
		@xpCmdShellValue = CAST([value] AS bit), 
		@xpCmdShellInUse = CAST([value_in_use] AS bit) 
	FROM 
		sys.configurations 
	WHERE 
		[name] = 'xp_cmdshell';

	IF EXISTS(SELECT NULL FROM dbo.[settings] WHERE [setting_key] = N'advanced_s4_error_handling') BEGIN 
		SELECT 
			@advancedS4 = CAST([setting_value] AS bit) 
		FROM 
			dbo.[settings] 
		WHERE 
			[setting_key] = N'advanced_s4_error_handling';
	END;

	-- check to see if enabled first: 
	IF @advancedS4 = 1 AND @xpCmdShellInUse = 1 BEGIN
		PRINT 'Advanced S4 error handling (ability to use xp_cmdshell) already/previously enabled.';
		GOTO termination;
	END;

	IF @xpCmdShellValue = 1 AND @xpCmdShellInUse = 0 BEGIN 
		RECONFIGURE;
		SET @xpCmdShellInUse = 1;
	END;

	IF @xpCmdShellValue = 0 BEGIN

        IF EXISTS (SELECT NULL FROM sys.[configurations] WHERE [name] = N'show advanced options' AND [value_in_use] = 0) BEGIN
            EXEC sp_configure 'show advanced options', 1; 
            RECONFIGURE;
        END;

		EXEC sp_configure 'xp_cmdshell', 1; 
		RECONFIGURE;

		SELECT @xpCmdShellValue = 1, @xpCmdShellInUse = 1;
	END;

	IF @advancedS4 = 0 BEGIN 
		IF EXISTS(SELECT NULL FROM dbo.[settings] WHERE [setting_key] = N'advanced_s4_error_handling') BEGIN
			UPDATE dbo.[settings] 
			SET 
				[setting_value] = N'1', 
				[comments] = N'Manually enabled on ' + CONVERT(nvarchar(30), GETDATE(), 120) + N'.'  
			WHERE 
				[setting_key] = N'advanced_s4_error_handling';
		  END;
		ELSE BEGIN 
			INSERT INTO dbo.[settings] (
				[setting_type],
				[setting_key],
				[setting_value],
				[comments]
			)
			VALUES (
				N'UNIQUE', 
				N'advanced_s4_error_handling', 
				N'1', 
				N'Manually enabled on ' + CONVERT(nvarchar(30), GETDATE(), 120) + N'.' 
			);
		END;
		SET @advancedS4 = 1;
	END;

termination: 
	SELECT 
		@xpCmdShellValue [xp_cmdshell.value], 
		@xpCmdShellInUse [xp_cmdshell.value_in_use],
		@advancedS4 [advanced_s4_error_handling.value];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.disable_advanced_capabilities','P') IS NOT NULL
	DROP PROC dbo.disable_advanced_capabilities
GO

CREATE PROC dbo.disable_advanced_capabilities

AS 
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @xpCmdShellValue bit; 
	DECLARE @xpCmdShellInUse bit;
	DECLARE @advancedS4 bit = 0;
	DECLARE @errorMessage nvarchar(MAX);
		
	SELECT 
		@xpCmdShellValue = CAST([value] AS bit), 
		@xpCmdShellInUse = CAST([value_in_use] AS bit) 
	FROM 
		sys.configurations 
	WHERE 
		[name] = 'xp_cmdshell';

	IF EXISTS(SELECT NULL FROM dbo.[settings] WHERE [setting_key] = N'advanced_s4_error_handling') BEGIN 

		SELECT 
			@advancedS4 = CAST([setting_value] AS bit) 
		FROM 
			dbo.[settings] 
		WHERE 
			[setting_key] = N'advanced_s4_error_handling';
	END;

	BEGIN TRY 
		IF @xpCmdShellValue = 1 OR @xpCmdShellInUse = 1 BEGIN
			EXEC sp_configure 'xp_cmdshell', 0; 
			RECONFIGURE;	
			
			SELECT @xpCmdShellValue = 0, @xpCmdShellInUse = 0;
		END;

		IF EXISTS (SELECT NULL FROM dbo.[settings] WHERE [setting_key] = N'advanced_s4_error_handling') BEGIN
			IF @advancedS4 = 1 BEGIN 
				UPDATE dbo.[settings]
				SET 
					[setting_value] = N'0', 
					[comments] = N'Manually DISABLED on ' + CONVERT(nvarchar(30), GETDATE(), 120) + N'.' 
				WHERE 
					[setting_key] = N'advanced_s4_error_handling';
			  END;
			ELSE BEGIN
				INSERT INTO dbo.[settings] (
					[setting_type],
					[setting_key],
					[setting_value],
					[comments]
				)
				VALUES (
					N'UNIQUE', 
					N'advanced_s4_error_handling', 
					N'1', 
					N'Manually DISABLED on ' + CONVERT(nvarchar(30), GETDATE(), 120) + N'.' 
				);
			END;
			SET @advancedS4 = 0;
		END;

	END TRY
	BEGIN CATCH 
		SELECT @errorMessage = N'Unhandled Exception: ' + CAST(ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE();
		RAISERROR(@errorMessage, 16, 1);
		RETURN -1;
	END CATCH

	SELECT 
		@xpCmdShellValue [xp_cmdshell.value], 
		@xpCmdShellInUse [xp_cmdshell.value_in_use],
		@advancedS4 [advanced_s4_error_handling.value];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_advanced_capabilities','P') IS NOT NULL
	DROP PROC dbo.verify_advanced_capabilities;
GO

CREATE PROC dbo.verify_advanced_capabilities
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @xpCmdShellInUse bit;
	DECLARE @advancedS4 bit;
	DECLARE @errorMessage nvarchar(1000);
	
	SELECT 
		@xpCmdShellInUse = CAST([value_in_use] AS bit) 
	FROM 
		sys.configurations 
	WHERE 
		[name] = 'xp_cmdshell';

	SELECT 
		@advancedS4 = CAST([setting_value] AS bit) 
	FROM 
		dbo.[settings] 
	WHERE 
		[setting_key] = N'advanced_s4_error_handling';

	IF @xpCmdShellInUse = 1 AND ISNULL(@advancedS4, 0) = 1
		RETURN 0;
	
	RAISERROR(N'Advanced S4 error handling capabilities are NOT enabled. Please consult S4 setup documentation and execute admindb.dbo.enable_advanced_capabilities;', 16, 1);
	RETURN -1;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
-- Common and Utilities:
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.normalize_file_path','FN') IS NOT NULL
	DROP FUNCTION dbo.[normalize_file_path];
GO

CREATE FUNCTION dbo.[normalize_file_path] (@FilePath sysname)
RETURNS sysname
	WITH RETURNS NULL ON NULL INPUT
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
    	DECLARE @output sysname = @FilePath;
    	
		IF(RIGHT(@FilePath, 1) = N'\')
			SET @output = LEFT(@FilePath, LEN(@FilePath) - 1);    	
    	
    	RETURN @output;
    
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.check_paths','P') IS NOT NULL
	DROP PROC dbo.check_paths;
GO

CREATE PROC dbo.check_paths 
	@Path				nvarchar(MAX),
	@Exists				bit					OUTPUT
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @Exists = 0;

	DECLARE @results TABLE (
		[output] varchar(500)
	);

	DECLARE @command nvarchar(2000) = N'IF EXIST "' + @Path + N'" ECHO EXISTS';

	INSERT INTO @results ([output])  
	EXEC sys.xp_cmdshell @command;

	IF EXISTS (SELECT NULL FROM @results WHERE [output] = 'EXISTS')
		SET @Exists = 1;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO


IF OBJECT_ID('dbo.load_default_path','FN') IS NOT NULL
	DROP FUNCTION dbo.load_default_path;
GO

CREATE FUNCTION dbo.load_default_path(@PathType sysname) 
RETURNS nvarchar(4000)
AS
BEGIN
 
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @output sysname;

	IF UPPER(@PathType) = N'BACKUPS'
		SET @PathType = N'BACKUP';

	IF UPPER(@PathType) = N'LOGS'
		SET @PathType = N'LOG';

	DECLARE @valueName nvarchar(4000);

	SET @valueName = CASE @PathType
		WHEN N'BACKUP' THEN N'BackupDirectory'
		WHEN N'DATA' THEN N'DefaultData'
		WHEN N'LOG' THEN N'DefaultLog'
		ELSE N''
	END;

	IF @valueName = N''
		RETURN 'Error. Invalid @PathType Specified.';

	EXEC master..xp_instance_regread
		N'HKEY_LOCAL_MACHINE',  
		N'Software\Microsoft\MSSQLServer\MSSQLServer',  
		@valueName,
		@output OUTPUT, 
		'no_output';

	-- account for older versions and/or values not being set for data/log paths: 
	IF @output IS NULL BEGIN 
		IF @PathType = 'DATA' BEGIN 
			EXEC master..xp_instance_regread
				N'HKEY_LOCAL_MACHINE',  
				N'Software\Microsoft\MSSQLServer\MSSQLServer\Parameters',  
				N'SqlArg0',  -- try grabbing service startup parameters instead: 
				@output OUTPUT, 
				'no_output';			

			IF @output IS NOT NULL BEGIN 
				SET @output = SUBSTRING(@output, 3, 255)
				SET @output = SUBSTRING(@output, 1, LEN(@output) - CHARINDEX('\', REVERSE(@output)))
			  END;
			ELSE BEGIN
				SELECT @output = CAST(SERVERPROPERTY('InstanceDefaultDataPath') AS nvarchar(400)); -- likely won't provide any data if we didn't get it previoulsy... 
			END;
		END;

		IF @PathType = 'LOG' BEGIN 
			EXEC master..xp_instance_regread
				N'HKEY_LOCAL_MACHINE',  
				N'Software\Microsoft\MSSQLServer\MSSQLServer\Parameters',  
				N'SqlArg0',  -- try grabbing service startup parameters instead: 
				@output OUTPUT, 
				'no_output';			

			IF @output IS NOT NULL BEGIN 
				SET @output = SUBSTRING(@output, 3, 255)
				SET @output = SUBSTRING(@output, 1, LEN(@output) - CHARINDEX('\', REVERSE(@output)))
			  END;
			ELSE BEGIN
				SELECT @output = CAST(SERVERPROPERTY('InstanceDefaultLogPath') AS nvarchar(400)); -- likely won't provide any data if we didn't get it previoulsy... 
			END;
		END;
	END;

	SET @output = dbo.[normalize_file_path](@output);

	RETURN @output;
END;
GO




-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.load_default_setting','P') IS NOT NULL
	DROP PROC dbo.load_default_setting;
GO

CREATE PROC dbo.load_default_setting
	@SettingName			sysname	                    = NULL, 
	@Result					sysname			            = N''       OUTPUT			-- NOTE: Non-NULL for PROJECT or REPLY convention
AS
	SET NOCOUNT ON; 
	
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @output sysname; 

    SET @output = (SELECT TOP 1 [setting_value] FROM dbo.settings WHERE UPPER([setting_key]) = UPPER(@SettingName) ORDER BY [setting_id] DESC);

    -- load convention 'settings' if nothing has been explicitly set: 
    IF @output IS NULL BEGIN
        DECLARE @conventions table ( 
            setting_key sysname NOT NULL, 
            setting_value sysname NOT NULL
        );

        INSERT INTO @conventions (
            [setting_key],
            [setting_value]
        )
        VALUES 
		    (N'DEFAULT_BACKUP_PATH', (SELECT dbo.[load_default_path](N'BACKUP'))),
		    (N'DEFAULT_DATA_PATH', (SELECT dbo.[load_default_path](N'LOG'))),
		    (N'DEFAULT_LOG_PATH', (SELECT dbo.[load_default_path](N'DATA'))),
		    (N'DEFAULT_OPERATOR', N'Alerts'),
		    (N'DEFAULT_PROFILE', N'General');            

        SELECT @output = [setting_value] FROM @conventions WHERE [setting_key] = @SettingName;

    END;

    IF @Result IS NULL 
        SET @Result = @output; 
    ELSE BEGIN 
        DECLARE @dynamic nvarchar(MAX) = N'SELECT @output [' + @SettingName + N'];';  
        
        EXEC sys.sp_executesql 
            @dynamic, 
            N'@output sysname', 
            @output = @output;
    END;
    
    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO 


IF OBJECT_ID('dbo.shred_resources','IF') IS NOT NULL
	DROP FUNCTION dbo.shred_resources;
GO

CREATE FUNCTION dbo.shred_resources(@resources xml)
RETURNS TABLE 
AS 
  RETURN	
	
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SELECT 
		[resource].value('resource_identifier[1]', 'sysname') [resource_identifier], 
		[resource].value('@database[1]', 'sysname') [database], 
		[resource].value('(transaction/@transaction_id)[1]', 'bigint') transaction_id,
		[resource].value('(transaction/@request_mode)[1]', 'sysname') lock_mode, 
		[resource].value('(transaction/@reference_count)[1]', 'int') reference_count,
		[resource].value('lock_owner_address[1]', 'sysname') [lock_owner_address], 
		[resource].query('.') [resource_data]
	FROM 
		@resources.nodes('//resource') [XmlData]([resource]);

GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.is_system_database','FN') IS NOT NULL
	DROP FUNCTION dbo.is_system_database;
GO

CREATE FUNCTION dbo.is_system_database(@DatabaseName sysname) 
	RETURNS bit
AS 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN 
		DECLARE @output bit = 0;
		DECLARE @override sysname; 

		IF UPPER(@DatabaseName) IN (N'MASTER', N'MSDB', N'MODEL')
			SET @output = 1; 

		IF UPPER(@DatabaseName) = N'TEMPDB'  -- not sure WHY this would ever be interrogated, but... it IS a system database.
			SET @output = 1;
		
		IF UPPER(@DatabaseName) = N'ADMINDB' BEGIN -- by default, the [admindb] is treated as a system database (but this can be overwritten as a setting in dbo.settings).
			SET @output = 1;

			SELECT @override = setting_value FROM dbo.settings WHERE setting_key = N'admindb_is_system_db';

			IF @override = N'0'	-- only overwrite if a) the setting is there/defined AND the setting's value = 0 (i.e., false).
				SET @output = 0;
		END;

		IF UPPER(@DatabaseName) = N'DISTRIBUTION' BEGIN -- same with the distribution database... 
			SET @output = 1;
			
			SELECT @override = setting_value FROM dbo.settings WHERE setting_key = N'distribution_is_system_db';

			IF @override = N'0'	-- only overwrite if a) the setting is there/defined AND the setting's value = 0 (i.e., false).
				SET @output = 0;
		END;

		RETURN @output;
	END; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.parse_vector','P') IS NOT NULL
	DROP PROC dbo.parse_vector;
GO

CREATE PROC dbo.parse_vector
	@Vector									sysname					, 
	@ValidationParameterName				sysname					= NULL,
	@ProhibitedIntervals					sysname					= NULL,				-- by default, ALL intervals are allowed... 
	@IntervalType							sysname					OUT, 
	@Value									bigint					OUT, 
	@Error									nvarchar(MAX)			OUT
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ValidationParameterName = ISNULL(NULLIF(@ValidationParameterName, N''), N'@Vector');
	IF @ValidationParameterName LIKE N'@%'
		SET @ValidationParameterName = REPLACE(@ValidationParameterName, N'@', N'');

	DECLARE @intervals table ( 
		[key] sysname NOT NULL, 
		[interval] sysname NOT NULL
	);

	INSERT INTO @intervals ([key],[interval]) 
	SELECT [key], [interval] 
	FROM (VALUES 
			(N'B', N'BACKUP'), (N'BACKUP', N'BACKUP'),
			(N'MILLISECOND', N'MILLISECOND'), (N'MS', N'MILLISECOND'), (N'SECOND', N'SECOND'), (N'S', N'SECOND'),(N'MINUTE', N'MINUTE'), (N'M', N'MINUTE'), 
			(N'N', N'MINUTE'), (N'HOUR', N'HOUR'), (N'H', 'HOUR'), (N'DAY', N'DAY'), (N'D', N'DAY'), (N'WEEK', N'WEEK'), (N'W', N'WEEK'),
			(N'MONTH', N'MONTH'), (N'MO', N'MONTH'), (N'QUARTER', N'QUARTER'), (N'Q', N'QUARTER'), (N'YEAR', N'YEAR'), (N'Y', N'YEAR')
	) x ([key], [interval]);

	SET @Vector = LTRIM(RTRIM(UPPER(REPLACE(@Vector, N' ', N''))));
	DECLARE @boundary int, @intervalValue sysname, @interval sysname;
	SET @boundary = PATINDEX(N'%[^0-9]%', @Vector) - 1;

	IF @boundary < 1 BEGIN 
		SET @Error = N'Invalid Vector format specified for parameter @' + @ValidationParameterName + N'. Format must be in ''XX nn'' or ''XXnn'' format - where XX is an ''integer'' duration (e.g., 72) and nn is an interval-specifier (e.g., HOUR, HOURS, H, or h).';
		RETURN -1;
	END;

	SET @intervalValue = LEFT(@Vector, @boundary);
	SET @interval = UPPER(REPLACE(@Vector, @intervalValue, N''));

	IF @interval LIKE '%S' AND @interval NOT IN ('S', 'MS')
		SET @interval = LEFT(@interval, LEN(@interval) - 1); 

	IF NOT @interval IN (SELECT [key] FROM @intervals) BEGIN
		SET @Error = N'Invalid interval specifier defined for @' + @ValidationParameterName + N'. Valid interval specifiers are { [MILLISECOND(S)|MS] | [SECOND(S)|S] | [MINUTE(S)|M|N] | [HOUR(S)|H] | [DAY(S)|D] | [WEEK(S)|W] | [MONTH(S)|MO] | [QUARTER(S)|Q] | [YEAR(S)|Y] }';
		RETURN -10;
	END;

	--  convert @interval to a sanitized version of itself:
	SELECT @interval = [interval] FROM @intervals WHERE [key] = @interval;

	-- check for prohibited intervals: 
	IF NULLIF(@ProhibitedIntervals, N'') IS NOT NULL BEGIN 
		-- delete INTERVALS based on keys - e.g., if ms is prohibited, we don't want to simply delete the MS entry - we want to get all 'forms' of it (i.e., MS, MILLISECOND, etc.)
		DELETE FROM @intervals WHERE [interval] IN (SELECT [interval] FROM @intervals WHERE UPPER([key]) IN (SELECT UPPER([result]) FROM dbo.[split_string](@ProhibitedIntervals, N',', 1)));
		
		IF @interval NOT IN (SELECT [interval] FROM @intervals) BEGIN
			SET @Error = N'The interval-specifier [' + @interval + N'] is not permitted in this operation type. Prohibited intervals for this operation are: ' + @ProhibitedIntervals + N'.';
			RETURN -30;
		END;
	END;

	SELECT 
		@IntervalType = @interval, 
		@Value = CAST(@intervalValue AS bigint);

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.translate_vector','P') IS NOT NULL
	DROP PROC dbo.translate_vector;
GO

CREATE PROC dbo.translate_vector
	@Vector									sysname						= NULL, 
	@ValidationParameterName				sysname						= NULL, 
	@ProhibitedIntervals					sysname						= NULL,								
	@TranslationDatePart					sysname						= N'MILLISECOND',					-- The 'DATEPART' value you want to convert BY/TO. Allowed Values: { MILLISECONDS | SECONDS | MINUTES | HOURS | DAYS | WEEKS | MONTHS | YEARS }
	@Output									bigint						= NULL		OUT, 
	@Error									nvarchar(MAX)				= NULL		OUT
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------

	-- convert @TranslationDatePart to a sanitized version of itself:
	IF @TranslationDatePart IS NULL OR @TranslationDatePart NOT IN ('MILLISECOND', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR') BEGIN 
		SET @Error = N'Invalid @TranslationDatePart value specified. Allowed values are: { [MILLISECOND(S)|MS] | [SECOND(S)|S] | [MINUTE(S)|M|N] | [HOUR(S)|H] | [DAY(S)|D] | [WEEK(S)|W] | [MONTH(S)|MO] | [YEAR(S)|Y] }.';
		RETURN -12;
	END;

	IF @ProhibitedIntervals IS NULL
		SET @ProhibitedIntervals = N'BACKUP';

	IF dbo.[count_matches](@ProhibitedIntervals, N'BACKUP') < 1
		SET @ProhibitedIntervals = @ProhibitedIntervals + N', BACKUP';

	DECLARE @errorMessage nvarchar(MAX);
	DECLARE @interval sysname;
	DECLARE @duration bigint;

	EXEC dbo.parse_vector 
		@Vector = @Vector, 
		@ValidationParameterName  = @ValidationParameterName, 
		@ProhibitedIntervals = @ProhibitedIntervals, 
		@IntervalType = @interval OUTPUT, 
		@Value = @duration OUTPUT, 
		@Error = @errorMessage OUTPUT; 

	IF @errorMessage IS NOT NULL BEGIN 
		SET @Error = @errorMessage;
		RETURN -10;
	END;

	-----------------------------------------------------------------------------
	-- Processing: 
	DECLARE @now datetime = GETDATE();
	
	BEGIN TRY 

		DECLARE @command nvarchar(400) = N'SELECT @difference = DATEDIFF(' + @TranslationDatePart + N', @now, (DATEADD(' + @interval + N', ' + CAST(@duration AS sysname) + N', @now)));'
		EXEC sp_executesql 
			@command, 
			N'@now datetime, @difference bigint OUTPUT', 
			@now = @now, 
			@difference = @Output OUTPUT;

	END TRY 
	BEGIN CATCH
		SELECT @Error = N'EXCEPTION: ' + CAST(ERROR_MESSAGE() AS sysname) + N' - ' + ERROR_MESSAGE();
		RETURN -30;
	END CATCH

	RETURN 0;
GO	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.translate_vector_delay','P') IS NOT NULL
	DROP PROC dbo.translate_vector_delay;
GO

CREATE PROC dbo.translate_vector_delay
	@Vector								sysname     	= NULL, 
	@ParameterName						sysname			= NULL, 
	@Output								sysname			= NULL		OUT, 
	@Error								nvarchar(MAX)	= NULL		OUT
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @difference int;

	EXEC dbo.translate_vector 
		@Vector = @Vector, 
		@ValidationParameterName = @ParameterName,
		@ProhibitedIntervals = N'DAY,WEEK,MONTH,QUARTER,YEAR',  -- days are overkill for any sort of WAITFOR delay specifier (that said, 38 HOURS would work... )  
		@Output = @difference OUTPUT, 
		@Error = @Error OUTPUT;

	IF @difference > 187200100 BEGIN 
		RAISERROR(N'@Vector can not be > 52 Hours when defining a DELAY value.', 16, 1);
		RETURN -2;
	END; 

	IF @Error IS NOT NULL BEGIN 
		RAISERROR(@Error, 16, 1); 
		RETURN -5;
	END;
	
	SELECT @Output = RIGHT(dbo.[format_timespan](@difference), 12);

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO 

IF OBJECT_ID('dbo.translate_vector_datetime','P') IS NOT NULL
	DROP PROC dbo.translate_vector_datetime;
GO

CREATE PROC dbo.translate_vector_datetime
	@Vector									sysname						= NULL, 
	@Operation								sysname						= N'ADD',		-- Allowed Values are { ADD | SUBTRACT }
	@ValidationParameterName				sysname						= NULL, 
	@ProhibitedIntervals					sysname						= NULL,	
	@Output									datetime					OUT, 
	@Error									nvarchar(MAX)				OUT
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	IF UPPER(@Operation) NOT IN (N'ADD', N'SUBTRACT') BEGIN 
		RAISERROR('Valid operations (values for @Operation) are { ADD | SUBTRACT }.', 16, 1);
		RETURN -1;
	END;

	IF @ProhibitedIntervals IS NULL
		SET @ProhibitedIntervals = N'BACKUP';

	IF dbo.[count_matches](@ProhibitedIntervals, N'BACKUP') < 1
		SET @ProhibitedIntervals = @ProhibitedIntervals + N', BACKUP';

	DECLARE @errorMessage nvarchar(MAX);
	DECLARE @interval sysname;
	DECLARE @duration bigint;

	EXEC dbo.parse_vector 
		@Vector = @Vector, 
		@ValidationParameterName  = @ValidationParameterName, 
		@ProhibitedIntervals = @ProhibitedIntervals, 
		@IntervalType = @interval OUTPUT, 
		@Value = @duration OUTPUT, 
		@Error = @errorMessage OUTPUT; 

	IF @errorMessage IS NOT NULL BEGIN 
		SET @Error = @errorMessage;
		RETURN -10;
	END;

	DECLARE @sql nvarchar(2000) = N'SELECT @timestamp = DATEADD({0}, {2}{1}, GETDATE());';
	SET @sql = REPLACE(@sql, N'{0}', @interval);
	SET @sql = REPLACE(@sql, N'{1}', @duration);

	IF UPPER(@Operation) = N'ADD'
		SET @sql = REPLACE(@sql, N'{2}', N'');
	ELSE 
		SET @sql = REPLACE(@sql, N'{2}', N'0 - ');

	DECLARE @ts datetime;

	BEGIN TRY 
		
		EXEC sys.[sp_executesql]
			@sql, 
			N'@timestamp datetime OUT', 
			@timestamp = @ts OUTPUT;

	END TRY
	BEGIN CATCH 
		SELECT @Error = N'EXCEPTION: ' + CAST(ERROR_MESSAGE() AS sysname) + N' - ' + ERROR_MESSAGE();
		RETURN -30;
	END CATCH

	SET @Output = @ts;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_alerting_configuration','P') IS NOT NULL
	DROP PROC dbo.[verify_alerting_configuration];
GO

CREATE PROC dbo.[verify_alerting_configuration]
	@OperatorName						    sysname									= N'{DEFAULT}',
	@MailProfileName					    sysname									= N'{DEFAULT}'
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    DECLARE @output sysname;

    IF UPPER(@OperatorName) = N'{DEFAULT}' OR (NULLIF(@OperatorName, N'') IS NULL) BEGIN 
        SET @output = NULL;
        EXEC dbo.load_default_setting 
            @SettingName = N'DEFAULT_OPERATOR', 
            @Result = @output OUTPUT;

        SET @OperatorName = @output;
    END;

    IF UPPER(@MailProfileName) = N'{DEFAULT}' OR (NULLIF(@MailProfileName, N'') IS NULL) BEGIN
        SET @output = NULL;
        EXEC dbo.load_default_setting 
            @SettingName = N'DEFAULT_PROFILE', 
            @Result = @output OUTPUT;   
            
        SET @MailProfileName = @output;
    END;
	
    -- Operator Check:
	IF ISNULL(@OperatorName, '') IS NULL BEGIN
		RAISERROR('An Operator is not specified - error details can''t be via email if encountered.', 16, 1);
		RETURN -4;
		END;
	ELSE BEGIN
		IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
			RAISERROR('Invalid Operator Name Specified.', 16, 1);
			RETURN -4;
		END;
	END;

	-- Profile Check:
	DECLARE @DatabaseMailProfile nvarchar(255);
	EXEC master.dbo.xp_instance_regread 
        N'HKEY_LOCAL_MACHINE', 
        N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', 
        @param = @DatabaseMailProfile OUT, 
        @no_output = N'no_output';
 
	IF @DatabaseMailProfile != @MailProfileName BEGIN
		RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
		RETURN -5;
	END; 

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.extract_waitresource','P') IS NOT NULL
	DROP PROC dbo.extract_waitresource;
GO

CREATE PROC dbo.extract_waitresource
	@WaitResource				sysname, 
	@DatabaseMappings			nvarchar(MAX)			= NULL,
	@Output						nvarchar(2000)			= NULL    OUTPUT
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF NULLIF(@WaitResource, N'') IS NULL BEGIN 
		SET @Output = N'';
		RETURN 0;
	END;
		
	IF @WaitResource = N'0:0:0' BEGIN 
		SET @Output = N'[0:0:0] - UNIDENTIFIED_RESOURCE';  -- Paul Randal Identified this on twitter on 2019-08-06: https://twitter.com/PaulRandal/status/1158810119670358016
                                                           -- specifically: when the last wait type is PAGELATCH, the last resource isn't preserved - so we get 0:0:0 - been that way since 2005. 
                                                           --      and, I honestly wonder if that could/would be the case with OTHER scenarios? 
		RETURN 0;
	END;

    IF @WaitResource LIKE N'ACCESS_METHODS_DATASET_PARENT%' BEGIN 
        SET @Output = N'[SYSTEM].[PARALLEL_SCAN (CXPACKET)].[' + @WaitResource + N']';
        RETURN 0;
    END;

	IF @WaitResource LIKE '%COMPILE]' BEGIN -- just change the formatting so that it matches 'rules processing' details below... 
		SET @WaitResource = N'COMPILE: ' + REPLACE(REPLACE(@WaitResource, N' [COMPILE]', N''), N'OBJECT: ', N'');
	END;

	IF @WaitResource LIKE '%[0-9]%:%[0-9]%:%[0-9]%' AND @WaitResource NOT LIKE N'%: %' BEGIN -- this is a 'shorthand' PAGE identifier: 
		SET @WaitResource = N'XPAGE: ' + @WaitResource;
	END;

	IF @WaitResource LIKE N'KEY: %' BEGIN 
		SET @WaitResource = REPLACE(REPLACE(@WaitResource, N' (', N':'), N')', N'');  -- extract to 'explicit' @part4... 
	END;

	IF @WaitResource LIKE N'RID: %' BEGIN 
		SET @WaitResource = REPLACE(@WaitResource, N'RID: ', N'ROW: '); -- standardize... 
	END;

	IF @WaitResource LIKE N'TABLE: %' BEGIN
		SET @WaitResource = REPLACE(@WaitResource, N'TABLE: ', N'TAB: '); -- standardize formatting... 
	END;

	CREATE TABLE #ExtractionMapping ( 
		row_id int NOT NULL, 
		[database_id] int NOT NULL,         -- source_id (i.e., from production)
        [metadata_name] sysname NOT NULL,   -- db for which OBJECT_ID(), PAGE/HOBT/KEY/etc. lookups should be executed against - LOCALLY
        [mapped_name] sysname NULL          -- friendly-name (i.e., if prod_db_name = widgets, and local meta-data-db = widgets_copyFromProd, friendly_name makes more sense as 'widgets' but will DEFAULT to widgets_copyFromProd (if friendly is NOT specified)
	); 

	IF NULLIF(@DatabaseMappings, N'') IS NOT NULL BEGIN
		INSERT INTO #ExtractionMapping ([row_id], [database_id], [metadata_name], [mapped_name])
		EXEC dbo.[shred_string] 
		    @Input = @DatabaseMappings, 
		    @RowDelimiter = N',',
		    @ColumnDelimiter = N'|'
	END;

	SET @WaitResource = REPLACE(@WaitResource, N' ', N'');
	DECLARE @parts table (row_id int, part nvarchar(200));

	INSERT INTO @parts (row_id, part) 
	SELECT [row_id], [result] FROM dbo.[split_string](@WaitResource, N':', 1);

	BEGIN TRY 
		DECLARE @waittype sysname, @part2 bigint, @part3 bigint, @part4 sysname, @part5 sysname;
		SELECT @waittype = part FROM @parts WHERE [row_id] = 1; 
		SELECT @part2 = CAST(part AS bigint) FROM @parts WHERE [row_id] = 2; 
		SELECT @part3 = CAST(part AS bigint) FROM @parts WHERE [row_id] = 3; 
		SELECT @part4 = part FROM @parts WHERE [row_id] = 4; 
		SELECT @part5 = part FROM @parts WHERE [row_id] = 5; 
	
		DECLARE @lookupSQL nvarchar(2000);
		DECLARE @objectName sysname;
		DECLARE @indexName sysname;
		DECLARE @objectID int;
		DECLARE @indexID int;
		DECLARE @error bit = 0;

		DECLARE @logicalDatabaseName sysname; 
		DECLARE @metaDataDatabaseName sysname;

		-- NOTE: _MAY_ need to override this in some resource types - but, it's used in SO many types (via @part2) that 'solving' for it here makes tons of sense). 
		SET @metaDataDatabaseName = ISNULL((SELECT [metadata_name] FROM [#ExtractionMapping] WHERE [database_id] = @part2), DB_NAME(@part2));
        SET @logicalDatabaseName = ISNULL((SELECT ISNULL([mapped_name], [metadata_name]) FROM [#ExtractionMapping] WHERE [database_id] = @part2), DB_NAME(@part2));

		IF @waittype = N'DATABASE' BEGIN
			IF @part3 = 0 
				SELECT @Output = QUOTENAME(@logicalDatabaseName) + N'- SCHEMA_LOCK';
			ELSE 
				SELECT @Output = QUOTENAME(@logicalDatabaseName) + N' - DATABASE_LOCK';

			RETURN 0;
		END; 

		IF @waittype = N'FILE' BEGIN 
            -- MKC: lookups are pointless -.. 
			--SET @lookupSQL = N'SELECT @objectName = [physical_name] FROM [Xcelerator].sys.[database_files] WHERE FILE_ID = ' + CAST(@part3 AS sysname) + N';';
			--EXEC [sys].[sp_executesql]
			--	@stmt = @lookupSQL, 
			--	@params = N'@objectName sysname OUTPUT', 
			--	@objectName = @objectName OUTPUT;

			--SELECT @Output = QUOTENAME(@logicalDatabaseName) + N' - FILE_LOCK (' + ISNULL(@objectName, N'FILE_ID: ' + CAST(@part3 AS sysname)) + N')';
            SELECT @Output = QUOTENAME(@logicalDatabaseName) + N' - FILE_LOCK (Data or Log file - Engine does not specify)';
			RETURN 0;
		END;

		-- TODO: test/verify output AGAINST real 'capture' info.... 
		IF @waittype = N'TAB' BEGIN 
			SET @lookupSQL = N'SELECT @objectName = [name] FROM [' + ISNULL(@metaDataDatabaseName, N'master') + N'].sys.objects WHERE object_id = ' + CAST(@part3 AS sysname) + N';';	

			EXEC [sys].[sp_executesql]
				@stmt = @lookupSQL, 
				@params = N'@objectName sysname OUTPUT', 
				@objectName = @objectName OUTPUT;

			SET @Output = QUOTENAME(ISNULL(@logicalDatabaseName, N'DB_ID: ' + CAST(@part2 AS sysname))) + N'.' + QUOTENAME(ISNULL(@objectName, N'TABLE_ID: ' + CAST(@part3 AS sysname))) + N' - TABLE_LOCK';
			RETURN 0;
		END;

		IF @waittype = N'KEY' BEGIN 
			SET @lookupSQL = N'SELECT @objectName = o.[name], @indexName = i.[name] FROM [' + ISNULL(@metaDataDatabaseName, N'master') + N'].sys.partitions p INNER JOIN [' + ISNULL(@metaDataDatabaseName, N'master') + N'].sys.objects o ON p.[object_id] = o.[object_id] INNER JOIN [' + ISNULL(@metaDataDatabaseName, N'master') + N'].sys.indexes i ON [o].[object_id] = [i].[object_id] AND p.[index_id] = [i].[index_id] WHERE p.hobt_id = ' + CAST(@part3 AS sysname) + N';';

			EXEC [sys].[sp_executesql]
				@stmt = @lookupSQL, 
				@params = N'@objectName sysname OUTPUT, @indexName sysname OUTPUT', 
				@objectName = @objectName OUTPUT, 
				@indexName = @indexName OUTPUT;

			SET @Output = QUOTENAME(ISNULL(@metaDataDatabaseName, N'DB_ID: ' + CAST(@part2 AS sysname))) + N'.' + QUOTENAME(ISNULL(@objectName, N'TABLE_ID: ' + CAST(@part3 AS sysname))) + N'.' + QUOTENAME(ISNULL(@indexName, 'INDEX_ID: -1')) + N'.[RANGE: (' + ISNULL(@part4, N'') + N')] - KEY_LOCK';
			RETURN 0;
		END;

		IF @waittype = N'OBJECT' OR @waittype = N'COMPILE' BEGIN 
			SET @lookupSQL = N'SELECT @objectName = [name] FROM [' + ISNULL(@metaDataDatabaseName, N'master') + N'].sys.objects WHERE object_id = ' + CAST(@part3 AS sysname) + N';';	
			EXEC [sys].[sp_executesql]
				@stmt = @lookupSQL, 
				@params = N'@objectName sysname OUTPUT', 
				@objectName = @objectName OUTPUT;		

			SET @Output = QUOTENAME(ISNULL(@logicalDatabaseName, N'DB_ID: ' + CAST(@part2 AS sysname))) + N'.' + QUOTENAME(ISNULL(@objectName, N'OBJECT_ID: ' + CAST(@part3 AS sysname))) + N' - ' + @waittype +N'_LOCK';
			RETURN 0;
		END;

		IF @waittype IN(N'PAGE', N'XPAGE', N'EXTENT', N'ROW') BEGIN 

			CREATE TABLE #results (ParentObject varchar(255), [Object] varchar(255), Field varchar(255), [VALUE] varchar(255));
			SET @lookupSQL = N'DBCC PAGE('''+ @metaDataDatabaseName + ''', ' + CAST(@part3 AS sysname) + ', ' + @part4 + ', 1) WITH TABLERESULTS;'

			INSERT INTO #results ([ParentObject], [Object], [Field], [VALUE])
			EXECUTE (@lookupSQL);
		
			SELECT @objectID = CAST([VALUE] AS int) FROM [#results] WHERE [ParentObject] = N'PAGE HEADER:' AND [Field] = N'Metadata: ObjectId';
			SELECT @indexID = CAST([VALUE] AS int) FROM [#results] WHERE [ParentObject] = N'PAGE HEADER:' AND [Field] = N'Metadata: IndexId';
		
			SET @lookupSQL = N'SELECT @objectName = [name] FROM [' + ISNULL(@metaDataDatabaseName, N'master') + N'].sys.objects WHERE object_id = ' + CAST(@objectID AS sysname) + N';';	
			EXEC [sys].[sp_executesql]
				@stmt = @lookupSQL, 
				@params = N'@objectName sysname OUTPUT', 
				@objectName = @objectName OUTPUT;

			SET @lookupSQL = N'SELECT @indexName = [name] FROM [' + ISNULL(@metaDataDatabaseName, N'master') + N'].sys.indexes WHERE object_id = ' + CAST(@objectID AS sysname) + N' AND index_id = ' + CAST(@indexID AS sysname) + N';';	
			EXEC [sys].[sp_executesql]
				@stmt = @lookupSQL, 
				@params = N'@indexName sysname OUTPUT', 
				@indexName = @indexName OUTPUT;

			IF @waittype = N'ROW' 
				SET @Output = QUOTENAME(ISNULL(@logicalDatabaseName, N'DB_ID: ' + CAST(@part2 AS sysname))) + N'.' + QUOTENAME(ISNULL(@objectName, N'TABLE_ID: ' + CAST(@part3 AS sysname))) + N'.' + QUOTENAME(ISNULL(@indexName, 'INDEX_ID: ' + CAST(@indexID AS sysname))) + N'.[PAGE_ID: ' + ISNULL(@part4, N'')  + N'].[SLOT: ' + ISNULL(@part5, N'') + N'] - ' + @waittype + N'_LOCK';
			ELSE
				SET @Output = QUOTENAME(ISNULL(@logicalDatabaseName, N'DB_ID: ' + CAST(@part2 AS sysname))) + N'.' + QUOTENAME(ISNULL(@objectName, N'TABLE_ID: ' + CAST(@part3 AS sysname))) + N'.' + QUOTENAME(ISNULL(@indexName, 'INDEX_ID: ' + CAST(@indexID AS sysname))) + N' - ' + @waittype + N'_LOCK';
			RETURN 0;
		END;
	END TRY 
	BEGIN CATCH 
		PRINT 'PROCESSING_EXCEPTION: Line: ' + CAST(ERROR_LINE() AS sysname) + N' - Error: ' + CAST(ERROR_NUMBER() AS sysname) + N' -> ' + ERROR_MESSAGE();
		SET @error = 1;
	END CATCH

	-- IF we're still here - then either there was an exception 'shredding' the resource identifier - or we're in an unknown resource-type. (Either outcome, though, is that we're dealing with an unknown/non-implemented type.)
	SELECT @waittype [wait_type], @part2 [part2], @part3 [part3], @part4 [part4], @part5 [part5];

	IF @error = 1 
		SET @Output = QUOTENAME(@WaitResource) + N' - EXCEPTION_PROCESSING_WAIT_RESOURCE';
	ELSE
		SET @Output = QUOTENAME(@WaitResource) + N' - S4_UNKNOWN_WAIT_RESOURCE';

	RETURN -1;
GO


-----------------------------------
USE	[admindb];
GO

IF OBJECT_ID('dbo.list_databases_matching_token','P') IS NOT NULL
	DROP PROC dbo.list_databases_matching_token;
GO

CREATE PROC dbo.list_databases_matching_token	
	@Token								sysname			= N'{DEV}',					-- { [DEV] | [TEST] }
	@SerializedOutput					xml				= N'<default/>'	    OUTPUT
AS 

	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	
	IF NOT @Token LIKE N'{%}' BEGIN 
		RAISERROR(N'@Token names must be ''wrapped'' in {curly brackets] (and must also be defined in dbo.setttings).', 16, 1);
		RETURN -5;
	END;

	-----------------------------------------------------------------------------
	-- Processing:
	DECLARE @tokenMatches table ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL
	);

	IF UPPER(@Token) IN (N'{ALL}', N'{SYSTEM}', N'{USER}') BEGIN
		-- define system databases - we'll potentially need this in a number of different cases...
		DECLARE @system_databases TABLE ( 
			[entry_id] int IDENTITY(1,1) NOT NULL, 
			[database_name] sysname NOT NULL
		); 	
	
		INSERT INTO @system_databases ([database_name])
		SELECT N'master' UNION SELECT N'msdb' UNION SELECT N'model';		

		-- Treat admindb as {SYSTEM} if defined as system... : 
		IF (SELECT dbo.is_system_database('admindb')) = 1 BEGIN
			INSERT INTO @system_databases ([database_name])
			VALUES ('admindb');
		END;

		-- same with distribution database - but only if present:
		IF EXISTS (SELECT NULL FROM master.sys.databases WHERE [name] = 'distribution') BEGIN
			IF (SELECT dbo.is_system_database('distribution')) = 1  BEGIN
				INSERT INTO @system_databases ([database_name])
				VALUES ('distribution');
			END;
		END;

		IF UPPER(@Token) IN (N'{ALL}', N'{SYSTEM}') BEGIN 
			INSERT INTO @tokenMatches ([database_name])
			SELECT [database_name] FROM @system_databases; 
		END; 

		IF UPPER(@Token) IN (N'{ALL}', N'{USER}') BEGIN 
			INSERT INTO @tokenMatches ([database_name])
			SELECT [name] FROM sys.databases
			WHERE [name] NOT IN (SELECT [database_name] COLLATE SQL_Latin1_General_CP1_CI_AS  FROM @system_databases)
				AND LOWER([name]) <> N'tempdb'
			ORDER BY [name];
		 END; 

	  END; 
	ELSE BEGIN
		
		-- 'custom token'... 
		DECLARE @tokenDefs table (
			row_id int IDENTITY(1,1) NOT NULL,
			pattern sysname NOT NULL
		); 

		INSERT INTO @tokenDefs ([pattern])
		SELECT 
			[setting_value] 
		FROM 
			dbo.[settings]
		WHERE 
			[setting_key] = @Token
		ORDER BY 
			[setting_id];

		IF NOT EXISTS (SELECT NULL FROM @tokenDefs) BEGIN 
			DECLARE @errorMessage nvarchar(2000) = N'No filter definitions were defined for token: ' + @Token + '. Please check dbo.settings for ' + @Token + N' settings_key(s) and/or create as needed.';
			RAISERROR(@errorMessage, 16, 1);
			RETURN -1;
		END;
	
		INSERT INTO @tokenMatches ([database_name])
		SELECT 
			d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS [database_name]
		FROM 
			sys.databases d
			INNER JOIN @tokenDefs f ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS LIKE f.[pattern] 
		ORDER BY 
			f.row_id, d.[name];
	END;

	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- if @SerializedOutput has been EXPLICITLY provided as an argument... reply 

		SELECT @SerializedOutput = (SELECT 
			[row_id] [database/@id],
			[database_name] [database]
		FROM 
			@tokenMatches
		ORDER BY 
			[row_id] 
		FOR XML PATH(''), ROOT('databases'));		

		RETURN 0;
	END;

    -- otherwise (if we're still here) ... PROJECT:
	SELECT 
		[database_name]
	FROM 
		@tokenMatches 
	ORDER BY 
		[row_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.replace_dbname_tokens','P') IS NOT NULL
	DROP PROC dbo.replace_dbname_tokens;
GO

CREATE PROC dbo.replace_dbname_tokens
	@Input					nvarchar(MAX), 
	@AllowedTokens			nvarchar(MAX)		= NULL,			-- When NON-NULL overrides lookup of all DEFINED token types in dbo.settings (i.e., where the setting_key is like [xxx]). 			
	@Output					nvarchar(MAX)		OUTPUT
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Inputs: 


	-----------------------------------------------------------------------------
	-- processing: 
	IF NULLIF(@AllowedTokens, N'') IS NULL BEGIN

		SET @AllowedTokens = N'';
		
		WITH aggregated AS (
			SELECT 
				UPPER(setting_key) [token], 
				COUNT(*) [ranking]
			FROM 
				dbo.[settings] 
			WHERE 
				[setting_key] LIKE '{%}'
			GROUP BY 
				[setting_key]

			UNION 
			
			SELECT 
				[token], 
				[ranking] 
			FROM (VALUES (N'{ALL}', 1000), (N'{SYSTEM}', 999), (N'{USER}', 998)) [x]([token], [ranking])
		) 

		SELECT @AllowedTokens = @AllowedTokens + [token] + N',' FROM [aggregated] ORDER BY [ranking] DESC;

		SET @AllowedTokens = LEFT(@AllowedTokens, LEN(@AllowedTokens) - 1);
	END;

	DECLARE @tokensToProcess table (
		row_id int IDENTITY(1,1) NOT NULL, 
		token sysname NOT NULL
	); 

	INSERT INTO @tokensToProcess ([token])
	SELECT [result] FROM dbo.[split_string](@AllowedTokens, N',', 1) ORDER BY [row_id];

	-- now that allowed tokens are defined, make sure any tokens specified within @Input are defined in @AllowedTokens: 
	DECLARE @possibleTokens table (
		token sysname NOT NULL
	);

	INSERT INTO @possibleTokens ([token])
	SELECT [result] FROM dbo.[split_string](@Input, N',', 1) WHERE [result] LIKE N'%{%}' ORDER BY [row_id];

	IF EXISTS (SELECT NULL FROM @possibleTokens WHERE [token] NOT IN (SELECT [token] FROM @tokensToProcess)) BEGIN
		RAISERROR('Undefined database-name token specified in @Input. Please ensure that custom database-name tokens are defined in dbo.settings.', 16, 1);
		RETURN -1;
	END;

	DECLARE @intermediateResults nvarchar(MAX) = @Input;
	DECLARE @currentToken sysname;
	DECLARE @databases xml;
	DECLARE @serialized nvarchar(MAX);

	DECLARE walker CURSOR LOCAL FAST_FORWARD FOR 
	SELECT token FROM @tokensToProcess ORDER BY [row_id];

	OPEN walker; 
	FETCH NEXT FROM walker INTO @currentToken;

	WHILE @@FETCH_STATUS = 0 BEGIN

		SET @databases = NULL;
		SET @serialized = N'';

		EXEC dbo.list_databases_matching_token 
			@Token = @currentToken, 
			@SerializedOutput = @databases OUTPUT; 		

		WITH shredded AS ( 
			SELECT 
				[data].[row].value('@id[1]', 'int') [row_id], 
				[data].[row].value('.[1]', 'sysname') [database_name]
			FROM 
				@databases.nodes('//database') [data]([row])
		) 
		
		SELECT 
			@serialized = @serialized + [database_name] + ', '
		FROM 
			[shredded] 
		ORDER BY 
			[row_id];

		IF NULLIF(@serialized, N'') IS NOT NULL
			SET @serialized = LEFT(@serialized, LEN(@serialized) -1); 

		SET @intermediateResults = REPLACE(@intermediateResults, @currentToken, @serialized);


		FETCH NEXT FROM walker INTO @currentToken;
	END;

	CLOSE walker;
	DEALLOCATE walker;

	SET @Output = @intermediateResults;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO


IF OBJECT_ID('dbo.format_sql_login','FN') IS NOT NULL
	DROP FUNCTION dbo.format_sql_login;
GO

CREATE FUNCTION dbo.format_sql_login (
    @Enabled                          bit,                                  -- IF NULL the login will be DISABLED via the output/script.
    @BehaviorIfLoginExists            sysname         = N'NONE',            -- { NONE | ALTER | DROP_AND_CREATE }
    @Name                             sysname,                              -- always required.
    @Password                         varchar(256),                         -- NOTE: while not 'strictly' required by ALTER LOGIN statements, @Password is ALWAYS required for dbo.format_sql_login.
    @SID                              varchar(100),                         -- only processed if this is a CREATE or a DROP/CREATE... 
    @DefaultDatabase                  sysname         = N'master',          -- have to specify DEFAULT for this to work... obviously
    @DefaultLanguage                  sysname         = N'{DEFAULT}',       -- have to specify DEFAULT for this to work... obviously
    @CheckExpiration				  bit             = 0,                  -- have to specify DEFAULT for this to work... obviously
    @CheckPolicy                      bit             = 0                   -- have to specify DEFAULT for this to work... obviously
)
RETURNS nvarchar(MAX)
AS 
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    BEGIN 
        DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
        DECLARE @newAtrributeLine sysname = @crlf + NCHAR(9) + N' ';

        DECLARE @output nvarchar(MAX) = N'-- ERROR scripting login. ' + @crlf 
            + N'--' + NCHAR(9) + N'Parameters @Name and @Password are both required.' + @crlf
            + N'--' + NCHAR(9) + '   Supplied Values: @Name -> [{Name}], @Password -> [{Password}].'
        
        IF NULLIF(@BehaviorIfLoginExists, N'') IS NULL 
            SET @BehaviorIfLoginExists = N'NONE';

        IF UPPER(@BehaviorIfLoginExists) NOT IN (N'NONE', N'ALTER', N'DROP_AND_CREATE')
            SET @BehaviorIfLoginExists = N'NONE';

        IF (NULLIF(@Name, N'') IS NULL) OR (NULLIF(@Password, N'') IS NULL) BEGIN 
            SET @output = REPLACE(@output, N'{name}', ISNULL(NULLIF(@Name, N''), N'#NOT PROVIDED#'));
            SET @output = REPLACE(@output, N'{Password}', ISNULL(NULLIF(@Password, N''), N'#NOT PROVIDED#'));

            GOTO Done;
        END;        
        
        DECLARE @attributes sysname = N'{PASSWORD}{SID}{DefaultDatabase}{DefaultLanguage}{CheckExpiration}{CheckPolicy};';
        DECLARE @alterAttributes sysname = REPLACE(@attributes, N'{SID}', N'');

        DECLARE @template nvarchar(MAX) = N'
IF NOT EXISTS (SELECT NULL FROM [master].[sys].[server_principals] WHERE [name] = ''{EscapedName}'') BEGIN 
	CREATE LOGIN [{Name}] WITH {Attributes} {Disable} {ElseClause} {SidReplacementDrop}{CreateOrAlter} {Attributes2} {Disable2}
END; ';
        -- Main logic flow:
        IF UPPER(@BehaviorIfLoginExists) = N'NONE' BEGIN 
            SET @template = REPLACE(@template, N'{SidReplacementDrop}', N'');
            SET @template = REPLACE(@template, N'{ElseClause}', N'');
            SET @template = REPLACE(@template, N'{CreateOrAlter}', N''); 
                
            SET @template = REPLACE(@template, N'{Attributes2}', N'');
            SET @template = REPLACE(@template, N'{Disable2}', N'');

        END;

        IF UPPER(@BehaviorIfLoginExists) = N'ALTER' BEGIN 
            SET @template = REPLACE(@template, N'{SidReplacementDrop}', N'');

            SET @template = REPLACE(@template, N'{ElseClause}', @crlf + N'  END;' + @crlf + N'ELSE BEGIN' + @crlf);
            SET @template = REPLACE(@template, N'{CreateOrAlter}', NCHAR(9) + N'ALTER LOGIN [{Name}] WITH ');
            SET @template = REPLACE(@template, N'{Attributes2}', @alterAttributes);
            SET @template = REPLACE(@template, N'{Disable2}', N'{Disable}');
        END;

        IF UPPER(@BehaviorIfLoginExists) = N'DROP_AND_CREATE' BEGIN 
            SET @template = REPLACE(@template, N'{ElseClause}', @crlf + N'  END;' + @crlf + N'ELSE BEGIN' + @crlf);
            SET @template = REPLACE(@template, N'{SidReplacementDrop}', NCHAR(9) + N'DROP LOGIN ' + QUOTENAME(@Name) + N';' + @crlf + @crlf);
            SET @template = REPLACE(@template, N'{CreateOrAlter}', NCHAR(9) + N'CREATE LOGIN [{Name}] WITH '); 
            
            SET @template = REPLACE(@template, N'{Attributes2}', @attributes);
            SET @template = REPLACE(@template, N'{Disable2}', N'{Disable}');
        END;
  
        -- initialize output with basic details:
        SET @output = REPLACE(@template, N'{Attributes}', @attributes);
		SET @output = REPLACE(@output, N'{Name}', @Name);
		SET @output = REPLACE(@output, N'{EscapedName}', REPLACE(@Name, N'''', N''''''));
		
        IF (@Password LIKE '0x%') --AND (@Password NOT LIKE '%HASHED')
            SET @Password = @Password + N' HASHED';
        ELSE 
            SET @Password = N'''' + @Password + N'''';
        
        SET @output = REPLACE(@output, N'{PASSWORD}', @newAtrributeLine + NCHAR(9) + N'PASSWORD = ' + @Password);

        IF NULLIF(@SID, N'') IS NOT NULL BEGIN 
            SET @output = REPLACE(@output, N'{SID}', @newAtrributeLine + N',SID = ' + @SID);
            END;
        ELSE BEGIN 
            SET @output = REPLACE(@output, N'{SID}', N'');
        END;

        -- Defaults:
        IF NULLIF(@DefaultDatabase, N'') IS NOT NULL BEGIN 
            SET @output = REPLACE(@output, N'{DefaultDatabase}', @newAtrributeLine + N',DEFAULT_DATABASE = ' + QUOTENAME(@DefaultDatabase));
            END; 
        ELSE BEGIN
            SET @output = REPLACE(@output, N'{DefaultDatabase}', N'');
        END;

        IF NULLIF(@DefaultLanguage, N'') IS NOT NULL BEGIN 
            IF UPPER(@DefaultLanguage) = N'{DEFAULT}'
                SELECT @DefaultLanguage = [name] FROM sys.syslanguages WHERE 
                    [langid] = (SELECT [value_in_use] FROM sys.[configurations] WHERE [name] = N'default language');

            SET @output = REPLACE(@output, N'{DefaultLanguage}', @newAtrributeLine + N',DEFAULT_LANGUAGE = ' + QUOTENAME(@DefaultLanguage));
            END;
        ELSE BEGIN 
            SET @output = REPLACE(@output, N'{DefaultLanguage}', N'');
        END;

        -- checks:
        IF @CheckExpiration IS NULL BEGIN 
            SET @output = REPLACE(@output, N'{CheckExpiration}', N'');
            END;
        ELSE BEGIN 
            SET @output = REPLACE(@output, N'{CheckExpiration}', @newAtrributeLine + N',CHECK_EXPIRATION = ' + CASE WHEN @CheckExpiration = 1 THEN N'ON' ELSE 'OFF' END);
        END;

        IF @CheckPolicy IS NULL BEGIN 
            SET @output = REPLACE(@output, N'{CheckPolicy}', N'');
            END;
        ELSE BEGIN 
            SET @output = REPLACE(@output, N'{CheckPolicy}', @newAtrributeLine + N',CHECK_POLICY = ' + CASE WHEN @CheckPolicy = 1 THEN N'ON' ELSE 'OFF' END);
        END;

        -- enabled:
        IF ISNULL(@Enabled, 0) = 0 BEGIN -- default secure (i.e., if we don't get an EXPLICIT enabled, disable... 
            SET @output = REPLACE(@output, N'{Disable}', @crlf + @crlf + NCHAR(9) + N'ALTER LOGIN ' + QUOTENAME(@Name) + N' DISABLE;');
            END;
        ELSE BEGIN
            SET @output = REPLACE(@output, N'{Disable}', N'');
        END;

Done:

        RETURN @output;
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.format_windows_login', 'FN') IS NOT NULL DROP FUNCTION [dbo].[format_windows_login];
GO

CREATE	FUNCTION [dbo].[format_windows_login] (
	@Enabled bit, -- IF NULL the login will be DISABLED via the output/script.
	@BehaviorIfLoginExists sysname = N'NONE', -- { NONE | ALTER | DROP_ANCE_CREATE }
	@Name sysname, -- always required.
	@DefaultDatabase sysname = N'master', -- have to specify DEFAULT for this to work... obviously
	@DefaultLanguage sysname = N'{DEFAULT}' -- have to specify DEFAULT for this to work... obviously
)
RETURNS nvarchar(MAX)
AS

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

BEGIN

	SET @Enabled = ISNULL(@Enabled, 0);
	SET @DefaultDatabase = NULLIF(@DefaultDatabase, N'');
	SET @DefaultLanguage = NULLIF(@DefaultLanguage, N'');
	SET @BehaviorIfLoginExists = ISNULL(NULLIF(@BehaviorIfLoginExists, N''), N'NONE');
	
	IF UPPER(@BehaviorIfLoginExists) NOT IN (N'NONE', N'ALTER', N'DROP_AND_CREATE') SET @BehaviorIfLoginExists = N'NONE';

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @newAtrributeLine sysname = @crlf + NCHAR(9) + NCHAR(9);

	DECLARE @output nvarchar(MAX) = N'-- ERROR scripting login. ' + @crlf + N'--' + NCHAR(9) + N'Parameter @Name is required.';

	IF (NULLIF(@Name, N'') IS NULL) BEGIN
		-- output is already set/defined.
		GOTO Done;
	END;

	IF (UPPER(@BehaviorIfLoginExists) = N'ALTER') AND (@DefaultDatabase IS NULL) AND (@DefaultLanguage IS NULL) BEGIN
		-- if these values are EXPLICITLY set to NULL (vs using the defaults), then we CAN'T run an alter - the statement would be: "ALTER LOGIN [principal\name];" ... which no worky. 
		SET @BehaviorIfLoginExists = N'DROP_AND_CREATE';
	END;

	DECLARE @attributesPresent bit = 1;
	IF @DefaultDatabase IS NULL AND @DefaultLanguage IS NULL 
		SET @attributesPresent = 0;

	DECLARE @createAndDisable nvarchar(MAX) = N'CREATE LOGIN [{Name}] FROM WINDOWS{withAttributes};{disable}';

	IF @Enabled = 0  
		SET @createAndDisable = REPLACE(@createAndDisable, N'{disable}', @crlf + @crlf + NCHAR(9) + N'ALTER LOGIN ' + QUOTENAME(@Name) + N' DISABLE;');
	ELSE 
		SET @createAndDisable = REPLACE(@createAndDisable, N'{disable}', N'');
		
	IF @attributesPresent = 1 BEGIN 
		DECLARE @attributes nvarchar(MAX) = N' WITH';

		IF @DefaultDatabase IS NOT NULL BEGIN
			SET @attributes = @attributes + @newAtrributeLine + N'DEFAULT_DATABASE = ' + QUOTENAME(@DefaultDatabase);
		END;

		IF @DefaultLanguage IS NOT NULL BEGIN 
			
			IF UPPER(@DefaultLanguage) = N'{DEFAULT}'
				SELECT
					@DefaultLanguage = [name]
				FROM
					[sys].[syslanguages]
				WHERE
					[langid] = (
					SELECT [value_in_use] FROM [sys].[configurations] WHERE [name] = N'default language'
				);

			IF @DefaultDatabase IS NULL 
				SET @attributes = @attributes + @newAtrributeLine + N'DEFAULT_LANGUAGE = ' + QUOTENAME(@DefaultLanguage)
			ELSE 
				SET @attributes = @attributes +  @newAtrributeLine + N',DEFAULT_LANGUAGE = ' + QUOTENAME(@DefaultLanguage)
		END;

		SET @createAndDisable = REPLACE(@createAndDisable, N'{withAttributes}', @attributes);
	  END
	ELSE BEGIN
		SET @createAndDisable = REPLACE(@createAndDisable, N'{withAttributes}', N'');
	END;

	DECLARE @flowTemplate nvarchar(MAX) = N'
IF NOT EXISTS (SELECT NULL FROM [master].[sys].[server_principals] WHERE [name] = ''{EscapedName}'') BEGIN 
	{createAndDisable}{else}{alterOrCreateAndDisable}
END; ';

	SET @output = REPLACE(@flowTemplate, N'{createAndDisable}', @createAndDisable);

	IF UPPER(@BehaviorIfLoginExists) = N'NONE' BEGIN
		SET @output = REPLACE(@output, N'{else}', N'');
		SET @output = REPLACE(@output, N'{alterOrCreateAndDisable}', N'');
	END;

	IF UPPER(@BehaviorIfLoginExists) = N'ALTER' BEGIN
		SET @output = REPLACE(@output, N'{else}', @crlf + N'  END;' + @crlf + N'ELSE BEGIN ');

		SET @createAndDisable = REPLACE(@createAndDisable, N'CREATE', N'ALTER');
		SET @createAndDisable = REPLACE(@createAndDisable, N' FROM WINDOWS', N'');

		SET @output = REPLACE(@output, N'{alterOrCreateAndDisable}', @crlf + NCHAR(9) + @createAndDisable);
	END;


	IF UPPER(@BehaviorIfLoginExists) = N'DROP_AND_CREATE' BEGIN
		SET @output = REPLACE(@output, N'{else}', @crlf + N'  END;' + @crlf + N'ELSE BEGIN ');

		SET @createAndDisable = @crlf + NCHAR(9) + N'DROP LOGIN [{Name}];' + @crlf + @crlf + NCHAR(9) + @createAndDisable;

		SET @output = REPLACE(@output, N'{alterOrCreateAndDisable}', @crlf + NCHAR(9) + @createAndDisable);
	END;

	SET @output = REPLACE(@output, N'{Name}', @Name);
	SET @output = REPLACE(@output, N'{EscapedName}', REPLACE(@Name, N'''', N''''''));

Done:

	RETURN @output;

END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_sql_login','P') IS NOT NULL
	DROP PROC dbo.script_sql_login;
GO

CREATE PROC dbo.script_sql_login
    @LoginName                              sysname,       
    @BehaviorIfLoginExists                  sysname                 = N'NONE',            -- { NONE | ALTER | DROP_AND_CREATE }
	@DisableExpiryChecks					bit						= 0, 
    @DisablePolicyChecks					bit						= 0,
	@ForceMasterAsDefaultDB					bit						= 0, 
	@IncludeDefaultLanguage					bit						= 0,
    @Output                                 nvarchar(MAX)           = ''        OUTPUT
AS 
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    IF NULLIF(@LoginName, N'') IS NULL BEGIN 
        RAISERROR('@LoginName is required.', 16, 1);
        RETURN -1;
    END;

    DECLARE @enabled bit, @name sysname, @password nvarchar(2000), @sid nvarchar(1000); 
    DECLARE @defaultDB sysname, @defaultLang sysname, @checkExpiration bit, @checkPolicy bit;

    SELECT 
        @enabled = CASE WHEN [is_disabled] = 1 THEN 0 ELSE 1 END,
        @name = [name],
        @password = N'0x' + CONVERT(nvarchar(2000), [password_hash], 2),
        @sid = N'0x' + CONVERT(nvarchar(1000), [sid], 2),
        @defaultDB = [default_database_name],
        @defaultLang = [default_language_name],
        @checkExpiration = [is_expiration_checked], 
        @checkPolicy = [is_policy_checked]
    FROM 
        sys.[sql_logins]
    WHERE 
        [name] = @LoginName;

    IF @name IS NULL BEGIN 
        IF @Output IS NULL 
            SET @Output = '-- No Login matching the name ' + QUOTENAME(@LoginName) + N' exists on the current server.';
        ELSE 
            PRINT '-- No Login matching the name ' + QUOTENAME(@LoginName) + N' exists on the current server.';

        RETURN -2;
    END;

    ---------------------------------------------------------
    -- overrides:
    IF @ForceMasterAsDefaultDB = 1 
        SET @defaultDB = N'master';

    IF @DisableExpiryChecks = 1 
        SET @checkExpiration = 0;

    IF @DisablePolicyChecks = 1 
        SET @checkPolicy = 0;

	IF @IncludeDefaultLanguage = 0
		SET @defaultLang = NULL;

    ---------------------------------------------------------
    -- load output:
    DECLARE @formatted nvarchar(MAX);
    SELECT @formatted = dbo.[format_sql_login](
        @enabled, 
        @BehaviorIfLoginExists,
        @name, 
        @password, 
        @sid, 
        @defaultDB,
        @defaultLang, 
        @checkExpiration, 
        @checkPolicy
     );

    IF @Output IS NULL BEGIN 
        SET @Output = @formatted;
        RETURN 0;
    END;

    PRINT @formatted;
    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_windows_login','P') IS NOT NULL
	DROP PROC dbo.[script_windows_login];
GO

CREATE PROC dbo.[script_windows_login]
    @LoginName                              sysname,       
    @BehaviorIfLoginExists                  sysname                 = N'NONE',            -- { NONE | ALTER | DROP_AND_CREATE }
	@ForceMasterAsDefaultDB					bit						= 0, 
	@IncludeDefaultLanguage					bit						= 0,
    @Output                                 nvarchar(MAX)           = ''        OUTPUT

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @enabled bit, @name sysname;
	DECLARE @defaultDB sysname, @defaultLang sysname;

	SELECT 
        @enabled = CASE WHEN [is_disabled] = 1 THEN 0 ELSE 1 END,
        @name = [name],
        @defaultDB = [default_database_name],
        @defaultLang = [default_language_name]
	FROM 
		sys.[server_principals] 
	WHERE 
		[name] = @LoginName;


    IF @name IS NULL BEGIN 
        IF @Output IS NULL 
            SET @Output = '-- No Login matching the name ' + QUOTENAME(@LoginName) + N' exists on the current server.';
        ELSE 
            PRINT '-- No Login matching the name ' + QUOTENAME(@LoginName) + N' exists on the current server.';

        RETURN -2;
    END;	

    ---------------------------------------------------------
    -- overrides:
    IF @ForceMasterAsDefaultDB = 1 
        SET @defaultDB = N'master';

	IF @IncludeDefaultLanguage = 0
		SET @defaultLang = NULL;

    ---------------------------------------------------------
    -- load output:
    DECLARE @formatted nvarchar(MAX);
	SELECT @formatted = dbo.[format_windows_login](
		@enabled, 
		@BehaviorIfLoginExists, 
		@name,
		@defaultDB, 
		@defaultLang
	);

    IF @Output IS NULL BEGIN 
        SET @Output = @formatted;
        RETURN 0;
    END;

    PRINT @formatted;
    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.create_agent_job','P') IS NOT NULL
	DROP PROC dbo.[create_agent_job];
GO

CREATE PROC dbo.[create_agent_job]
	@TargetJobName							sysname, 
	@JobCategoryName						sysname					= NULL, 
	@JobEnabled								bit						= 1,					-- Default to creation of the job in Enabled state.
	@AddBlankInitialJobStep					bit						= 1, 
	@OperatorToAlertOnErrors				sysname					= N'Alerts',
	@OverWriteExistingJobDetails			bit						= 0,					-- NOTE: Initially, this means: DROP/CREATE. Eventually, this'll mean: repopulate the 'guts' of the job if/as needed... 
	@JobID									uniqueidentifier		OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @existingJob sysname; 
	SELECT 
		@existingJob = [name]
	FROM 
		msdb.dbo.sysjobs
	WHERE 
		[name] = @TargetJobName;

	IF @existingJob IS NOT NULL BEGIN 
		IF @OverWriteExistingJobDetails = 1 BEGIN 
			-- vNEXT: for now this just DROPs/CREATEs a new job. While that makes sure the config/details are correct, that LOSEs job-history. 
			--			in the future, another sproc will go out and 'gut'/reset/remove ALL job-details - leaving just a 'shell' (the job and its name). 
			--				at which point, we can then 'add' in all details specified here... so that: a) the details are correct, b) we've kept the history. 
			EXEC msdb..sp_delete_job 
			    @job_name = @TargetJobName,
			    @delete_history = 1,
			    @delete_unused_schedule = 1; 
		  END;
		ELSE BEGIN
			RAISERROR('Unable to create job [%s] - because it already exists. Set @OverwriteExistingJobs = 1 or manually remove existing job/etc.', 16, 1, @TargetJobName);
			RETURN -5;
		END;
	END;

	-- Ensure that the Job Category exists:
	IF NULLIF(@JobCategoryName, N'') IS NULL 
		SET @JobCategoryName = N'[Uncategorized (Local)'; 

	IF NOT EXISTS(SELECT NULL FROM msdb..syscategories WHERE [name] = @JobCategoryName) BEGIN 
		EXEC msdb..sp_add_category 
			@class = N'JOB',
			@type = 'LOCAL',  
		    @name = @JobCategoryName;
	END;

	-- Create the Job:
	SET @JobID = NULL;  -- nasty 'bug' with sp_add_job: if @jobID is NOT NULL, it a) is passed out bottom and b) if a JOB with that ID already exists, sp_add_job does nothing. 
	
	EXEC msdb.dbo.sp_add_job
		@job_name = @TargetJobName,                     
		@enabled = @JobEnabled,                         
		@description = N'',                   
		@category_name = @JobCategoryName,                
		@owner_login_name = N'sa',             
		@notify_level_eventlog = 0,           
		@notify_level_email = 2,              
		@notify_email_operator_name = @OperatorToAlertOnErrors,   
		@delete_level = 0,                    
		@job_id = @JobID OUTPUT;

	EXEC msdb.dbo.[sp_add_jobserver] 
		@job_id = @JobID, 
		@server_name = N'(LOCAL)';


	IF @AddBlankInitialJobStep = 1 BEGIN
		EXEC msdb..sp_add_jobstep
			@job_id = @JobID,
			@step_id = 1,
			@step_name = N'Initialize Job History',
			@subsystem = N'TSQL',
			@command = N'/* 

  SQL Server Agent Job History can NOT be shown until the first 
  Job Step is complete. This step is a place-holder. 

*/',
			@on_success_action = 3,		-- go to the next step
			@on_fail_action = 3,		-- go to the next step. Arguably, should be 'quit with failure'. But, a) this shouldn't fail and, b) we don't CARE about this step 'running' so much as we do about SUBSEQUENT steps.
			@database_name = N'admindb',
			@retry_attempts = 0;

	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[generate_bounding_times]','P') IS NOT NULL
	DROP PROC dbo.[generate_bounding_times];
GO

CREATE PROC dbo.[generate_bounding_times]
	@Start						datetime,
	@End						datetime,
	@Minutes					int, 
	@SerializedOutput			xml					= N'<default/>'	    OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	IF @End < @Start BEGIN 
		RAISERROR(N'@End can NOT be earlier than @Start.', 16, 1);
		RETURN -1;
	END;

	IF @End = @Start BEGIN 
		RAISERROR(N'@Start and @End may NOT be the same value.', 16, 1);
		RETURN -2;
	END;

	SELECT 
		@Start = DATEADD(MINUTE, DATEDIFF(MINUTE, 0, @Start) / @Minutes * @Minutes, 0), 
		@End = DATEADD(MINUTE, DATEDIFF(MINUTE, 0, @End) / @Minutes * @Minutes, 0);

	CREATE TABLE #times (
		[block_id] int IDENTITY(1,1) NOT NULL, 
		[time_block] datetime NOT NULL
	);
	
	WITH times AS ( 
		SELECT @Start [time_block] 

		UNION ALL 

		SELECT DATEADD(MINUTE, @minutes, [time_block]) [time_block]
		FROM [times]
		WHERE [time_block] < @End
	) 

	INSERT INTO [#times] (
		[time_block]
	)
	SELECT [time_block] 
	FROM times
	OPTION (MAXRECURSION 0);

	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- RETURN instead of project.. 
		SELECT @SerializedOutput = (
			SELECT 
				[block_id],
				[time_block]
			FROM 
				[#times] 
			ORDER BY 
				[block_id]
			FOR XML PATH(N'time'), ROOT(N'times'), TYPE
		);

		RETURN 0;
	END;

	SELECT 
		[time_block] 
	FROM 
		[#times] 
	ORDER BY 
		[block_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO 

IF OBJECT_ID('dbo.list_databases','P') IS NOT NULL
	DROP PROC dbo.list_databases
GO

CREATE PROC dbo.list_databases
	@Targets								nvarchar(MAX)	= N'{ALL}',		-- {ALL} | {SYSTEM} | {USER} | {READ_FROM_FILESYSTEM} | comma,delimited,list, of, databases, where, spaces, do,not,matter
	@Exclusions								nvarchar(MAX)	= NULL,			-- comma, delimited, list, of, db, names, %wildcards_allowed%
	@Priorities								nvarchar(MAX)	= NULL,			-- higher,priority,dbs,*,lower,priority, dbs  (where * is an ALPHABETIZED list of all dbs that don't match a priority (positive or negative)). If * is NOT specified, the following is assumed: high, priority, dbs, [*]
	@ExcludeClones							bit				= 1, 
	@ExcludeSecondaries						bit				= 1,			-- exclude AG and Mirroring secondaries... 
	@ExcludeSimpleRecovery					bit				= 0,			-- exclude databases in SIMPLE recovery mode
	@ExcludeReadOnly						bit				= 0,			
	@ExcludeRestoring						bit				= 1,			-- explicitly removes databases in RESTORING and 'STANDBY' modes... 
	@ExcludeRecovering						bit				= 1,			-- explicitly removes databases in RECOVERY, RECOVERY_PENDING, and SUSPECT modes.
	@ExcludeOffline							bit				= 1				-- removes ANY state other than ONLINE.

AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	IF NULLIF(@Targets, N'') IS NULL BEGIN
		RAISERROR('@Targets cannot be null or empty - it must either be the specialized token {ALL}, {SYSTEM}, {USER}, or a comma-delimited list of databases/folders.', 16, 1);
		RETURN -1;
	END

	IF ((SELECT dbo.[count_matches](@Targets, N'{ALL}')) > 0) AND (UPPER(@Targets) <> N'{ALL}') BEGIN
		RAISERROR(N'When the Token {ALL} is specified for @Targets, no ADDITIONAL db-names or tokens may be specified.', 16, 1);
		RETURN -1;
	END;

	IF (SELECT dbo.[count_matches](@Exclusions, N'{READ_FROM_FILESYSTEM}')) > 0 BEGIN 
		RAISERROR(N'The {READ_FROM_FILESYSTEM} is NOT a valid exclusion token.', 16, 1);
		RETURN -2;
	END;

	IF (SELECT dbo.[count_matches](@Targets, N'{READ_FROM_FILESYSTEM}')) > 0 BEGIN 
		RAISERROR(N'@Targets may NOT be set to (or contain) {READ_FROM_FILESYSTEM}. The {READ_FROM_FILESYSTEM} token is ONLY allowed as an option/token for @TargetDatabases in dbo.restore_databases and dbo.apply_logs.', 16, 1);
		RETURN -3;
	END;

	IF ((SELECT dbo.[count_matches](@Exclusions, N'{SYSTEM}')) > 0) AND ((SELECT dbo.[count_matches](@Targets, N'{ALL}')) > 0) BEGIN
		RAISERROR(N'{SYSTEM} can NOT be specified as an Exclusion when @Targets is (or contains) {ALL}. Replace {ALL} with {USER} for @Targets and remove {SYSTEM} from @Exclusions instead (to load all databases EXCEPT ''System'' Databases.', 16, 1);
		RETURN -5;
	END;

	IF ((SELECT dbo.[count_matches](@Exclusions, N'{USER}')) > 0) AND ((SELECT dbo.[count_matches](@Targets, N'{ALL}')) > 0) BEGIN
		RAISERROR(N'{USER} can NOT be specified as an Exclusion when @Targets is (or contains) {ALL}. Replace {ALL} with {SYSTEM} for @Targets and remove {USER} from @Exclusions instead (to load all databases EXCEPT ''User'' Databases.', 16, 1);
		RETURN -6;
	END;

	IF ((SELECT dbo.[count_matches](@Exclusions, N'{USER}')) > 0) OR ((SELECT dbo.[count_matches](@Exclusions, N'{ALL}')) > 0) BEGIN 
		RAISERROR(N'@Exclusions may NOT be set to {ALL} or {USER}.', 16, 1);
		RETURN -7;
	END;


	-----------------------------------------------------------------------------
	-- Initialize helper objects:
	DECLARE @topN int = (SELECT COUNT(*) FROM sys.databases) + 100;

	SELECT TOP (@topN) IDENTITY(int, 1, 1) as N 
    INTO #Tally
    FROM sys.columns;

	DECLARE @deserialized table (
		[row_id] int NOT NULL, 
		[result] sysname NOT NULL
	); 

    DECLARE @target_databases TABLE ( 
        [entry_id] int IDENTITY(1,1) NOT NULL, 
        [database_name] sysname NOT NULL
    ); 

	DECLARE @system_databases TABLE ( 
		[entry_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL
	); 	



	-- load system databases - we'll (potentially) need these in a few evaluations (and avoid nested insert exec): 
	DECLARE @serializedOutput xml = '';
	EXEC dbo.[list_databases_matching_token]
	    @Token = N'{SYSTEM}',
	    @SerializedOutput = @serializedOutput OUTPUT;
	
	WITH shredded AS ( 
		SELECT 
			[data].[row].value('@id[1]', 'int') [row_id], 
			[data].[row].value('.[1]', 'sysname') [database_name]
		FROM 
			@serializedOutput.nodes('//database') [data]([row])
	)
	 
	INSERT INTO @system_databases ([database_name])
	SELECT [database_name] FROM [shredded] ORDER BY [row_id];
		
	-----------------------------------------------------------------------------
	-- Account for tokens: 
	DECLARE @tokenReplacementOutcome int;
	DECLARE @replacedOutput nvarchar(MAX);
	IF @Targets LIKE N'%{%}%' BEGIN 
		EXEC @tokenReplacementOutcome = dbo.replace_dbname_tokens 
			@Input = @Targets, 
			@Output = @replacedOutput OUTPUT;

		IF @tokenReplacementOutcome <> 0 GOTO ErrorCondition;

		SET @Targets = @replacedOutput;
	END;

	 -- If not a token, then try comma delimitied: 
	 IF NOT EXISTS (SELECT NULL FROM @target_databases) BEGIN
	
		INSERT INTO @deserialized ([row_id], [result])
		SELECT [row_id], CAST([result] AS sysname) [result] FROM dbo.[split_string](@Targets, N',', 1);

		IF EXISTS (SELECT NULL FROM @deserialized) BEGIN 
			INSERT INTO @target_databases ([database_name])
			SELECT [result] FROM @deserialized ORDER BY [row_id];
		END;
	 END;

	-----------------------------------------------------------------------------
	-- Remove Exclusions: 
	IF @ExcludeClones = 1 BEGIN 
		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM sys.databases WHERE source_database_id IS NOT NULL);		
	END;

	IF @ExcludeSecondaries = 1 BEGIN 

		DECLARE @synchronized table ( 
			[database_name] sysname NOT NULL
		);

		-- remove any mirrored secondaries: 
		INSERT INTO @synchronized ([database_name])
		SELECT d.[name] 
		FROM sys.[databases] d 
		INNER JOIN sys.[database_mirroring] dm ON d.[database_id] = dm.[database_id] AND dm.[mirroring_guid] IS NOT NULL
		WHERE UPPER(dm.[mirroring_role_desc]) <> N'PRINCIPAL';

		-- dynamically account for any AG'd databases:
		IF (SELECT dbo.get_engine_version()) >= 11.0 BEGIN		
			CREATE TABLE #hadr_names ([name] sysname NOT NULL);
			EXEC sp_executesql N'INSERT INTO #hadr_names ([name]) SELECT d.[name] FROM sys.databases d INNER JOIN sys.dm_hadr_availability_replica_states hars ON d.replica_id = hars.replica_id WHERE hars.role_desc <> ''PRIMARY'';'	

			INSERT INTO @synchronized ([database_name])
			SELECT [name] FROM #hadr_names;
		END

		-- Exclude any databases that aren't operational: (NOTE, this excluding all dbs that are non-operational INCLUDING those that might be 'out' because of Mirroring, but it is NOT SOLELY trying to remove JUST mirrored/AG'd databases)
		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [database_name] FROM @synchronized);
	END;

	IF @ExcludeSimpleRecovery = 1 BEGIN 
		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM sys.databases WHERE UPPER([recovery_model_desc]) = 'SIMPLE');
	END; 

	IF @ExcludeReadOnly = 1 BEGIN
		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM sys.databases WHERE [is_read_only] = 1)
	END;

	IF @ExcludeRestoring = 1 BEGIN
		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM sys.databases WHERE UPPER([state_desc]) = 'RESTORING');		

		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM sys.databases WHERE [is_in_standby] = 1);
	END; 

	IF @ExcludeRecovering = 1 BEGIN 
		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM sys.databases WHERE UPPER([state_desc]) IN (N'RECOVERY', N'RECOVERY_PENDING', N'SUSPECT'));
	END;
	 
	IF @ExcludeOffline = 1 BEGIN -- all states OTHER than online... 
		DELETE FROM @target_databases 
		WHERE [database_name] IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM sys.databases WHERE UPPER([state_desc]) = N'OFFLINE');
	END;

	-- Exclude explicit exclusions: 
	IF NULLIF(@Exclusions, '') IS NOT NULL BEGIN;
		
		DELETE FROM @deserialized;

		-- Account for tokens: 
		IF @Exclusions LIKE N'%{%}%' BEGIN 
			EXEC @tokenReplacementOutcome = dbo.replace_dbname_tokens 
				@Input = @Exclusions, 
				@Output = @replacedOutput OUTPUT;
			
			IF @tokenReplacementOutcome <> 0 GOTO ErrorCondition;

			SET @Exclusions = @replacedOutput;
		END;

		INSERT INTO @deserialized ([row_id], [result])
		SELECT [row_id], CAST([result] AS sysname) [result] FROM dbo.[split_string](@Exclusions, N',', 1);

		-- note: delete on BOTH = and LIKE... 
		DELETE t 
		FROM @target_databases t
		INNER JOIN @deserialized d ON (t.[database_name] = d.[result]) OR (t.[database_name] LIKE d.[result]);
	END;

	-----------------------------------------------------------------------------
	-- Prioritize:
	IF ISNULL(@Priorities, '') IS NOT NULL BEGIN;

		-- Account for tokens: 
		IF @Priorities LIKE N'%{%}%' ESCAPE N'~' BEGIN 
			EXEC @tokenReplacementOutcome = dbo.replace_dbname_tokens 
				@Input = @Priorities, 
				@Output = @replacedOutput OUTPUT;

			IF @tokenReplacementOutcome <> 0 GOTO ErrorCondition;
		
			SET @Priorities = @replacedOutput;
		END;		

		DECLARE @prioritized table (
			priority_id int IDENTITY(1,1) NOT NULL, 
			[database_name] sysname NOT NULL
		);

		INSERT INTO @prioritized ([database_name])
		SELECT [result] FROM dbo.[split_string](@Priorities, N',', 1) ORDER BY [row_id];
				
		DECLARE @alphabetized int;
		SELECT @alphabetized = priority_id FROM @prioritized WHERE [database_name] = '*';

		IF @alphabetized IS NULL
			SET @alphabetized = (SELECT MAX(entry_id) + 1 FROM @target_databases);

		DECLARE @prioritized_targets TABLE ( 
			[entry_id] int IDENTITY(1,1) NOT NULL, 
			[database_name] sysname NOT NULL
		); 

		WITH core AS ( 
			SELECT 
				t.[database_name], 
				CASE 
					WHEN p.[database_name] IS NULL THEN 0 + t.entry_id
					WHEN p.[database_name] IS NOT NULL AND p.priority_id <= @alphabetized THEN -32767 + p.priority_id
					WHEN p.[database_name] IS NOT NULL AND p.priority_id > @alphabetized THEN 32767 + p.priority_id
				END [prioritized_priority]
			FROM 
				@target_databases t 
				LEFT OUTER JOIN @prioritized p ON t.[database_name] LIKE p.[database_name]
		) 

		INSERT INTO @prioritized_targets ([database_name])
		SELECT 
			[database_name]
		FROM core 
		ORDER BY 
			core.prioritized_priority;

		DELETE FROM @target_databases;
		INSERT INTO @target_databases ([database_name])
		SELECT [database_name] 
		FROM @prioritized_targets
		ORDER BY entry_id;
	END;

	-----------------------------------------------------------------------------
	-- project: 
	SELECT 
		[database_name] 
	FROM 
		@target_databases
	ORDER BY 
		[entry_id];

	RETURN 0;

ErrorCondition:
	RETURN -1;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.format_timespan','FN') IS NOT NULL
	DROP FUNCTION dbo.format_timespan;
GO

CREATE FUNCTION dbo.format_timespan(@Milliseconds bigint)
RETURNS sysname
WITH RETURNS NULL ON NULL INPUT
AS
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	BEGIN

		DECLARE @output sysname;

		IF @Milliseconds IS NULL OR @Milliseconds = 0	
			SET @output = N'000:00:00.000';

		IF @Milliseconds > 0 BEGIN
			SET @output = RIGHT('000' + CAST(@Milliseconds / 3600000 as sysname), 3) + N':' + RIGHT('00' + CAST((@Milliseconds / (60000) % 60) AS sysname), 2) + N':' + RIGHT('00' + CAST(((@Milliseconds / 1000) % 60) AS sysname), 2) + N'.' + RIGHT('000' + CAST((@Milliseconds) AS sysname), 3)
		END;

		IF @Milliseconds < 0 BEGIN
			SET @output = N'-' + RIGHT('000' + CAST(ABS(@Milliseconds / 3600000) as sysname), 3) + N':' + RIGHT('00' + CAST(ABS((@Milliseconds / (60000) % 60)) AS sysname), 2) + N':' + RIGHT('00' + CAST((ABS((@Milliseconds / 1000) % 60)) AS sysname), 2) + N'.' + RIGHT('000' + CAST(ABS((@Milliseconds)) AS sysname), 3)
		END;


		RETURN @output;
	END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.format_number','FN') IS NOT NULL
	DROP FUNCTION dbo.[format_number];
GO

CREATE FUNCTION dbo.[format_number] (@Number decimal(38,6), @Length int = 14, @Decimal int = 2, @UseSeparator bit = 1, @FullWidthUnicode bit = 1, @Culture sysname = N'{DEFAULT}')
RETURNS sysname
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
		SET @Length = ISNULL(@Length, 14);
		SET @Decimal = ISNULL(@Decimal, 2);
		SET @UseSeparator = ISNULL(@UseSeparator, 1);
		SET @FullWidthUnicode = ISNULL(@FullWidthUnicode, 1);
		SET @Culture = ISNULL(NULLIF(@Culture, N''), N'{DEFAULT}');

    	DECLARE @output sysname; 
		DECLARE @format sysname = N'N';
		IF @UseSeparator = 0 
			SET @format = N'F';

		IF @Decimal >= 0 BEGIN
			SET @format = @format + CAST(@Decimal AS sysname);
		  END;
		ELSE BEGIN 
			SET @format = @format  + N'0';
		END;

		IF UPPER(@Culture) = N'{DEFAULT}'
			SET @Culture = N'en-US'; /* TODO: see notes in header.  */

		SET @output = FORMAT(@Number, @format, @Culture);

		IF @Length > 0 BEGIN

			IF LEN(@output) > @Length 
				SET @output = N'..!';

			IF @FullWidthUnicode = 1 BEGIN
				DECLARE @NSpace nchar(1) = NCHAR(8199);  -- figure space (or space that's the width of a figure/number) - U+2007.
				DECLARE @NComma nchar(1) = NCHAR(65292); -- fullwidth comma - U+FF0C
				DECLARE @NDot nchar(1) = NCHAR(65294);

				SET @output = RIGHT(REPLICATE(@NSpace, (@Length - LEN(@output))) + @output, @Length);
				SET @output = REPLACE(@output, N',', @NComma);
				--SET @output = REPLACE(@output, N'.', @NDot);
			  END;
			ELSE BEGIN 
				/* This can ONLY approximate right-alignment... cuz of how ASCII/default font in SSMS/etc. provides different widths to space, comma, dot... */
				SET @output = RIGHT(REPLICATE(N' ', (@Length - LEN(@output))) + @output, @Length);
				SET @output = REPLACE(@output, N' ', N'  ');
			END;
		END;

    	RETURN @output;
    
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.xml_decode','FN') IS NOT NULL
	DROP FUNCTION dbo.[xml_decode];
GO

CREATE FUNCTION dbo.[xml_decode] (@Input nvarchar(MAX), @TransformLtAndGtOnly bit = 0)
RETURNS nvarchar(MAX)
	WITH RETURNS NULL ON NULL INPUT
AS
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
    	DECLARE @output nvarchar(MAX);

		-- https://stackoverflow.com/a/1091953

		SET @output = REPLACE(@Input, N'&lt;', N'<');
		SET @output = REPLACE(@output, N'&gt;', N'>');

		IF @TransformLtAndGtOnly = 0 BEGIN
    		SET @output = REPLACE(@output, N'&amp;', N'&');
    		SET @output = REPLACE(@output, N'&apos;', N'''');
    		SET @output = REPLACE(@output, N'&quot;', N'"');
    	END;

    	RETURN @output;
    
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.get_local_timezone','FN') IS NOT NULL
	DROP FUNCTION dbo.[get_local_timezone];
GO

CREATE FUNCTION dbo.[get_local_timezone]()
RETURNS sysname
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
    	DECLARE @output sysname;
    	
		EXEC sys.[xp_regread]
			'HKEY_LOCAL_MACHINE',
			'SYSTEM\CurrentControlSet\Control\TimeZoneInformation',
			'TimeZoneKeyName',
			@output OUTPUT; 

    	RETURN @output;
    
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.get_timezone_offset_minutes','FN') IS NOT NULL
	DROP FUNCTION dbo.[get_timezone_offset_minutes];
GO

CREATE FUNCTION dbo.[get_timezone_offset_minutes] (@TimeZone sysname)
RETURNS int
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	IF NULLIF(@TimeZone, N'') IS NULL 
			SET @TimeZone = N'{SERVER_LOCAL}';

    	DECLARE @output int;
		DECLARE @atTimeZone datetime;
		DECLARE @utc datetime = GETUTCDATE();

		IF UPPER(@TimeZone) = N'{SERVER_LOCAL}'
			SET @TimeZone = dbo.[get_local_timezone]();
    	
    	SELECT @atTimeZone = @utc AT TIME ZONE 'UTC' AT TIME ZONE @TimeZone;
    	
    	SELECT @output = DATEDIFF(MINUTE, @utc, @atTimeZone);
    	
    	RETURN @output;
    
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.count_matches','FN') IS NOT NULL
	DROP FUNCTION dbo.count_matches;
GO

CREATE FUNCTION dbo.count_matches(@input nvarchar(MAX), @pattern sysname) 
RETURNS int 
AS 
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN 
		DECLARE @output int = 0;

		DECLARE @actualLength int = LEN(@input); 
		DECLARE @replacedLength int = LEN(CAST(REPLACE(@input, @pattern, N'') AS nvarchar(MAX)));
		DECLARE @patternLength int = LEN(@pattern);  

		IF @replacedLength < @actualLength BEGIN 
		
			-- account for @pattern being 1 or more spaces: 
			IF @patternLength = 0 AND DATALENGTH(LTRIM(@pattern)) = 0 
				SET @patternLength = DATALENGTH(@pattern) / 2;
			
			IF @patternLength > 0
				SET @output =  (@actualLength - @replacedLength) / @patternLength;
		END;
		
		RETURN @output;
	END; 
GO


-----------------------------------
USE [admindb];
GO


IF OBJECT_ID('dbo.kill_connections_by_hostname','P') IS NOT NULL
	DROP PROC dbo.kill_connections_by_hostname;
GO

CREATE PROC dbo.kill_connections_by_hostname
	@HostName				sysname, 
	@Interval				sysname			= '3 seconds', 
	@MaxIterations			int				= 5, 

-- TODO: Add error-handling AND reporting... along with options to 'run silent' and so on... 
--		as in, there are going to be some cases where we automate this, and it should raise errors if it can't kill all spids owned by @HostName... 
--			and, at other times... we won't necessarily care... (and just want the tool to do 'ad hoc' kills of a single host-name - without having to have all of the 'plumbing' needed for Mail Profiles, Operators, Etc... 
	@PrintOnly				int				= 0
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Inputs:
	IF UPPER(HOST_NAME()) = UPPER(@HostName) BEGIN 
		RAISERROR('Invalid HostName - You can''t KILL spids owned by the host running this stored procedure.', 16, 1);
		RETURN -1;
	END;

	DECLARE @waitFor sysname
	DECLARE @error nvarchar(MAX);

	EXEC dbo.[translate_vector_delay]
	    @Vector = @Interval,
	    @ParameterName = N'@Interval',
	    @Output = @waitFor OUTPUT,
	    @Error = @error OUTPUT;
	
	IF @error IS NOT NULL BEGIN 
		RAISERROR(@error, 16, 1);
		RETURN -10;
	END;

	-----------------------------------------------------------------------------
	-- Processing: 	
	DECLARE @statement nvarchar(MAX) = N'';
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	DECLARE @currentIteration int = 0; 
	WHILE (@currentIteration < @MaxIterations) BEGIN
		
		SET @statement = N''; 

		SELECT 
			@statement = @statement + N'KILL ' + CAST(session_id AS sysname) + N';'  + @crlf
		FROM 
			[master].sys.[dm_exec_sessions] 
		WHERE 
			[host_name] = @HostName;
		
		IF @PrintOnly = 1 BEGIN 
			PRINT N'--------------------------------------';
			PRINT @statement; 
			PRINT @crlf;
			PRINT N'WAITFOR DELAY ' + @waitFor; 
			PRINT @crlf;
			PRINT @crlf;
		  END; 
		ELSE BEGIN 
			EXEC (@statement);
			WAITFOR DELAY @waitFor;
		END;

		SET @currentIteration += 1;
	END; 

	-- then... report on any problems/errors.

	RETURN 0;
GO	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.execute_uncatchable_command','P') IS NOT NULL
	DROP PROC dbo.execute_uncatchable_command;
GO

CREATE PROC dbo.execute_uncatchable_command
	@Statement				varchar(4000), 
	@FilterType				varchar(20), 
	@Result					varchar(4000)			OUTPUT	
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Dependencies:
	EXEC dbo.verify_advanced_capabilities;	

	-----------------------------------------------------------------------------
	-- Validate Inputs:

	IF @FilterType NOT IN (N'BACKUP',N'RESTORE',N'CREATEDIR',N'ALTER',N'DROP',N'DELETEFILE', N'UN-STANDBY') BEGIN;
		RAISERROR('Configuration Error: Invalid @FilterType specified.', 16, 1);
		SET @Result = 'Configuration Problem with dbo.execute_uncatchable_command.';
		RETURN -1;
	END 

	DECLARE @filters table (
		filter_text varchar(200) NOT NULL, 
		filter_type varchar(20) NOT NULL
	);

	INSERT INTO @filters (filter_text, filter_type)
	VALUES 
	-- BACKUP:
	('Processed % pages for database %', 'BACKUP'),
	('BACKUP DATABASE successfully processed % pages in %','BACKUP'),
	('BACKUP DATABASE WITH DIFFERENTIAL successfully processed % pages in %', 'BACKUP'),
	('BACKUP LOG successfully processed % pages in %', 'BACKUP'),
	('BACKUP DATABASE...FILE=<name> successfully processed % pages in % seconds %).', 'BACKUP'), -- for file/filegroup backups
	('The log was not truncated because records at the beginning %sp_repldone% to mark transactions as distributed %', 'BACKUP'),  -- NOTE: should only be enabled on systems where there's a JOB to force cleanup of replication in log... 

	-- RESTORE:
	('RESTORE DATABASE successfully processed % pages in %', 'RESTORE'),
	('RESTORE LOG successfully processed % pages in %', 'RESTORE'),
	('Processed % pages for database %', 'RESTORE'),
    ('DBCC execution completed. If DBCC printed error messages, contact your system administrator.', 'RESTORE'),  --  if CDC has been enabled (even if we're NOT running KEEP_CDC), recovery will throw in some sort of DBCC operation... 

		-- whenever there's a patch or upgrade...
	('Converting database % from version % to the current version %', 'RESTORE'), 
	('RESTORE DATABASE ... FILE=<name> successfully processed % pages in % seconds %).', N'RESTORE'),  -- partial recovery operations... 
	('Database % running the upgrade step from version % to version %.', 'RESTORE'),

	-- CREATEDIR:
	('Command(s) completed successfully.', 'CREATEDIR'), 

	-- ALTER:
	('Command(s) completed successfully.', 'ALTER'),
	('Nonqualified transactions are being rolled back. Estimated rollback completion%', 'ALTER'), 

	-- DROP:
	('Command(s) completed successfully.', 'DROP'),

	-- DELETEFILE:
	('Command(s) completed successfully.','DELETEFILE'),

	-- UN-STANDBY (i.e., pop a db out of STANDBY and into NORECOVERY... 
	('RESTORE DATABASE successfully processed % pages in % seconds%', 'UN-STANDBY'),
	('Command(s) completed successfully.', N'UN-STANDBY')

	-- add other filters here as needed... 
	;

	DECLARE @delimiter nchar(4) = N' -> ';

	CREATE TABLE #Results (
		result_id int IDENTITY(1,1),
		result nvarchar(MAX)
	);

	DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
	DECLARE @command varchar(2000) = 'sqlcmd {0} -q "' + REPLACE(@Statement, @crlf, ' ') + '"';

	-- Account for named instances:
	DECLARE @serverName sysname = '';
	IF @@SERVICENAME <> N'MSSQLSERVER'
		SET @serverName = N' -S .\' + @@SERVICENAME;
		
	SET @command = REPLACE(@command, '{0}', @serverName);

	--PRINT @command;

	INSERT INTO #Results (result)
	EXEC master.sys.xp_cmdshell @command;

	DELETE r
	FROM 
		#Results r 
		INNER JOIN @filters x ON x.filter_type = @FilterType AND r.result LIKE x.filter_text;

	IF EXISTS (SELECT NULL FROM #Results WHERE result IS NOT NULL) BEGIN;
		SET @Result = '';
		SELECT @Result = @Result + result + @delimiter FROM #Results WHERE result IS NOT NULL ORDER BY result_id;
		SET @Result = LEFT(@Result, LEN(@Result) - LEN(@delimiter));
	END

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.transient_error_occurred','FN') IS NOT NULL
	DROP FUNCTION dbo.[transient_error_occurred];
GO

CREATE FUNCTION dbo.[transient_error_occurred] (@executeCommandResults xml)
RETURNS bit
	WITH RETURNS NULL ON NULL INPUT
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
    	DECLARE @output bit = 1;
    	DECLARE @count int; 

		SELECT @count = @executeCommandResults.value(N'count(/iterations/iteration)', N'int');
    	IF(@count = 1) 
			SET @output = 0;
    	
    	RETURN @output;
    
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.execute_command','P') IS NOT NULL
	DROP PROC dbo.[execute_command];
GO

CREATE PROC dbo.[execute_command]
	@Command								nvarchar(MAX), 
	@ExecutionType							sysname						= N'SQLCMD',						-- { SQLCMD | SHELL | POSH | PARTNER }
	@ExecutionAttemptsCount					int							= 2,								-- TOTAL number of times to try executing process - until either success (no error) or @ExecutionAttemptsCount reached. a value of 1 = NO retries... 
	@DelayBetweenAttempts					sysname						= N'5s',
	@IgnoredResults							nvarchar(2000)				= N'{COMMAND_SUCCESS}',				--  'comma, delimited, list of, wild%card, statements, to ignore, can include, {tokens}'. Allowed Tokens: {COMMAND_SUCCESS} | {USE_DB_SUCCESS} | {ROWS_AFFECTED} | {BACKUP} | {RESTORE} | {SHRINKLOG} | {DBCC} ... 
    @SafeResults							nvarchar(2000)				= N'',								-- { ALL | custom_pattern } just like @IgnoredResults but marked as 'safe' (i.e., ALSO ignored and won't trigger error conditions), meaning that they're something the user wants back (e.g., results of a ping 10.0.0.1... various 'bits' of result could be flagged as SAFE.
	@ErrorResults							nvarchar(2000)				= N'',								-- 'Inverse' of @SafeResults - i.e., if setting @SafeResults to {ALL}... that's a pain IF there's one or three various bits of exact text that result in an error... 
	@PrintOnly                              bit                         = 0,
	@Outcome								xml							OUTPUT, 
	@ErrorMessage							nvarchar(MAX)				OUTPUT
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	EXEC dbo.verify_advanced_capabilities;	

	-----------------------------------------------------------------------------
	-- Validate Inputs:
	SET @ExecutionType = ISNULL(@ExecutionType, N'SQLCMD');
	SET @IgnoredResults = NULLIF(@IgnoredResults, N'');
	SET @SafeResults = NULLIF(@SafeResults, N'');

	IF @ExecutionAttemptsCount <= 0 SET @ExecutionAttemptsCount = 1;

    IF @ExecutionAttemptsCount > 0 

    IF UPPER(@ExecutionType) NOT IN (N'SQLCMD', N'SHELL', N'POSH', N'PARTNER') BEGIN 
        RAISERROR(N'Permitted @ExecutionType values are { SQLCMD | SHELL | POSH | PARTNER }.', 16, 1);
        RETURN -2;
    END; 

	-- if @ExecutionType = PARTNER, make sure we have a PARTNER entry in sys.servers... 
	--  or, vNEXT: @ExecutionType of PARTNER:SQL-130-11B can/will ultimately be allowed... 

    -- validate @DelayBetweenAttempts (if required/present):
    IF @ExecutionAttemptsCount > 1 BEGIN
	    DECLARE @delay sysname; 
	    DECLARE @error nvarchar(MAX);
	    EXEC dbo.[translate_vector_delay]
	        @Vector = @DelayBetweenAttempts,
	        @ParameterName = N'@DelayBetweenAttempts',
	        @Output = @delay OUTPUT, 
	        @Error = @error OUTPUT;

	    IF @error IS NOT NULL BEGIN 
		    RAISERROR(@error, 16, 1);
		    RETURN -5;
	    END;
    END;

	-----------------------------------------------------------------------------
	-- Processing: 

	DECLARE @filters table (
		filter_type varchar(20) NOT NULL, 
		filter_text varchar(2000) NOT NULL
	); 
	
	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{USE_DB_SUCCESS}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('USE_DB_SUCCESS', 'Changed database context to ''%');
		
		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{USE_DB_SUCCESS}', N'');
	END; 

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{COMMAND_SUCCESS}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('COMMAND_SUCCESS', 'Command(s) completed successfully.');
		
		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{COMMAND_SUCCESS}', N'');
	END; 

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{ROWS_AFFECTED}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('ROWS_AFFECTED', '% rows affected)%');
		
		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{ROWS_AFFECTED}', N'');
	END; 

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{BACKUP}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('BACKUP', 'Processed % pages for database %'),
			('BACKUP', 'BACKUP DATABASE successfully processed % pages in %'),
			('BACKUP', 'BACKUP DATABASE WITH DIFFERENTIAL successfully processed % pages in %'),
			('BACKUP', 'BACKUP LOG successfully processed % pages in %'),
			('BACKUP', 'BACKUP DATABASE...FILE=<name> successfully processed % pages in % seconds %).'), -- for file/filegroup backups
			('BACKUP', 'The log was not truncated because records at the beginning %sp_repldone% to mark transactions as distributed %');  -- NOTE: should only be enabled on systems where there's a JOB to force cleanup of replication in log... 
		
		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{BACKUP}', N'');
	END; 

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{DELETEFILE}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('DELETEFILE', 'Command(s) completed successfully.');
		
		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{DELETEFILE}', N'');
	END; 
	
	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{RESTORE}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('RESTORE', 'RESTORE DATABASE successfully processed % pages in %'),
			('RESTORE', 'RESTORE LOG successfully processed % pages in %'),
			('RESTORE', 'Processed % pages for database %'),
			('RESTORE', 'Converting database % from version % to the current version %'),    -- whenever there's a patch or upgrade... 
			('RESTORE', 'Database % running the upgrade step from version % to version %.'),	-- whenever there's a patch or upgrade... 
			('RESTORE', 'RESTORE DATABASE ... FILE=<name> successfully processed % pages in % seconds %).'),  -- partial recovery operations... 
            ('RESTORE', 'DBCC execution completed. If DBCC printed error messages, contact your system administrator.');  -- if CDC was enabled on source (even if we don't issue KEEP_CDC), some sort of DBCC command fires during RECOVERY.
		
		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{RESTORE}', N'');
	END;

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{SINGLE_USER}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('SINGLE_USER', 'Changed database context to %'),
			('SINGLE_USER', 'Nonqualified transactions are being rolled back. Estimated rollback completion%');
					
		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{SINGLE_USER}', N'');
	END;

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{COPYFILE}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('COPYFILE', '%1 file(s) copied%');

		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{COPYFILE}', N'');
	END;

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{S3COPYFILE}', N'')))) BEGIN
		-- PlaceHolder: there isn't, currently, any 'noise' output from Write-S3Object...

		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{S3COPYFILE}', N'');
	END;

	IF (LEN(@IgnoredResults) <> LEN((REPLACE(@IgnoredResults, N'{OFFLINE}', N'')))) BEGIN
		INSERT INTO @filters ([filter_type],[filter_text])
		VALUES 
			('OFFLINE', 'Failed to restart the current database. The current database is switched to master%');

		SET @IgnoredResults = REPLACE(@IgnoredResults, N'{OFFLINE}', N'');
	END;

	-- TODO: {SHRINKLOG}
	-- TODO: {DBCC} (success)

	INSERT INTO @filters ([filter_type], [filter_text])
	SELECT 'CUSTOM_IGNORED', [result] FROM dbo.[split_string](@IgnoredResults, N',', 1) WHERE LEN([result]) > 0;

	IF @SafeResults IS NOT NULL BEGIN 
		IF UPPER(@SafeResults) = N'{ALL}' BEGIN 
			INSERT INTO @filters ([filter_type], [filter_text]) 
			VALUES ('SAFE_WILDCARD', N'%_%');
		  END; 
		ELSE BEGIN
			INSERT INTO @filters ([filter_type], [filter_text])
			SELECT 'SAFE', [result] FROM dbo.[split_string](@SafeResults, N',', 1) WHERE LEN([result]) > 0;
		END;
	END;

	DECLARE @explicitErrors table (error_id int IDENTITY(1,1) NOT NULL, error_text sysname); 
	IF @ErrorResults IS NOT NULL BEGIN 
		INSERT INTO @explicitErrors ([error_text])
		SELECT [result] FROM dbo.[split_string](@ErrorResults, N',', 1) WHERE LEN([result]) > 0;
	END;

	CREATE TABLE #cmd_results (
		[result_id] int IDENTITY(1,1),
		[result_text] nvarchar(MAX), 
		[ignored_match] sysname NULL, 
		[explicit_error] sysname NULL
	);

	DECLARE @result xml;
	DECLARE @iterations table ( 
		iteration_id int IDENTITY(1,1) NOT NULL, 
		execution_time datetime NOT NULL,
		succeeded bit NOT NULL, 
		exception bit NOT NULL,
		result xml NOT NULL
	);

	DECLARE @xpCmd varchar(2000);
	DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
	DECLARE @serverName sysname = '.';
    DECLARE @execOutput int;

	IF UPPER(@ExecutionType) = N'SHELL' BEGIN
        SET @xpCmd = CAST(@Command AS varchar(2000));
    END;
    
    IF UPPER(@ExecutionType) IN (N'SQLCMD', N'PARTNER') BEGIN
		SET @xpCmd = 'sqlcmd{0} -Q "' + REPLACE(CAST(@Command AS varchar(2000)), @crlf, ' ') + '"';

        IF UPPER(@ExecutionType) = N'SQLCMD' BEGIN 
		    IF @@SERVICENAME <> N'MSSQLSERVER'  -- Account for named instances:
			    SET @serverName = N' .\' + @@SERVICENAME;
	    END; 

	    IF UPPER(@ExecutionType) = N'PARTNER' BEGIN 
		    SELECT @serverName = REPLACE([data_source], N'tcp:', N'') FROM sys.servers WHERE [name] = N'PARTNER';
	    END; 

		SET @xpCmd = REPLACE(@xpCmd, '{0}', ' -S' + @serverName);
    END;

	IF UPPER(@ExecutionType) IN (N'POSH') BEGIN 
		SET @xpCmd = 'Powershell.exe -Command "' + REPLACE(CAST(@Command AS varchar(2000)), @crlf, ' ') + '"';
	END;
	
	DECLARE @executionCount int = 0;
	DECLARE @succeeded bit = 0;
	DECLARE @executionTime datetime;
	DECLARE @exceptionOccurred bit = 0;
    
ExecutionAttempt:
	
	SET @executionCount = @executionCount + 1;
	SET @result = NULL;
	SET @succeeded = 0;
	SET @exceptionOccurred = 0;
	SET @executionTime = GETDATE();

	DELETE FROM #cmd_results;

	IF @PrintOnly = 1 BEGIN 
		PRINT N'-- xp_cmdshell ''' + @xpCmd + ''';';
        --PRINT @xpCmd;
		SET @succeeded = 1; 
		GOTO Terminate;
	END;

	BEGIN TRY 
		--PRINT @xpCmd;
		
		INSERT INTO #cmd_results ([result_text]) 
		EXEC master.sys.[xp_cmdshell] @xpCmd;

		DELETE FROM #cmd_results WHERE [result_text] IS NULL;

		UPDATE r 
		SET 
			r.[ignored_match] = x.[filter_type]
		FROM 
			#cmd_results r
			LEFT OUTER JOIN @filters x ON (r.[result_text] LIKE x.[filter_text]) OR (r.[result_text] = x.[filter_text]) 
				OR (x.[filter_type] IN (N'SAFE', N'SAFE_WILDCARD') AND r.[result_text] = x.[filter_text]); 

		IF EXISTS (SELECT NULL FROM @explicitErrors) BEGIN 
			UPDATE r 
			SET 
				r.[explicit_error] = x.error_text
			FROM 
				[#cmd_results] r 
				INNER JOIN @explicitErrors x ON (r.[result_text] LIKE x.[error_text]) OR (r.[result_text] = x.[error_text]);
		END;

		SELECT @result = (SELECT 
			result_id [result_row/@result_id], 
			CASE WHEN [ignored_match] IN (N'SAFE', N'SAFE_WILDCARD') THEN NULL ELSE [ignored_match] END [result_row/@ignored],
			CASE WHEN [ignored_match] IN (N'SAFE', N'SAFE_WILDCARD') THEN [ignored_match] ELSE NULL END [result_row/@safe],
			[explicit_error] [result_row/@explicit_error],
			CASE 
				WHEN [ignored_match] IS NOT NULL AND [explicit_error] IS NOT NULL THEN 1
				WHEN [ignored_match] IS NULL THEN 1
				ELSE 0 
			END [result_row/@is_error],
			[result_text] [result_row]
		FROM 
			[#cmd_results] 
		ORDER BY 
			[result_id]
		FOR XML PATH(''), TYPE);

		/* Determine Success or Error based on ... ignored/safe vs explicit errors and ... NULLs/etc. */
		WITH simplified AS ( 
			SELECT 
				CASE 
					WHEN [ignored_match] IS NOT NULL AND [explicit_error] IS NOT NULL THEN 1
					WHEN [ignored_match] IS NULL THEN 1
					ELSE 0 
				END [success]
			FROM 
				[#cmd_results] 
		) 

		SELECT @succeeded = CASE WHEN MAX(success) > 0 THEN 0 ELSE 1 END FROM [simplified];
	END TRY

	BEGIN CATCH 
		WITH faked AS ( 
			SELECT 
				ERROR_NUMBER() [error_number], 
				ERROR_LINE() [error_line], 
				ERROR_SEVERITY() [severity],
				ERROR_MESSAGE() [error_message]
		)
		
		SELECT @result = (SELECT 
			[error_number] [exception/@error_number], 
			[error_line] [exception/@error_line], 
			[severity] [exception/@severity],
			[error_message] [exception]
		FROM 
			faked
		FOR XML PATH(''), TYPE);

		SET @exceptionOccurred = 1;
	END CATCH;

	IF @result IS NOT NULL BEGIN 
		INSERT INTO @iterations ([result], [execution_time], [succeeded], [exception])
		VALUES (@result, @executionTime, @succeeded, @exceptionOccurred);
	END; 

Terminate:
	IF @succeeded = 0 BEGIN 
		IF @executionCount < @ExecutionAttemptsCount BEGIN 
			WAITFOR DELAY @delay; 
			GOTO ExecutionAttempt;
		END;
	END;  

	SELECT @Outcome = (SELECT 
		CASE 
			WHEN [exception] = 1 THEN N'EXCEPTION' 
			WHEN [exception] = 0 AND [succeeded] = 1 THEN N'SUCCEEDED'
			ELSE N'FAILED'
		END [iteration/@execution_outcome],
		[iteration_id] [iteration/@iteration_id],
		[execution_time] [iteration/@execution_time],
		[result] [iteration]
	FROM 
		@iterations 
	ORDER BY 
		[iteration_id] 
	FOR XML PATH(''), ROOT('iterations'), TYPE);

	IF @succeeded = 1
		RETURN 0;

	/* Otherwise: serialize/output error details: */
	SET @ErrorMessage = N'';
	
	WITH core AS ( 
		SELECT 
			[i].[iteration_id],
			x.result_row.value(N'(@result_id)', N'int') [row_id], 
			x.result_row.value(N'(@is_error)', N'bit') [is_error], 
			CAST(0 AS bit) [is_exception],
			x.result_row.value(N'.', N'nvarchar(max)') [content]
		FROM 
			@iterations i  
			CROSS APPLY i.result.nodes(N'/result_row') x(result_row)
		WHERE 
			[i].[exception] = 0

		UNION SELECT 
			[i].[iteration_id],
			1 [row_id], 
			0 [is_error], 
			CAST(1 AS bit) [is_exception],
			N'EXCEPTION::> ErrorNumber: ' + CAST(x.exception.value(N'(@error_number)', N'int') AS sysname) + N', LineNumber: ' + CAST(x.exception.value(N'(@error_line)', N'int') AS sysname) + N', Severity: ' + CAST(x.exception.value(N'(@severity)', N'int') AS sysname) + N', Message: ' + x.exception.value(N'.', N'nvarchar(max)') [content]
			
		FROM 
			@iterations i 
			CROSS APPLY i.result.nodes(N'/exception') x(exception)
	) 

	SELECT 
		@ErrorMessage = @ErrorMessage + [content] + @crlf
	FROM 
		core 
	WHERE 
		[is_error] = 1 OR [is_exception] = 1
	ORDER BY	
		[iteration_id], [row_id];

	RETURN -1;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.execute_powershell','P') IS NOT NULL
	DROP PROC dbo.[execute_powershell];
GO

CREATE PROC dbo.[execute_powershell]
	@Command							nvarchar(MAX),
	@ExecutionAttemptsCount				int						= 2,								-- TOTAL number of times to try executing process - until either success (no error) or @ExecutionAttemptsCount reached. a value of 1 = NO retries... 
	@DelayBetweenAttempts				sysname					= N'5s',
	@PrintOnly							bit						= 0,
	@SerializedXmlOutput				xml						= N'<default/>'		OUTPUT, 
	@StringOutput						nvarchar(MAX)			= N''				OUTPUT,		-- Note that there's no reason this can't be JSON
	@ErrorMessage						nvarchar(MAX)			= NULL				OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @commandOutput xml; 
	DECLARE @returnValue int;

	EXEC @returnValue = [dbo].[execute_command]
		@Command = @Command,
		@ExecutionType = N'POSH',
		@ExecutionAttemptsCount = @ExecutionAttemptsCount,
		@DelayBetweenAttempts = @DelayBetweenAttempts,
		@SafeResults = N'{ALL}',  -- we're just piping results to/from PowerShell
		@PrintOnly = @PrintOnly,
		@ErrorMessage = @ErrorMessage OUTPUT,
		@Outcome = @commandOutput OUTPUT;

	IF @returnValue <> 0 OR @ErrorMessage IS NOT NULL BEGIN 
		RETURN -5;
	END;

	DECLARE @output nvarchar(MAX) = N'';
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	SELECT 
		@output = @output + n.r.value(N'(.)[1]', N'nvarchar(max)') + @crlf
	FROM 
		@commandOutput.nodes(N'//iterations/iteration/result_row') n(r); 

	IF (SELECT dbo.is_xml_empty(@SerializedXmlOutput)) = 1 BEGIN -- RETURN instead of project.. 
		BEGIN TRY
			-- NOTE: the FOR XML PATH output returned via dbo.execute_command ONLY encodes < and >, so only un-transform them via dbo.xml_decode (i.e., second parameter).
			SET @output = dbo.[xml_decode](@output, 1);

			-- HACK(ish):
			SET @output = REPLACE(@output, N' encoding="utf-8"?>', N' encoding="utf-16"?>');

			-- This might be a terrible idea: 
			SET @output = REPLACE(@output, N'&', N'&amp;');
	
			SELECT @SerializedXmlOutput = CAST(@output AS xml);
			RETURN 0;
		END TRY 
		BEGIN CATCH 
			SET @ErrorMessage = CAST (ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE();
			RETURN -10;
		END CATCH;
	END;

	IF @StringOutput IS NULL BEGIN 
		SELECT @StringOutput = @output;
		RETURN 0;
	END;

	EXEC dbo.[print_long_string] @output;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.establish_directory','P') IS NOT NULL
	DROP PROC dbo.establish_directory;
GO

CREATE PROC dbo.establish_directory
    @TargetDirectory                nvarchar(100), 
    @PrintOnly                      bit                     = 0,
    @Error                          nvarchar(MAX)           OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
	IF NULLIF(@TargetDirectory, N'') IS NULL BEGIN 
        SET @Error = N'The @TargetDirectory parameter for dbo.establish_directory may NOT be NULL or empty.';
        RETURN -1;
    END; 

    -- Normalize Path: 
    IF @TargetDirectory LIKE N'%\' OR @TargetDirectory LIKE N'%/'
        SET @TargetDirectory = LEFT(@TargetDirectory, LEN(@TargetDirectory) - 1);

    SET @Error = NULL;

    DECLARE @exists bit = 0; 
    IF @PrintOnly = 0 BEGIN 
        EXEC dbo.[check_paths] 
            @Path = @TargetDirectory, 
            @Exists = @exists OUTPUT;
    END;

    IF @exists = 1            
        RETURN 0; -- short-circuit. directory already exists.
    
    -- assume that we can/should be able to BUILD the path if it doesn't already exist: 
    DECLARE @command nvarchar(1000) = N'if not exist "' + @TargetDirectory + N'" mkdir "' + @TargetDirectory + N'"'; -- windows

    DECLARE @results xml;
	DECLARE @errorMessage nvarchar(MAX);
    EXEC dbo.[execute_command]
        @Command = @command, 
        @ExecutionType = N'SHELL',
        @ExecutionAttemptsCount = 1,
        @PrintOnly = @PrintOnly,
        @Outcome = @results OUTPUT, 
		@ErrorMessage = @errorMessage OUTPUT;

	IF @errorMessage IS NULL 
		RETURN 0; 
    
	SELECT @Error = @errorMessage;

    RETURN -1;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.load_backup_database_names','P') IS NOT NULL
	DROP PROC dbo.load_backup_database_names;
GO

CREATE PROC dbo.load_backup_database_names 
	@TargetDirectory				sysname				= N'{DEFAULT}',		
	@SerializedOutput				xml					= N'<default/>'					OUTPUT
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	-- EXEC dbo.verify_advanced_capabilities;	

	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	IF UPPER(@TargetDirectory) = N'{DEFAULT}' BEGIN
		SELECT @TargetDirectory = dbo.load_default_path('BACKUP');
	END;

	IF @TargetDirectory IS NULL BEGIN;
		RAISERROR('@TargetDirectory must be specified - and must point to a valid path.', 16, 1);
		RETURN - 10;
	END

	DECLARE @isValid bit;
	EXEC dbo.check_paths @TargetDirectory, @isValid OUTPUT;
	IF @isValid = 0 BEGIN
		RAISERROR(N'Specified @TargetDirectory is invalid - check path and retry.', 16, 1);
		RETURN -11;
	END;

	-----------------------------------------------------------------------------
	-- load databases from path/folder names:
	DECLARE @target_databases TABLE ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL
	); 

	DECLARE @directories table (
		row_id int IDENTITY(1,1) NOT NULL, 
		subdirectory sysname NOT NULL, 
		depth int NOT NULL
	);

    INSERT INTO @directories (subdirectory, depth)
    EXEC master.sys.xp_dirtree @TargetDirectory, 1, 0;

    INSERT INTO @target_databases ([database_name])
    SELECT subdirectory FROM @directories ORDER BY row_id;

	-- NOTE: if @AddServerNameToSystemBackupPath was added to SYSTEM backups... then master, model, msdb, etc... folders WILL exist. (But there won't be FULL_<dbname>*.bak files in those subfolders). 
	--		In this sproc we WILL list any 'folders' for system databases found (i.e., we're LISTING databases - not getting the actual backups or paths). 
	--		However, in dbo.restore_databases if the @TargetPath + N'\' + @dbToRestore doesn't find any files, and @dbToRestore is a SystemDB, we'll look in @TargetPath + '\' + @ServerName + '\' + @dbToRestore for <backup_type>_<db_name>*.bak/.trn etc.)... 

	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- if @SerializedOutput has been EXPLICITLY initialized as NULL/empty... then REPLY... 
		SELECT @SerializedOutput = (SELECT 
			[row_id] [database/@id],
			[database_name] [database]
		FROM 
			@target_databases
		ORDER BY 
			[row_id] 
		FOR XML PATH(''), ROOT('databases'));

		RETURN 0;
	END; 

	-----------------------------------------------------------------------------
	-- otherwise, project:

	SELECT 
		[database_name]
	FROM 
		@target_databases
	ORDER BY 
		[row_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO


IF OBJECT_ID('dbo.shred_string','P') IS NOT NULL
	DROP PROC dbo.shred_string
GO

CREATE PROC dbo.shred_string
	@Input						nvarchar(MAX), 
	@RowDelimiter				nvarchar(10) = N',', 
	@ColumnDelimiter			nvarchar(10) = N':'
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @rows table ( 
		[row_id] int,
		[result] nvarchar(200)
	);

	INSERT INTO @rows ([row_id], [result])
	SELECT [row_id], [result] 
	FROM [dbo].[split_string](@Input, @RowDelimiter, 1);

	DECLARE @columnCountMax int = 0;

	SELECT 
		@columnCountMax = 1 + MAX(dbo.count_matches([result], @ColumnDelimiter)) 
	FROM 
		@rows;

	--SELECT @columnCountMax;
	--SELECT * FROM @rows;

	--DECLARE @pivoted table ( 
	CREATE TABLE #pivoted (
		row_id int NOT NULL, 
		[column_id] int NOT NULL, 
		[result] sysname NULL
	);

	DECLARE @currentRow nvarchar(200); 
	DECLARE @currentRowID int = 1;

	SET @currentRow = (SELECT [result] FROM @rows WHERE [row_id] = @currentRowID);
	WHILE (@currentRow IS NOT NULL) BEGIN 

		INSERT INTO #pivoted ([row_id], [column_id], [result])
		SELECT @currentRowID, row_id, [result] FROM [dbo].[split_string](@currentRow, @ColumnDelimiter, 1);

		SET @currentRowID = @currentRowID + 1;
		SET @currentRow = (SELECT [result] FROM @rows WHERE [row_id] = @currentRowID);
	END; 

	DECLARE @sql nvarchar(MAX) = N'
	WITH tally AS ( 
		SELECT TOP (@columnCountMax)
			ROW_NUMBER() OVER (ORDER BY o1.[name]) AS n
		FROM sys.all_objects o1 
	), 
	transposed AS ( 
		SELECT
			p.row_id,
			CAST(N''column_'' AS varchar(20)) + RIGHT(CAST(''00'' AS varchar(20)) + CAST(t.n AS varchar(20)), 2) [column_name], 
			p.[result]
		FROM 
			#pivoted p
			INNER JOIN [tally] t ON p.[column_id] = t.n 
	)

	SELECT 
		[row_id], 
		{columns}
	FROM 
		(
			SELECT 
				t.row_id, 
				t.column_name, 
				t.result 
			FROM 
				[transposed] t
			--ORDER BY 
			--	t.[row_id], t.[column_name]
		) x 
	PIVOT ( MAX([result]) 
		FOR [column_name] IN ({columns})		
	) p; ';

	DECLARE @columns nvarchar(200) = N'';

	WITH tally AS ( 
		SELECT TOP (@columnCountMax)
			ROW_NUMBER() OVER (ORDER BY o1.[name]) AS n
		FROM sys.all_objects o1 
	)

	SELECT @columns = @columns + N'[' + CAST(N'column_' AS varchar(20)) + RIGHT(CAST('00' AS varchar(20)) + CAST(t.n AS varchar(20)), 2) + N'], ' FROM tally t;
	SET @columns = LEFT(@columns, LEN(@columns) - 1);

	SET @sql = REPLACE(@sql, N'{columns}', @columns); 

	EXEC [sys].[sp_executesql]
		@stmt = @sql, 
		@params = N'@columnCountMax int', 
		@columnCountMax = @columnCountMax;


	RETURN 0;

GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.print_long_string','P') IS NOT NULL
	DROP PROC dbo.print_long_string;
GO

CREATE PROC dbo.print_long_string 
	@Input				nvarchar(MAX)
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF @Input IS NULL 
		RETURN 0; 

	DECLARE @totalLength int = LEN(@Input); 
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	IF @totalLength <= 4000 BEGIN 
		PRINT @Input;
		RETURN 0;
	END;	

	DECLARE @currentLocation int = 1; -- NOT 0 based... 
	DECLARE @chunk nvarchar(4000);
	DECLARE @crlfLocation int;
	
	CREATE TABLE #chunks (
		row_id int IDENTITY(1,1) NOT NULL, 
		row_data nvarchar(MAX) NOT NULL 
	); 

	INSERT INTO [#chunks] ([row_data])
	SELECT [result] FROM dbo.[split_string](@Input, @crlf, 1);

	IF (SELECT COUNT(*) FROM [#chunks]) > 1 BEGIN 
		DECLARE @rowData nvarchar(MAX);
		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT row_data FROM [#chunks] ORDER BY [row_id];
		
		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @rowData;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			IF LEN(@rowData) > 4000 BEGIN 
				SET @totalLength = LEN(@rowData);
				WHILE @currentLocation <= @totalLength BEGIN
					SET @chunk = SUBSTRING(@rowData, @currentLocation, 4001); -- final arg = POSITION (not number of chars to take).
					
					SET @currentLocation = @currentLocation + (LEN(@chunk));

					PRINT @chunk;
				END;
			  END; 
			ELSE 
				PRINT @rowData; 

			FETCH NEXT FROM [walker] INTO @rowData;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

		RETURN 0;
	END; 

	-- Otherwise, if we're still here... 
	SET @totalLength = LEN(@Input);
	WHILE @currentLocation <= @totalLength BEGIN
		SET @chunk = SUBSTRING(@Input, @currentLocation, 4001); -- final arg = POSITION (not number of chars to take).

		SET @currentLocation = @currentLocation + (LEN(@chunk));

		PRINT @chunk; 
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.get_executing_dbname','P') IS NOT NULL
	DROP PROC dbo.[get_executing_dbname];
GO

CREATE PROC dbo.[get_executing_dbname]
    @ExecutingDBName                sysname         = N''      OUTPUT		-- note: NON-NULL default for RETURN or PROJECT convention... 
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    DECLARE @output sysname;
    DECLARE @resultCount int;
    DECLARE @options table (
        [db_name] sysname NOT NULL 
    ); 

    INSERT INTO @options ([db_name])
    SELECT 
        DB_NAME([resource_database_id]) [db_name]
        -- vNext... if I can link these (or any other columns) to something/anything in sys.dm_os_workers or sys.dm_os_tasks or ... anything ... 
        --      then I could 'know for sure'... 
        --          but, lock_owner_address ONLY maps to sys.dm_os_waiting_tasks ... and... we're NOT waiting... (well, the CALLER is not waiting).
        --, [lock_owner_address]
        --, [request_owner_lockspace_id]
    FROM 
        sys.[dm_tran_locks]
    WHERE 
        [request_session_id] = @@SPID
        AND [resource_database_id] <> DB_ID('admindb');
        
    SET @resultCount = @@ROWCOUNT;
    
    IF @resultCount > 1 BEGIN 
        RAISERROR('Could not determine executing database-name - multiple schema locks (against databases OTHER than admindb) are actively held by the current session_id.', 16, 1);
        RETURN -1;
    END;
    
    IF @resultCount < 1 BEGIN
        SET @output = N'admindb';
      END;
    ELSE BEGIN 
        SET @output = (SELECT TOP 1 [db_name] FROM @options);
    END;

    IF @ExecutingDBName IS NULL BEGIN 
		SET @ExecutingDBName = @output;
      END;
    ELSE BEGIN 
        SELECT @output [executing_db_name];
    END;

    RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.load_id_for_normalized_name','P') IS NOT NULL
	DROP PROC dbo.[load_id_for_normalized_name];
GO

CREATE PROC dbo.[load_id_for_normalized_name]
	@TargetName						sysname, 
	@ParameterNameForTarget			sysname			= N'@Target',
	@NormalizedName					sysname			OUTPUT, 
	@ObjectID						int				OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @targetDatabase sysname, @targetSchema sysname, @targetObjectName sysname;
	DECLARE @targetObjectId int;
	DECLARE @sql nvarchar(MAX);

	SELECT 
		@targetDatabase = PARSENAME(@TargetName, 3), 
		@targetSchema = ISNULL(PARSENAME(@TargetName, 2), N'dbo'), 
		@targetObjectName = PARSENAME(@TargetName, 1);
	
	IF @targetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @targetDatabase OUTPUT;
		
		IF @targetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for %s and/or S4 was unable to determine calling-db-context. Please use dbname.schemaname.objectname qualified names.', 16, 1, @ParameterNameForTarget);
			RETURN -5;
		END;
	END;

	SET @sql = N'SELECT @targetObjectId = o.[object_id] FROM [' + @targetDatabase + N'].sys.objects o INNER JOIN [' + @targetDatabase + N'].sys.[schemas] s ON [o].[schema_id] = [s].[schema_id] WHERE s.[name] = @targetSchema AND o.[name] = @targetObjectName; '

	EXEC [sys].[sp_executesql]
		@sql, 
		N'@targetSchema sysname, @targetObjectName sysname, @targetObjectId int OUTPUT', 
		@targetSchema = @targetSchema, 
		@targetObjectName = @targetObjectName, 
		@targetObjectId = @targetObjectId OUTPUT;

	IF @targetObjectId IS NULL BEGIN 
		RAISERROR(N'Invalid Table Name specified for %s. Please use dbname.schemaname.objectname qualified names.', 16, 1, @ParameterNameForTarget);
		RETURN -10;
	END;

	SET @ObjectID = @targetObjectId;
	SET @NormalizedName = QUOTENAME(@targetDatabase) + N'.' + QUOTENAME(@targetSchema) + N'.' + QUOTENAME(@targetObjectName);

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
-- Backups:
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.log_backup_history_detail','P') IS NOT NULL
	DROP PROC dbo.[log_backup_history_detail];
GO

CREATE PROC dbo.[log_backup_history_detail]
	@LogSuccessfulOutcomes			bit							= 1, 
	@ExecutionDetails				dbo.backup_history_entry	READONLY, 
	@BackupHistoryId				int							OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	IF (SELECT COUNT(*) FROM @ExecutionDetails) <> 1 BEGIN 
		RAISERROR(N'Invalid Configuration. @ExecutionDetails can only, ever, contain a single row at a time.', 16, 1);
	END;

	DECLARE @isError bit = 0; 
	IF EXISTS (SELECT NULL FROM @ExecutionDetails WHERE [error_details] IS NOT NULL) 
		SET @isError = 1;

	IF @isError = 0 AND @LogSuccessfulOutcomes = 0
		RETURN 0;

	IF @BackupHistoryId IS NULL BEGIN 
		INSERT INTO dbo.[backup_log] (
			[execution_id],
			[backup_date],
			[database],
			[backup_type],
			[backup_path],
			[copy_path],
			[offsite_path],
			[backup_start],
			[backup_end],
			[backup_succeeded],
			[verification_start],
			[verification_end],
			[verification_succeeded],
			[copy_succeeded],
			[copy_seconds],
			[failed_copy_attempts],
			[copy_details],
			[offsite_succeeded],
			[offsite_seconds],
			[failed_offsite_attempts],
			[offsite_details],
			[error_details]
		)
		SELECT 
			[execution_id],
			[backup_date],
			[database],
			[backup_type],
			[backup_path],
			[copy_path],
			[offsite_path],
			[backup_start],
			[backup_end],
			[backup_succeeded],
			[verification_start],
			[verification_end],
			[verification_succeeded],
			[copy_succeeded],
			[copy_seconds],
			[failed_copy_attempts],
			[copy_details],
			[offsite_succeeded],
			[offsite_seconds],
			[failed_offsite_attempts],
			[offsite_details],
			[error_details]
		FROM 
			@ExecutionDetails;

		SELECT @BackupHistoryId = SCOPE_IDENTITY();

		RETURN 0;
	END;

	UPDATE x 
	SET 
		x.[backup_date] = d.[backup_date],
		x.[database] = d.[database],
		x.[backup_type] = d.[backup_type],
		x.[backup_path] = d.[backup_path],
		x.[copy_path] = d.[copy_path],
		x.[offsite_path] = d.[offsite_path],
		x.[backup_start] = d.[backup_start],
		x.[backup_end] = d.[backup_end],
		x.[backup_succeeded] = d.[backup_succeeded],
		x.[verification_start] = d.[verification_start],
		x.[verification_end] = d.[verification_end],
		x.[verification_succeeded] = d.[verification_succeeded],
		x.[copy_succeeded] = d.[copy_succeeded],
		x.[copy_seconds] = d.[copy_seconds],
		x.[failed_copy_attempts] = d.[failed_copy_attempts],
		x.[copy_details] = d.[copy_details],
		x.[offsite_succeeded] = d.[offsite_succeeded],
		x.[offsite_seconds] = d.[offsite_seconds],
		x.[failed_offsite_attempts] = d.[failed_offsite_attempts],
		x.[offsite_details] = d.[offsite_details],
		x.[error_details] = d.[error_details]
	FROM
		dbo.backup_log x 
		INNER JOIN @ExecutionDetails d ON x.[backup_id] = @BackupHistoryId
	WHERE 
		x.backup_id = @BackupHistoryId; 

	RETURN 0;
GO		


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('[dbo].[remove_backup_files]','P') IS NOT NULL
	DROP PROC [dbo].[remove_backup_files];
GO

CREATE PROC [dbo].[remove_backup_files] 
	@BackupType							sysname,									-- { {ALL} | FULL|DIFF|LOG }
	@DatabasesToProcess					nvarchar(1000),								-- { {READ_FROM_FILESYSTEM} | name1,name2,etc }
	@DatabasesToExclude					nvarchar(600) = NULL,						-- { NULL | name1,name2 }  
	@TargetDirectory					nvarchar(2000) = N'{DEFAULT}',				-- { path_to_backups }
	@Retention							nvarchar(10),								-- #n  - where # is an integer for the threshold, and n is either m, h, d, w, or b - for Minutes, Hours, Days, Weeks, or B - for # of backups to retain.
	@ForceSecondaryCleanup				sysname = NULL,								-- { NULL | N'FORCE' }  - allows backups on a secondary (i.e., where DBs exist - but are in read-only/secondary mode) to be removed.
	@ServerNameInSystemBackupPath		bit = 0,									-- for mirrored servers/etc.
	@SendNotifications					bit	= 0,									-- { 0 | 1 } Email only sent if set to 1 (true).
	@OperatorName						sysname = N'Alerts',		
	@MailProfileName					sysname = N'General',
	@EmailSubjectPrefix					nvarchar(50) = N'[Backups Cleanup] ',
    @Output								nvarchar(MAX) = N'default' OUTPUT,			-- When explicitly set to NULL, summary/errors/output will be 'routed' into this variable instead of emailed/raised/etc.
	@PrintOnly							bit = 0 									-- { 0 | 1 }
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	EXEC dbo.verify_advanced_capabilities;

	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	DECLARE @Edition sysname;
	SELECT @Edition = CASE SERVERPROPERTY('EngineEdition')
		WHEN 2 THEN 'STANDARD'
		WHEN 3 THEN 'ENTERPRISE'
		WHEN 4 THEN 'EXPRESS'
		ELSE NULL
	END;

	IF @Edition = N'STANDARD' OR @Edition IS NULL BEGIN;
		-- check for Web:
		IF @@VERSION LIKE '%web%' SET @Edition = 'WEB';
	END;
	
	IF @Edition IS NULL BEGIN;
		RAISERROR('Unsupported SQL Server Edition detected. This script is only supported on Express, Web, Standard, and Enterprise (including Evaluation and Developer) Editions.', 16, 1);
		RETURN -2;
	END;
	
	IF ((@PrintOnly = 0) OR (NULLIF(@Output, N'default') IS NULL)) AND (@Edition != 'EXPRESS') BEGIN; -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 

		-- Operator Checks:
		IF ISNULL(@OperatorName, '') IS NULL BEGIN;
			RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
			RETURN -4;
		 END;
		ELSE BEGIN; 
			IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN;
				RAISERROR('Invalid Operator Name Specified.', 16, 1);
				RETURN -4;
			END;
		END;

		-- Profile Checks:
		DECLARE @DatabaseMailProfile nvarchar(255);
		EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output';
 
		IF @DatabaseMailProfile != @MailProfileName BEGIN;
			RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
			RETURN -5;
		END; 
	END;

	IF UPPER(@TargetDirectory) = N'{DEFAULT}' BEGIN
		SELECT @TargetDirectory = dbo.load_default_path('BACKUP');
	END;

	IF NULLIF(@TargetDirectory, N'') IS NULL BEGIN;
		RAISERROR('@BackupsDirectory cannot be NULL and must be a valid path.', 16, 1);
		RETURN -6;
	END;

	IF UPPER(@BackupType) NOT IN ('FULL', 'DIFF', 'LOG', '{ALL}') BEGIN;
		RAISERROR('Invalid @BackupType Specified. Allowable values are { {ALL} |  FULL | DIFF | LOG }.', 16, 1);

		RETURN -7;
	END;

	DECLARE @excludeSecondaries bit = 1;
	IF UPPER(@ForceSecondaryCleanup) = N'FORCE'
		SET @excludeSecondaries = 0;

	SET @Retention = LTRIM(RTRIM(REPLACE(@Retention, N' ', N'')));

	DECLARE @retentionType char(1);
	DECLARE @retentionValue bigint;
	DECLARE @retentionError nvarchar(MAX);
	DECLARE @retentionCutoffTime datetime; 

	IF UPPER(@Retention) = N'{INFINITE}' BEGIN 
		PRINT N'-- {INFINITE} retention detected. Terminating cleanup process.';
		RETURN 0;
	END;

	IF UPPER(@Retention) LIKE '%B%' OR UPPER(@Retention) LIKE '%BACKUP%' BEGIN 
		
		DECLARE @boundary int = PATINDEX(N'%[^0-9]%', @Retention)- 1;

		IF @boundary < 1 BEGIN 
			SET @retentionError = N'Invalid Vector format specified for parameter @Retention. Format must be in ''XX nn'' or ''XXnn'' format - where XX is an ''integer'' duration (e.g., 72) and nn is an interval-specifier (e.g., HOUR, HOURS, H, or h).';
			RAISERROR(@retentionError, 16, 1);
			RETURN -1;
		END;

		BEGIN TRY

			SET @retentionValue = CAST((LEFT(@Retention, @boundary)) AS int);
		END TRY
		BEGIN CATCH
			SET @retentionValue = -1;
		END CATCH

		IF @retentionValue < 0 BEGIN 
			RAISERROR('Invalid @Retention value specified. Number of Backups specified was formatted incorrectly or < 0.', 16, 1);
			RETURN -25;
		END;

		SET @retentionType = 'b';
	  END;
	ELSE BEGIN 

		EXEC dbo.[translate_vector_datetime]
		    @Vector = @Retention, 
		    @Operation = N'SUBTRACT', 
		    @ValidationParameterName = N'@Retention', 
		    @ProhibitedIntervals = N'BACKUP', 
		    @Output = @retentionCutoffTime OUTPUT, 
		    @Error = @retentionError OUTPUT;

		IF @retentionError IS NOT NULL BEGIN 
			RAISERROR(@retentionError, 16, 1);
			RETURN -26;
		END;
	END;

	IF @PrintOnly = 1 BEGIN 
		IF @retentionType = 'b'
			PRINT '-- Retention specification is to keep the last ' + CAST(@retentionValue AS sysname) + ' backup(s).';
		ELSE 
			PRINT '-- Retention specification is to remove backups created before [' + CONVERT(sysname, @retentionCutoffTime, 120) + N'].';
	END;

	SET @TargetDirectory = dbo.[normalize_file_path](@TargetDirectory);

	DECLARE @isValid bit;
	EXEC dbo.check_paths @TargetDirectory, @isValid OUTPUT;
	IF @isValid = 0 BEGIN;
		RAISERROR('Invalid @TargetDirectory specified - either the path does not exist, or SQL Server''s Service Account does not have permissions to access the specified directory.', 16, 1);
		RETURN -10;
	END;

	-----------------------------------------------------------------------------
	SET @Output = NULL;

	DECLARE @excludeSimple bit = 0;

	IF @BackupType = N'LOG'
		SET @excludeSimple = 1;

	IF ((SELECT dbo.[count_matches](@DatabasesToProcess, N'{READ_FROM_FILESYSTEM}')) > 0) BEGIN
		
		SET @excludeSimple = 0; /* DBs that might now/currently be SIMPLE might have T-LOGs that need to be cleaned up.... */

		DECLARE @databases xml = NULL;
		DECLARE @serialized nvarchar(MAX) = '';

		EXEC dbo.[load_backup_database_names]
		    @TargetDirectory = @TargetDirectory,
		    @SerializedOutput = @databases OUTPUT;

		WITH shredded AS ( 
			SELECT 
				[data].[row].value('@id[1]', 'int') [row_id], 
				[data].[row].value('.[1]', 'sysname') [database_name]
			FROM 
				@databases.nodes('//database') [data]([row])
		) 

		SELECT 
			@serialized = @serialized + [database_name] + N','
		FROM 
			shredded 
		ORDER BY 
			row_id;

		IF LEN(@serialized) > 1
			SET @serialized = LEFT(@serialized, LEN(@serialized) - 1);

		IF NULLIF(@serialized, N'') IS NULL BEGIN 
			RAISERROR(N'@TargetDatabases was set to {READ_FROM_FILESYSTEM} but the path ''%s'' specified by @TargetDirectory contained no sub-directories (that could be treated as locations for database backups).', 16, 1, @TargetDirectory);
			RETURN -20;
		END;

		SET @DatabasesToProcess = REPLACE(@DatabasesToProcess, N'{READ_FROM_FILESYSTEM}', @serialized); 
	END;

	DECLARE @targetDirectories table (
        [entry_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL,
        [directory_name] sysname NULL
    ); 

	INSERT INTO @targetDirectories ([database_name])
	EXEC dbo.list_databases
	    @Targets = @DatabasesToProcess,
	    @Exclusions = @DatabasesToExclude,
		@ExcludeSecondaries = @excludeSecondaries,
		@ExcludeSimpleRecovery = @excludeSimple;

	UPDATE @targetDirectories SET [directory_name] = [database_name] WHERE [directory_name] IS NULL;

	-----------------------------------------------------------------------------
	-- Account for backups of system databases with the server-name in the path:  
	IF @ServerNameInSystemBackupPath = 1 BEGIN
		
		-- simply add additional/'duplicate-ish' directories to check for anything that's a system database:
		DECLARE @serverName sysname = N'\' + REPLACE(@@SERVERNAME, N'\', N'_'); -- account for named instances. 

		-- and, note that IF we hand off the name of an invalid directory (i.e., say admindb backups are NOT being treated as system - so that D:\SQLBackups\admindb\SERVERNAME\ was invalid, then xp_dirtree (which is what's used to query for files) will simply return 'empty' results and NOT throw errors.
		INSERT INTO @targetDirectories ([database_name], [directory_name])
		SELECT 
			[database_name],
			[directory_name] + @serverName 
		FROM 
			@targetDirectories
		WHERE 
			[directory_name] IN (N'master', N'msdb', N'model', N'admindb'); 
	END;

	-----------------------------------------------------------------------------
	-- Process files for removal:
	DECLARE @currentDb sysname;
	DECLARE @currentDirectory sysname;
	DECLARE @command nvarchar(MAX);
	DECLARE @targetPath nvarchar(512);
	DECLARE @errorMessage nvarchar(MAX) = N'';
	DECLARE @file nvarchar(512);
	DECLARE @outcome xml;

	DECLARE @serializedFiles xml; 

	DECLARE @files table (
		[id] int IDENTITY(1,1) NOT NULL, 
		[file_name] nvarchar(MAX) NOT NULL, 
		[timestamp] datetime NOT NULL
	);

	DECLARE @lastN table ( 
		id int IDENTITY(1,1) NOT NULL, 
		original_id int NOT NULL, 
		backup_name nvarchar(512), 
		backup_type sysname
	);

	DECLARE @errors table (
		error_id int IDENTITY(1,1) NOT NULL, 
		[error_message] nvarchar(MAX) NOT NULL
	);

	DECLARE processor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name], [directory_name]
	FROM 
		@targetDirectories
	ORDER BY 
		[entry_id];

	OPEN processor;
	FETCH NEXT FROM processor INTO @currentDb, @currentDirectory;

	WHILE @@FETCH_STATUS = 0 BEGIN;
		
		SET @targetPath = @TargetDirectory + N'\' + @currentDirectory;

		-- cleanup from previous passes
		SET @errorMessage = NULL;
		
		DELETE FROM @files;
		SET @serializedFiles = NULL;

		IF @PrintOnly = 1 BEGIN
			PRINT N'-- EXEC admindb.dbo.load_backup_files @DatabaseToRestore = N''' + @currentDb + N''', @SourcePath = N''' + @targetPath + N''', @Mode = N''LIST''; ';
		END;

		EXEC dbo.load_backup_files 
			@DatabaseToRestore = @currentDb, 
			@SourcePath = @targetPath, 
			@Mode = N'LIST', 
			@Output = @serializedFiles OUTPUT;

		WITH shredded AS ( 
			SELECT 
				[data].[row].value('@id[1]', 'int') [id], 
				[data].[row].value('@file_name', 'nvarchar(max)') [file_name],
				[data].[row].value('@timestamp', 'datetime') [timestamp]
			FROM 
				@serializedFiles.nodes('//file') [data]([row])
		) 
		INSERT INTO @files (
			[file_name],
			[timestamp]
		)
		SELECT 
			[file_name],
			[timestamp]	
		FROM 
			shredded 
		ORDER BY 
			id;

		IF @retentionType = 'b' BEGIN -- Remove all backups of target type except the most recent N (where N is @retentionValue).
			
			-- clear out any state from previous iterations:
			DELETE FROM @lastN;

			IF @BackupType IN ('LOG', '{ALL}') BEGIN
				INSERT INTO @lastN (original_id, backup_name, backup_type)
				SELECT TOP (@retentionValue)
					id, 
					[file_name], 
					'LOG'
				FROM 
					@files
				WHERE 
					[file_name] LIKE 'LOG%.trn'
				ORDER BY 
					id DESC;

				IF @BackupType != '{ALL}' BEGIN
					DELETE FROM @files WHERE [file_name] NOT LIKE '%.trn';  -- if we're NOT doing {ALL}, then remove DIFF and FULL backups... 
				END;
			END;

			IF @BackupType IN ('FULL', '{ALL}') BEGIN
				INSERT INTO @lastN (original_id, backup_name, backup_type)
				SELECT TOP (@retentionValue)
					id, 
					[file_name], 
					'FULL'
				FROM 
					@files
				WHERE 
					[file_name] LIKE 'FULL%.bak'
				ORDER BY 
					id DESC;

				IF @BackupType != '{ALL}' BEGIN 
					DELETE FROM @files WHERE [file_name] NOT LIKE 'FULL%.bak'; -- if we're NOT doing all, then remove all non-FULL backups...  
				END
			END;

			IF @BackupType IN ('DIFF', '{ALL}') BEGIN
				INSERT INTO @lastN (original_id, backup_name, backup_type)
				SELECT TOP (@retentionValue)
					id, 
					[file_name], 
					'DIFF'
				FROM 
					@files
				WHERE 
					[file_name] LIKE 'DIFF%.bak'
				ORDER BY 
					id DESC;

					IF @BackupType != '{ALL}' BEGIN 
						DELETE FROM @files WHERE [file_name] NOT LIKE 'DIFF%.bak'; -- if we're NOT doing all, the remove non-DIFFs so they won't be nuked.
					END
			END;
			
			-- prune any/all files we're supposed to keep: 
			DELETE x 
			FROM 
				@files x 
				INNER JOIN @lastN l ON x.id = l.original_id AND x.[file_name] = l.backup_name;

		  END;
		ELSE BEGIN -- Any backups older than @RetentionCutoffTime are removed. 

			IF @BackupType IN ('LOG', '{ALL}') BEGIN;
			
				DELETE FROM @files WHERE [timestamp] >= @retentionCutoffTime; -- Remove any files we should keep.
				
				IF @BackupType != '{ALL}' BEGIN
					DELETE FROM @files WHERE [file_name] NOT LIKE '%.trn';  -- if we're NOT doing {ALL}, then remove DIFF and FULL backups... 
				END;
			END

			IF @BackupType IN ('FULL', 'DIFF', '{ALL}') BEGIN;

				DELETE FROM @files WHERE [file_name] NOT LIKE '%.bak'; -- remove (from processing) any files that don't use the .bak extension. 

				-- If a specific backup type is specified ONLY target that backup type:
				IF @BackupType != N'ALL' BEGIN;
				
					IF @BackupType = N'FULL'
						DELETE FROM @files WHERE [file_name] NOT LIKE N'FULL%';

					IF @BackupType = N'DIFF'
						DELETE FROM @files WHERE [file_name] NOT LIKE N'DIFF%';
				END

				DELETE FROM @files WHERE [timestamp] >= @retentionCutoffTime;
		    END
		END;

		-- whatever is left is what we now need to nuke/remove:
		DECLARE nuker CURSOR LOCAL FAST_FORWARD FOR 
		SELECT [file_name] FROM @files 
		ORDER BY id;

		OPEN nuker;
		FETCH NEXT FROM nuker INTO @file;

		WHILE @@FETCH_STATUS = 0 BEGIN;

			-- reset per each 'grab':
			SET @errorMessage = NULL;
			SET @command = N'del /q /f "' + @targetPath + N'\' + @file + N'"';

			BEGIN TRY
					
				EXEC dbo.[execute_command]
					@Command = @command,
					@ExecutionType = N'SHELL',
					@ExecutionAttemptsCount = 1,
					@IgnoredResults = N'{DELETEFILE}',
					@PrintOnly = @PrintOnly,
					@Outcome = @outcome OUTPUT, 
					@ErrorMessage = @errorMessage OUTPUT;

			END TRY 
			BEGIN CATCH
				SET @errorMessage = ISNULL(@errorMessage, '') +  N'Error deleting Backup File with command: [' + ISNULL(@command, '##NOT SET YET##') + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE() + N' ';
			END CATCH

			IF @errorMessage IS NOT NULL BEGIN;
				SET @errorMessage = ISNULL(@errorMessage, '') + '. Command: [' + ISNULL(@command, '#EMPTY#') + N']. ';

				INSERT INTO @errors ([error_message])
				VALUES (@errorMessage);
			END

			FETCH NEXT FROM nuker INTO @file;
		END;

		CLOSE nuker;
		DEALLOCATE nuker;

		FETCH NEXT FROM processor INTO @currentDb, @currentDirectory;
	END

	CLOSE processor;
	DEALLOCATE processor;

	-----------------------------------------------------------------------------
	-- Cleanup:

	IF (SELECT CURSOR_STATUS('local','nuker')) > -1 BEGIN;
		CLOSE nuker;
		DEALLOCATE nuker;
	END;

	-----------------------------------------------------------------------------
	-- Error Reporting:
	DECLARE @errorInfo nvarchar(MAX) = N'';
	DECLARE @crlf nchar(2) = CHAR(13) + CHAR(10);
	DECLARE @tab nchar(1) = CHAR(9);

	DECLARE @routeInfoAsOutput bit = 0;
	IF @Output IS NULL
		SET @routeInfoAsOutput = 1; 

	IF EXISTS (SELECT NULL FROM @errors) BEGIN;
		
		-- format based on output type (output variable or email/error-message), then 'raise, return, or send'... 
		IF @routeInfoAsOutput = 1 BEGIN;
			SELECT @errorInfo = @errorInfo + [error_message] + N', ' FROM @errors ORDER BY error_id;
			SET @errorInfo = LEFT(@errorInfo, LEN(@errorInfo) - 2);

			SET @Output = @errorInfo;
		  END
		ELSE BEGIN;

			SELECT @errorInfo = @errorInfo + @tab + N'- ' + [error_message] + @crlf + @crlf
			FROM 
				@errors
			ORDER BY 
				error_id;

			IF (@SendNotifications = 1) AND (@Edition != 'EXPRESS') BEGIN;
				DECLARE @emailSubject nvarchar(2000);
				SET @emailSubject = @EmailSubjectPrefix + N' - ERROR';

				SET @errorInfo = N'The following errors were encountered: ' + @crlf + @errorInfo;

				EXEC msdb..sp_notify_operator
					@profile_name = @MailProfileName,
					@name = @OperatorName,
					@subject = @emailSubject, 
					@body = @errorInfo;				
			END

			-- this is being executed as a stand-alone job (most likely) so... throw the output into the job's history... 
			PRINT @errorInfo;  
			
			RAISERROR(@errorMessage, 16, 1);
			RETURN -100;
		END
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.remove_offsite_backup_files','P') IS NOT NULL
	DROP PROC dbo.[remove_offsite_backup_files];
GO

CREATE PROC dbo.[remove_offsite_backup_files]
	@BackupType							sysname,														-- { ALL|FULL|DIFF|LOG }
	@DatabasesToProcess					nvarchar(1000),													-- { {READ_FROM_FILESYSTEM} | name1,name2,etc }
	@DatabasesToExclude					nvarchar(600)				= NULL,								-- { NULL | name1,name2 }  
	@OffSiteBackupPath					nvarchar(2000)				= NULL,								-- { path_to_backups }
	@OffSiteRetention					nvarchar(10),													-- #n  - where # is an integer for the threshold, and n is either m, h, d, w, or b - for Minutes, Hours, Days, Weeks, or B - for # of backups to retain.
	@ServerNameInSystemBackupPath		bit							= 0,								-- for mirrored servers/etc.
	@SendNotifications					bit							= 0,								-- { 0 | 1 } Email only sent if set to 1 (true).
	@OperatorName						sysname						= N'Alerts',		
	@MailProfileName					sysname						= N'General',
	@EmailSubjectPrefix					nvarchar(50)				= N'[OffSite Backups Cleanup ] ',
    @Output								nvarchar(MAX)				= N'default' OUTPUT,				-- When explicitly set to NULL, summary/errors/output will be 'routed' into this variable instead of emailed/raised/etc.
	@PrintOnly							bit							= 0 								-- { 0 | 1 }

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	IF UPPER(@OffSiteRetention) = N'{INFINITE}' BEGIN 
		PRINT N'-- {INFINITE} retention detected. Terminating off-site cleanup process.';
		RETURN 0; -- success
	END;

	RAISERROR(N'NON-INFINITE Retention-cleanup off OffSite Backup Copies is not yet implemented.', 16, 1);
	RETURN -100;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.backup_databases','P') IS NOT NULL
	DROP PROC dbo.backup_databases;
GO

CREATE PROC dbo.backup_databases 
	@BackupType							sysname,																-- { FULL|DIFF|LOG }
	@DatabasesToBackup					nvarchar(MAX),															-- { {SYSTEM} | {USER} |name1,name2,etc }
	@DatabasesToExclude					nvarchar(MAX)							= NULL,							-- { NULL | name1,name2 }  
	@Priorities							nvarchar(MAX)							= NULL,							-- { higher,priority,dbs,*,lower,priority,dbs } - where * represents dbs not specifically specified (which will then be sorted alphabetically
	@BackupDirectory					nvarchar(2000)							= N'{DEFAULT}',					-- { {DEFAULT} | path_to_backups }
	@CopyToBackupDirectory				nvarchar(2000)							= NULL,							-- { NULL | path_for_backup_copies } NOTE {PARTNER} allowed as a token (if a PARTNER is defined).
	@OffSiteBackupPath					nvarchar(2000)							= NULL,							-- e.g., S3::bucket-name:path\sub-path'
	@BackupRetention					nvarchar(10),															-- [DOCUMENT HERE]
	@CopyToRetention					nvarchar(10)							= NULL,							-- [DITTO: As above, but allows for diff retention settings to be configured for copied/secondary backups.]
	@OffSiteRetention					nvarchar(10)							= NULL,							-- { vector | n backups | {INFINITE} }   - where {INFINITE} is a token meaning: S4 won't tackle cleanups, instead this is handled by retention policies.
	@RemoveFilesBeforeBackup			bit										= 0,							-- { 0 | 1 } - when true, then older backups will be removed BEFORE backups are executed.
	@EncryptionCertName					sysname									= NULL,							-- Ignored if not specified. 
	@EncryptionAlgorithm				sysname									= NULL,							-- Required if @EncryptionCertName is specified. AES_256 is best option in most cases.
	@AddServerNameToSystemBackupPath	bit										= 0,							-- If set to 1, backup path is: @BackupDirectory\<db_name>\<server_name>\
	@AllowNonAccessibleSecondaries		bit										= 0,							-- If review of @DatabasesToBackup yields no dbs (in a viable state) for backups, exception thrown - unless this value is set to 1 (for AGs, Mirrored DBs) and then execution terminates gracefully with: 'No ONLINE dbs to backup'.
	@AlwaysProcessRetention				bit										= 0,							-- IF @AllowNonAccessibleSecondaries = 1, then if @AlwaysProcessRetention = 1, if/when we find NO databases to backup, we'll pass in the @TargetDatabases to a CLEANUP process vs simply short-circuiting execution.
	@Directives							nvarchar(400)							= NULL,							-- { KEEP_ONLINE | TAIL_OF_LOG[:<marker>][:<rollback_seconds>] | FINAL[:<marker>][:<rollback_seconds>] | COPY_ONLY | FILE:logical_file_name | FILEGROUP:file_group_name | MARKER:file-name-tail-marker }  - NOTE: NOT mutually exclusive. Also, MULTIPLE FILE | FILEGROUP directives can be specified - just separate with commas. e.g., FILE:secondary, FILE:tertiarty. 
	@LogSuccessfulOutcomes				bit										= 0,							-- By default, exceptions/errors are ALWAYS logged. If set to true, successful outcomes are logged to dba_DatabaseBackup_logs as well.
	@OperatorName						sysname									= N'Alerts',
	@MailProfileName					sysname									= N'General',
	@EmailSubjectPrefix					nvarchar(50)							= N'[Database Backups] ',
	@PrintOnly							bit										= 0								-- Instead of EXECUTING commands, they're printed to the console only. 	
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	DECLARE @return int;
    EXEC @return = dbo.verify_advanced_capabilities;
	IF @return <> 0 
		RETURN @return;

	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	DECLARE @Edition sysname;
	SELECT @Edition = CASE SERVERPROPERTY('EngineEdition')
		WHEN 2 THEN 'STANDARD'
		WHEN 3 THEN 'ENTERPRISE'
		WHEN 4 THEN 'EXPRESS'
		ELSE NULL
	END;

	IF @Edition = N'STANDARD' OR @Edition IS NULL BEGIN
		-- check for Web:
		IF @@VERSION LIKE '%web%' SET @Edition = N'WEB';

		IF @@VERSION LIKE '%Workgroup Edition%' SET @Edition = N'WORKGROUP';
	END;
	
	IF @Edition IS NULL BEGIN
		RAISERROR('Unsupported SQL Server Edition detected. This script is only supported on Express, Web, Standard, and Enterprise (including Evaluation and Developer) Editions.', 16, 1);
		RETURN -2;
	END;

	IF (@PrintOnly = 0) AND (@Edition != 'EXPRESS') BEGIN -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 

		-- Operator Checks:
		IF ISNULL(@OperatorName, '') IS NULL BEGIN
			RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
			RETURN -4;
		 END;
		ELSE BEGIN
			IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
				RAISERROR('Invalid Operator Name Specified.', 16, 1);
				RETURN -4;
			END;
		END;

		-- Profile Checks:
		DECLARE @DatabaseMailProfile nvarchar(255);
		EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output';
 
		IF @DatabaseMailProfile != @MailProfileName BEGIN
			RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
			RETURN -5;
		END; 
	END;

	IF UPPER(@BackupDirectory) = N'{DEFAULT}' BEGIN
		SELECT @BackupDirectory = dbo.load_default_path('BACKUP');
	END;

	IF NULLIF(@BackupDirectory, N'') IS NULL BEGIN
		RAISERROR('@BackupsDirectory cannot be NULL and must be a valid path.', 16, 1);
		RETURN -6;
	END;

	IF UPPER(@BackupType) NOT IN ('FULL', 'DIFF', 'LOG') BEGIN
		PRINT 'Usage: @BackupType = FULL|DIFF|LOG';
		RAISERROR('Invalid @BackupType Specified.', 16, 1);

		RETURN -7;
	END;

	IF UPPER(@DatabasesToBackup) = N'{READ_FROM_FILESYSTEM}' BEGIN
		RAISERROR('@DatabasesToBackup may NOT be set to the token {READ_FROM_FILESYSTEM} when processing backups.', 16, 1);
		RETURN -9;
	END

-- TODO: I really need to validate retention details HERE... i.e., BEFORE we start running backups. 
--		not sure of the best way to do that - i.e., short of copy/paste of the logic (here and there).

-- honestly, probably makes the most sense to push validation into a scalar UDF. the UDF returns a string/error or NULL (if there's nothing wrong). That way, both sprocs can use the validation details easily. 

	--IF (DATEADD(MINUTE, 0 - @fileRetentionMinutes, GETDATE())) >= GETDATE() BEGIN 
	--	 RAISERROR('Invalid @BackupRetentionHours - greater than or equal to NOW.', 16, 1);
	--	 RETURN -10;
	--END;

	--IF NULLIF(@CopyToBackupDirectory, '') IS NOT NULL BEGIN
	--	IF (DATEADD(MINUTE, 0 - @copyToFileRetentionMinutes, GETDATE())) >= GETDATE() BEGIN
	--		RAISERROR('Invalid @CopyToBackupRetentionHours - greater than or equal to NOW.', 16, 1);
	--		RETURN -11;
	--	END;
	--END;

	IF (SELECT dbo.[count_matches](@CopyToBackupDirectory, N'{PARTNER}')) > 0 BEGIN 

		IF NOT EXISTS (SELECT NULL FROM sys.servers WHERE [name] = N'PARTNER') BEGIN
			RAISERROR('THe {PARTNER} token can only be used in the @CopyToBackupDirectory if/when a PARTNER server has been registered as a linked server.', 16, 1);
			RETURN -20;
		END;

		DECLARE @partnerName sysname; 
		EXEC sys.[sp_executesql]
			N'SET @partnerName = (SELECT TOP 1 [name] FROM PARTNER.master.sys.servers WHERE [is_linked] = 0 ORDER BY [server_id]);', 
			N'@partnerName sysname OUTPUT', 
			@partnerName = @partnerName OUTPUT;

		SET @CopyToBackupDirectory = REPLACE(@CopyToBackupDirectory, N'{PARTNER}', @partnerName);
	END;

	IF NULLIF(@EncryptionCertName, '') IS NOT NULL BEGIN
		IF (CHARINDEX(N'[', @EncryptionCertName) > 0) OR (CHARINDEX(N']', @EncryptionCertName) > 0) 
			SET @EncryptionCertName = REPLACE(REPLACE(@EncryptionCertName, N']', N''), N'[', N'');
		
		-- make sure the cert name is legit and that an encryption algorithm was specified:
		IF NOT EXISTS (SELECT NULL FROM master.sys.certificates WHERE name = @EncryptionCertName) BEGIN
			RAISERROR('Certificate name specified by @EncryptionCertName is not a valid certificate (not found in sys.certificates).', 16, 1);
			RETURN -15;
		END;

		IF NULLIF(@EncryptionAlgorithm, '') IS NULL BEGIN
			RAISERROR('@EncryptionAlgorithm must be specified when @EncryptionCertName is specified.', 16, 1);
			RETURN -15;
		END;
	END;

	DECLARE @isCopyOnlyBackup bit = 0;
	DECLARE @fileOrFileGroupDirective nvarchar(2000) = '';
	DECLARE @setSingleUser bit = 0;
	DECLARE @keepOnline bit = 0; 
	DECLARE @setSingleUserRollbackSeconds int = 10;
	DECLARE @markerOverride sysname;

	IF NULLIF(@Directives, N'') IS NOT NULL BEGIN
		SET @Directives = UPPER(LTRIM(RTRIM(@Directives)));
		
		DECLARE @allDirectives table ( 
			row_id int NOT NULL, 
			directive sysname NOT NULL, 
			detail sysname NULL, 
			detail2 sysname NULL
		);

		INSERT INTO @allDirectives ([row_id], [directive])
		SELECT * FROM dbo.[split_string](@Directives, N',', 1);

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] LIKE N'%:%') BEGIN 
			UPDATE @allDirectives 
			SET 
				[directive] = SUBSTRING([directive], 0, CHARINDEX(N':', [directive])), 
				[detail] = SUBSTRING([directive], CHARINDEX(N':', [directive]) + 1, LEN([directive]))
			WHERE 
				[directive] LIKE N'%:%';
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [detail] LIKE N'%:%') BEGIN 
			UPDATE @allDirectives 
			SET 
				[detail] = SUBSTRING([detail], 0, CHARINDEX(N':', [detail])), 
				[detail2] = REPLACE(SUBSTRING([detail], CHARINDEX(N':', [detail]) + 1, LEN([detail])), N':', N'')			
			WHERE 
				[detail] LIKE N'%:%';
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] NOT IN (N'COPY_ONLY', N'FILE', N'FILEGROUP', N'MARKER', N'KEEP_ONLINE', N'TAIL_OF_LOG', N'FINAL')) BEGIN 
			RAISERROR(N'Invalid @Directives value specified. Permitted values are { FINAL | TAIL_OF_LOG | KEEP_ONLINE | COPY_ONLY | FILE:logical_name | FILEGROUP:group_name | MARKER:filename_tail_marker } only.', 16, 1);
			RETURN -20;
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives GROUP BY [directive] HAVING COUNT(*) > 1) BEGIN 
			RAISERROR(N'Duplicate Directives are NOT allowed within @Directives.', 16, 1);	
			RETURN -200;
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] = N'COPY_ONLY') BEGIN 
			IF UPPER(@BackupType) = N'DIFF' BEGIN
				-- NOTE: COPY_ONLY DIFF backups won't throw an error (in SQL Server) but they're logically 'wrong' - hence the S4 warning: https://learn.microsoft.com/en-us/sql/t-sql/statements/backup-transact-sql?view=sql-server-ver16
				RAISERROR(N'Invalid @Directives value specified. COPY_ONLY can NOT be specified when @BackupType = DIFF. Only FULL and LOG backups may be COPY_ONLY (and should be used only for one-off testing or other specialized needs.', 16, 1);
				RETURN -21;
			END; 

			SET @isCopyOnlyBackup = 1;
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE ([directive] = N'FILE') OR ([directive] = N'FILEGROUP')) BEGIN 
			SELECT 
				@fileOrFileGroupDirective = @fileOrFileGroupDirective + [directive] + N' = ''' + [detail] + N''', '
			FROM 
				@allDirectives
			WHERE 
				([directive] = N'FILE') OR ([directive] = N'FILEGROUP')
			ORDER BY 
				row_id;

			SET @fileOrFileGroupDirective = NCHAR(13) + NCHAR(10) + NCHAR(9) + LEFT(@fileOrFileGroupDirective, LEN(@fileOrFileGroupDirective) -1) + NCHAR(13) + NCHAR(10)+ NCHAR(9) + NCHAR(9);
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] = N'TAIL_OF_LOG') BEGIN 
			SELECT
				@setSingleUser = 1,
				@markerOverride = ISNULL([detail], N'tail_of_log'), 
				@setSingleUserRollbackSeconds = ISNULL([detail2], @setSingleUserRollbackSeconds)
			FROM 
				@allDirectives 
			WHERE 
				[directive] = N'TAIL_OF_LOG';
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] = N'FINAL') BEGIN 
			SELECT
				@setSingleUser = 1,
				@markerOverride = ISNULL([detail], N'tail_of_log'), 
				@setSingleUserRollbackSeconds = ISNULL([detail2], @setSingleUserRollbackSeconds)
			FROM 
				@allDirectives 
			WHERE 
				[directive] = N'FINAL';			
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] = N'KEEP_ONLINE') BEGIN 
			SET @keepOnline = 1;
		END;

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] = N'MARKER') BEGIN
			SELECT @markerOverride = [detail] FROM @allDirectives WHERE [directive] = N'MARKER';
		END;
	END;

	IF NULLIF(@OffSiteBackupPath, N'') IS NOT NULL BEGIN 
		IF @OffSiteBackupPath NOT LIKE 'S3::%' BEGIN 
			RAISERROR('S3 Backups are the only OffSite Backup Types currently supported. Please use the format S3::bucket-name:path\sub-path', 16, 1);
			RETURN -200;
		END;
	END;

	IF @AlwaysProcessRetention = 1 BEGIN 
		IF @AllowNonAccessibleSecondaries = 0 BEGIN 
			RAISERROR(N'@AlwaysProcessRetention can ONLY be set when @AllowNonAccessibleSecondaries = 1.', 16, 1);
			RETURN -19;
		END;
	END;

	-----------------------------------------------------------------------------
	DECLARE @excludeSimple bit = 0;

	IF UPPER(@BackupType) = N'LOG'
		SET @excludeSimple = 1;

	-- Determine which databases to backup:
	DECLARE @targetDatabases table (
        [entry_id] int IDENTITY(1,1) NOT NULL, 
        [database_name] sysname NOT NULL
    ); 

	INSERT INTO @targetDatabases ([database_name])
	EXEC dbo.list_databases
	    @Targets = @DatabasesToBackup,
	    @Exclusions = @DatabasesToExclude,
		@Priorities = @Priorities,
		-- NOTE: @ExcludeSecondaries, @ExcludeRecovering, @ExcludeRestoring, @ExcludeOffline ALL default to 1 - meaning that, for backups, we want the default (we CAN'T back those databases up no matter how much we want). (Well, except for secondaries...hmm).
		@ExcludeSimpleRecovery = @excludeSimple;

	-- verify that we've got something: 
	IF (SELECT COUNT(*) FROM @targetDatabases) <= 0 BEGIN
		IF @AllowNonAccessibleSecondaries = 1 BEGIN

			IF @AlwaysProcessRetention = 1 BEGIN 
				/* S4-529: In this case, we've got synchronized servers where we're NOT pushing backups to {PARTNER}... and want to force cleanup on secondary. */
				EXEC @return = [admindb].dbo.[remove_backup_files]
					@BackupType = @BackupType,
					@DatabasesToProcess = @DatabasesToBackup,
					@DatabasesToExclude = @DatabasesToExclude,
					@TargetDirectory = @BackupDirectory,
					@Retention = @BackupRetention,
					@ForceSecondaryCleanup = N'FORCE',
					@ServerNameInSystemBackupPath = NULL,
					@SendNotifications = 1,
					@OperatorName = @OperatorName,
					@MailProfileName = @MailProfileName,
					@EmailSubjectPrefix = @EmailSubjectPrefix,
					@PrintOnly = @PrintOnly;				
				
				RETURN @return;
			  END;
			ELSE BEGIN
				-- Because we're dealing with Synchronized DBs, we won't fail or throw an error here. Instead, we'll just report success (with no DBs to backup).
				PRINT 'No ONLINE databases available for backup. BACKUP terminating with success.';
				RETURN 0;
			END;
		   END; 
		ELSE BEGIN
			PRINT 'Usage: @DatabasesToBackup = {SYSTEM}|{USER}|dbname1,dbname2,dbname3,etc';
			RAISERROR('No databases specified for backup.', 16, 1);
			RETURN -20;
		END;
	END;

	IF @BackupDirectory = @CopyToBackupDirectory BEGIN
		RAISERROR('@BackupDirectory and @CopyToBackupDirectory can NOT be the same directory.', 16, 1);
		RETURN - 50;
	END;

	-- normalize paths: 
	SET @BackupDirectory = dbo.normalize_file_path(@BackupDirectory);
	SET @CopyToBackupDirectory = dbo.normalize_file_path(@CopyToBackupDirectory);
	SET @OffSiteBackupPath = dbo.normalize_file_path(@OffSiteBackupPath);

	IF NULLIF(@OffSiteBackupPath, N'') IS NOT NULL BEGIN 
		DECLARE @s3BucketName sysname; 
		DECLARE @s3KeyPath sysname;
		DECLARE @s3FullFileKey sysname;
		DECLARE @s3fullOffSitePath sysname;

		DECLARE @s3Parts table (row_id int NOT NULL, result nvarchar(MAX) NOT NULL);

		INSERT INTO @s3Parts (
			[row_id],
			[result]
		)
		SELECT [row_id], [result] FROM dbo.[split_string](REPLACE(@OffSiteBackupPath, N'S3::', N''), N':', 1)

		SELECT @s3BucketName = [result] FROM @s3Parts WHERE [row_id] = 1;
		SELECT @s3KeyPath = [result] FROM @s3Parts WHERE [row_id] = 2;
	END;

	----------------------------------------------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------
	-- meta-data:
	DECLARE @operationStart datetime;
	DECLARE @executionID uniqueidentifier = NEWID();
	
	DECLARE @currentBackupHistoryId int;
	DECLARE @executionDetails dbo.backup_history_entry;  /* TVP... */

	DECLARE @currentDatabase sysname;
	DECLARE @backupPath nvarchar(2000);
	DECLARE @copyToBackupPath nvarchar(2000);

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);

	DECLARE @serverName sysname;
	DECLARE @extension sysname;
	DECLARE @now datetime;
	DECLARE @timestamp sysname;
	DECLARE @offset sysname;
	DECLARE @backupName sysname;
	DECLARE @encryptionClause nvarchar(2000);

	DECLARE @ignoredResultTypes sysname;
	DECLARE @outcome xml;
	DECLARE @errorMessage nvarchar(MAX);

	DECLARE @copyStart datetime;
	DECLARE @copyDetails xml;
	DECLARE @offSiteCopyStart datetime;
	DECLARE @offSiteCopyDetails xml;

	DECLARE @cleanupErrorOccurred bit;

	DECLARE @command nvarchar(MAX);

	DECLARE backups CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name] 
	FROM 
		@targetDatabases
	ORDER BY 
		[entry_id];

	OPEN backups;

	FETCH NEXT FROM backups INTO @currentDatabase;
	WHILE @@FETCH_STATUS = 0 BEGIN
		
		DELETE @executionDetails;
		SET @outcome = NULL;
		SET @currentBackupHistoryId = NULL;
		SET @errorMessage = NULL; 

		-- TODO: Full details here: https://overachieverllc.atlassian.net/browse/S4-107
		-- start by making sure the current DB (which we grabbed during initialization) is STILL online/accessible (and hasn't failed over/etc.): 
		DECLARE @synchronized table ([database_name] sysname NOT NULL);
		INSERT INTO @synchronized ([database_name])
		SELECT [name] FROM sys.databases WHERE UPPER(state_desc) <> N'ONLINE';  -- mirrored dbs that have failed over and are now 'restoring'... 

		-- account for SQL Server 2008/2008 R2 (i.e., pre-HADR):
		IF (SELECT dbo.[get_engine_version]()) > 11.0 BEGIN
			INSERT INTO @synchronized ([database_name])
			EXEC sp_executesql N'SELECT d.[name] FROM sys.databases d INNER JOIN sys.dm_hadr_availability_replica_states hars ON d.replica_id = hars.replica_id WHERE hars.role_desc != ''PRIMARY'';'	
		END

		IF @currentDatabase IN (SELECT [database_name] FROM @synchronized) BEGIN
			PRINT 'Skipping database: ' + @currentDatabase + ' because it is no longer available, online, or accessible.';
			GOTO NextDatabase;  -- just 'continue' - i.e., short-circuit processing of this 'loop'... 
		END; 

		-- specify and verify path info:
		IF ((SELECT dbo.[is_system_database](@currentDatabase)) = 1) AND @AddServerNameToSystemBackupPath = 1
			SET @serverName = N'\' + REPLACE(@@SERVERNAME, N'\', N'_'); -- account for named instances. 
		ELSE 
			SET @serverName = N'';

		SET @backupPath = @BackupDirectory + N'\' + @currentDatabase + @serverName;
		SET @copyToBackupPath = REPLACE(@backupPath, @BackupDirectory, @CopyToBackupDirectory); 

		SET @operationStart = GETDATE();
		
		INSERT INTO @executionDetails (execution_id, backup_date, [database], backup_type, backup_path, copy_path, backup_start, [backup_succeeded])
		VALUES (@executionID, GETDATE(), @currentDatabase, @BackupType, @backupPath, @copyToBackupPath, @operationStart, 0);

		EXEC dbo.[log_backup_history_detail] 
			@LogSuccessfulOutcomes = @LogSuccessfulOutcomes, 
			@ExecutionDetails = @executionDetails, 
			@BackupHistoryId = @currentBackupHistoryId OUTPUT;  

		IF @RemoveFilesBeforeBackup = 1 BEGIN
			GOTO RemoveOlderFiles; 

DoneRemovingFilesBeforeBackup:
		END

		BEGIN TRY
            EXEC dbo.establish_directory
                @TargetDirectory = @backupPath, 
                @PrintOnly = @PrintOnly,
                @Error = @errorMessage OUTPUT;

			IF @errorMessage IS NOT NULL
				SET @errorMessage = N' Error verifying directory: [' + @backupPath + N']: ' + @errorMessage;

		END TRY
		BEGIN CATCH 
			SET @errorMessage = ISNULL(@errorMessage, '') + N'Exception attempting to validate file path for backup: [' + @backupPath + N']. Error: [' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE() + N']. Backup Filepath non-valid. Cannot continue with backup.';
		END CATCH;

		-- No directory = FATAL: log and GOTO NextDatabase... 
		IF @errorMessage IS NOT NULL BEGIN 
			UPDATE @executionDetails 
			SET 
				[error_details] = ISNULL([error_details], N'') + @errorMessage + N' '
			WHERE 
				[execution_id] = @executionID;			
			
			GOTO NextDatabase;
		END;

		-----------------------------------------------------------------------------
		-- Create/Execute Backup Command:

		-- Create a Backup Name: 
		SET @extension = N'.bak';
		IF @BackupType = N'LOG'
			SET @extension = N'.trn';

		SET @now = GETDATE();
		SET @timestamp = REPLACE(REPLACE(REPLACE(CONVERT(sysname, @now, 120), '-','_'), ':',''), ' ', '_');
		SET @offset = RIGHT(N'0000' + DATENAME(MILLISECOND, @now), 4) + RIGHT(CAST(CAST(RAND() AS decimal(12,11)) AS varchar(20)),3);
		IF NULLIF(@markerOverride, N'') IS NOT NULL
			SET @offset = @markerOverride;

		SET @backupName = @BackupType + N'_' + @currentDatabase + (CASE WHEN @fileOrFileGroupDirective = '' THEN N'' ELSE N'_PARTIAL' END) + '_backup_' + @timestamp + '_' + @offset + @extension;

		SET @command = N'';
		IF @setSingleUser = 1 BEGIN 
			SET @command = N'USE ' + QUOTENAME(@currentDatabase) + N';
ALTER DATABASE ' + QUOTENAME(@currentDatabase) + N' SET SINGLE_USER WITH ROLLBACK AFTER ' + CAST(@setSingleUserRollbackSeconds AS sysname) + N' SECONDS; ';
		END;

		SET @command = @command + N'BACKUP {type} ' + QUOTENAME(@currentDatabase) + N'{FILE|FILEGROUP} TO DISK = N''' + @backupPath + N'\' + @backupName + ''' 
	WITH 
		{COPY_ONLY}{COMPRESSION}{DIFFERENTIAL}{MAXTRANSFER}{ENCRYPTION}NAME = N''' + @backupName + ''', SKIP, REWIND, NOUNLOAD, CHECKSUM;
	
	';

		IF @BackupType IN (N'FULL', N'DIFF')
			SET @command = REPLACE(@command, N'{type}', N'DATABASE');
		ELSE 
			SET @command = REPLACE(@command, N'{type}', N'LOG');

		IF @Edition IN (N'EXPRESS',N'WEB',N'WORKGROUP') OR ((SELECT dbo.[get_engine_version]()) < 10.5 AND @Edition NOT IN ('ENTERPRISE'))
			SET @command = REPLACE(@command, N'{COMPRESSION}', N'');
		ELSE 
			SET @command = REPLACE(@command, N'{COMPRESSION}', N'COMPRESSION, ');

		IF @BackupType = N'DIFF'
			SET @command = REPLACE(@command, N'{DIFFERENTIAL}', N'DIFFERENTIAL, ');
		ELSE 
			SET @command = REPLACE(@command, N'{DIFFERENTIAL}', N'');

		IF @isCopyOnlyBackup = 1 
			SET @command = REPLACE(@command, N'{COPY_ONLY}', N'COPY_ONLY, ');
		ELSE 
			SET @command = REPLACE(@command, N'{COPY_ONLY}', N'');

		IF NULLIF(@EncryptionCertName, '') IS NOT NULL BEGIN
			SET @encryptionClause = ' ENCRYPTION (ALGORITHM = ' + ISNULL(@EncryptionAlgorithm, N'AES_256') + N', SERVER CERTIFICATE = ' + ISNULL(@EncryptionCertName, '') + N'), ';
			SET @command = REPLACE(@command, N'{ENCRYPTION}', @encryptionClause);
		  END;
		ELSE 
			SET @command = REPLACE(@command, N'{ENCRYPTION}','');

		-- account for 'partial' backups: 
		SET @command = REPLACE(@command, N'{FILE|FILEGROUP}', @fileOrFileGroupDirective);

		-- Account for TDE and 2016+ Compression: 
		IF EXISTS (SELECT NULL FROM sys.[dm_database_encryption_keys] WHERE [database_id] = DB_ID(@currentDatabase) AND [encryption_state] <> 0) BEGIN 

			IF (SELECT dbo.[get_engine_version]()) > 13.0
				SET @command = REPLACE(@command, N'{MAXTRANSFER}', N'MAXTRANSFERSIZE = 2097152, ');
			ELSE BEGIN 
				-- vNEXT / when adding processing-bus implementation and 'warnings' channel... output the following into WARNINGS: 
				PRINT 'Disabling Database Compression for database [' + @currentDatabase + N'] because TDE is enabled on pre-2016 SQL Server instance.';
				SET @command = REPLACE(@command, N'COMPRESSION, ', N'');
				SET @command = REPLACE(@command, N'{MAXTRANSFER}', N'');
			END;
		  END;
		ELSE BEGIN 
			SET @command = REPLACE(@command, N'{MAXTRANSFER}', N'');
		END;
		
		IF @setSingleUser = 1 BEGIN 
			IF @keepOnline = 1 BEGIN 
				PRINT '-- Directive ''KEEP_ONLINE'' was specified - NOT taking database ' + QUOTENAME(@currentDatabase) + N' offline.';
			  END; 
			ELSE BEGIN 
				SET @command = @command + N' ALTER DATABASE ' + QUOTENAME(@currentDatabase) + N' SET OFFLINE; ';
			END;
		END;

		BEGIN TRY 
			
			SET @errorMessage = NULL;
			SET @ignoredResultTypes = N'{BACKUP}';
			IF @setSingleUser = 1 SET @ignoredResultTypes = @ignoredResultTypes + N',{SINGLE_USER}';
			IF @keepOnline = 0 SET @ignoredResultTypes = @ignoredResultTypes + N',{OFFLINE}'

			EXEC dbo.[execute_command]
				@Command = @command,
				@ExecutionType = N'SQLCMD',
				@ExecutionAttemptsCount = 1,
				@IgnoredResults = @ignoredResultTypes,
				@PrintOnly = @PrintOnly,
				@Outcome = @outcome OUTPUT,
				@ErrorMessage = @errorMessage OUTPUT;
			
			IF @errorMessage IS NOT NULL 
				SET @errorMessage = N'Error with BACKUP command: ' + @errorMessage;

		END TRY 
		BEGIN CATCH 
			SET @errorMessage = N'Exception executing backup with the following command: [' + @command + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
		END CATCH;

		UPDATE @executionDetails 
		SET 
			backup_end = GETDATE(),
			backup_succeeded = CASE WHEN @errorMessage IS NULL THEN 1 ELSE 0 END, 
			verification_start = CASE WHEN @errorMessage IS NULL THEN GETDATE() ELSE NULL END, 
			[error_details] = ISNULL([error_details], N'') + @errorMessage + N' '
		WHERE 
			[execution_id] = @executionID;

		EXEC dbo.[log_backup_history_detail] 
			@LogSuccessfulOutcomes = @LogSuccessfulOutcomes, 
			@ExecutionDetails = @executionDetails, 
			@BackupHistoryId = @currentBackupHistoryId OUTPUT;  

		-- Backup failed, FATAL - already logged, so Goto NextDatabase.
		IF @errorMessage IS NOT NULL
			GOTO NextDatabase;

		-----------------------------------------------------------------------------
		-- Kick off the verification:
		SET @errorMessage = NULL;
		SET @command = N'RESTORE VERIFYONLY FROM DISK = N''' + @backupPath + N'\' + @backupName + N''' WITH NOUNLOAD, NOREWIND;';

		IF @PrintOnly = 1 
			PRINT @command;
		ELSE BEGIN
			BEGIN TRY
				EXEC sys.sp_executesql @command;
			END TRY
			BEGIN CATCH
				SET @errorMessage = N'Exception during backup verification for backup of database: [' + @currentDatabase + ']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
			END CATCH;
		END;

		UPDATE @executionDetails
		SET 
			verification_end = GETDATE(),
			verification_succeeded = CASE WHEN @errorMessage IS NULL THEN 1 ELSE 0 END,
			[error_details] = ISNULL([error_details], N'') + @errorMessage + N' '
		WHERE
			[execution_id] = @executionID;

		EXEC dbo.[log_backup_history_detail] 
			@LogSuccessfulOutcomes = @LogSuccessfulOutcomes, 
			@ExecutionDetails = @executionDetails, 
			@BackupHistoryId = @currentBackupHistoryId OUTPUT;  

		-- Fatal. Logged... so go next... 
		IF @errorMessage IS NOT NULL 
			GOTO NextDatabase;

		-----------------------------------------------------------------------------
		-- Now that the backup (and, optionally/ideally) verification are done, copy the file to a secondary location if specified:
		SET @errorMessage = NULL;
		SET @copyDetails = NULL;
		IF NULLIF(@CopyToBackupDirectory, N'') IS NOT NULL BEGIN
			
			SET @copyStart = GETDATE();

            BEGIN TRY 
                EXEC dbo.establish_directory
                    @TargetDirectory = @copyToBackupPath, 
                    @PrintOnly = @PrintOnly,
                    @Error = @errorMessage OUTPUT;                

                IF @errorMessage IS NOT NULL
				    SET @errorMessage = N'Error verifying COPY_TO directory: [' + @copyToBackupPath + N']: ' + @errorMessage;  

            END TRY
            BEGIN CATCH 
                SET @errorMessage = N'Exception attempting to validate COPY_TO file path for backup: [' + @copyToBackupPath + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
            END CATCH

			IF @errorMessage IS NULL BEGIN
				
				SET @command = N'XCOPY "' + @backupPath + N'\' + @backupName + N'" "' + @copyToBackupPath + N'\" /q';  -- XCOPY supported on Windows 2003+; robocopy is supported on Windows 2008+

				BEGIN TRY 
					EXEC dbo.[execute_command]
						@Command = @command,
						@ExecutionType = N'SHELL',
						@ExecutionAttemptsCount = 2,
						@DelayBetweenAttempts = N'5 seconds',
						@IgnoredResults = N'{COPYFILE}',
						@PrintOnly = @PrintOnly,
						@Outcome = @outcome OUTPUT,
						@ErrorMessage = @errorMessage OUTPUT; 

					IF @errorMessage IS NOT NULL OR dbo.[transient_error_occurred](@outcome) = 1 
						SET @copyDetails = @outcome;

				END TRY 
				BEGIN CATCH 
					SET @errorMessage = N'Exception copying backup to [' + @copyToBackupPath + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
				END CATCH;
		    END;

			UPDATE @executionDetails
			SET 
				copy_succeeded = CASE WHEN @errorMessage IS NULL THEN 1 ELSE 0 END, 
				copy_seconds = DATEDIFF(SECOND, @copyStart, GETDATE()), 
				failed_copy_attempts = (SELECT @outcome.value(N'count(/iterations/iteration)', N'int')) - 1, 
				copy_details = CAST(@copyDetails AS nvarchar(MAX)), 
				[error_details] = ISNULL([error_details], N'') + @errorMessage + N' '
			WHERE 
				[execution_id] = @executionID;

			EXEC dbo.[log_backup_history_detail] 
				@LogSuccessfulOutcomes = @LogSuccessfulOutcomes, 
				@ExecutionDetails = @executionDetails, 
				@BackupHistoryId = @currentBackupHistoryId OUTPUT;  
			
			-- NON-FATAL... (if there were errors)

		END;

		-----------------------------------------------------------------------------
		-- Process @OffSite backups as necessary: 
		SET @errorMessage = NULL;
		SET @offSiteCopyDetails = NULL;
		SET @outcome = NULL;
		IF NULLIF(@OffSiteBackupPath, N'') IS NOT NULL BEGIN 
			
			SET @offSiteCopyStart = GETDATE();

			DECLARE @offsiteCopy table ([row_id] int IDENTITY(1, 1) NOT NULL, [output] nvarchar(2000));
			DELETE FROM @offsiteCopy;

			SET @s3FullFileKey = @s3KeyPath + '\' + @currentDatabase + @serverName + N'\' + @backupName;
			SET @s3fullOffSitePath = N'S3::' + @s3BucketName + N':' + @s3FullFileKey;

			SET @command = N'Write-S3Object -BucketName ''' + @s3BucketName + N''' -Key ''' + @s3FullFileKey + N''' -File ''' + @backupPath + N'\' + @backupName + N''' -ConcurrentServiceRequest 2';

			BEGIN TRY 
				EXEC dbo.[execute_command]
					@Command = @command,
					@ExecutionType = N'POSH',
					@ExecutionAttemptsCount = 3,
					@DelayBetweenAttempts = N'3 seconds',
					@IgnoredResults = N'{S3COPYFILE}',
					@PrintOnly = @PrintOnly,
					@Outcome = @outcome OUTPUT,
					@ErrorMessage = @errorMessage OUTPUT

			END TRY 
			BEGIN CATCH
				SET @errorMessage = N'Exception copying backup to OffSite Location [' + @s3fullOffSitePath + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
			END CATCH;

			IF @errorMessage IS NOT NULL OR dbo.[transient_error_occurred](@outcome) = 1 BEGIN
				SET @offSiteCopyDetails = @outcome;
			END;

			UPDATE @executionDetails
			SET 
				offsite_path = @s3fullOffSitePath,
				offsite_succeeded = CASE WHEN @errorMessage IS NULL THEN 1 ELSE 0 END,
				offsite_seconds = DATEDIFF(SECOND, @offSiteCopyStart, GETDATE()), 
				failed_offsite_attempts = ((SELECT @outcome.value(N'count(/iterations/iteration)', N'int')) - (CASE WHEN @errorMessage IS NULL THEN 0 ELSE 1 END)), 
				offsite_details = CAST(@offSiteCopyDetails AS nvarchar(MAX)), 
				[error_details] = ISNULL([error_details], N'') + @errorMessage + N' '
			WHERE
				[execution_id] = @executionID;

			EXEC dbo.[log_backup_history_detail] 
				@LogSuccessfulOutcomes = @LogSuccessfulOutcomes, 
				@ExecutionDetails = @executionDetails, 
				@BackupHistoryId = @currentBackupHistoryId OUTPUT;  

			-- NON-FATAL... (if there were errors)

		END;

		-----------------------------------------------------------------------------
		-- Remove backups:
		IF @RemoveFilesBeforeBackup = 0 BEGIN;
RemoveOlderFiles:
			SET @cleanupErrorOccurred = 0;
			SET @errorMessage = NULL;
			BEGIN TRY
				
				EXEC dbo.remove_backup_files
                    @BackupType = @BackupType,
                    @DatabasesToProcess = @currentDatabase,
                    @TargetDirectory = @BackupDirectory,
                    @Retention = @BackupRetention, 
					@ServerNameInSystemBackupPath = @AddServerNameToSystemBackupPath,
					@OperatorName = @OperatorName,
					@MailProfileName  = @DatabaseMailProfile,
					@Output = @errorMessage OUTPUT, 
					@PrintOnly = @PrintOnly;

			END TRY 
			BEGIN CATCH 
				SET @errorMessage = ISNULL(@errorMessage, '') + 'Exception removing backups. Error: ' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
			END CATCH;

			IF @errorMessage IS NOT NULL BEGIN
				UPDATE @executionDetails SET [error_details] = ISNULL([error_details], N'') + @errorMessage + N' ' WHERE [execution_id] = @executionID;
				SET @cleanupErrorOccurred = 1;
			END;
			
			IF NULLIF(@CopyToBackupDirectory,'') IS NOT NULL BEGIN;
				SET @errorMessage = NULL;

				BEGIN TRY 
					EXEC dbo.remove_backup_files
						@BackupType= @BackupType,
						@DatabasesToProcess = @currentDatabase,
						@TargetDirectory = @CopyToBackupDirectory,
						@Retention = @CopyToRetention, 
						@ServerNameInSystemBackupPath = @AddServerNameToSystemBackupPath,
						@OperatorName = @OperatorName,
						@MailProfileName  = @DatabaseMailProfile,
						@Output = @errorMessage OUTPUT, 
						@PrintOnly = @PrintOnly;

				END TRY 
				BEGIN CATCH 
					SET @errorMessage = ISNULL(@errorMessage, '') + 'Exception removing COPY_TO backups. Error: ' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
				END CATCH;
				
				IF @errorMessage IS NOT NULL BEGIN
					UPDATE @executionDetails SET [error_details] = ISNULL([error_details], N'') + @errorMessage + N' ' WHERE [execution_id] = @executionID;
					SET @cleanupErrorOccurred = 1;
				END;
					
			END;

			IF NULLIF(@OffSiteBackupPath, N'') IS NOT NULL BEGIN 
				SET @errorMessage = NULL;
		
				BEGIN TRY 
					EXEC dbo.[remove_offsite_backup_files]
						@BackupType = @BackupType,
						@DatabasesToProcess = @currentDatabase,
						@OffSiteBackupPath = @OffSiteBackupPath,
						@OffSiteRetention = @OffSiteRetention,
						@ServerNameInSystemBackupPath = @AddServerNameToSystemBackupPath,
						@OperatorName = @OperatorName,
						@MailProfileName = @DatabaseMailProfile,
						@Output = @errorMessage OUTPUT, 
						@PrintOnly = @PrintOnly;

				END TRY 
				BEGIN CATCH 
					SET @errorMessage = ISNULL(@errorMessage, '') + 'Exception removing OFFSITE backups. Error: ' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
				END CATCH;

				IF @errorMessage IS NOT NULL BEGIN
					UPDATE @executionDetails SET [error_details] = ISNULL([error_details], N'') + @errorMessage + N' ' WHERE [execution_id] = @executionID;
					SET @cleanupErrorOccurred = 1;
				END;

			END;

			IF @RemoveFilesBeforeBackup = 1 BEGIN;
				IF @cleanupErrorOccurred = 0 -- there weren't any problems/issues - so keep processing.
					GOTO DoneRemovingFilesBeforeBackup;

				-- otherwise, the remove operations failed, they were set to run FIRST, which means we now might not have enough disk - so we need to 'fail' this operation and move on to the next db... 
				GOTO NextDatabase;
			END
		END

NextDatabase:
		EXEC dbo.[log_backup_history_detail] 
			@LogSuccessfulOutcomes = @LogSuccessfulOutcomes, 
			@ExecutionDetails = @executionDetails, 
			@BackupHistoryId = @currentBackupHistoryId OUTPUT;  

		PRINT '
';

		IF (SELECT CURSOR_STATUS('local','nuker')) > -1 BEGIN;
			CLOSE nuker;
			DEALLOCATE nuker;
		END;

		FETCH NEXT FROM backups INTO @currentDatabase;
	END;

	CLOSE backups;
	DEALLOCATE backups;

	----------------------------------------------------------------------------------------------------------------------------------------------------------
	-----------------------------------------------------------------------------
	-- Cleanup:

	-- close/deallocate any cursors left open:
	IF (SELECT CURSOR_STATUS('local','backups')) > -1 BEGIN;
		CLOSE backups;
		DEALLOCATE backups;
	END;

	-- MKC:
--			need to add some additional logic/processing here. 
--			a) look for failed copy operations up to X hours ago? 
--		    b) try to re-run them - via dba_sync... or ... via 'raw' roboopy? hmmm. 
--			c) mark any that succeed as done... success. 
--			d) up-tick any that still failed. 
--			e) for any that exceed @maxCopyToRetries - create an error and log it against all previous rows/databases that have failed? hmmm. Yeah... if we've been failing for, say, 45 minutes and sending 'warnings'... then we want to 
--				'call it' for all of the ones that have failed up to this point... and flag them as 'errored out' (might require a new column in the table). OR... maybe it works by me putting something like the following into error details
--				(for ALL rows that have failed up to this point - i.e., previous attempts + the current attempt/iteration):
--				"Attempts to copy backups from @sourcePath to @copyToPath consistently failed from @backupEndTime to @now (duration?) over @MaxSomethingAttempts. No longer attempting to synchronize files - meaning that backups are in jeopardy. Please
--					fix @CopyToPath and, when complete, run dba_syncDbs with such and such arguments? to ensure dbs copied on to secondary...."
--			   because, if that happens... then... the 'history' for backups will show errors (whereas they didn't show/report errors previously - so that covers 'history' - with a summary of when we 'called it'... 
--				and, this covers... the current rows as well. i.e., they'll have errors... which will then get picked up by the logic below. 
--			f) for any true 'errors', those get picked up below. 
--			g) for any non-errors - but failures to copy, there needs to be a 'warning' email sent - with a summary (list) of each db that hasn't copied - current number of attempts, how long it's been, etc. 

	DECLARE @emailErrorMessage nvarchar(MAX);

	IF EXISTS (SELECT NULL FROM dbo.backup_log WHERE execution_id = @executionID AND error_details IS NOT NULL) BEGIN;
		SET @emailErrorMessage = N'BACKUP TYPE: ' + @BackupType + @crlf
			+ N'TARGETS: ' + @DatabasesToBackup + @crlf
			+ @crlf 
			+ N'The following errors were encountered: ' + @crlf;

		SELECT @emailErrorMessage = @emailErrorMessage + @tab + N'- Target Database: [' + [database] + N']. Error: ' + error_details + @crlf + @crlf
		FROM 
			dbo.backup_log
		WHERE 
			execution_id = @executionID
			AND error_details IS NOT NULL 
		ORDER BY 
			backup_id;

	END;

	DECLARE @emailSubject nvarchar(2000);
	IF @emailErrorMessage IS NOT NULL BEGIN;
		
		IF RIGHT(@EmailSubjectPrefix, 1) <> N' ' SET @EmailSubjectPrefix = @EmailSubjectPrefix + N' ';
		SET @emailSubject = @EmailSubjectPrefix + N'- ' + @BackupType + N' - ERROR';
		SET @emailErrorMessage = @emailErrorMessage + @crlf + @crlf + N'Execute [ SELECT * FROM [admindb].dbo.backup_log WHERE execution_id = ''' + CAST(@executionID AS nvarchar(36)) + N'''; ] for details.';

		IF @PrintOnly = 1 BEGIN 
			PRINT @emailSubject;
			PRINT @emailErrorMessage;
		  END;
		ELSE BEGIN 

			IF UPPER(@Edition) <> N'EXPRESS' BEGIN;
				EXEC msdb..sp_notify_operator
					@profile_name = @MailProfileName,
					@name = @OperatorName,
					@subject = @emailSubject, 
					@body = @emailErrorMessage;
			END;

		END;
	END;

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
-- Configuration:
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.update_server_name','P') IS NOT NULL
	DROP PROC dbo.[update_server_name];
GO

CREATE PROC dbo.[update_server_name]
	@PrintOnly			bit				= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @currentHostNameInWindows sysname;
	DECLARE @serverNameFromSysServers sysname; 

	SELECT
		@currentHostNameInWindows = CAST(SERVERPROPERTY('ComputerNamePhysicalNetBIOS') AS sysname),
		@serverNameFromSysServers = @@SERVERNAME;

	IF UPPER(@currentHostNameInWindows) <> UPPER(@serverNameFromSysServers) BEGIN
		DECLARE @oldServerName sysname = @serverNameFromSysServers;
		DECLARE @newServerName sysname = @currentHostNameInWindows;

		PRINT N'BIOS/Windows HostName: ' + @newServerName + N' does not match name defined within SQL Server: ' + @oldServerName + N'.';
		

		IF @PrintOnly = 0 BEGIN 

			PRINT N'Initiating update to SQL Server definitions.';
			
			EXEC sp_dropserver @oldServerName;
			EXEC sp_addserver @newServerName, local;

			PRINT N'SQL Server Server-Name set to ' + @newServerName + N'.';

			PRINT 'Please RESTART SQL Server to ensure that this change has FULLY taken effect.';

		END;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.force_removal_of_tempdb_file','P') IS NOT NULL
	DROP PROC dbo.[force_removal_of_tempdb_file];
GO

CREATE PROC dbo.[force_removal_of_tempdb_file]
	@FileName			sysname			= NULL, 
	@Force				sysname			= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @FileName = NULLIF(@FileName, N'');
	SET @Force = NULLIF(@Force, N'');

	IF @FileName IS NULL BEGIN 
		RAISERROR('Please specify the logical file name of a file for @FileName to continue.', 16, 1);
		RETURN -1;
	END;
	
	IF @Force IS NULL OR @Force <> N'FORCE' BEGIN 
		RAISERROR('Forcibly removing a data-file from the tempdb REQUIRES dropping plans and buffers from the cache. @Force MUST be set to ''FORCE'' before this script will run.', 16, 1);
		RETURN -2;
	END;
	
	IF NOT EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE name = @FileName) BEGIN 
		RAISERROR('A tempdb file matching the name ''%s'' was not found. Please check the input of @FileName and try again.', 16, 1, @FileName);
		RETURN -5;
	END;

	DECLARE @command nvarchar(MAX); 
	SET @command = N'ALTER DATABASE [tempdb] REMOVE FILE [' + @FileName + N']; ';

	BEGIN TRY 
		EXEC sp_executesql @command;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH

	IF NOT EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE name = @FileName)
		GOTO Done;

	SET @command = N'USE [tempdb]; DBCC SHRINKFILE(''' + @FileName + N''', EMPTYFILE) WITH NO_INFOMSGS;';

	BEGIN TRY 
		EXEC sp_executesql @command;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH

	SET @command = N'ALTER DATABASE [tempdb] REMOVE FILE [' + @FileName + N']; ';

	BEGIN TRY 
		EXEC sp_executesql @command;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH

	IF NOT EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE name = @FileName)
		GOTO Done;	

	-- If we're still here: 
	SET @command = N'DBCC FREESYSTEMCACHE (''ALL'');
	DBCC FREESESSIONCACHE();
	DBCC DROPCLEANBUFFERS();
	DBCC FREEPROCCACHE();';

	BEGIN TRY 
		EXEC sp_executesql @command;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH

	SET @command = N'ALTER DATABASE [tempdb] REMOVE FILE [' + @FileName + N']; ';

	BEGIN TRY 
		EXEC sp_executesql @command;
	END TRY
	BEGIN CATCH
		PRINT ''
	END CATCH

	IF NOT EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE name = @FileName)
		GOTO Done;	

	PRINT 'Unable to remove file. Recommend WAITING for 60 - 80 seconds, then a restart of SQL Server Service if needed.';
	RETURN -100;
	
Done: 
	PRINT 'File Removed';
	
	RETURN 0; 
GO

--	DECLARE @output xml;
--	DECLARE @command nvarchar(MAX); 
--	DECLARE @removeCommand nvarchar(MAX);

--	SET @removeCommand = N'ALTER DATABASE [tempdb] REMOVE FILE [' + @FileName + N']; ';
--	SET @command = @removeCommand;

--	EXEC dbo.[execute_command]
--		@Command = @command,
--		@ExecutionType = N'SQLCMD',
--		@ExecutionAttemptsCount = 1,
--		@DelayBetweenAttempts = 0,
--		@IgnoredResults = N'',
--		@Results = @output OUTPUT;

--	IF NOT EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE name = @FileName)
--		GOTO Done;
		
--	SET @command = N'USE [tempdb]; DBCC SHRINKFILE(''' + @FileName + N''', EMPTYFILE);';

--	EXEC dbo.[execute_command]
--		@Command = @command,
--		@ExecutionType = N'SQLCMD',
--		@ExecutionAttemptsCount = 1,
--		@DelayBetweenAttempts = 0,
--		@IgnoredResults = N'',
--		@Results = @output OUTPUT;

--	-- we WILL get results via the above... so just attempt to drop the file again: 
--	SET @command = @removeCommand
--	EXEC dbo.[execute_command]
--		@Command = @command,
--		@ExecutionType = N'SQLCMD',
--		@ExecutionAttemptsCount = 1,
--		@DelayBetweenAttempts = 0,
--		@IgnoredResults = N'',
--		@Results = @output OUTPUT;

--	IF NOT EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE name = @FileName)
--		GOTO Done;

--	-- if we're still here: 

--	SET @command = N'DBCC FREESYSTEMCACHE (''ALL'');
--DBCC FREESESSIONCACHE();
--DBCC DROPCLEANBUFFERS();
--DBCC FREEPROCCACHE();'; 

--	EXEC dbo.[execute_command]
--		@Command = @command,
--		@ExecutionType = N'SQLCMD',
--		@ExecutionAttemptsCount = 1,
--		@DelayBetweenAttempts = 0,
--		@IgnoredResults = N'',
--		@Results = @output OUTPUT;

--	-- again, we WILL get output from the above... so just re-attempt to remove the file: 
--	SET @command = @removeCommand
--	EXEC dbo.[execute_command]
--		@Command = @command,
--		@ExecutionType = N'SQLCMD',
--		@ExecutionAttemptsCount = 1,
--		@DelayBetweenAttempts = 0,
--		@IgnoredResults = N'',
--		@Results = @output OUTPUT;

--	IF NOT EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE name = @FileName)
--		GOTO Done;

--	-- If we're still here: 
--	PRINT N'ERROR: '; 
--	PRINT CAST(@output AS nvarchar(MAX)); 

--	RETURN -100;

--Done: 
--	PRINT 'File Removed';
	
	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.configure_tempdb_files','P') IS NOT NULL
	DROP PROC dbo.[configure_tempdb_files];
GO

CREATE PROC dbo.[configure_tempdb_files]
	@TargetDataFileCount				int				= NULL, 
	@TargetDataFilePath					sysname			= NULL, 
	@TargetLogFilePath					sysname			= NULL, 
	-- vNEXT:
	--@DataFileStartSizeInMBs			int			= NULL, 
	--@DataFileGrowthSizeInMBs			int				= NULL,
	--@LogFileStartSizeInMBs			int			= NULL, 
	--@LogFileGrowthSizeInMBs			int			= NULL, 
	@PrintOnly							bit				= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	-- TODO: Validate inputs
	SET @TargetDataFilePath	= NULLIF(@TargetDataFilePath, N'');
	SET @TargetLogFilePath	= NULLIF(@TargetLogFilePath, N'');

	-- Normalize Paths: 
	IF @TargetDataFilePath IS NOT NULL AND @TargetDataFilePath NOT LIKE N'%\' SET @TargetDataFilePath = @TargetDataFilePath + N'\';
	IF @TargetLogFilePath IS NOT NULL AND @TargetLogFilePath NOT LIKE N'%\' SET @TargetLogFilePath = @TargetLogFilePath + N'\';

	DECLARE @currentDataFilesCount int; 
	SELECT @currentDataFilesCount = COUNT(*) FROM [tempdb].sys.[database_files] WHERE [type] = 0;

	--DECLARE @removeTemplate nvarchar(MAX) = N'ALTER DATABASE [tempdb] REMOVE FILE [{name}]; ';
	DECLARE @removeTemplate nvarchar(MAX) = N'EXEC admindb.dbo.force_removal_of_tempdb_file @FileName = N''{name}'', @Force = N''FORCE''; ';
	DECLARE @addTemplate nvarchar(MAX) = N'ALTER DATABASE [tempdb] ADD FILE (NAME = ''{name}'', FILENAME = ''{fileName}'', SIZE = {size}, MAXSIZE = {maxSize}, FILEGROWTH = {growth}); ';
	DECLARE @modifyTemplate nvarchar(MAX) = N'ALTER DATABASE [tempdb] MODIFY FILE (NAME = ''{name}'', FILENAME = ''{path}{name}.ndf''); ';
	DECLARE @modifyLogTemplate nvarchar(MAX) = N'ALTER DATABASE [tempdb] MODIFY FILE (NAME =''{name}'', FILENAME = ''{fileName}''); ';

	DECLARE @command nvarchar(MAX);
	DECLARE @currentFileName sysname;
	DECLARE @currentFilePhysicalName nvarchar(260);

	DECLARE @oldPathName nvarchar(260);
	DECLARE @newPathName nvarchar(260);

	DECLARE @commands table (
		command_id int IDENTITY(1, 1) NOT NULL, 
		command nvarchar(MAX) NOT NULL 
	);

	-- Modify existing files if needed: 
	IF @TargetDataFilePath IS NOT NULL BEGIN 
		IF EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE [type] = 0 AND [physical_name] NOT LIKE @TargetDataFilePath + N'%') BEGIN
			
			SET @modifyTemplate = REPLACE(@modifyTemplate, N'{path}', @TargetDataFilePath);

			INSERT INTO  @commands (
				[command]
			)
			SELECT 
				REPLACE(@modifyTemplate, N'{name}', [name])
			FROM 
				[tempdb].sys.[database_files] 
			WHERE 
				[type] = 0 
				AND [physical_name] NOT LIKE @TargetDataFilePath + N'%' 
			ORDER BY 
				[file_id];

		END;
	END;

	-- account for removing files (if target count is < current file count):
	IF @currentDataFilesCount > @TargetDataFileCount BEGIN
		
		DECLARE @currentRemovedFileID int;
		DECLARE @currentRemovedFile sysname;

		DECLARE remover CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[x].[data_file_id], 
			[x].[name]
		FROM (
			SELECT 
				ROW_NUMBER() OVER (ORDER BY file_id) [data_file_id], 
				[name] 
			FROM 
				tempdb.sys.[database_files] 
			WHERE 
				[type] = 0
			) x 
		WHERE 
			[x].[data_file_id] > @TargetDataFileCount
		ORDER BY 
			[x].[data_file_id];
		
		
		OPEN remover;
		FETCH NEXT FROM remover INTO @currentRemovedFileID, @currentRemovedFile;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			SET @command = REPLACE(@removeTemplate, N'{name}', @currentRemovedFile);

			INSERT INTO @commands (command) VALUES (@command);
		
			FETCH NEXT FROM remover INTO @currentRemovedFileID, @currentRemovedFile;
		END;
		
		CLOSE remover;
		DEALLOCATE remover;

	END;

	-- add additional data files (if desired file count > current count):
	IF @TargetDataFileCount > @currentDataFilesCount BEGIN 
		DECLARE @fileNamePattern sysname;  

		SELECT @fileNamePattern = [name] FROM [tempdb].sys.[database_files] WHERE [file_id] = 3;

		-- simplified implementation for now: 
		IF @fileNamePattern IS NOT NULL BEGIN
			IF RIGHT(@fileNamePattern, 1) = N'2' BEGIN
				SET @fileNamePattern = REPLACE(@fileNamePattern, N'2', N'');
			END;
		END;

		IF @fileNamePattern IS NULL 
			SET @fileNamePattern = N'tempdev'; 

		IF @TargetDataFilePath IS NULL BEGIN 
			SELECT 
				@currentFilePhysicalName = [physical_name]
			FROM 
				[tempdb].sys.[database_files] 
			WHERE 
				file_id = 1;

			SET @TargetDataFilePath = LEFT(@currentFilePhysicalName, 1 + LEN(@currentFilePhysicalName) - CHARINDEX(N'\', REVERSE(@currentFilePhysicalName)));
		END;

-- until vNEXT: 
DECLARE @size sysname; 
DECLARE @maxSize sysname; 
DECLARE @growth sysname;

SELECT
	@size = CAST(([size] * 8) AS sysname) + N'KB', 
	@maxSize = CASE WHEN [max_size] = -1 THEN N'UNLIMITED' WHEN [max_size] = 0 THEN N'0' ELSE CAST(([max_size] * 8) AS sysname) + N'KB' END,
	@growth = CASE WHEN [growth] = 0 THEN N'0' ELSE CAST(([growth] * 8) AS sysname) + N'KB' END
FROM 
	[tempdb].sys.[database_files] 
WHERE 
	[file_id] = 1;

		DECLARE @currentFileCount int = @currentDataFilesCount;

		WHILE @currentFileCount < @TargetDataFileCount BEGIN 

			SET @command = REPLACE(@addTemplate, N'{name}', @fileNamePattern + CAST(@currentFileCount + 1 AS sysname));
			SET @command = REPLACE(@command, N'{fileName}', @TargetDataFilePath + @fileNamePattern + CAST(@currentFileCount + 1 AS sysname) + N'.ndf');

			SET @command = REPLACE(@command, N'{size}', @size);
			SET @command = REPLACE(@command, N'{maxSize}', @maxSize);
			SET @command = REPLACE(@command, N'{growth}', @growth);

			INSERT INTO @commands (command) VALUES (@command);

			SET @currentFileCount = @currentFileCount + 1;
		END;
	END;

	-- move the tempdb log if needed:
	IF @TargetLogFilePath IS NOT NULL BEGIN 
		IF EXISTS (SELECT NULL FROM [tempdb].sys.[database_files] WHERE [type] = 1 AND [physical_name] NOT LIKE @TargetLogFilePath + N'%') BEGIN
			SELECT 
				@currentFileName = [name], 
				@currentFilePhysicalName = [physical_name]
			FROM 
				[tempdb].sys.[database_files] 
			WHERE 
				file_id = 2;

			SET @oldPathName = LEFT(@currentFilePhysicalName, 1 + LEN(@currentFilePhysicalName) - CHARINDEX(N'\', REVERSE(@currentFilePhysicalName)));
			SET @newPathName = REPLACE(@currentFilePhysicalName, @oldPathName, @TargetLogFilePath);

			SET @command = REPLACE(@modifyLogTemplate, N'{name}', @currentFileName);
			SET @command = REPLACE(@command, N'{fileName}', @newPathName);

			INSERT INTO @commands (command) VALUES (@command);
		END;
	END;
	
	-- Process/Finalize:
	DECLARE runner CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		command 
	FROM 
		@commands 
	ORDER BY 
		command_id;
		
	OPEN runner;
	FETCH NEXT FROM runner INTO @command;
		
	WHILE @@FETCH_STATUS = 0 BEGIN
		
		IF @PrintOnly = 1 BEGIN
			PRINT @command;
			PRINT N'GO'
			PRINT N'';
		  END; 
		ELSE BEGIN 
			EXEC sp_executesql @command;
		END;
		
		FETCH NEXT FROM runner INTO @command;
	END;
		
	CLOSE runner;
	DEALLOCATE runner;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_server_configuration','P') IS NOT NULL
	DROP PROC dbo.script_server_configuration;
GO

CREATE PROC dbo.script_server_configuration 

AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- meta / formatting: 
	DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
	DECLARE @tab char(1) = CHAR(9);

	DECLARE @sectionMarker nvarchar(2000) = N'--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'
	
	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Hardware: 
	PRINT @sectionMarker;
	PRINT N'-- Hardware'
	PRINT @sectionMarker;	

	DECLARE @output nvarchar(MAX) = @crlf + @tab;
	SET @output = @output + N'-- Processors' + @crlf; 

	SELECT @output = @output
		+ @tab + @tab + N'PhysicalCpuCount: ' + CAST(cpu_count/hyperthread_ratio AS sysname) + @crlf
		+ @tab + @tab + N'HyperthreadRatio: ' + CAST([hyperthread_ratio] AS sysname) + @crlf
		+ @tab + @tab + N'LogicalCpuCount: ' + CAST(cpu_count AS sysname) + @crlf
	FROM 
		sys.dm_os_sys_info;

	DECLARE @cpuFamily sysname; 
	EXEC sys.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'HARDWARE\DESCRIPTION\System\CentralProcessor\0', N'ProcessorNameString', @cpuFamily OUT;

	SET @output = @output + @tab + @tab + N'ProcessorFamily: ' + @cpuFamily + @crlf;
	PRINT @output;

	DECLARE @physicalMemorySize bigint;
	DECLARE @memoryLookupCommand nvarchar(2000) = N'SELECT @physicalMemorySize = physical_memory_kb/1024 FROM sys.[dm_os_sys_info];';
	IF (SELECT dbo.[get_engine_version]()) < 11  -- account for change to sys.dm_os_sys_info between SQL Server 2008R2 and 2012 ... 
		SET @memoryLookupCommand = N'SELECT @physicalMemorySize = physical_memory_in_bytes/1024/1024 FROM sys.[dm_os_sys_info];';

	EXEC sys.[sp_executesql]
		@memoryLookupCommand, 
		N'@physicalMemorySize bigint OUTPUT', 
		@physicalMemorySize = @physicalMemorySize OUTPUT;

	SET @output = @crlf + @tab + N'-- Memory' + @crlf;
	SELECT @output = @output + @tab + @tab + N'PhysicalMemoryOnServer: ' + CAST(@physicalMemorySize AS sysname) + N'MB ' + @crlf FROM sys.[dm_os_sys_info];
	SET @output = @output + @tab + @tab + N'MemoryNodes: ' + @crlf;

	SELECT @output = @output 
		+ @tab + @tab + @tab + N'NODE_ID: ' + CAST(node_id AS sysname) + N' - ' + node_state_desc + N' (OnlineSchedulerCount: ' + CAST(online_scheduler_count AS sysname) + N', CpuAffinity: ' + CAST(cpu_affinity_mask AS sysname) + N')' + @crlf
	FROM sys.dm_os_nodes;
	
	PRINT @output;

	SET @output = @crlf + @crlf + @tab + N'-- Disks' + @crlf;

	DECLARE @disks table (
		[volume_mount_point] nvarchar(256) NULL,
		[file_system_type] nvarchar(256) NULL,
		[logical_volume_name] nvarchar(256) NULL,
		[total_gb] decimal(18,2) NULL,
		[available_gb] decimal(18,2) NULL
	);

	INSERT INTO @disks ([volume_mount_point], [file_system_type], [logical_volume_name], [total_gb], [available_gb])
	SELECT DISTINCT 
		vs.volume_mount_point, 
		vs.file_system_type, 
		vs.logical_volume_name, 
		CONVERT(DECIMAL(18,2),vs.total_bytes/1073741824.0) AS [total_gb],
		CONVERT(DECIMAL(18,2), vs.available_bytes/1073741824.0) AS [available_gb]  
	FROM 
		sys.master_files AS f
		CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.[file_id]) AS vs; 

	SELECT @output = @output
		+ @tab + @tab + volume_mount_point + @crlf + @tab + @tab + @tab + N'Label: ' + logical_volume_name + N', FileSystem: ' + file_system_type + N', TotalGB: ' + CAST([total_gb] AS sysname)  + N', AvailableGB: ' + CAST([available_gb] AS sysname) + @crlf
	FROM 
		@disks 
	ORDER BY 
		[volume_mount_point];	

	PRINT @output + @crlf;

	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Process Installation Details:
	PRINT @sectionMarker;
	PRINT N'-- Installation Details'
	PRINT @sectionMarker;

	DECLARE @properties table (
		row_id int IDENTITY(1,1) NOT NULL, 
		segment_name sysname, 
		property_name sysname
	);

	INSERT INTO @properties (segment_name, property_name)
	VALUES 
	(N'ProductDetails', 'Edition'), 
	(N'ProductDetails', 'ProductLevel'), 
	(N'ProductDetails', 'ProductUpdateLevel'),
	(N'ProductDetails', 'ProductVersion'),
	(N'ProductDetails', 'ProductMajorVersion'),
	(N'ProductDetails', 'ProductMinorVersion'),

	(N'InstanceDetails', 'ServerName'),
	(N'InstanceDetails', 'InstanceName'),
	(N'InstanceDetails', 'IsClustered'),
	(N'InstanceDetails', 'Collation'),

	(N'InstanceFeatures', 'FullTextInstalled'),
	(N'InstanceFeatures', 'IntegratedSecurityOnly'),
	(N'InstanceFeatures', 'FilestreamConfiguredLevel'),
	(N'InstanceFeatures', 'HadrEnabled'),
	(N'InstanceFeatures', 'InstanceDefaultDataPath'),
	(N'InstanceFeatures', 'InstanceDefaultLogPath'),
	(N'InstanceFeatures', 'ErrorLogFileName'),
	(N'InstanceFeatures', 'BuildClrVersion');

	DECLARE propertyizer CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		segment_name,
		property_name 
	FROM 
		@properties
	ORDER BY 
		row_id;

	DECLARE @segment sysname; 
	DECLARE @propertyName sysname;
	DECLARE @propertyValue sysname;
	DECLARE @segmentFamily sysname = N'';

	DECLARE @sql nvarchar(MAX);

	OPEN propertyizer; 

	FETCH NEXT FROM propertyizer INTO @segment, @propertyName;

	WHILE @@FETCH_STATUS = 0 BEGIN
		
		SET @sql = N'SELECT @output = CAST(SERVERPROPERTY(''' + @propertyName + N''') as sysname);';

		EXEC sys.sp_executesql 
			@stmt = @sql, 
			@params = N'@output sysname OUTPUT', 
			@output = @propertyValue OUTPUT;

		IF @segment <> @segmentFamily BEGIN 
			SET @segmentFamily = @segment;

			PRINT @crlf + @tab + N'-- ' + @segmentFamily;
		END 
		
		PRINT @tab + @tab + @propertyName + ': ' + ISNULL(@propertyValue, N'NULL');

		FETCH NEXT FROM propertyizer INTO @segment, @propertyName;
	END;

	CLOSE propertyizer; 
	DEALLOCATE propertyizer;

	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Output Service Details:
	PRINT @crlf + @crlf;
	PRINT @sectionMarker;
	PRINT N'-- Service Details'
	PRINT @sectionMarker;	

	DECLARE @memoryType sysname = N'CONVENTIONAL';
	IF EXISTS (SELECT NULL FROM sys.dm_os_memory_nodes WHERE [memory_node_id] <> 64 AND [locked_page_allocations_kb] <> 0) 
		SET @memoryType = N'LOCKED';


	PRINT @crlf + @tab + N'-- LPIM CONFIG: ' +  @crlf + @tab + @tab + @memoryType;

	DECLARE @command nvarchar(MAX);
	SET @command = N'SELECT 
	servicename, 
	startup_type_desc, 
	service_account, 
	is_clustered, 
	cluster_nodename, 
	[filename] [path], 
	{0} ifi_enabled 
FROM 
	sys.dm_server_services;';	

	IF ((SELECT dbo.get_engine_version()) >= 13.00) -- ifi added to 2016+
		SET @command = REPLACE(@command, N'{0}', 'instant_file_initialization_enabled');
	ELSE 
		SET @command = REPLACE(@command, N'{0}', '''?''');


	DECLARE @serviceDetails table (
		[servicename] nvarchar(256) NOT NULL,
		[startup_type_desc] nvarchar(256) NOT NULL,
		[service_account] nvarchar(256) NOT NULL,
		[is_clustered] nvarchar(1) NOT NULL,
		[cluster_nodename] nvarchar(256) NULL,
		[path] nvarchar(256) NOT NULL,
		[ifi_enabled] nvarchar(1) NOT NULL
	);
	
	INSERT INTO @serviceDetails ([servicename],  [startup_type_desc], [service_account], [is_clustered], [cluster_nodename], [path], [ifi_enabled])
	EXEC master.sys.[sp_executesql] @command;

	SET @output = @crlf + @tab;

	SELECT 
		@output = @output 
		+ N'-- ' + [servicename] + @crlf 
		+ @tab + @tab + N'StartupType: ' + [startup_type_desc] + @crlf 
		+ @tab + @tab + N'ServiceAccount: ' + service_account + @crlf 
		+ @tab + @tab + N'IsClustered: ' + [is_clustered] + CASE WHEN [cluster_nodename] IS NOT NULL THEN + N' (' + cluster_nodename + N')' ELSE N'' END + @crlf  
		+ @tab + @tab + N'FilePath: ' + [path] + @crlf
		+ @tab + @tab + N'IFI Enabled: ' + [ifi_enabled] + @crlf + @crlf + @tab

	FROM 
		@serviceDetails;


	PRINT @output;

	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- TODO: Cluster Details (if/as needed). 


	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Global Trace Flags
	DECLARE @traceFlags table (
		[trace_flag] [int] NOT NULL,
		[status] [bit] NOT NULL,
		[global] [bit] NOT NULL,
		[session] [bit] NOT NULL
	)

	INSERT INTO @traceFlags (trace_flag, [status], [global], [session])
	EXECUTE ('DBCC TRACESTATUS() WITH NO_INFOMSGS');

	PRINT @sectionMarker;
	PRINT N'-- Trace Flags'
	PRINT @sectionMarker;

	SET @output = N'' + @crlf;

	SELECT @output = @output 
		+ @tab + N'-- ' + CAST([trace_flag] AS sysname) + N': ' + CASE WHEN [status] = 1 THEN 'ENABLED' ELSE 'DISABLED' END + @crlf
	FROM 
		@traceFlags 
	WHERE 
		[global] = 1;

	PRINT @output + @crlf;

	------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
	-- Configuration Settings (outside of norms): 

	DECLARE @config_defaults TABLE (
		[name] nvarchar(35) NOT NULL,
		default_value sql_variant NOT NULL
	);

	INSERT INTO @config_defaults (name, default_value) VALUES 
	('access check cache bucket count',0),
	('access check cache quota',0),
	('Ad Hoc Distributed Queries',0),
	('affinity I/O mask',0),
	('affinity mask',0),
	('affinity64 I/O mask',0),
	('affinity64 mask',0),
	('Agent XPs',1),
	('allow polybase export', 0),
	('allow updates',0),
	('automatic soft-NUMA disabled', 0), -- default is good in best in most cases
	('awe enabled',0),
	('backup checksum default', 0), -- this should really be 1
	('backup compression default',0),
	('blocked process threshold (s)',0),
	('c2 audit mode',0),
	('clr enabled',0),
	('clr strict', 1), -- 2017+ (enabled by default)
	('common criteria compliance enabled',0),
	('contained database authentication', 0),
	('cost threshold for parallelism',5),
	('cross db ownership chaining',0),
	('cursor threshold',-1),
	('Database Mail XPs',0),
	('default full-text language',1033),
	('default language',0),
	('default trace enabled',1),
	('disallow results from triggers',0),
	('EKM provider enabled',0),
	('external scripts enabled',0),  -- 2016+
	('filestream access level',0),
	('fill factor (%)',0),
	('ft crawl bandwidth (max)',100),
	('ft crawl bandwidth (min)',0),
	('ft notify bandwidth (max)',100),
	('ft notify bandwidth (min)',0),
	('index create memory (KB)',0),
	('in-doubt xact resolution',0),
	('hadoop connectivity', 0),  -- 2016+
	('lightweight pooling',0),
	('locks',0),
	('max degree of parallelism',0),
	('max full-text crawl range',4),
	('max server memory (MB)',2147483647),
	('max text repl size (B)',65536),
	('max worker threads',0),
	('media retention',0),
	('min memory per query (KB)',1024),
	('min server memory (MB)',0), -- NOTE: SQL Server apparently changes this one 'in-flight' on a regular basis
	('nested triggers',1),
	('network packet size (B)',4096),
	('Ole Automation Procedures',0),
	('open objects',0),
	('optimize for ad hoc workloads',0),
	('PH timeout (s)',60),
	('polybase network encryption',1),
	('precompute rank',0),
	('priority boost',0),
	('query governor cost limit',0),
	('query wait (s)',-1),
	('recovery interval (min)',0),
	('remote access',1),
	('remote admin connections',0),
	('remote data archive',0),
	('remote login timeout (s)',10),
	('remote proc trans',0),
	('remote query timeout (s)',600),
	('Replication XPs',0),
	('scan for startup procs',0),
	('server trigger recursion',1),
	('set working set size',0),
	('show advanced options',0),
	('SMO and DMO XPs',1),
	('SQL Mail XPs',0),
	('transform noise words',0),
	('two digit year cutoff',2049),
	('user connections',0),
	('user options',0),
	('xp_cmdshell',0);

	PRINT @sectionMarker;
	PRINT N'-- Modified Configuration Options'
	PRINT @sectionMarker;	

	SET @output = N'';

	SELECT @output = @output +
		+ @tab + N'-- ' + c.[name] + @crlf
		+ @tab + @tab + N'DEFAULT: ' + CAST([d].[default_value] AS sysname) + @crlf
		+ @tab + @tab + N'VALUE_IN_USE: ' +  CAST(c.[value_in_use] AS sysname) + @crlf
		+ @tab + @tab + N'VALUE: ' + CAST(c.[value] AS sysname) + @crlf + @crlf
	FROM sys.configurations c 
	INNER JOIN @config_defaults d ON c.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = d.[name]
	WHERE
		c.value <> c.value_in_use
		OR c.value_in_use <> d.default_value;
	

	PRINT @output;


		-- Server Log - config setttings (path and # to keep/etc.)

		-- base paths - backups, data, log... 

		-- count of all logins... 
		-- list of all logins with SysAdmin membership.

		-- list of all dbs, files/file-paths... and rough sizes/details. 

		-- DDL triggers. 

		-- endpoints. 

		-- linked servers. 

		-- credentials (list and detail - sans passwords/sensitive info). 

		-- Resource Governor Pools/settings/etc. 

		-- Audit Specs? (yes - though... guessing they're hard-ish to script?)  -- and these are things i can add-in later - i.e., 30 - 60 minutes here/there to add in audits, XEs, and the likes... 

		-- XEs ? (yeah... why not). 

		-- Mirrored DB configs. (partners, listeners, certs, etc.)

		-- AG configs + listeners and such. 

		-- replication pubs and subs

		-- Mail Settings. Everything. 
			-- profiles and which one is the default. 
			--		list of accounts per profile (in ranked order)
			-- accounts and all details. 


		-- SQL Server Agent - 
			-- config settings. 
			-- operators
			-- alerts
			-- operators
			-- JOBS... all of 'em.  (guessing I can FIND a script that'll do this for me - i.e., someone else has likely written it).


	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.export_server_configuration','P') IS NOT NULL
	DROP PROC dbo.export_server_configuration;
GO

CREATE PROC dbo.export_server_configuration 
	@OutputPath								nvarchar(2000)			= N'{DEFAULT}',
	@CopyToPath								nvarchar(2000)			= NULL, 
	@AddServerNameToFileName				bit						= 1, 
	@OperatorName							sysname					= N'Alerts',
	@MailProfileName						sysname					= N'General',
	@EmailSubjectPrefix						nvarchar(50)			= N'[Server Configuration Export] ',	 
	@PrintOnly								bit						= 0	

AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
    EXEC dbo.verify_advanced_capabilities;

	-----------------------------------------------------------------------------
	-- Input Validation:

	DECLARE @edition sysname;
	SELECT @edition = CASE SERVERPROPERTY('EngineEdition')
		WHEN 2 THEN 'STANDARD'
		WHEN 3 THEN 'ENTERPRISE'
		WHEN 4 THEN 'EXPRESS'
		ELSE NULL
	END;

	IF @edition = N'STANDARD' OR @edition IS NULL BEGIN
		-- check for Web:
		IF @@VERSION LIKE '%web%' SET @edition = 'WEB';
	END;
	
	IF @edition IS NULL BEGIN
		RAISERROR('Unsupported SQL Server Edition detected. This script is only supported on Express, Web, Standard, and Enterprise (including Evaluation and Developer) Editions.', 16, 1);
		RETURN -2;
	END;

	IF (@PrintOnly = 0) AND (@edition <> 'EXPRESS') BEGIN -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 

		-- Operator Checks:
		IF ISNULL(@OperatorName, '') IS NULL BEGIN
			RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
			RETURN -4;
		 END;
		ELSE BEGIN
			IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
				RAISERROR('Invalid Operator Name Specified.', 16, 1);
				RETURN -4;
			END;
		END;

		-- Profile Checks:
		DECLARE @databaseMailProfile nvarchar(255);
		EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @databaseMailProfile OUT, @no_output = N'no_output';
 
		IF @databaseMailProfile != @MailProfileName BEGIN
			RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
			RETURN -5;
		END; 
	END;

	IF UPPER(@OutputPath) = N'{DEFAULT}' BEGIN
		SELECT @OutputPath = dbo.load_default_path('BACKUP');
	END;

	IF NULLIF(@OutputPath, N'') IS NULL BEGIN
		RAISERROR('@OutputPath cannot be NULL and must be a valid path.', 16, 1);
		RETURN -6;
	END;

	IF @PrintOnly = 1 BEGIN 
		
		-- just execute the sproc that prints info to the screen: 
		EXEC dbo.script_server_configuration;

		RETURN 0;
	END; 


	-- if we're still here, we need to dynamically output/execute dbo.script_server_configuration so that output is directed to a file (and copied if needed)
	--		while catching and alerting on any errors or problems. 
	DECLARE @errorDetails nvarchar(MAX);
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);

	-- normalize paths: 
	IF(RIGHT(@OutputPath, 1) = '\')
		SET @OutputPath = LEFT(@OutputPath, LEN(@OutputPath) - 1);

	IF(RIGHT(ISNULL(@CopyToPath, N''), 1) = '\')
		SET @CopyToPath = LEFT(@CopyToPath, LEN(@CopyToPath) - 1);

	DECLARE @outputFileName varchar(2000);
	SET @outputFileName = @OutputPath + '\' + CASE WHEN @AddServerNameToFileName = 1 THEN @@SERVERNAME + '_' ELSE '' END + N'Server_Configuration.txt';

	DECLARE @errors table ( 
		error_id int IDENTITY(1,1) NOT NULL, 
		error nvarchar(MAX) 
	);

	DECLARE @xpCmdShellOutput table (
		result_id int IDENTITY(1,1) NOT NULL, 
		result nvarchar(MAX) NULL
	);

	-- Set up a 'translation' of the sproc call (for execution via xp_cmdshell): 
	DECLARE @sqlCommand varchar(MAX); 
	SET @sqlCommand = N'EXEC admindb.dbo.script_server_configuration;';

	DECLARE @command varchar(8000) = 'sqlcmd {0} -Q "{1}" -o "{2}"';

	-- replace parameters: 
	SET @command = REPLACE(@command, '{0}', CASE WHEN UPPER(@@SERVICENAME) = 'MSSQLSERVER' THEN '' ELSE ' -S .\' + UPPER(@@SERVICENAME) END);
	SET @command = REPLACE(@command, '{1}', @sqlCommand);
	SET @command = REPLACE(@command, '{2}', @outputFileName);

	BEGIN TRY

		INSERT INTO @xpCmdShellOutput ([result])
		EXEC master.sys.[xp_cmdshell] @command;

		DELETE FROM @xpCmdShellOutput WHERE [result] IS NULL; 

		IF EXISTS (SELECT NULL FROM @xpCmdShellOutput) BEGIN 
			SET @errorDetails = N'';
			SELECT 
				@errorDetails = @errorDetails + [result] + @crlf + @tab
			FROM 
				@xpCmdShellOutput 
			ORDER BY 
				[result_id];

			SET @errorDetails = N'Unexpected problem while attempting to write configuration details to disk: ' + @crlf + @crlf + @tab + @errorDetails + @crlf + @crlf + N'COMMAND: [' + @command + N']';

			INSERT INTO @errors (error) VALUES (@errorDetails);
		END
		
		-- Verify that the file was written as expected: 
		SET @command = 'for %a in ("' + @outputFileName + '") do @echo %~ta';
		DELETE FROM @xpCmdShellOutput; 

		INSERT INTO @xpCmdShellOutput ([result])
		EXEC master.sys.[xp_cmdshell] @command;

		DECLARE @timeStamp datetime; 
		SELECT @timeStamp = MAX(CAST([result] AS datetime)) FROM @xpCmdShellOutput WHERE [result] IS NOT NULL;

		IF DATEDIFF(MINUTE, @timeStamp, GETDATE()) > 2 BEGIN 
			SET @errorDetails = N'TimeStamp for [' + @outputFileName + N'] reads ' + CONVERT(nvarchar(30), @timeStamp, 120) + N'. Current Execution Time is: ' + CONVERT(nvarchar(30), GETDATE(), 120) + N'. File writing operations did NOT throw an error, but time-stamp difference shows ' + @outputFileName + N' file was NOT written as expected.' ;
			
			INSERT INTO @errors (error) VALUES (@errorDetails);
		END;

		-- copy the file if/as needed:
		IF @CopyToPath IS NOT NULL BEGIN

			DELETE FROM @xpCmdShellOutput;
			SET @command = 'COPY "{0}" "{1}\"';

			SET @command = REPLACE(@command, '{0}', @outputFileName);
			SET @command = REPLACE(@command, '{1}', @CopyToPath);

			INSERT INTO @xpCmdShellOutput ([result])
			EXEC master.sys.[xp_cmdshell] @command;

			DELETE FROM @xpCmdShellOutput WHERE [result] IS NULL OR [result] LIKE '%1 file(s) copied.%'; 

			IF EXISTS (SELECT NULL FROM @xpCmdShellOutput) BEGIN 

				SET @errorDetails = N'';
				SELECT 
					@errorDetails = @errorDetails + [result] + @crlf + @tab
				FROM 
					@xpCmdShellOutput 
				ORDER BY 
					[result_id];

				SET @errorDetails = N'Unexpected problem while copying file from @OutputPath to @CopyFilePath : ' + @crlf + @crlf + @tab + @errorDetails + @crlf + @crlf + N'COMMAND: [' + @command + N']';

				INSERT INTO @errors (error) VALUES (@errorDetails);
			END 
		END;

	END TRY 
	BEGIN CATCH
		SET @errorDetails = N'Unexpected Exception while executing command: [' + ISNULL(@command, N'#ERROR#') + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();

		INSERT INTO @errors (error) VALUES (@errorDetails);
	END CATCH

REPORTING: 
	IF EXISTS (SELECT NULL FROM @errors) BEGIN
		DECLARE @emailErrorMessage nvarchar(MAX) = N'The following errors were encountered: ' + @crlf + @crlf;

		SELECT 
			@emailErrorMessage = @emailErrorMessage + N'- ' + [error] + @crlf
		FROM 
			@errors
		ORDER BY 
			error_id;

		DECLARE @emailSubject nvarchar(2000);
		SET @emailSubject = @EmailSubjectPrefix + N' - ERROR';
	
		IF @edition <> 'EXPRESS' BEGIN;
			EXEC msdb.dbo.sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName,
				@subject = @emailSubject, 
				@body = @emailErrorMessage;
		END;		

	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.backup_server_certificate','P') IS NOT NULL
	DROP PROC dbo.[backup_server_certificate];
GO

CREATE PROC dbo.[backup_server_certificate]
	@CertificateName					sysname							= NULL,
	@BackupDirectory					nvarchar(2000)					= N'{DEFAULT}',					
	@CopyToBackupDirectory				nvarchar(2000)					= NULL,	
	@EncryptionKeyPassword				sysname, 
	@PrintOnly							bit								= 0 
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @CertificateName = NULLIF(@CertificateName, N'');
	SET @BackupDirectory = NULLIF(@BackupDirectory, N'');
	SET @CopyToBackupDirectory = NULLIF(@CopyToBackupDirectory, N'');
	SET @EncryptionKeyPassword = NULLIF(@EncryptionKeyPassword, N'');

	SET @PrintOnly = ISNULL(@PrintOnly, 0);

	IF @CertificateName IS NULL BEGIN 
		RAISERROR(N'@CertificateName is Required.', 16, 1);
		RETURN -1;
	END;

	-- verify that cert exists:
	IF NOT EXISTS (SELECT NULL FROM master.sys.[certificates] WHERE [name] = @CertificateName) BEGIN
		RAISERROR(N'@CertificateName of ''%s'' was not found in [master] database. Please check your input and try again.', 16, 1, @CertificateName);
		RETURN -2;
	END;

	-- Note: couldn't find calls to the internal logic that SQL Server uses to enforce/check password complexity - or it'd be 'fun' to run @EncryptionKeyPassword through that prior to attempting BACKUP... 
	IF @EncryptionKeyPassword IS NULL BEGIN 
		RAISERROR(N'@EncryptionKeyPassword is Required - and is used to secure/protect access to private-key details when persisted to disk as a .cer + .key file.', 16, 1);
		RETURN -5;
	END;

	IF UPPER(@BackupDirectory) = N'{DEFAULT}' BEGIN 
		SELECT @BackupDirectory = dbo.load_default_path('BACKUP');
	END;
	
	IF @BackupDirectory IS NULL BEGIN 
		RAISERROR(N'@BackupDirectory is Required.', 16, 1);
		RETURN -10;
	END;

	-- normalize paths: 
	IF(RIGHT(@BackupDirectory, 1) = N'\')
		SET @BackupDirectory = LEFT(@BackupDirectory, LEN(@BackupDirectory) - 1);

	IF(RIGHT(ISNULL(@CopyToBackupDirectory, N''), 1) = N'\')
		SET @CopyToBackupDirectory = LEFT(@CopyToBackupDirectory, LEN(@CopyToBackupDirectory) - 1);

	
    DECLARE @outcome nvarchar(MAX) = NULL;
	BEGIN TRY
        EXEC dbo.establish_directory
            @TargetDirectory = @BackupDirectory, 
            @PrintOnly = @PrintOnly,
            @Error = @outcome OUTPUT;

		IF @outcome IS NOT NULL BEGIN
			RAISERROR('Invalid Directory detected for @BackupDirectory. Error Message: %s', 16, 1, @outcome);
			RETURN -20;
		END;

		IF @CopyToBackupDirectory IS NOT NULL BEGIN
			SET @outcome = NULL;
			EXEC dbo.establish_directory
				@TargetDirectory = @CopyToBackupDirectory, 
				@PrintOnly = @PrintOnly,
				@Error = @outcome OUTPUT;

			IF @outcome IS NOT NULL BEGIN
				RAISERROR('Invalid Directory detected for @CopyToBackupDirectory. Error Message: %s', 16, 1, @outcome);
				RETURN -20;
			END;
		END;

	END TRY 
	BEGIN CATCH
		SELECT @outcome = ERROR_MESSAGE();
		RAISERROR(N'Unexpected Error verifying Backup Directory Target(s). Error: %s', 16, 1, @outcome);
		RETURN -30;
	END CATCH;
			
	-----------------------------------------------------------------------------
	-- Process Backup Operation: 
	DECLARE @template nvarchar(MAX) = N'USE [master];

BACKUP CERTIFICATE [' + @CertificateName + N']
TO FILE = N''{BackupPath}\' + @CertificateName + N'.cer''
WITH PRIVATE KEY (
	FILE = N''{BackupPath}\' + @CertificateName + N'_PrivateKey.key'', 
	ENCRYPTION BY PASSWORD = N''' + @EncryptionKeyPassword + N'''
);
';

	DECLARE @command nvarchar(MAX) = @template; 
	SET @command = REPLACE(@template, N'{BackupPath}', @BackupDirectory);

	BEGIN TRY 

		IF @PrintOnly = 1 
			PRINT @command; 
		ELSE 
			EXEC sp_executesql @command; 

	END TRY
	BEGIN CATCH 
		SELECT @outcome = ERROR_MESSAGE(); 
		RAISERROR('Unexpected error executing BACKUP CERTIFICATE against @BackupDirectory. Error Message: %s', 16, 1, @outcome);
		RETURN -40;
	END CATCH

	IF @CopyToBackupDirectory IS NOT NULL BEGIN 
		BEGIN TRY 
			SET @command = @template;
			SET @command = REPLACE(@template, N'{BackupPath}', @CopyToBackupDirectory);

			IF @PrintOnly = 1 
				PRINT @command; 
			ELSE 
				EXEC sp_executesql @command; 

		END TRY 
		BEGIN CATCH
			SELECT @outcome = ERROR_MESSAGE(); 
			RAISERROR('Unexpected error executing BACKUP CERTIFICATE against @CopyToBackupDirectory. Error Message: %s', 16, 1, @outcome);
			RETURN -41;
		END CATCH;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.create_server_certificate','P') IS NOT NULL
	DROP PROC dbo.[create_server_certificate];
GO

CREATE PROC dbo.[create_server_certificate]
	@MasterKeyEncryptionPassword		sysname					= NULL,
	@CertificateName					sysname					= NULL,
	@CertificateSubject					sysname					= NULL,
	@CertificateExpiryVector			sysname					= N'10 years',
	--@CreateOnPartner					bit						= 0,
	@BackupDirectory					nvarchar(2000)			= NULL, -- if this and @EncKey are non-null, we'll execute a backup... 
	@CopyToBackupDirectory				nvarchar(2000)			= NULL,	
	@EncryptionKeyPassword				sysname					= NULL, 
	@PrintOnly							bit						= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @MasterKeyEncryptionPassword = NULLIF(@MasterKeyEncryptionPassword, N'');
	SET @CertificateName = NULLIF(@CertificateName, N'');
	SET @BackupDirectory = NULLIF(@BackupDirectory, N'');
	SET @CopyToBackupDirectory = NULLIF(@CopyToBackupDirectory, N'');
	SET @EncryptionKeyPassword = NULLIF(@EncryptionKeyPassword, N'');
	SET @CertificateSubject = NULLIF(@CertificateSubject, N'');

	SET @BackupDirectory = ISNULL(@BackupDirectory, N'{DEFAULT}');
	SET @CertificateExpiryVector = ISNULL(@CertificateExpiryVector, N'10 years');
	SET @PrintOnly = ISNULL(@PrintOnly, 0);
	--SET @CreateOnPartner = ISNULL(@CreateOnPartner, 0);
	
	IF @CertificateName IS NULL BEGIN 
		RAISERROR('@CertificateName is Required.', 16, 1);
		RETURN -1;
	END; 

	IF @CertificateSubject IS NULL BEGIN 
		RAISERROR('@CertificateSubject is required. Please provide a simple description of this certificate''s purpose.', 16, 1);
		RETURN -2;
	END;

	-- verify that cert does not exist:
	IF EXISTS (SELECT NULL FROM master.sys.[certificates] WHERE [name] = @CertificateName) BEGIN
		RAISERROR(N'@CertificateName of ''%s'' already exists in the [master] database.', 16, 1, @CertificateName);
		RETURN -5;
	END;

	-- translate expiry: 
	DECLARE @certExpiry datetime;
	DECLARE @vectorError nvarchar(MAX);
	EXEC dbo.[translate_vector_datetime]
		@Vector = @CertificateExpiryVector, 
		@Operation = N'ADD', 
		@ValidationParameterName = N'@CertificateExpiryVector', 
		@ProhibitedIntervals = N'BACKUP, SECOND', 
		@Output = @certExpiry OUTPUT, 
		@Error = @vectorError OUTPUT;

	IF @vectorError IS NOT NULL BEGIN 
		RAISERROR(@vectorError, 16, 1);
		RETURN -26;
	END;

	DECLARE @command nvarchar(MAX);

	-----------------------------------------------------------------------------
	-- Verify Master Key Encryption:
	IF NOT EXISTS (SELECT NULL FROM master.sys.[symmetric_keys] WHERE [symmetric_key_id] = 101) BEGIN 
		
		IF @MasterKeyEncryptionPassword IS NULL BEGIN 
			RAISERROR(N'Master Key Encryption has not yet been defined (in the [master] databases). Please supply a @MasterKeyEncryptionPassword.', 16, 1);
			RETURN -8;
		END;

		SET @command = N'USE [master];

IF NOT EXISTS (SELECT NULL FROM master.sys.symmetric_keys WHERE symmetric_key_id = 101) BEGIN;
	CREATE MASTER KEY ENCRYPTION BY PASSWORD = N''' + @MasterKeyEncryptionPassword + N''';
END;
';
		IF @PrintOnly = 1
			PRINT @command; 
		ELSE 
			EXEC sp_executesql @command;
	END;

	DECLARE @outcome nvarchar(MAX);

	SET @command = N'USE [master];
CREATE CERTIFICATE [' + @CertificateName + N']
WITH 
	SUBJECT = N''"' + @CertificateSubject + N'"'', 
	EXPIRY_DATE = ''' + CONVERT(sysname, @certExpiry, 23) + N''';
';

	BEGIN TRY 
		IF @PrintOnly = 1 
			PRINT @command; 
		ELSE 
			EXEC sp_executesql @command;

	END TRY
	BEGIN CATCH
		SELECT @outcome = ERROR_MESSAGE();
		RAISERROR(N'Unexpected Error executing CREATE CERTFICATE. Error: %s', 16, 1, @outcome);
		RETURN - 10;
	END CATCH;

	IF @BackupDirectory IS NOT NULL AND @EncryptionKeyPassword IS NOT NULL BEGIN 
		IF @PrintOnly = 1 BEGIN 
			
			PRINT N'';
			PRINT N'------------------------------------------------------------------------------------------------';
			PRINT N'-- Skipping Certificate Backup (because @PrintOnly = 1). However, command WOULD look similar to: ';

			DECLARE @backup nvarchar(MAX) = N'EXEC dbo.[backup_server_certificate]
	@CertificateName = N''' + @CertificateName + N''',
	@BackupDirectory = N''' + @BackupDirectory + ''',
	--@CopyToBackupDirectory = @CopyToBackupDirectory,
	@EncryptionKeyPassword = N''' + @EncryptionKeyPassword + N''',
	@PrintOnly = 1; ';

			EXEC dbo.[print_long_string] @backup;

			PRINT N'------------------------------------------------------------------------------------------------';

		  END; 
		ELSE BEGIN
			EXEC dbo.[backup_server_certificate]
				@CertificateName = @CertificateName,
				@BackupDirectory = @BackupDirectory,
				@CopyToBackupDirectory = @CopyToBackupDirectory,
				@EncryptionKeyPassword = @EncryptionKeyPassword,
				@PrintOnly = @PrintOnly;
		END;
	  END;
	ELSE BEGIN 
		RAISERROR('WARNING: Please use admindb.dbo.backup_server_certificate to create a backup of %s - to protect against disasters.', 6, 1, @CertificateName)
	END;

	-- vNEXT: if @CreateOnPartner.... 

	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.restore_server_certificate','P') IS NOT NULL
	DROP PROC dbo.[restore_server_certificate];
GO

CREATE PROC dbo.[restore_server_certificate]
	@OriginalCertificateName						sysname			= NULL, 
	@CertificateAndKeyRootDirectory					sysname			= NULL,			-- {DEFAULT} is supported - i.e., for .cer/.key files dropped into default backups root.
	@PrivateKeyEncryptionPassword					sysname			= NULL,	
	@MasterKeyEncryptionPassword					sysname			= NULL,
	@OptionalNewCertificateName						sysname			= NULL, 
	@FullCertificateFilePath						sysname			= NULL,			-- specific/direct paths if @CertificateAndKeyRootDirectory needs to be overridden.
	@FullKeyFilePath								sysname			= NULL,			-- ditto.
	--@RestoreOnPartner								bit				= 0, 
	@PrintOnly										bit				= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @OriginalCertificateName = NULLIF(@OriginalCertificateName, N'');
	SET @CertificateAndKeyRootDirectory = NULLIF(@CertificateAndKeyRootDirectory, N'');
	SET @PrivateKeyEncryptionPassword = NULLIF(@PrivateKeyEncryptionPassword, N'');

	SET @MasterKeyEncryptionPassword = NULLIF(@MasterKeyEncryptionPassword, N'');
	SET @OptionalNewCertificateName = NULLIF(@OptionalNewCertificateName, N'');
	SET @FullCertificateFilePath = NULLIF(@FullCertificateFilePath, N'');
	SET @FullKeyFilePath = NULLIF(@FullKeyFilePath, N'');
	
	--SET @RestoreOnPartner = ISNULL(@RestoreOnPartner, 0);
	SET @PrintOnly = ISNULL(@PrintOnly, 0);

	DECLARE @certFileFullPath sysname;
	DECLARE @keyFileFullPath sysname;

	IF @FullCertificateFilePath IS NOT NULL AND @FullKeyFilePath IS NULL OR @FullKeyFilePath IS NOT NULL AND @FullCertificateFilePath IS NULL BEGIN 
		RAISERROR('When specifying explicit/full-path details for .cer and .key files both @FullCertificateFilePath and @FullKeyFilePath must BOTH be specified.', 16, 1);
		RETURN -1;
	END;

	-- there are 2x ways to 'find' the .cer and .key - full-blown file-paths or S4 convention of {backupPath}\{certname}.{extension}
	IF @FullCertificateFilePath IS NOT NULL AND @FullKeyFilePath IS NOT NULL BEGIN 
		
		SET @certFileFullPath = dbo.normalize_file_path(@FullCertificateFilePath);
		SET @keyFileFullPath = dbo.normalize_file_path(@FullKeyFilePath);

	  END;
	ELSE BEGIN 
		IF @OriginalCertificateName IS NULL BEGIN 
			RAISERROR(N'@OriginalCertificateName is required - and, by S4 convention, should match the name of the original/source certificate.', 16, 1);
			RETURN -2;
		END; 

		IF UPPER(@CertificateAndKeyRootDirectory) = N'{DEFAULT}' BEGIN 
			SELECT @CertificateAndKeyRootDirectory = dbo.load_default_path('BACKUP');
		END;

		IF @CertificateAndKeyRootDirectory IS NULL BEGIN 
			RAISERROR(N'@CertificateAndKeyRootDirectory and should point to the directory where your {@OriginalCertificateName}.cer and .key files are stored.', 16, 1);
			RETURN -3;
		END;

		SET @certFileFullPath = @CertificateAndKeyRootDirectory + N'\' + @OriginalCertificateName + N'.cer';
		SET @keyFileFullPath = @CertificateAndKeyRootDirectory + N'\' + @OriginalCertificateName + N'_PrivateKey.key'

	END;

	IF @PrivateKeyEncryptionPassword IS NULL BEGIN 
		RAISERROR(N'@PrivateKeyEncryptionPassword is required - and should be the password defined for protection of your certificate''s .key file.', 16, 1);
		RETURN -20;
	END;

	-- Verify that Cer and Key files exist:
	DECLARE @exists bit;

	EXEC dbo.[check_paths] 
		@Path = @certFileFullPath, 
		@Exists = @exists OUTPUT;
	
	IF @exists = 0 BEGIN 
		RAISERROR(N'The .cer file path specified (%s) is invalid or does not exist.', 16, 1, @certFileFullPath);
		RETURN -21;
	END;

	EXEC dbo.[check_paths] 
		@Path = @keyFileFullPath, 
		@Exists = @exists OUTPUT;

	IF @exists = 0 BEGIN 
		RAISERROR(N'The .key file path specified (%s) is invalid or does not exist.', 16, 1, @keyFileFullPath);
		RETURN -21;
	END;

	-- verify that target cert name does not already exist: 
	DECLARE @certName sysname = ISNULL(@OptionalNewCertificateName, @OriginalCertificateName);

	IF EXISTS (SELECT NULL FROM [master].sys.[certificates] WHERE [name] = @certName) BEGIN 
		RAISERROR(N'Target certificate name ''%s'' already exists on server.', 16, 1, @certName);
		RETURN 0;
	END;


	-----------------------------------------------------------------------------
	-- Verify Master Key Encryption:
	-- DRY_VIOLATION: the code below exists here and in dbo.create_server_certificate:
	IF NOT EXISTS (SELECT NULL FROM master.sys.[symmetric_keys] WHERE [symmetric_key_id] = 101) BEGIN 
		
		IF @MasterKeyEncryptionPassword IS NULL BEGIN 
			RAISERROR(N'Master Key Encryption has not yet been defined (in the [master] databases). Please supply a @MasterKeyEncryptionPassword.', 16, 1);
			RETURN -8;
		END;

		DECLARE @command nvarchar(MAX) = N'USE [master];

IF NOT EXISTS (SELECT NULL FROM master.sys.symmetric_keys WHERE symmetric_key_id = 101) BEGIN;
	CREATE MASTER KEY ENCRYPTION BY PASSWORD = N''' + @MasterKeyEncryptionPassword + N''';
END;
';
		IF @PrintOnly = 1
			PRINT @command; 
		ELSE 
			EXEC sp_executesql @command;

	END;


	DECLARE @template nvarchar(MAX) = N'USE [master];

CREATE CERTIFICATE [{certName}] 
FROM 
	FILE = ''{certFile}''
WITH 
	PRIVATE KEY (
		FILE = ''{keyFile}'',
		DECRYPTION BY PASSWORD = ''{password}''
	);
';

	DECLARE @sql nvarchar(MAX) = @template;
	SET @sql = REPLACE(@sql, N'{certName}', @certName);
	SET @sql = REPLACE(@sql, N'{certFile}', @certFileFullPath);
	SET @sql = REPLACE(@sql, N'{keyFile}', @keyFileFullPath);
	SET @sql = REPLACE(@sql, N'{password}', @PrivateKeyEncryptionPassword);


	DECLARE @outcome nvarchar(MAX);
	BEGIN TRY 
		IF @PrintOnly = 1
			PRINT @sql;
		ELSE 
			EXEC sp_executesql @sql;

	END TRY
	BEGIN CATCH
		SELECT @outcome = ERROR_MESSAGE();
		RAISERROR(N'Unexpected Error executing CREATE CERTFICATE from FILE + PRIVATE KEY FILE. Error: %s', 16, 1, @outcome);
		RETURN -40;
	END CATCH;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.configure_instance','P') IS NOT NULL
	DROP PROC dbo.[configure_instance];
GO

CREATE PROC dbo.[configure_instance]
	@MaxDOP									int				= NULL, 
	@CostThresholdForParallelism			int				= NULL,	 
	@MaxServerMemoryGBs						decimal(8,1)	= NULL,
	@OptimizeForAdhocWorkloads				bit				= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	DECLARE @return int;
    EXEC @return = dbo.verify_advanced_capabilities;
	IF @return <> 0 
		RETURN @return;

	DECLARE @changesMade bit = 0;
	
	-- Enable the Dedicated Admin Connection: 
	IF NOT EXISTS (SELECT NULL FROM sys.[configurations] WHERE [name] = N'remote admin connections' AND [value_in_use] = 1) BEGIN
		EXEC sp_configure 'remote admin connections', 1;
		SET @changesMade = 1;
	END;
	
	IF @MaxDOP IS NOT NULL BEGIN
		DECLARE @currentMaxDop int;
		
		SELECT @currentMaxDop = CAST([value_in_use] AS int) FROM sys.[configurations] WHERE [name] = N'max degree of parallelism';

		IF @currentMaxDop <> @MaxDOP BEGIN
			-- vNEXT verify that the value is legit (i.e., > -1 (0 IS valid) and < total core count/etc.)... 
			EXEC sp_configure 'max degree of parallelism', @MaxDOP;

			SET @changesMade = 1;
		END;
	END;

	IF @CostThresholdForParallelism IS NOT NULL BEGIN 
		DECLARE @currentThreshold int; 

		SELECT @currentThreshold = CAST([value_in_use] AS int) FROM sys.[configurations] WHERE [name] = N'cost threshold for parallelism';

		IF @currentThreshold <> @CostThresholdForParallelism BEGIN
			EXEC sp_configure 'cost threshold for parallelism', @CostThresholdForParallelism;

			SET @changesMade = 1;
		END;
	END;

	IF @MaxServerMemoryGBs IS NOT NULL BEGIN 
		DECLARE @maxServerMemAsInt int; 
		DECLARE @currentMaxServerMem int;

		SET @maxServerMemAsInt = @MaxServerMemoryGBs * 1024;
		SELECT @currentMaxServerMem = CAST([value_in_use] AS int) FROM sys.[configurations] WHERE [name] LIKE N'max server memory%';

		-- pad by 30MB ... i.e., 'close enough':
		IF ABS((@currentMaxServerMem - @maxServerMemAsInt)) > 30 BEGIN
			EXEC sp_configure 'max server memory', @maxServerMemAsInt;

			SET @changesMade = 1;
		END;
	END;

	DECLARE @currentOptimizeForAdhocValue int;
	SELECT @currentOptimizeForAdhocValue = CAST([value_in_use] AS int) FROM sys.[configurations] WHERE [name] LIKE N'optimize for ad hoc workloads';
	IF @OptimizeForAdhocWorkloads = 1 BEGIN 
		IF @currentOptimizeForAdhocValue = 0 BEGIN
			EXEC sp_configure 'optimize for ad hoc workloads', 1;

			SET @changesMade = 1;
		END;
	  END;
	ELSE BEGIN 
		IF @currentOptimizeForAdhocValue = 1 BEGIN
			EXEC sp_configure 'optimize for ad hoc workloads', 0;

			SET @changesMade = 1;
		END;
	END;


	IF @changesMade = 1 BEGIN
		RECONFIGURE;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.configure_database_mail','P') IS NOT NULL
	DROP PROC dbo.configure_database_mail;
GO

CREATE PROC dbo.configure_database_mail
    @ProfileName                    sysname             = N'General', 
    @OperatorName                   sysname             = N'Alerts', 
    @OperatorEmail                  sysname, 
    @SmtpAccountName                sysname             = N'Default SMTP Account', 
    @SmtpAccountDescription         sysname             = N'Defined/Created by S4',
    @SmtpOutgoingEmailAddress       sysname,
    @SmtpOutgoingDisplayName        sysname             = NULL,            -- e.g., SQL1 or POD2-SQLA, etc.  Will be set to @@SERVERNAME if NULL 
    @SmtpServerName                 sysname, 
    @SmtpPortNumber                 int                 = 587, 
    @SmtpRequiresSSL                bit                 = 1, 
    @SmtpAuthType                   sysname             = N'BASIC',         -- WINDOWS | BASIC | ANONYMOUS
    @SmptUserName                   sysname				= NULL,
    @SmtpPassword                   sysname				= NULL, 
	@SendTestEmailUponCompletion	bit					= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 


	SET @SmptUserName = NULLIF(@SmptUserName, N'');
	SET @SmtpPassword = NULLIF(@SmtpPassword, N'');

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	DECLARE @return int;
    EXEC @return = dbo.verify_advanced_capabilities;
	IF @return <> 0 
		RETURN @return;

	SET @SmtpAccountName = ISNULL(NULLIF(@SmtpAccountName, N''), N'Default SMTP Account');

	-----------------------------------------------------------------------------
	-- Verify that the SQL Server Agent is running
	IF NOT EXISTS (SELECT NULL FROM sys.[dm_server_services] WHERE [servicename] LIKE '%Agent%' AND [status_desc] = N'Running') BEGIN
		RAISERROR('SQL Server Agent Service is NOT running. Please ensure that it is running (and/or that this is not an Express Edition of SQL Server) before continuing.', 16, 1);
		RETURN -100;
	END;

	-----------------------------------------------------------------------------
    IF NULLIF(@ProfileName, N'') IS NULL OR NULLIF(@OperatorName, N'') IS NULL OR NULLIF(@OperatorEmail, N'') IS NULL BEGIN 
        RAISERROR(N'@ProfileName, @OperatorName, and @OperatorEmail are all REQUIRED parameters.', 16, 1);
        RETURN -1;
    END;

    IF NULLIF(@SmtpOutgoingEmailAddress, N'') IS NULL OR NULLIF(@SmtpServerName, N'') IS NULL OR NULLIF(@SmtpAuthType, N'') IS NULL BEGIN 
        RAISERROR(N'@SmtpOutgoingEmailAddress, @SmtpServerName, and @SmtpAuthType are all REQUIRED parameters.', 16, 1);
        RETURN -2;
    END;

    IF UPPER(@SmtpAuthType) NOT IN (N'WINDOWS', N'BASIC', N'ANONYMOUS') BEGIN 
        RAISERROR(N'Valid options for @SmtpAuthType are { WINDOWS | BASIC | ANONYMOUS }.', 16, 1);
        RETURN -3;
    END;

    IF @SmtpPortNumber IS NULL OR @SmtpRequiresSSL IS NULL OR @SmtpRequiresSSL NOT IN (0, 1) BEGIN 
        RAISERROR(N'@SmtpPortNumber and @SmtpRequiresSSL are both REQUIRED Parameters. @SmtpRequiresSSL must also have a value of 0 or 1.', 16, 1);
        RETURN -4;
    END;

    IF NULLIF(@SmtpOutgoingDisplayName, N'') IS NULL 
        SELECT @SmtpOutgoingDisplayName = @@SERVERNAME;

    --------------------------------------------------------------
    -- Enable Mail XPs: 
	DECLARE @reconfigure bit = 0;
    IF EXISTS (SELECT NULL FROM sys.[configurations] WHERE [name] = N'show advanced options' AND [value_in_use] = 0) BEGIN
        EXEC sp_configure 'show advanced options', 1; 
        
		SET @reconfigure = 1;
    END;

    IF EXISTS (SELECT NULL FROM sys.[configurations] WHERE [name] = N'Database Mail XPs' AND [value_in_use] = 0) BEGIN
        EXEC sp_configure 'Database Mail XPs', 1; 
	    
		SET @reconfigure = 1;
    END;

	IF @reconfigure = 1 BEGIN
		RECONFIGURE;
	END;

    --------------------------------------------------------------
    -- Create Profile: 
    DECLARE @profileID int; 
	SELECT @profileID = profile_id FROM msdb.dbo.[sysmail_profile] WHERE [name] = @ProfileName;
	
	IF @profileID IS NULL BEGIN 
		EXEC msdb.dbo.[sysmail_add_profile_sp] 
			@profile_name = @ProfileName, 
			@description = N'S4-Created Profile... ', 
			@profile_id = @profileID OUTPUT;		
	END;

    --------------------------------------------------------------
    -- Create an Account: 
    DECLARE @accountID int; 
    DECLARE @useDefaultCredentials bit = 0;  -- username/password. 
    IF UPPER(@SmtpAuthType) = N'WINDOWS' SET @useDefaultCredentials = 1;  -- use windows. 
    IF UPPER(@SmtpAuthType) = N'ANONYMOUS' SET @useDefaultCredentials = 0;  

	SELECT @accountID = account_id FROM msdb.dbo.[sysmail_account] WHERE [name] = @SmtpAccountName;
	IF @accountID IS NULL BEGIN 
		EXEC msdb.dbo.[sysmail_add_account_sp]
			@account_name = @SmtpAccountName,
			@email_address = @SmtpOutgoingEmailAddress,
			@display_name = @SmtpOutgoingDisplayName,
			--@replyto_address = N'',
			@description = @SmtpAccountDescription,
			@mailserver_name = @SmtpServerName,
			@mailserver_type = N'SMTP',
			@port = @SmtpPortNumber,
			@username = @SmptUserName,
			@password = @SmtpPassword,
			@use_default_credentials = @useDefaultCredentials,
			@enable_ssl = @SmtpRequiresSSL,
			@account_id = @accountID OUTPUT;
	  END;
	ELSE BEGIN 
		EXEC msdb.dbo.[sysmail_update_account_sp]
			@account_id = @accountID,
			@account_name = @SmtpAccountName,
			@email_address = @SmtpOutgoingEmailAddress,
			@display_name = @SmtpOutgoingDisplayName,
			--@replyto_address = N'',
			@description = @SmtpAccountDescription,
			@mailserver_name = @SmtpServerName,
			@mailserver_type = N'SMTP',
			@port = @SmtpPortNumber,
			@username = @SmptUserName,
			@password = @SmtpPassword,
			@use_default_credentials = @useDefaultCredentials,
			@enable_ssl = @SmtpRequiresSSL;
	END;

    --------------------------------------------------------------
    -- Bind Account to Profile:
	IF NOT EXISTS (SELECT NULL FROM msdb.dbo.[sysmail_profileaccount] WHERE [profile_id] = @profileID AND [account_id] = @accountID) BEGIN
		EXEC msdb.dbo.sysmail_add_profileaccount_sp 
			@profile_id = @profileID,
			@account_id = @accountID, 
			@sequence_number = 1;  
	END;

    --------------------------------------------------------------
    -- set as default: 
    EXEC msdb.dbo.sp_set_sqlagent_properties 
	    @databasemail_profile = @ProfileName,
        @use_databasemail = 1;

    --------------------------------------------------------------
    -- Create Operator: 
	IF NOT EXISTS (SELECT NULL FROM msdb.dbo.[sysoperators] WHERE [name] = @OperatorName AND [email_address] = @OperatorEmail) BEGIN
		EXEC msdb.dbo.[sp_add_operator]
			@name = @OperatorName,
			@enabled = 1,
			@email_address = @OperatorEmail;
	END;

    --------------------------------------------------------------
    -- Enable SQL Server Agent to use Database Mail and enable tokenization:
    EXEC msdb.dbo.[sp_set_sqlagent_properties]  -- NON-DOCUMENTED SPROC: 
        @alert_replace_runtime_tokens = 1,
        @use_databasemail = 1,
        @databasemail_profile = @ProfileName;

    -- define a default operator:
    EXEC master.dbo.sp_MSsetalertinfo 
        @failsafeoperator = @OperatorName, 
		@notificationmethod = 1;

    --------------------------------------------------------------
    -- vNext: bind operator and profile to dbo.settings as 'default' operator/profile details. 

	/*
	
		UPSERT... 
			dbo.settings: 
				setting_type	= SINGLETON
				setting_key		= s4_default_profile
				setting_value	= @ProfileName


		UPSERT 
			dbo.settings: 
				setting_type	= SINGLETON
				setting_key		= s4_default_operator
				setting_value	= @OperatorName				
	
		THEN... 
			need some sort of check/validation/CYA at the start of this processs
				that avoids configuring mail IF the values above are already set? 
					or something along those lines... 


			because... this process isn't super idempotent (or is it?)

	*/

	IF @SendTestEmailUponCompletion = 0 
		RETURN 0;

	--------------------------------------------------------------
	-- Send a test email - to verify that the SQL Server Agent can correctly send email... 

	DECLARE @version sysname = (SELECT [version_number] FROM dbo.version_history WHERE [version_id] = (SELECT MAX([version_id]) FROM dbo.[version_history]));
	DECLARE @body nvarchar(MAX) = N'Test Email - Configuration Validation.

If you''re seeing this, the SQL Server Agent on ' + @SmtpOutgoingDisplayName + N' has been correctly configured to 
allow alerts via the SQL Server Agent.

Triggered by dbo.configure_database_mail. S4 version ' + @version + N'.

';
	EXEC msdb.dbo.[sp_notify_operator] 
		@profile_name = @ProfileName, 
		@name = @OperatorName, 
		@subject = N'', 
		@body = @body;

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.enable_alerts','P') IS NOT NULL
	DROP PROC dbo.[enable_alerts];
GO

CREATE PROC dbo.[enable_alerts]
    @OperatorName                   sysname             = N'Alerts',
    @AlertTypes                     sysname             = N'SEVERITY_AND_IO',       -- SEVERITY | IO | SEVERITY_AND_IO
    @PrintOnly                      bit                 = 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -- TODO: verify that @OperatorName is a valid operator.

    IF UPPER(@AlertTypes) NOT IN (N'SEVERITY', N'IO', N'SEVERITY_AND_IO') BEGIN 
        RAISERROR('Valid @AlertTypes are { SEVERITY | IO | SEVERITY_AND_IO }.', 16, 1);
        RETURN -5;
    END;

    DECLARE @ioAlerts table (
        message_id int NOT NULL, 
        [name] sysname NOT NULL
    );

    DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

    DECLARE @alertTemplate nvarchar(MAX) = N'------- {name}
IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysalerts WHERE severity = {severity} AND [name] = N''{name}'') BEGIN
    EXEC msdb.dbo.sp_add_alert 
	    @name = N''{name}'', 
        @message_id = {id},
        @severity = {severity},
        @enabled = 1,
        @delay_between_responses = 0,
        @include_event_description_in = 1; 
    EXEC msdb.dbo.sp_add_notification 
	    @alert_name = N''{name}'', 
	    @operator_name = N''{operator}'', 
	    @notification_method = 1; 
END;' ;

    SET @alertTemplate = REPLACE(@alertTemplate, N'{operator}', @OperatorName);

    DECLARE @command nvarchar(MAX) = N'';

    IF UPPER(@AlertTypes) IN (N'SEVERITY', N'SEVERITY_AND_IO') BEGIN
            
        DECLARE @severityTemplate nvarchar(MAX) = REPLACE(@alertTemplate, N'{id}', N'0');
        SET @severityTemplate = REPLACE(@severityTemplate, N'{name}', N'Severity 0{severity}');

        WITH numbers AS ( 
            SELECT 
                ROW_NUMBER() OVER (ORDER BY [object_id]) [severity]
            FROM 
                sys.[objects] 
            WHERE 
                [object_id] < 50
        )

        SELECT
            @command = @command + @crlf + @crlf + REPLACE(@severityTemplate, N'{severity}', severity)
        FROM 
            numbers
        WHERE 
            [severity] >= 17 AND [severity] <= 25
        ORDER BY 
            [severity];
    END;

    IF UPPER(@AlertTypes) IN ( N'IO', N'SEVERITY_AND_IO') BEGIN 

        IF DATALENGTH(@command) > 2 SET @command = @command + @crlf + @crlf;

        INSERT INTO @ioAlerts (
            [message_id],
            [name]
        )
        VALUES       
            (605, N'605 - Page Allocation Unit Error'),
            (823, N'823 - Read/Write Failure'),
            (824, N'824 - Page Error'),
            (825, N'825 - Read-Retry Required');

        DECLARE @ioTemplate nvarchar(MAX) = REPLACE(@alertTemplate, N'{severity}', N'0');

        SELECT
            @command = @command + @crlf + @crlf + REPLACE(REPLACE(@ioTemplate, N'{id}', message_id), N'{name}', [name])
        FROM 
            @ioAlerts;

    END;

    IF @PrintOnly = 1 
        EXEC dbo.[print_long_string] @command;
    ELSE 
        EXEC sp_executesql @command;

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

/* HACK: note that this sproc has an UGLY work-around at the bottom of the sproc (i.e., this code file) to get around an ugly bug within Powershell... */

IF OBJECT_ID('dbo.enable_alert_filtering_x','P') IS NOT NULL
	DROP PROC dbo.[enable_alert_filtering_x];
GO

CREATE PROC dbo.[enable_alert_filtering_x]
    @TargetAlerts                   nvarchar(MAX)           = N'SEVERITY',					-- { SEVERITY | IO | SEVERITY_AND_IO }
    @ExcludedAlerts                 nvarchar(MAX)           = NULL,							-- N'%18, %4605%, Severity%, etc..'. NOTE: 1480, if present, is filtered automatically.. 
    @AlertsProcessingJobName        sysname                 = N'Filter Alerts', 
    @AlertsProcessingJobCategory    sysname                 = N'Alerting',
	@OperatorName				    sysname					= N'Alerts',
	@MailProfileName			    sysname					= N'General'
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF UPPER(@TargetAlerts) NOT IN (N'SEVERITY', N'IO', N'SEVERITY_AND_IO') BEGIN 
		RAISERROR('Allowed inputs for @Target Alerts are { SEVERITY | IO | SEVERITY_AND_IO }. Specific alerts my be removed from targeting via @ExcludedAlerts.', 16, 1);
		RETURN -1;
	END;

    ------------------------------------
    -- create a 'response' job: 
    DECLARE @errorMessage nvarchar(MAX);

    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.syscategories WHERE [name] = @AlertsProcessingJobCategory AND category_class = 1) BEGIN
        
        BEGIN TRY
            EXEC msdb.dbo.sp_add_category 
                @class = N'JOB', 
                @type = N'LOCAL', 
                @name = @AlertsProcessingJobCategory;
        END TRY 
        BEGIN CATCH 
            SELECT @errorMessage = N'Unexpected problem creating job category [' + @AlertsProcessingJobCategory + N'] on server [' + @@SERVERNAME + N']. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
            RAISERROR(@errorMessage, 16, 1);
            RETURN -20;
        END CATCH;
    END;

    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobs WHERE [name] = @AlertsProcessingJobName) BEGIN 
    
        -- vNEXT: check to see if there isn't already a job 'out there' that's doing these exact same things - i.e., where the @command is pretty close to the same stuff 
        --          being done below. And, if it is, raise a WARNING... but don't raise an error OR kill execution... 
        DECLARE @command nvarchar(MAX) = N'
        DECLARE @ErrorNumber int, @Severity int;
        SET @ErrorNumber = CONVERT(int, N''$`(ESCAPE_SQUOTE(A-ERR))'');
        SET @Severity = CONVERT(int, N''$`(ESCAPE_NONE(A-SEV))'');

        EXEC admindb.dbo.process_alerts 
	        @ErrorNumber = @ErrorNumber, 
	        @Severity = @Severity,
	        @Message = N''$`(ESCAPE_SQUOTE(A-MSG))'', 
            @OperatorName = N''{operator}'', 
            @MailProfileName = N''{profile}''; ';

        SET @command = REPLACE(@command, N'{operator}', @OperatorName);
        SET @command = REPLACE(@command, N'{profile}', @MailProfileName);
        
        BEGIN TRANSACTION; 

        BEGIN TRY 
            EXEC msdb.dbo.[sp_add_job]
                @job_name = @AlertsProcessingJobName,
                @enabled = 1,
                @description = N'Executed by SQL Server Agent Alerts - to enable logic/processing for filtering of ''noise'' alerts.',
                @start_step_id = 1,
                @category_name = @AlertsProcessingJobCategory,
                @owner_login_name = N'sa',
                @notify_level_email = 2,
                @notify_email_operator_name = @OperatorName,
                @delete_level = 0;

            -- TODO: might need a version check here... i.e., this behavior is new to ... 2017? (possibly 2016?) (or I'm on drugs) (eithe way, NOT clearly documented as of 2019-07-29)
            EXEC msdb.dbo.[sp_add_jobserver] 
                @job_name = @AlertsProcessingJobName, 
                @server_name = N'(LOCAL)';

            EXEC msdb.dbo.[sp_add_jobstep]
                @job_name = @AlertsProcessingJobName,
                @step_id = 1,
                @step_name = N'Process Alert Filtering',
                @subsystem = N'TSQL',
                @command = @command,
                @cmdexec_success_code = 0,
                @on_success_action = 1,
                @on_success_step_id = 0,
                @on_fail_action = 2,
                @on_fail_step_id = 0,
                @database_name = N'admindb',
                @flags = 0;

            COMMIT TRANSACTION;
        END TRY 
        BEGIN CATCH 
            SELECT @errorMessage = N'Unexpected error creating alert-processing/filtering job on server [' + @@SERVERNAME + N']. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
            RAISERROR(@errorMessage, 16, 1);
            ROLLBACK TRANSACTION;
            RETURN -25;
        END CATCH;

      END;
    ELSE BEGIN 
        -- vNEXT: verify that the @OperatorName and @MailProfileName in job-step 1 are the same as @inputs... 
        PRINT 'Alert Response-Job Already Exists (created previously). Please MANUALLY verify that the operator and profile defined is correct.';
    END;

    ------------------------------------
    -- process targets/exclusions:
    DECLARE @inclusions table (
        [name] sysname NOT NULL 
    );

    DECLARE @targets table (
        [name] sysname NOT NULL 
    );

    IF UPPER(@TargetAlerts) IN (N'SEVERITY', N'SEVERITY_AND_IO') BEGIN 
        INSERT INTO @targets (
            [name] 
        )
        SELECT 
            s.[name] 
        FROM 
            msdb.dbo.[sysalerts] s
		WHERE 
			[name] LIKE 'Severity%'
    END;

	IF UPPER(@TargetAlerts) IN (N'IO', N'SEVERITY_AND_IO') BEGIN 
        INSERT INTO @targets (
            [name] 
        )
        SELECT 
            s.[name] 
        FROM 
            msdb.dbo.[sysalerts] s
		WHERE 
			[name] LIKE N'82%'
			AND 
			[name] LIKE N'605 -%'
	END;

    DECLARE @exclusions table ( 
        [name] sysname NOT NULL
    );

    INSERT INTO @exclusions (
        [name]
    )
    VALUES (
        N'1480%'
    );

    IF NULLIF(@ExcludedAlerts, N'') IS NOT NULL BEGIN
        INSERT INTO @exclusions (
            [name]
        )
        SELECT [result] FROM dbo.[split_string](@ExcludedAlerts, N',', 1);
    END;
	
    DECLARE walker CURSOR LOCAL FAST_FORWARD FOR
    SELECT 
        [t].[name] 
    FROM 
        @targets [t]
        LEFT OUTER JOIN @exclusions x ON [t].[name] LIKE [x].[name]
    WHERE 
        x.[name] IS NULL;

    DECLARE @currentAlert sysname; 

    OPEN [walker]; 

    FETCH NEXT FROM [walker] INTO @currentAlert;

    WHILE @@FETCH_STATUS = 0 BEGIN
        
        IF EXISTS (SELECT NULL FROM msdb.dbo.[sysalerts] WHERE [name] = @currentAlert AND [has_notification] = 1) BEGIN
            EXEC msdb.dbo.[sp_delete_notification] 
                @alert_name = @currentAlert, 
                @operator_name = @OperatorName;
        END;
        
        IF NOT EXISTS (SELECT NULL FROM [msdb].dbo.[sysalerts] WHERE [name] = @currentAlert AND NULLIF([job_id], N'00000000-0000-0000-0000-000000000000') IS NOT NULL) BEGIN
            EXEC msdb.dbo.[sp_update_alert]
                @name = @currentAlert,
                @job_name = @AlertsProcessingJobName;
        END;
        
        FETCH NEXT FROM [walker] INTO @currentAlert;
    END;

    CLOSE [walker];
    DEALLOCATE [walker];

    RETURN 0;
GO

/* HACK: Powershell's Invoke-SqlCmd is choking on the dollar-sign in front of (ESCAPE_SQUOTE... even with -DisableParameters set to true. This is an ugly work-around to 
			allow admindb and all code to be deployed via Powershell if/as desired - by escaping that $ with a ` (inside a place-holder sproc) then doing a 'replace' ... etc.
*/
DECLARE @definition nvarchar(MAX) = (SELECT [definition] FROM sys.[sql_modules] WHERE [object_id] = OBJECT_ID('dbo.enable_alert_filtering_x'));
DECLARE @drop nvarchar(MAX) = N'IF OBJECT_ID(''dbo.[enable_alert_filtering_x]'',''P'') IS NOT NULL BEGIN 
	DROP PROC dbo.[enable_alert_filtering_x]; 
END;
';
EXEC sys.sp_executesql @drop;

SET @definition = REPLACE(@definition, N'`', N'');
SET @definition = REPLACE(@definition, N'enable_alert_filtering_x', N'enable_alert_filtering');
SET @drop = REPLACE(@drop, N'enable_alert_filtering_x', N'enable_alert_filtering');

EXEC sys.sp_executesql @drop;
EXEC sys.sp_executesql @definition;


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.manage_server_history','P') IS NOT NULL
	DROP PROC dbo.[manage_server_history];
GO

CREATE PROC dbo.[manage_server_history]
	@HistoryCleanupJobName				sysname			= N'Regular History Cleanup', 
	@JobCategoryName					sysname			= N'Server Maintenance', 
	@JobOperatorToAlertOnErrors			sysname			= N'Alerts',
	@NumberOfServerLogsToKeep			int				= 24, 
	@StartDayOfWeekForCleanupJob		sysname			= N'Sunday',
	@StartTimeForCleanupJob				time			= N'09:45',				-- AM/24-hour time (i.e. defaults to morning)
	@TimeZoneForUtcOffset				sysname			= NULL,					-- IF the server is running on UTC time, this is the time-zone you want to adjust backups to (i.e., 2AM UTC would be 4PM pacific - not a great time for full backups. Values ...   e.g., 'Central Standard Time', 'Pacific Standard Time', 'Eastern Daylight Time' 
	@AgentJobHistoryRetention			sysname			= N'4 weeks', 
	@BackupHistoryRetention				sysname			= N'4 weeks', 
	@EmailHistoryRetention				sysname			= N'', 
	@CycleFTCrawlLogsInDatabases		nvarchar(MAX)	= NULL,
	@CleanupS4History					sysname			= N'', 
	@OverWriteExistingJob				bit				= 0						-- Exactly as it sounds. Used for cases where we want to force an exiting job into a 'new' shap.e... 
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	-- TODO: validate inputs... 

	-- translate 'local' timezone to UTC-zoned servers:
	IF @TimeZoneForUtcOffset IS NOT NULL BEGIN 
		IF (SELECT [dbo].[get_engine_version]()) >= 13.0 BEGIN 

			DECLARE @utc datetime = GETUTCDATE();
			DECLARE @atTimeZone datetime;
			DECLARE @offsetSQL nvarchar(MAX) = N'SELECT @atTimeZone = @utc AT TIME ZONE ''UTC'' AT TIME ZONE @TimeZoneForUtcOffset; ';
			
			EXEC sys.[sp_executesql]
				@offsetSQL, 
				N'@atTimeZone datetime OUTPUT, @utc datetime, @TimeZoneForUtcOffset sysname', 
				@atTimeZone = @atTimeZone OUTPUT, 
				@utc = @utc, 
				@TimeZoneForUtcOffset = @TimeZoneForUtcOffset;

			SET @StartTimeForCleanupJob = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @StartTimeForCleanupJob);

		  END; 
		ELSE BEGIN 
			RAISERROR('@TimeZoneForUtcOffset is NOT supported on SQL Server versions prior to SQL Server 2016. Set value to NULL.', 16, 1); 
			RETURN -100;
		END;
	END;

	DECLARE @outcome int;
	DECLARE @error nvarchar(MAX);

	-- Set the Error Log Retention value: 
	EXEC xp_instance_regwrite 
		N'HKEY_LOCAL_MACHINE', 
		N'Software\Microsoft\MSSQLServer\MSSQLServer', 
		N'NumErrorLogs', 
		REG_DWORD, 
		@NumberOfServerLogsToKeep;

	-- Toggle Agent History Retention (i.e., get rid of 'silly' 1000/100 limits): 
	EXEC [msdb].[dbo].[sp_set_sqlagent_properties]			-- undocumented, but... pretty 'solid'/obvious: EXEC msdb.dbo.sp_helptext 'sp_set_sqlagent_properties';
		@jobhistory_max_rows = -1, 
		@jobhistory_max_rows_per_job = -1;

	DECLARE @historyDaysBack int; 
	EXEC @outcome = dbo.[translate_vector]
		@Vector = @AgentJobHistoryRetention,
		@ValidationParameterName = N'@AgentJobHistoryRetention',
		@ProhibitedIntervals = 'MILLISECOND, SECOND, MINUTE, HOUR',
		@TranslationDatePart = 'DAY',
		@Output = @historyDaysBack OUTPUT,
		@Error = @error OUTPUT;

	IF @outcome <> 0 BEGIN
		RAISERROR(@error, 16, 1);
		RETURN - 20;
	END;

	DECLARE @backupDaysBack int;
	EXEC @outcome = dbo.[translate_vector]
		@Vector = @BackupHistoryRetention, 
		@ValidationParameterName = N'@BackupHistoryRetention', 
		@ProhibitedIntervals = 'MILLISECOND, SECOND, MINUTE, HOUR',
		@TranslationDatePart = 'DAY',
		@Output = @backupDaysBack OUTPUT, 
		@Error = @error OUTPUT;

	IF @outcome <> 0 BEGIN
		RAISERROR(@error, 16, 1);
		RETURN - 21;
	END;

	DECLARE @emailDaysBack int; 
	IF NULLIF(@EmailHistoryRetention, N'') IS NOT NULL BEGIN
		EXEC @outcome = dbo.[translate_vector]
			@Vector = @EmailHistoryRetention, 
			@ValidationParameterName = N'@EmailHistoryRetention', 
			@ProhibitedIntervals = 'MILLISECOND, SECOND, MINUTE, HOUR',
			@TranslationDatePart = 'DAY',
			@Output = @emailDaysBack OUTPUT, 
			@Error = @error OUTPUT;

		IF @outcome <> 0 BEGIN
			RAISERROR(@error, 16, 1);
			RETURN - 22;
		END;
	END;

	DECLARE @dayNames TABLE (
		day_map int NOT NULL, 
		day_name sysname NOT NULL
	);
	INSERT INTO @dayNames
	(
		day_map,
		day_name
	)
	SELECT id, val FROM (VALUES (1, N'Sunday'), (2, N'Monday'), (4, N'Tuesday'), (8, N'Wednesday'), (16, N'Thursday'), (32, N'Friday'), (64, N'Saturday')) d(id, val);

	IF NOT EXISTS(SELECT NULL FROM @dayNames WHERE UPPER([day_name]) = UPPER(@StartDayOfWeekForCleanupJob)) BEGIN
		RAISERROR(N'Specified value of ''%s'' for @StartDayOfWeekForCleanupJob is invalid.', 16, 1);
		RETURN -2;
	END;
	   	 
	DECLARE @jobId uniqueidentifier;
	EXEC [dbo].[create_agent_job]
		@TargetJobName = @HistoryCleanupJobName,
		@JobCategoryName = @JobCategoryName,
		@AddBlankInitialJobStep = 1,
		@OperatorToAlertOnErrorss = @JobOperatorToAlertOnErrors,
		@OverWriteExistingJobDetails = @OverWriteExistingJob,
		@JobID = @jobId OUTPUT;

	-- create a schedule:
	DECLARE @dayMap int;
	SELECT @dayMap = [day_map] FROM @dayNames WHERE UPPER([day_name]) = UPPER(@StartDayOfWeekForCleanupJob);

	DECLARE @dateAsInt int = CAST(CONVERT(sysname, GETDATE(), 112) AS int);
	DECLARE @startTimeAsInt int = CAST((LEFT(REPLACE(CONVERT(sysname, @StartTimeForCleanupJob, 108), N':', N''), 6)) AS int);
	DECLARE @scheduleName sysname = N'Schedule: ' + @HistoryCleanupJobName;

	EXEC msdb.dbo.sp_add_jobschedule 
		@job_name = @HistoryCleanupJobName,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = 8,	
		@freq_interval = @dayMap,
		@freq_subday_type = 1,
		@freq_subday_interval = 0, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 1, 
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;

	-- Start adding job-steps:
	DECLARE @currentStepName sysname;
	DECLARE @currentCommand nvarchar(MAX);
	DECLARE @currentStepId int = 2;		-- job step ID 1 is the placeholder... 

	-- Remove Job History
	SET @currentStepName = N'Truncate Job History';
	SET @currentCommand = N'DECLARE @cutoff datetime; 
SET @cutoff = DATEADD(DAY, 0 - {daysBack}, GETDATE());

EXEC msdb.dbo.sp_purge_jobhistory  
	@oldest_date = @cutoff; ';

	SET @currentCommand = REPLACE(@currentCommand, N'{daysBack}', @historyDaysBack);

	EXEC msdb..sp_add_jobstep 
		@job_id = @jobId,               
	    @step_id = @currentStepId,		
	    @step_name = @currentStepName,	
	    @subsystem = N'TSQL',			
	    @command = @currentCommand,		
	    @on_success_action = 3,			
	    @on_fail_action = 3, 
	    @database_name = N'msdb',
	    @retry_attempts = 2,
	    @retry_interval = 1;			
	
	SET @currentStepId += 1;


	-- Remove stale Jobs Activity: 
	SET @currentStepName = N'Remove Stale Jobs Activity';
	SET @currentCommand = N'EXEC admindb.dbo.clear_stale_jobsactivity; ';

	EXEC msdb..sp_add_jobstep
		@job_id = @jobId,               
	    @step_id = @currentStepId,		
	    @step_name = @currentStepName,	
	    @subsystem = N'TSQL',			
	    @command = @currentCommand,		
	    @on_success_action = 3,			
	    @on_fail_action = 3, 
	    @database_name = N'admindb',
	    @retry_attempts = 2,
	    @retry_interval = 1;	

	SET @currentStepId += 1;

	-- Remove Backup History:
	SET @currentStepName = N'Truncate Backup History';
	SET @currentCommand = N'DECLARE @cutoff datetime; 
SET @cutoff = DATEADD(DAY, 0 - {daysBack}, GETDATE());

EXEC msdb.dbo.sp_delete_backuphistory  
	@oldest_date = @cutoff; ';

	SET @currentCommand = REPLACE(@currentCommand, N'{daysBack}', @backupDaysBack);

	EXEC msdb..sp_add_jobstep 
		@job_id = @jobId,               
	    @step_id = @currentStepId,		
	    @step_name = @currentStepName,	
	    @subsystem = N'TSQL',			
	    @command = @currentCommand,		
	    @on_success_action = 3,			
	    @on_fail_action = 3, 
	    @database_name = N'msdb',
	    @retry_attempts = 2,
	    @retry_interval = 1;			
	
	SET @currentStepId += 1;
	
	-- Remove Email History:
	IF NULLIF(@EmailHistoryRetention, N'') IS NOT NULL BEGIN 

		SET @currentStepName = N'Truncate Email History';
		SET @currentCommand = N'DECLARE @cutoff datetime; 
SET @cutoff = DATEADD(DAY, 0 - {daysBack}, GETDATE());

EXEC msdb.dbo.sysmail_delete_mailitems_sp  
	@sent_before = @cutoff, 
	@sent_status = ''sent''; ';

		SET @currentCommand = REPLACE(@currentCommand, N'{daysBack}', @emailDaysBack);

		EXEC msdb..sp_add_jobstep 
			@job_id = @jobId,               
			@step_id = @currentStepId,		
			@step_name = @currentStepName,	
			@subsystem = N'TSQL',			
			@command = @currentCommand,		
			@on_success_action = 3,			
			@on_fail_action = 3, 
			@database_name = N'msdb',
			@retry_attempts = 2,
			@retry_interval = 1;			
	
		SET @currentStepId += 1;

	END;

	-- Remove FTCrawlHistory:
--	IF @CycleFTCrawlLogsInDatabases IS NOT NULL BEGIN

--		DECLARE @ftStepNameTemplate sysname = N'{dbName} - Truncate FT Crawl History';
--		SET @currentCommand = N'SET NOCOUNT ON;

--DECLARE @catalog sysname; 
--DECLARE @command nvarchar(300); 
--DECLARE @template nvarchar(200) = N''EXEC sp_fulltext_recycle_crawl_log ''''{0}''''; '';

--DECLARE walker CURSOR LOCAL FAST_FORWARD FOR 
--SELECT 
--	[name]
--FROM 
--	sys.[fulltext_catalogs]
--ORDER BY 
--	[name];

--OPEN walker; 
--FETCH NEXT FROM walker INTO @catalog;

--WHILE @@FETCH_STATUS = 0 BEGIN

--	SET @command = REPLACE(@template, N''{0}'', @catalog);

--	--PRINT @command;
--	EXEC sys.[sp_executesql] @command;

--	FETCH NEXT FROM walker INTO @catalog;
--END;

--CLOSE walker;
--DEALLOCATE walker; ';

--		DECLARE @currentDBName sysname;
--		DECLARE @targets table (
--			row_id int IDENTITY(1, 1) NOT NULL,
--			[db_name] sysname NOT NULL
--		);

--		INSERT INTO @targets 
--		EXEC dbo.list_databases 
--			@Targets = @CycleFTCrawlLogsInDatabases, 
--			@ExcludeClones = 1, 
--			@ExcludeSecondaries = 1, 
--			@ExcludeSimpleRecovery = 0, 
--			@ExcludeReadOnly = 1, 
--			@ExcludeRestoring = 1, 
--			@ExcludeRecovering = 1, 
--			@ExcludeOffline = 1;

--		DECLARE [cycler] CURSOR LOCAL FAST_FORWARD FOR 
--		SELECT
--			[db_name]
--		FROM 
--			@targets 
--		ORDER BY 
--			[row_id];

--		OPEN [cycler];
--		FETCH NEXT FROM [cycler] INTO @currentDBName;
		
--		WHILE @@FETCH_STATUS = 0 BEGIN
		
--			SET @currentStepName = REPLACE(@ftStepNameTemplate, N'{dbName}', @currentDBName);

--			EXEC msdb..sp_add_jobstep 
--				@job_id = @jobId,               
--				@step_id = @currentStepId,		
--				@step_name = @currentStepName,	
--				@subsystem = N'TSQL',			
--				@command = @currentCommand,		
--				@on_success_action = 3,			
--				@on_fail_action = 3, 
--				@database_name = @currentDBName,
--				@retry_attempts = 2,
--				@retry_interval = 1;			
	
--			SET @currentStepId += 1;
		
--			FETCH NEXT FROM [cycler] INTO @currentDBName;
--		END;
		
--		CLOSE [cycler];
--		DEALLOCATE [cycler];

--	END;

	-- Cycle Error Logs: 
	SET @currentStepName = N'Cycle Logs';
	SET @currentCommand = N'-- Error Log:
USE master;
GO
EXEC master.sys.sp_cycle_errorlog;
GO

-- SQL Server Agent Error Log:
USE msdb;
GO
EXEC dbo.sp_cycle_agent_errorlog;
GO ';	

	EXEC msdb..sp_add_jobstep 
			@job_id = @jobId,               
			@step_id = @currentStepId,		
			@step_name = @currentStepName,	
			@subsystem = N'TSQL',			
			@command = @currentCommand,		
			@on_success_action = 1,	-- quit reporting success	
			@on_fail_action = 2,	-- quit reporting failure 
			@database_name = N'msdb',
			@retry_attempts = 2,
			@retry_interval = 1;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.enable_disk_monitoring','P') IS NOT NULL
	DROP PROC dbo.[enable_disk_monitoring];
GO

CREATE PROC dbo.[enable_disk_monitoring]
	@WarnWhenFreeGBsGoBelow				decimal(12,1)		= 22.0,				
	@HalveThresholdAgainstCDrive		bit					= 0,	
	@DriveCheckJobName					sysname				= N'Regular Drive Space Checks',
	@JobCategoryName					sysname				= N'Monitoring',
	@JobOperatorToAlertOnErrors			sysname				= N'Alerts',
	@MailProfileName					sysname				= N'General',
	@EmailSubjectPrefix					nvarchar(50)		= N'[DriveSpace Checks] ',
	@CheckFrequencyInterval				sysname				= N'20 minutes', 
	@OverWriteExistingJob				bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-- TODO: validate inputs... 
	
	DECLARE @dailyJobStartTime	time = '00:03';

	-- translate/validate job start/frequency:
	DECLARE @frequencyMinutes int;
	DECLARE @outcome int; 
	DECLARE @error nvarchar(MAX);

	EXEC @outcome = dbo.[translate_vector]
		@Vector = @CheckFrequencyInterval,
		@ValidationParameterName = N'@CheckFrequency',
		@ProhibitedIntervals = N'MILLISECOND,WEEK,MONTH,YEAR',
		@TranslationDatePart = 'MINUTE',
		@Output = @frequencyMinutes OUTPUT,
		@Error = @error OUTPUT;

	IF @outcome <> 0 BEGIN 
		RAISERROR(@error, 16, 1); 
		RETURN @outcome;
	END;

	DECLARE @scheduleFrequencyType int = 4;  -- daily (in all scenarios below)
	DECLARE @schedFrequencyInterval int;   
	DECLARE @schedSubdayType int; 
	DECLARE @schedSubdayInteval int; 
	DECLARE @translationSet bit = 0;  -- bit of a hack at this point... 

	IF @frequencyMinutes <= 0 BEGIN
		RAISERROR('Invalid value for @CheckFrequencyInterval. Intervals must be > 1 minute and <= 24 hours.', 16, 1);
		RETURN -5;
	END;

	IF @CheckFrequencyInterval LIKE '%day%' BEGIN 
		IF @frequencyMinutes > (60 * 24 * 7) BEGIN 
			RAISERROR('@CheckFrequencyInterval may not be set for > 7 days. Hours/Minutes and < 7 days are allowable options.', 16, 1);
			RETURN -20;
		END;

		SET @schedFrequencyInterval = @frequencyMinutes / (60 * 24);
		SET @schedSubdayType = 1; -- at the time specified... 
		SET @schedSubdayInteval = 0;   -- ignored... 

		SET @translationSet = 1;
	END;

	IF @CheckFrequencyInterval LIKE '%hour%' BEGIN
		IF @frequencyMinutes > (60 * 24) BEGIN 
			RAISERROR('Please specify ''day[s]'' for @CheckFrequencyInterval when setting values for > 1 day.', 16, 1);
			RETURN -21;
		END;

		SET @schedFrequencyInterval = 1;
		SET @schedSubdayType = 8;  -- hours
		SET @schedSubdayInteval = @frequencyMinutes / 60;
		SET @translationSet = 1; 
	END;
	
	IF @CheckFrequencyInterval LIKE '%minute%' BEGIN
		IF @frequencyMinutes > (60 * 24) BEGIN 
			RAISERROR('Please specify ''day[s]'' for @CheckFrequencyInterval when setting values for > 1 day.', 16, 1);
			RETURN -21;
		END;		

		SET @schedFrequencyInterval = 1;
		SET @schedSubdayType = 4;  -- minutes
		SET @schedSubdayInteval = @frequencyMinutes;
		SET @translationSet = 1;
	END;

--SELECT @scheduleFrequencyType [FreqType], @schedFrequencyInterval [FrequencyInterval], @schedSubdayType [subdayType], @schedSubdayInteval [subDayInterval];
--RETURN 0;

	IF @translationSet = 0 BEGIN
		RAISERROR('Invalid timespan value specified for @CheckFrequencyInterval. Allowable values are Minutes, Hours, and (less than) 7 days.', 16, 1);
		RETURN -30;
	END;

	DECLARE @jobId uniqueidentifier;
	EXEC dbo.[create_agent_job]
		@TargetJobName = @DriveCheckJobName,
		@JobCategoryName = @JobCategoryName,
		@AddBlankInitialJobStep = 0,	-- this isn't usually a long-running job - so it doesn't need this... 
		@OperatorToAlertOnErrorss = @JobOperatorToAlertOnErrors,
		@OverWriteExistingJobDetails = @OverWriteExistingJob,
		@JobID = @jobId OUTPUT;
	
	-- create a schedule:
	DECLARE @dateAsInt int = CAST(CONVERT(sysname, GETDATE(), 112) AS int);
	DECLARE @startTimeAsInt int = CAST((LEFT(REPLACE(CONVERT(sysname, @dailyJobStartTime, 108), N':', N''), 6)) AS int);
	DECLARE @scheduleName sysname = N'Schedule: ' + @DriveCheckJobName;

	EXEC msdb.dbo.sp_add_jobschedule 
		@job_id = @jobId,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = @scheduleFrequencyType,										
		@freq_interval = @schedFrequencyInterval,								
		@freq_subday_type = @schedSubdayType,							
		@freq_subday_interval = @schedSubdayInteval, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 0, 
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;

	-- Define Job Step for execution of checkup logic: 
	DECLARE @crlfTab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);
	DECLARE @stepBody nvarchar(MAX) = N'EXEC admindb.dbo.verify_drivespace 
	@WarnWhenFreeGBsGoBelow = {freeGBs}{halveForC}{Operator}{Profile}{Prefix};';
	
	SET @stepBody = REPLACE(@stepBody, N'{freeGBs}', CAST(@WarnWhenFreeGBsGoBelow AS sysname));

	--TODO: need a better way of handling/processing addition of non-defaults... 
	IF @HalveThresholdAgainstCDrive = 1
		SET @stepBody = REPLACE(@stepBody, N'{halveForC}', @crlfTab + N',@HalveThresholdAgainstCDrive = 1')
	ELSE 
		SET @stepBody = REPLACE(@stepBody, N'{halveForC}', N'');

	IF UPPER(@JobOperatorToAlertOnErrors) <> N'ALERTS' 
		SET @stepBody = REPLACE(@stepBody, N'{Operator}', @crlfTab + N',@OperatorName = ''' + @JobOperatorToAlertOnErrors + N'''');
	ELSE 
		SET @stepBody = REPLACE(@stepBody, N'{Operator}', N'');

	IF UPPER(@MailProfileName) <> N'GENERAL'
		SET @stepBody = REPLACE(@stepBody, N'{Profile}', @crlfTab + N',@MailProfileName = ''' + @MailProfileName + N'''');
	ELSE 
		SET @stepBody = REPLACE(@stepBody, N'{Profile}', N'');

	IF UPPER(@EmailSubjectPrefix) <> N'[DRIVESPACE CHECKS] '
		SET @stepBody = REPLACE(@stepBody, N'{Prefix}', @crlfTab + N',@EmailSubjectPrefix = ''' + @EmailSubjectPrefix + N'''');
	ELSE
		SET @stepBody = REPLACE(@stepBody, N'{Prefix}', N'');

	EXEC msdb..sp_add_jobstep
		@job_id = @jobId,
		@step_id = 1,
		@step_name = N'Check on Disk Space and Send Alerts',
		@subsystem = N'TSQL',
		@command = @stepBody,
		@on_success_action = 1,
		@on_success_step_id = 0,
		@on_fail_action = 2,
		@on_fail_step_id = 0,
		@database_name = N'admindb',
		@retry_attempts = 1,
		@retry_interval = 1;
	
	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.create_backup_jobs','P') IS NOT NULL
	DROP PROC dbo.[create_backup_jobs];
GO

CREATE PROC dbo.[create_backup_jobs]
	@UserDBTargets								sysname					= N'{USER}',
	@UserDBExclusions							sysname					= N'',
	@EncryptionCertName							sysname					= NULL,
	@BackupsDirectory							sysname					= N'{DEFAULT}', 
	@CopyToBackupDirectory						sysname					= N'',
	--@OffSiteBackupPath						sysname					= NULL, 
	@SystemBackupRetention						sysname					= N'4 days', 
	@CopyToSystemBackupRetention				sysname					= N'4 days', 
	@UserFullBackupRetention					sysname					= N'3 days', 
	@CopyToUserFullBackupRetention				sysname					= N'3 days',
	@LogBackupRetention							sysname					= N'73 hours', 
	@CopyToLogBackupRetention					sysname					= N'73 hours',
	@AllowForSecondaryServers					bit						= 0,							-- Set to 1 for Mirrored/AG'd databases. 
	@FullSystemBackupsStartTime					sysname					= N'18:50:00',					-- if '', then system backups won't be created... 
	@FullUserBackupsStartTime					sysname					= N'02:00:00',					
	@DiffBackupsStartTime						sysname					= NULL, 
	@DiffBackupsRunEvery						sysname					= NULL,							-- minutes or hours ... e.g., N'4 hours' or '180 minutes', etc. 
	@LogBackupsStartTime						sysname					= N'00:02:00',					-- ditto ish
	@LogBackupsRunEvery							sysname					= N'10 minutes',				-- vector, but only allows minutes (i think).
	@TimeZoneForUtcOffset									sysname					= NULL,							-- IF the server is running on UTC time, this is the time-zone you want to adjust backups to (i.e., 2AM UTC would be 4PM pacific - not a great time for full backups. Values ...   e.g., 'Central Standard Time', 'Pacific Standard Time', 'Eastern Daylight Time' 
	@JobsNamePrefix								sysname					= N'Database Backups - ',		-- e.g., "Database Backups - USER - FULL" or "Database Backups - USER - LOG" or "Database Backups - SYSTEM - FULL"
	@JobsCategoryName							sysname					= N'Backups',							
	@JobOperatorToAlertOnErrors					sysname					= N'Alerts',	
	@ProfileToUseForAlerts						sysname					= N'General',
	@OverWriteExistingJobs						bit						= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
    DECLARE @check int;

	EXEC @check = dbo.verify_advanced_capabilities;
    IF @check <> 0
        RETURN @check;

    EXEC @check = dbo.verify_alerting_configuration
        @JobOperatorToAlertOnErrors, 
        @ProfileToUseForAlerts;

    IF @check <> 0 
        RETURN @check;

	-- TODO: validate inputs: 
	SET @EncryptionCertName = NULLIF(@EncryptionCertName, N'');
	SET @DiffBackupsStartTime = NULLIF(@DiffBackupsStartTime, N'');
	SET @TimeZoneForUtcOffset = NULLIF(@TimeZoneForUtcOffset, N'');

	IF NULLIF(@DiffBackupsStartTime, N'') IS NOT NULL AND @DiffBackupsRunEvery IS NULL BEGIN 
		RAISERROR('@DiffBackupsRunEvery must be set/specified when a @DiffBackupsStartTime is specified.', 16, 1);
		RETURN -2;
	END;

	-- translate 'local' timezone to UTC-zoned servers:
	IF @TimeZoneForUtcOffset IS NOT NULL BEGIN 
		IF (SELECT [dbo].[get_engine_version]()) >= 13.0 BEGIN 
			IF NOT EXISTS (SELECT NULL FROM sys.[time_zone_info] WHERE [name] = @TimeZoneForUtcOffset) BEGIN
				RAISERROR(N'Invalid Time-Zone Specified: %s.', 16, 1, @TimeZoneForUtcOffset);
				RETURN -10;
			END;

			DECLARE @utc datetime = GETUTCDATE();
			DECLARE @atTimeZone datetime;
			
			DECLARE @offsetSQL nvarchar(MAX) = N'SELECT @atTimeZone = @utc AT TIME ZONE ''UTC'' AT TIME ZONE @TimeZoneForUtcOffset; ';
			
			EXEC sys.[sp_executesql]
				@offsetSQL, 
				N'@atTimeZone datetime OUTPUT, @utc datetime, @TimeZoneForUtcOffset sysname', 
				@atTimeZone = @atTimeZone OUTPUT, 
				@utc = @utc, 
				@TimeZoneForUtcOffset = @TimeZoneForUtcOffset;

		  END;
		ELSE BEGIN 
			-- TODO: I might be able to pull this info out of the registry? https://learn.microsoft.com/en-us/sql/relational-databases/system-catalog-views/sys-time-zone-info-transact-sql?view=sql-server-ver16  

			RAISERROR('@TimeZoneForUtcOffset is NOT supported on SQL Server versions prior to SQL Server 2016. Set value to NULL.', 16, 1); 
			RETURN -100;
		END;

		SET @FullSystemBackupsStartTime = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @FullSystemBackupsStartTime);
		SET @FullUserBackupsStartTime = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @FullUserBackupsStartTime);
		SET @LogBackupsStartTime = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @LogBackupsStartTime);
		SET @DiffBackupsStartTime = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @DiffBackupsStartTime);
	END;

	DECLARE @systemStart time, @userStart time, @logStart time, @diffStart time;
	SELECT 
		@systemStart	= CAST(@FullSystemBackupsStartTime AS time), 
		@userStart		= CAST(@FullUserBackupsStartTime AS time), 
		@logStart		= CAST(@LogBackupsStartTime AS time), 
		@diffStart		= CAST(@DiffBackupsStartTime AS time);

	DECLARE @logFrequencyMinutes int;
	DECLARE @diffFrequencyMinutes int;
	DECLARE @outcome int; 
	DECLARE @error nvarchar(MAX);

	EXEC @outcome = dbo.[translate_vector]
		@Vector = @LogBackupsRunEvery,
		@ValidationParameterName = N'@LogBackupsRunEvery',
		@ProhibitedIntervals = N'MILLISECOND,SECOND,HOUR,DAY,WEEK,MONTH,YEAR',
		@TranslationDatePart = 'MINUTE',
		@Output = @logFrequencyMinutes OUTPUT,
		@Error = @error OUTPUT;

	IF @outcome <> 0 BEGIN 
		RAISERROR(@error, 16, 1); 
		RETURN @outcome;
	END;

	IF @diffStart IS NOT NULL BEGIN 

		EXEC @outcome = dbo.[translate_vector]
			@Vector = @DiffBackupsRunEvery,
			@ValidationParameterName = N'@DiffBackupsRunEvery',
			@ProhibitedIntervals = N'MILLISECOND,SECOND,DAY,WEEK,MONTH,YEAR',
			@TranslationDatePart = 'MINUTE',
			@Output = @diffFrequencyMinutes OUTPUT,
			@Error = @error OUTPUT;

		IF @outcome <> 0 BEGIN 
			RAISERROR(@error, 16, 1); 
			RETURN @outcome;
		END;

		IF @diffFrequencyMinutes > 90 BEGIN
			DECLARE @remainder int = (SELECT @diffFrequencyMinutes % 60);
			IF @remainder <> 0 BEGIN 
				RAISERROR(N'@DiffBackupsRunEvery can only be specified in minutes up to a max of 90 minutes - otherwise, they must be specified in hours (e.g., 2 hours, 4 hours, or 28 minutes are all valid inputs).', 16, 1);
				RETURN - 100;
			END;

			IF @diffFrequencyMinutes > 1200 BEGIN 
				RAISERROR(N'@DiffBackupsRunEvery can not be > 1200 minutes.', 16, 1);
				RETURN -101;
			END;
		END;
	END;

	DECLARE @backupsTemplate nvarchar(MAX) = N'EXEC admindb.dbo.[backup_databases]
	@BackupType = N''{backupType}'',
	@DatabasesToBackup = N''{targets}'',
	@DatabasesToExclude = N''{exclusions}'',
	@BackupDirectory = N''{backupsDirectory}'',{copyToDirectory}
	@BackupRetention = N''{retention}'',{copyToRetention}{encryption}
	@LogSuccessfulOutcomes = 1,{secondaries}{operator}{profile}
	@PrintOnly = 0;';

	DECLARE @sysBackups nvarchar(MAX), @userBackups nvarchar(MAX), @diffBackups nvarchar(MAX), @logBackups nvarchar(MAX);
	DECLARE @crlfTab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);

	-- 'global' template config settings/options: 
	SET @backupsTemplate = REPLACE(@backupsTemplate, N'{backupsDirectory}', @BackupsDirectory);
	
	IF NULLIF(@EncryptionCertName, N'') IS NULL 
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{encryption}', N'');
	ELSE 
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{encryption}', @crlfTab + N'@EncryptionCertName = N''' + @EncryptionCertName + N''',' + @crlfTab + N'@EncryptionAlgorithm = N''AES_256'',');

	IF NULLIF(@CopyToBackupDirectory, N'') IS NULL BEGIN
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{copyToDirectory}', N'');
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{copyToRetention}', N'');
	  END;
	ELSE BEGIN
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{copyToDirectory}', @crlfTab + N'@CopyToBackupDirectory = N''' + @CopyToBackupDirectory + N''', ');
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{copyToRetention}', @crlfTab + N'@CopyToRetention = N''{copyRetention}'', ');
	END;

	IF NULLIF(@JobOperatorToAlertOnErrors, N'') IS NULL
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{operator}', N'');
	ELSE 
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{operator}', @crlfTab + N'@OperatorName = N''' + @JobOperatorToAlertOnErrors + N''', ');

	IF NULLIF(@ProfileToUseForAlerts, N'') IS NULL
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{profile}', N'');
	ELSE 
		SET @backupsTemplate = REPLACE(@backupsTemplate, N'{profile}', @crlfTab + N'@MailProfileName = N''' + @ProfileToUseForAlerts + N''', ');

	-- system backups: 
	SET @sysBackups = REPLACE(@backupsTemplate, N'{exclusions}', N'');

	IF @AllowForSecondaryServers = 0 
		SET @sysBackups = REPLACE(@sysBackups, N'{secondaries}', N'');
	ELSE 
		SET @sysBackups = REPLACE(@sysBackups, N'{secondaries}', @crlfTab + N'@AddServerNameToSystemBackupPath = 1, ');

	SET @sysBackups = REPLACE(@sysBackups, N'{backupType}', N'FULL');
	SET @sysBackups = REPLACE(@sysBackups, N'{targets}', N'{SYSTEM}');
	SET @sysBackups = REPLACE(@sysBackups, N'{retention}', @SystemBackupRetention);
	SET @sysBackups = REPLACE(@sysBackups, N'{copyRetention}', ISNULL(@CopyToSystemBackupRetention, N''));

	-- Make sure to exclude _s4test dbs from USER backups: 
	IF NULLIF(@UserDBExclusions, N'') IS NULL 
		SET @UserDBExclusions = N'%s4test';
	ELSE BEGIN 
		IF @UserDBExclusions NOT LIKE N'%s4test%'
			SET @UserDBExclusions = @UserDBExclusions + N', %s4test';
	END;

	SET @backupsTemplate = REPLACE(@backupsTemplate, N'{exclusions}', @UserDBExclusions);

	-- MKC: this code is terrible (i.e., the copy/paste/tweak of 3x roughly similar calls - for full, diff, log - but with slightly diff parameters.
	-- full user backups: 
	SET @userBackups = @backupsTemplate;

	IF @AllowForSecondaryServers = 0 
		SET @userBackups = REPLACE(@userBackups, N'{secondaries}', N'');
	ELSE 
		SET @userBackups = REPLACE(@userBackups, N'{secondaries}', @crlfTab + N'@AllowNonAccessibleSecondaries = 1, ');

	SET @userBackups = REPLACE(@userBackups, N'{backupType}', N'FULL');
	SET @userBackups = REPLACE(@userBackups, N'{targets}', @UserDBTargets);
	SET @userBackups = REPLACE(@userBackups, N'{retention}', @UserFullBackupRetention);
	SET @userBackups = REPLACE(@userBackups, N'{copyRetention}', ISNULL(@CopyToUserFullBackupRetention, N''));
	SET @userBackups = REPLACE(@userBackups, N'{exclusions}', @UserDBExclusions);

	-- diff user backups: 
	SET @diffBackups = @backupsTemplate;

	IF @AllowForSecondaryServers = 0 
		SET @diffBackups = REPLACE(@diffBackups, N'{secondaries}', N'');
	ELSE 
		SET @diffBackups = REPLACE(@diffBackups, N'{secondaries}', @crlfTab + N'@AllowNonAccessibleSecondaries = 1, ');

	SET @diffBackups = REPLACE(@diffBackups, N'{backupType}', N'DIFF');
	SET @diffBackups = REPLACE(@diffBackups, N'{targets}', @UserDBTargets);
	SET @diffBackups = REPLACE(@diffBackups, N'{retention}', @UserFullBackupRetention);
	SET @diffBackups = REPLACE(@diffBackups, N'{copyRetention}', ISNULL(@CopyToUserFullBackupRetention, N''));
	SET @diffBackups = REPLACE(@diffBackups, N'{exclusions}', @UserDBExclusions);

	-- log backups: 
	SET @logBackups = @backupsTemplate;

	IF @AllowForSecondaryServers = 0 
		SET @logBackups = REPLACE(@logBackups, N'{secondaries}', N'');
	ELSE 
		SET @logBackups = REPLACE(@logBackups, N'{secondaries}', @crlfTab + N'@AllowNonAccessibleSecondaries = 1, ');

	SET @logBackups = REPLACE(@logBackups, N'{backupType}', N'LOG');
	SET @logBackups = REPLACE(@logBackups, N'{targets}', @UserDBTargets);
	SET @logBackups = REPLACE(@logBackups, N'{retention}', @LogBackupRetention);
	SET @logBackups = REPLACE(@logBackups, N'{copyRetention}', ISNULL(@CopyToLogBackupRetention, N''));
	SET @logBackups = REPLACE(@logBackups, N'{exclusions}', @UserDBExclusions);

	DECLARE @jobs table (
		job_id int IDENTITY(1,1) NOT NULL, 
		job_name sysname NOT NULL, 
		job_step_name sysname NOT NULL, 
		job_body nvarchar(MAX) NOT NULL,
		job_start_time time NULL
	);

	INSERT INTO @jobs (
		[job_name],
		[job_step_name],
		[job_body],
		[job_start_time]
	)
	VALUES	
	(
		N'SYSTEM - Full', 
		N'FULL Backup of SYSTEM Databases', 
		@sysBackups, 
		@systemStart
	), 
	(
		N'USER - Full', 
		N'FULL Backup of USER Databases', 
		@userBackups, 
		@userStart
	), 
	(
		N'USER - Diff', 
		N'DIFF Backup of USER Databases', 
		@diffBackups, 
		@diffStart
	), 
	(
		N'USER - Log', 
		N'TLOG Backup of USER Databases', 
		@logBackups, 
		@logStart
	);
	
	DECLARE @currentJobSuffix sysname, @currentJobStep sysname, @currentJobStepBody nvarchar(MAX), @currentJobStart time;

	DECLARE @currentJobName sysname;
	DECLARE @existingJob sysname; 
	DECLARE @jobID uniqueidentifier;

	DECLARE @dateAsInt int;
	DECLARE @startTimeAsInt int; 
	DECLARE @scheduleName sysname;

	DECLARE @schedSubdayType int; 
	DECLARE @schedSubdayInteval int; 
	
	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[job_name],
		[job_step_name],
		[job_body],
		[job_start_time]
	FROM 
		@jobs
	WHERE 
		[job_start_time] IS NOT NULL -- don't create jobs for 'tasks' without start times.
	ORDER BY 
		[job_id];
	
	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @currentJobSuffix, @currentJobStep, @currentJobStepBody, @currentJobStart;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
	
		SET @currentJobName =  @JobsNamePrefix + @currentJobSuffix;

		SET @jobID = NULL;
		EXEC [admindb].[dbo].[create_agent_job]
			@TargetJobName = @currentJobName,
			@JobCategoryName = @JobsCategoryName,
			@JobEnabled = 0, -- create backup jobs as disabled (i.e., require admin review + manual intervention to enable... 
			@AddBlankInitialJobStep = 1,
			@OperatorToAlertOnErrorss = @JobOperatorToAlertOnErrors,
			@OverWriteExistingJobDetails = @OverWriteExistingJobs,
			@JobID = @jobID OUTPUT;
		
		-- create a schedule:
		SET @dateAsInt = CAST(CONVERT(sysname, GETDATE(), 112) AS int);
		SET @startTimeAsInt = CAST((LEFT(REPLACE(CONVERT(sysname, @currentJobStart, 108), N':', N''), 6)) AS int);
		SET @scheduleName = @currentJobName + N' Schedule';

		IF (@currentJobName LIKE '%Log%') OR (@currentJobName LIKE '%Diff%') BEGIN 
			IF (@currentJobName LIKE '%Log%') BEGIN
				SET @schedSubdayType = 4; -- every N minutes
				SET @schedSubdayInteval = @logFrequencyMinutes;
			
			  END;
			 ELSE BEGIN
				IF @diffFrequencyMinutes > 90 BEGIN
					SET @schedSubdayType = 8; -- every N hours
					SET @schedSubdayInteval = @diffFrequencyMinutes / 60;
				  END;
				ELSE BEGIN 
					SET @schedSubdayType = 4;
					SET @schedSubdayInteval = @diffFrequencyMinutes;
				END;
			END;
		  END; 
		ELSE BEGIN 
			SET @schedSubdayType = 1; -- at the specified (start) time. 
			SET @schedSubdayInteval = 0
		END;

		EXEC msdb.dbo.sp_add_jobschedule 
			@job_id = @jobID,
			@name = @scheduleName,
			@enabled = 1, 
			@freq_type = 4,  -- daily										
			@freq_interval = 1,  -- every 1 days... 								
			@freq_subday_type = @schedSubdayType,							
			@freq_subday_interval = @schedSubdayInteval, 
			@freq_relative_interval = 0, 
			@freq_recurrence_factor = 0, 
			@active_start_date = @dateAsInt, 
			@active_start_time = @startTimeAsInt;

		-- now add the job step:
		EXEC msdb..sp_add_jobstep
			@job_id = @jobID,
			@step_id = 2,		-- place-holder already defined for step 1
			@step_name = @currentJobStep,
			@subsystem = N'TSQL',
			@command = @currentJobStepBody,
			@on_success_action = 1,		-- quit reporting success
			@on_fail_action = 2,		-- quit reporting failure 
			@database_name = N'admindb',
			@retry_attempts = 0,
			@retry_interval = 0;
	
	FETCH NEXT FROM [walker] INTO @currentJobSuffix, @currentJobStep, @currentJobStepBody, @currentJobStart;
	END;
	
	CLOSE [walker];
	DEALLOCATE [walker];
	
	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.create_restore_test_job','P') IS NOT NULL
	DROP PROC dbo.[create_restore_test_job];
GO

CREATE PROC dbo.[create_restore_test_job]
    @JobName						sysname				= N'Database Backups - Regular Restore Tests',
	@RestoreTestStartTime			time				= N'22:30:00',
	@TimeZoneForUtcOffset			sysname				= NULL,				-- IF the server is running on UTC time, this is the time-zone you want to adjust backups to (i.e., 2AM UTC would be 4PM pacific - not a great time for full backups. Values ...   e.g., 'Central Standard Time', 'Pacific Standard Time', 'Eastern Daylight Time' 
	@JobCategoryName				sysname				= N'Backups',
	@AllowForSecondaries			bit					= 0,									-- IF AG/Mirrored environment (secondaries), then wrap restore-test in IF is_primary_server check... 
    @DatabasesToRestore				nvarchar(MAX)		= N'{READ_FROM_FILESYSTEM}', 
    @DatabasesToExclude				nvarchar(MAX)		= N'',									-- TODO: document specialized logic here... 
    @Priorities						nvarchar(MAX)		= NULL,
    @BackupsRootPath				nvarchar(MAX)		= N'{DEFAULT}',
    @RestoredRootDataPath			nvarchar(MAX)		= N'{DEFAULT}',
    @RestoredRootLogPath			nvarchar(MAX)		= N'{DEFAULT}',
    @RestoredDbNamePattern			nvarchar(40)		= N'{0}_s4test',
    @AllowReplace					nchar(7)			= NULL,									-- NULL or the exact term: N'REPLACE'...
	@RpoWarningThreshold			nvarchar(10)		= N'24 hours',							-- Only evaluated if non-NULL. 
    @DropDatabasesAfterRestore		bit					= 1,									-- Only works if set to 1, and if we've RESTORED the db in question. 
    @MaxNumberOfFailedDrops			int					= 1,									-- number of failed DROP operations we'll tolerate before early termination.
	@OperatorName					sysname				= N'Alerts',
    @MailProfileName				sysname				= N'General',
    @EmailSubjectPrefix				nvarchar(50)		= N'[RESTORE TEST] ',
	@OverWriteExistingJob			bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-- TODO: validate inputs... 
	SET @TimeZoneForUtcOffset = NULLIF(@TimeZoneForUtcOffset, N'');
	SET @Priorities = NULLIF(@Priorities, N'');
	SET @AllowReplace = NULLIF(@AllowReplace, N'');

	-- translate 'local' timezone to UTC-zoned servers:
	IF @TimeZoneForUtcOffset IS NOT NULL BEGIN 
		IF (SELECT [dbo].[get_engine_version]()) >= 13.0 BEGIN 

			DECLARE @utc datetime = GETUTCDATE();
			DECLARE @atTimeZone datetime;
			DECLARE @offsetSQL nvarchar(MAX) = N'SELECT @atTimeZone = @utc AT TIME ZONE ''UTC'' AT TIME ZONE @TimeZoneForUtcOffset; ';
			
			EXEC sys.[sp_executesql]
				@offsetSQL, 
				N'@atTimeZone datetime OUTPUT, @utc datetime, @TimeZoneForUtcOffset sysname', 
				@atTimeZone = @atTimeZone OUTPUT, 
				@utc = @utc, 
				@TimeZoneForUtcOffset = @TimeZoneForUtcOffset;

			SET @RestoreTestStartTime = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @RestoreTestStartTime);
		  END;
		ELSE BEGIN 
			RAISERROR('@TimeZoneForUtcOffset is NOT supported on SQL Server versions prior to SQL Server 2016. Set value to NULL.', 16, 1); 
			RETURN -100;
		END;
	END;

	DECLARE @restoreStart time;
	SELECT 
		@restoreStart	= CAST(@RestoreTestStartTime AS time);

	-- Typical Use-Case/Pattern: 
	IF UPPER(@AllowReplace) <> N'REPLACE' AND @DropDatabasesAfterRestore IS NULL 
		SET @DropDatabasesAfterRestore = 1;

	-- Define the Job Step: 
	DECLARE @restoreTemplate nvarchar(MAX) = N'EXEC admindb.dbo.restore_databases  
	@DatabasesToRestore = N''{targets}'',{exclusions}{priorities}
	@BackupsRootPath = N''{backupsPath}'',
	@RestoredRootDataPath = N''{dataPath}'',
	@RestoredRootLogPath = N''{logPath}'',
	@RestoredDbNamePattern = N''{restorePattern}'',{replace}{rpo}{operator}{profile}
	@DropDatabasesAfterRestore = {drop},
	@PrintOnly = 0; ';

	IF @AllowForSecondaries = 1 BEGIN 
		SET @restoreTemplate = N'IF (SELECT admindb.dbo.is_primary_server()) = 1 BEGIN
	EXEC admindb.dbo.restore_databases  
		@DatabasesToRestore = N''{targets}'',{exclusions}{priorities}
		@BackupsRootPath = N''{backupsPath}'',
		@RestoredRootDataPath = N''{dataPath}'',
		@RestoredRootLogPath = N''{logPath}'',
		@RestoredDbNamePattern = N''{restorePattern}'',{replace}{rpo}{operator}{profile}
		@DropDatabasesAfterRestore = {drop},
		@PrintOnly = 0; 
END;'

	END;

	DECLARE @crlfTab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);
	DECLARE @jobStepBody nvarchar(MAX) = @restoreTemplate;

	-- TODO: document the 'special case' of SYSTEM as exclusions... 
	IF @DatabasesToRestore IN (N'{READ_FROM_FILESYSTEM}', N'{ALL}') BEGIN 
		IF NULLIF(@DatabasesToExclude, N'') IS NULL 
			SET @DatabasesToExclude = N'{SYSTEM}'
		ELSE BEGIN
			IF @DatabasesToExclude NOT LIKE N'%{SYSTEM}%' BEGIN
				SET @DatabasesToExclude = N'{SYSTEM},' + @DatabasesToExclude;
			END;
		END;
	END;

	IF NULLIF(@DatabasesToExclude, N'') IS NULL 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{exclusions}', N'');
	ELSE 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{exclusions}', @crlfTab + N'@DatabasesToExclude = ''' + @DatabasesToExclude + N''', ');

	IF NULLIF(@OperatorName, N'Alerts') IS NULL 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{operator}', N'');
	ELSE 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{operator}', @crlfTab + N'@OperatorName = ''' + @OperatorName + N''', ');

	IF NULLIF(@MailProfileName, N'General') IS NULL 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{profile}', N'');
	ELSE 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{profile}', @crlfTab + N'@MailProfileName = ''' + @MailProfileName + N''', ');

	IF NULLIF(@Priorities, N'') IS NULL 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{priorities}', N'');
	ELSE 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{priorities}', @crlfTab + N'@Priorities = N''' + @Priorities + N''', ');

	IF NULLIF(@AllowReplace, N'') IS NULL
		SET @jobStepBody = REPLACE(@jobStepBody, N'{replace}', N'');
	ELSE 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{replace}', @crlfTab + N'@AllowReplace = N''' + @AllowReplace + N''', ');

	IF NULLIF(@RpoWarningThreshold, N'') IS NULL
		SET @jobStepBody = REPLACE(@jobStepBody, N'{rpo}', N'');
	ELSE 
		SET @jobStepBody = REPLACE(@jobStepBody, N'{rpo}', @crlfTab + N'@RpoWarningThreshold = N''' + @RpoWarningThreshold + N''', ');

	SET @jobStepBody = REPLACE(@jobStepBody, N'{targets}', @DatabasesToRestore);
	SET @jobStepBody = REPLACE(@jobStepBody, N'{backupsPath}', @BackupsRootPath);
	SET @jobStepBody = REPLACE(@jobStepBody, N'{dataPath}', @RestoredRootDataPath);
	SET @jobStepBody = REPLACE(@jobStepBody, N'{logPath}', @RestoredRootLogPath);
	SET @jobStepBody = REPLACE(@jobStepBody, N'{restorePattern}', @RestoredDbNamePattern);

	SET @jobStepBody = REPLACE(@jobStepBody, N'{drop}', CAST(@DropDatabasesAfterRestore AS sysname));

	DECLARE @jobId uniqueidentifier = NULL;
	EXEC [dbo].[create_agent_job]
		@TargetJobName = @JobName,
		@JobCategoryName = @JobCategoryName,
		@JobEnabled = 0, -- create restore-test job as disabled (i.e., require admin review + manual intervention to enable... 
		@AddBlankInitialJobStep = 1,
		@OperatorToAlertOnErrorss = @OperatorName,
		@OverWriteExistingJobDetails = @OverWriteExistingJob,
		@JobID = @jobId OUTPUT;
	
	-- create a schedule:
	DECLARE @dateAsInt int = CAST(CONVERT(sysname, GETDATE(), 112) AS int);
	DECLARE @startTimeAsInt int = CAST((LEFT(REPLACE(CONVERT(sysname, @restoreStart, 108), N':', N''), 6)) AS int);
	DECLARE @scheduleName sysname = @JobName + ' Schedule';

	EXEC msdb.dbo.sp_add_jobschedule 
		@job_id = @jobId,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = 4,		-- daily								
		@freq_interval = 1, -- every 1 days							
		@freq_subday_type = 1,	-- at the scheduled time... 					
		@freq_subday_interval = 0, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 0, 
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;

	-- and add the job step: 
	EXEC msdb..sp_add_jobstep
		@job_id = @jobId,
		@step_id = 2,		-- place-holder defined as job-step 1.
		@step_name = N'Restore Tests',
		@subsystem = N'TSQL',
		@command = @jobStepBody,
		@on_success_action = 1,
		@on_success_step_id = 0,
		@on_fail_action = 2,
		@on_fail_step_id = 0,
		@database_name = N'admindb',
		@retry_attempts = 0,
		@retry_interval = 0;
	
	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.create_index_maintenance_jobs','P') IS NOT NULL
	DROP PROC dbo.[create_index_maintenance_jobs];
GO

CREATE PROC dbo.[create_index_maintenance_jobs]
	@DailyJobRunsOnDays							sysname					= N'M,W,F',			-- allow for whatever makes sense - i.e., all... or M,W,F and so on... 
	@WeekendJobRunsOnDays						sysname					= N'Su',				-- allow for one or both... 
	@IXMaintenanceJobStartTime					sysname					= N'21:50:00',				-- or whatever... (and note that UTC offset here ... could be tricky... 
	@TimeZoneForUtcOffset						sysname					= NULL,						-- IF the server is running on UTC time, this is the time-zone you want to adjust backups to (i.e., 2AM UTC would be 4PM pacific - not a great time for full backups. Values ...   e.g., 'Central Standard Time', 'Pacific Standard Time', 'Eastern Daylight Time' 
	@JobsNamePrefix								sysname					= N'Index Maintenance - ',
	@JobsCategoryName							sysname					= N'Database Maintenance',							
	@JobOperatorToAlertOnErrors					sysname					= N'Alerts',	
	@OverWriteExistingJobs						bit						= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	-- Validate Inputs: 
	SET @DailyJobRunsOnDays = ISNULL(NULLIF(@DailyJobRunsOnDays, N''), N'M,W,F');
	SET @WeekendJobRunsOnDays = ISNULL(NULLIF(@WeekendJobRunsOnDays, N''), N'Su');
	
	SET @TimeZoneForUtcOffset = NULLIF(@TimeZoneForUtcOffset, N'');

	DECLARE @days table (
		abbreviation sysname,
		day_name sysname, 
		bit_map int 
	);

	INSERT INTO @days (
		[abbreviation],
		[day_name],
		[bit_map]
	)
	VALUES	
		(N'Su', N'Sunday', 1),
		(N'Sun', N'Sunday', 1),
		(N'M', N'Monday', 2),
		(N'T', N'Tuesday', 4),
		(N'Tu', N'Tuesday', 4),
		(N'W', N'Wednesday', 8),
		(N'Th', N'Thursday', 16),
		(N'Thu', N'Thursday', 16),
		(N'F', N'Friday', 32),
		(N'Sa', N'Saturday', 64),
		(N'Sat', N'Saturday', 64);

	-- TODO: verify that @DailyJobsRunsOnDays and @WeekendJobRunsOnDays are 'in' the approved [abbreviation]s defined in @days.


	IF NULLIF(@IXMaintenanceJobStartTime, N'') IS NULL BEGIN 
		RAISERROR('@IXMaintenanceJobStartTime can NOT be NULL - please specify a start-time - e.g., ''04:20:00''.', 16, 1);
		RETURN -2;
	END;

	-- translate 'local' timezone to UTC-zoned servers:
	IF @TimeZoneForUtcOffset IS NOT NULL BEGIN 
		IF (SELECT [dbo].[get_engine_version]()) >= 13.0 BEGIN 

			DECLARE @utc datetime = GETUTCDATE();
			DECLARE @atTimeZone datetime;
			DECLARE @offsetSQL nvarchar(MAX) = N'SELECT @atTimeZone = @utc AT TIME ZONE ''UTC'' AT TIME ZONE @TimeZoneForUtcOffset; ';
			
			EXEC sys.[sp_executesql]
				@offsetSQL, 
				N'@atTimeZone datetime OUTPUT, @utc datetime, @TimeZoneForUtcOffset sysname', 
				@atTimeZone = @atTimeZone OUTPUT, 
				@utc = @utc, 
				@TimeZoneForUtcOffset = @TimeZoneForUtcOffset;

			SET @IXMaintenanceJobStartTime = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @IXMaintenanceJobStartTime);
		  END;
		ELSE BEGIN
			RAISERROR('@TimeZoneForUtcOffset is NOT supported on SQL Server versions prior to SQL Server 2016. Set value to NULL.', 16, 1); 
			RETURN -100;
		END;
	END;

	DECLARE @weekDayIxTemplate nvarchar(MAX) = N'EXECUTE [master].dbo.IndexOptimize
	@Databases = ''ALL_DATABASES'',
	@FragmentationLow = NULL,
	@FragmentationMedium = ''INDEX_REORGANIZE'',
	@FragmentationHigh = ''INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE'',
	@FragmentationLevel1 = 40,
	@FragmentationLevel2 = 70, 
	@MSShippedObjects = ''Y'', -- include system objects/etc.
	@LogToTable = ''Y'',
	@UpdateStatistics = ''ALL'';  ';

	DECLARE @weekendIxTemplate nvarchar(MAX) = N'EXECUTE [master].dbo.IndexOptimize
	@Databases = ''ALL_DATABASES'',
	@FragmentationLow = NULL,
	@FragmentationMedium = ''INDEX_REORGANIZE'',
	@FragmentationHigh = ''INDEX_REBUILD_ONLINE,INDEX_REBUILD_OFFLINE'',
	@FragmentationLevel1 = 20,
	@FragmentationLevel2 = 40, 
	@MSShippedObjects = ''Y'', -- include system objects/etc.
	@UpdateStatistics = ''ALL'', 
	@LogToTable = ''Y''; ';

	DECLARE @jobId uniqueidentifier; 
	DECLARE @jobName sysname = @JobsNamePrefix + N'WeekDay';
	DECLARE @dateAsInt int;
	DECLARE @startTimeAsInt int; 
	DECLARE @scheduleName sysname;

	DECLARE @weekdayInterval int; 
	DECLARE @weekendInterval int; 

	EXEC dbo.[create_agent_job]
		@TargetJobName = @jobName,
		@JobCategoryName = @JobsCategoryName,
		@JobEnabled = 0,
		@AddBlankInitialJobStep = 1,
		@OperatorToAlertOnErrorss = @JobOperatorToAlertOnErrors,
		@OverWriteExistingJobDetails = @OverWriteExistingJobs,
		@JobID = @jobId OUTPUT;

	-- create a schedule:
	SET @dateAsInt = CAST(CONVERT(sysname, GETDATE(), 112) AS int);
	SET @startTimeAsInt = CAST((LEFT(REPLACE(CONVERT(sysname, CAST(@IXMaintenanceJobStartTime AS datetime), 108), N':', N''), 6)) AS int);
	SET @scheduleName = @jobName + N' Schedule';
	
	SELECT 
		@weekdayInterval = SUM(x.[bit_map])
	FROM 
		@days x 
		INNER JOIN (
			SELECT 
				CAST([result] AS sysname) [abbreviation]
			FROM 
				dbo.[split_string](@DailyJobRunsOnDays, N',', 1)
		) y ON [x].[abbreviation] = [y].[abbreviation];

	EXEC msdb.dbo.sp_add_jobschedule 
		@job_id = @jobId,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = 8,  -- weekly
		@freq_interval = @weekdayInterval,  -- every bit-map days... 					
		@freq_subday_type = 1,  -- at specified time... 							
		@freq_subday_interval = 0, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 1, -- every 1 weeks
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;

	-- add a job-step: 
	EXEC msdb..sp_add_jobstep
		@job_id = @jobId,
		@step_id = 2,		-- place-holder already defined for step 1
		@step_name = N'Weekday Index Maintenance',
		@subsystem = N'TSQL',
		@command = @weekDayIxTemplate,
		@on_success_action = 1,		-- quit reporting success
		@on_fail_action = 2,		-- quit reporting failure 
		@database_name = N'master',
		@retry_attempts = 0,
		@retry_interval = 0;

	-- Reset and create a job for weekend maintenance
	SET @jobId = NULL;

	SET @jobName = @JobsNamePrefix + N'Weekend';

	EXEC dbo.[create_agent_job]
		@TargetJobName = @jobName,
		@JobCategoryName = @JobsCategoryName,
		@JobEnabled = 0,
		@AddBlankInitialJobStep = 1,
		@OperatorToAlertOnErrorss = @JobOperatorToAlertOnErrors,
		@OverWriteExistingJobDetails = @OverWriteExistingJobs,
		@JobID = @jobId OUTPUT;

	-- define the schedule:
	SET @scheduleName = @jobName + N' Schedule';

	SELECT 
		@weekendInterval = SUM(x.[bit_map])
	FROM 
		@days x 
		INNER JOIN (
			SELECT 
				CAST([result] AS sysname) [abbreviation]
			FROM 
				dbo.[split_string](@WeekendJobRunsOnDays, N',', 1)
		) y ON [x].[abbreviation] = [y].[abbreviation];

	EXEC msdb.dbo.sp_add_jobschedule 
		@job_id = @jobId,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = 8,  -- weekly
		@freq_interval = @weekendInterval,  -- every bit-map days... 					
		@freq_subday_type = 1,  -- at specified time... 							
		@freq_subday_interval = 0, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 1, 
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;

	EXEC msdb..sp_add_jobstep
		@job_id = @jobId,
		@step_id = 2,		-- place-holder already defined for step 1
		@step_name = N'Weekend Index Maintenance',
		@subsystem = N'TSQL',
		@command = @weekendIxTemplate,
		@on_success_action = 1,		-- quit reporting success
		@on_fail_action = 2,		-- quit reporting failure 
		@database_name = N'master',
		@retry_attempts = 0,
		@retry_interval = 0;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.create_consistency_checks_job','P') IS NOT NULL
	DROP PROC dbo.[create_consistency_checks_job];
GO

CREATE PROC dbo.[create_consistency_checks_job]
	@ExecutionDays							sysname									= N'M, W, F, Su',
	@JobStartTime							sysname									= N'04:10:00',
	@JobName								sysname									= N'Database Consistency Checks',
	@JobCategoryName						sysname									= N'Database Maintenance',			
	@TimeZoneForUtcOffset					sysname									= NULL,
	@Targets								nvarchar(MAX)	                        = N'{ALL}',		-- {ALL} | {SYSTEM} | {USER} | comma,delimited,list, of, databases, where, spaces, do,not,matter
	@Exclusions								nvarchar(MAX)	                        = NULL,			-- comma, delimited, list, of, db, names, %wildcards_allowed%
	@Priorities								nvarchar(MAX)	                        = NULL,			-- higher,priority,dbs,*,lower,priority, dbs  (where * is an ALPHABETIZED list of all dbs that don't match a priority (positive or negative)). If * is NOT specified, the following is assumed: high, priority, dbs, [*]
	@IncludeExtendedLogicalChecks           bit                                     = 0,
    @OperatorName						    sysname									= N'Alerts',
	@MailProfileName					    sysname									= N'General',
	@EmailSubjectPrefix					    nvarchar(50)							= N'[Database Corruption Checks] ',	
    @OverWriteExistingJobs					bit										= 0

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ExecutionDays = ISNULL(NULLIF(@ExecutionDays, N''), N'M, W, F, Su');
	SET @JobName = ISNULL(NULLIF(@JobName, N''), N'Database Consistency Checks');
	SET @JobCategoryName = ISNULL(NULLIF(@JobCategoryName, N''), N'Database Maintenance');
	
	SET @TimeZoneForUtcOffset = NULLIF(@TimeZoneForUtcOffset, N'');

	/*  Dependencies Validation: */ 
    DECLARE @check int;

	EXEC @check = dbo.verify_advanced_capabilities;
    IF @check <> 0
        RETURN @check;

    EXEC @check = dbo.verify_alerting_configuration
        @OperatorName, 
        @MailProfileName;

    IF @check <> 0 
        RETURN @check;

	/* UTC Translation if/as necessary */
	IF @TimeZoneForUtcOffset IS NOT NULL BEGIN 
		IF (SELECT [dbo].[get_engine_version]()) >= 13.0 BEGIN 

			DECLARE @utc datetime = GETUTCDATE();
			DECLARE @atTimeZone datetime;
			
			DECLARE @offsetSQL nvarchar(MAX) = N'SELECT @atTimeZone = @utc AT TIME ZONE ''UTC'' AT TIME ZONE @TimeZoneForUtcOffset; ';
			
			EXEC sys.[sp_executesql]
				@offsetSQL, 
				N'@atTimeZone datetime OUTPUT, @utc datetime, @TimeZoneForUtcOffset sysname', 
				@atTimeZone = @atTimeZone OUTPUT, 
				@utc = @utc, 
				@TimeZoneForUtcOffset = @TimeZoneForUtcOffset;

			SET @JobStartTime = DATEADD(MINUTE, 0 - (DATEDIFF(MINUTE, @utc, @atTimeZone)), @JobStartTime);

		  END;
		ELSE BEGIN 
			RAISERROR('@TimeZoneForUtcOffset is NOT supported on SQL Server versions prior to SQL Server 2016. Set value to NULL.', 16, 1); 
			RETURN -100;
		END;
	END;

	DECLARE @jobStart time = CAST(@JobStartTime AS time);

	DECLARE @jobTemplate nvarchar(MAX) = N'EXEC admindb.dbo.[check_database_consistency]
	@Targets = N''{Targets}'', 
	@IncludeExtendedLogicalChecks = {extended}{Exclusions}{Priorities}{operator}{profile}{prefix}; ';
	--@Exclusions = N''{Exclusions}'', 
	--@Priorities = N''{Priorities}''; ';

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9); 

	DECLARE @dbccJobStep nvarchar(MAX) = @jobTemplate;

	SET @dbccJobStep = REPLACE(@dbccJobStep, N'{Targets}', @Targets);
	SET @dbccJobStep = REPLACE(@dbccJobStep, N'{extended}', CAST(@IncludeExtendedLogicalChecks AS sysname));

	IF @Exclusions IS NULL 
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{Exclusions}', N'');
	ELSE 
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{Exclusions}', N',' + @crlf + @tab + N'@Exclusions = N''' + @Exclusions + N'''');

	IF @Priorities IS NULL 
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{Priorities}', N'');
	ELSE 
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{Priorities}', N',' + @crlf + @tab + N'@Priorities = N''' + @Priorities + N'''');

	IF UPPER(@OperatorName) = N'ALERTS'
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{operator}', N'');
	ELSE 
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{operator}', N',' + @crlf + @tab + N'@OperatorName = N''' + @OperatorName + N'''');

	IF UPPER(@MailProfileName) = N'GENERAL'
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{profile}', N'');
	ELSE 
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{profile}', N',' + @crlf + @tab + N'@MailProfileName = N''' + @MailProfileName + N'''');

	IF @EmailSubjectPrefix = N'[Database Corruption Checks] '
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{prefix}', N'');
	ELSE 
		SET @dbccJobStep = REPLACE(@dbccJobStep, N'{prefix}', N',' + @crlf + @tab + N'@EmailSubjectPrefix = N''' + @EmailSubjectPrefix + N'''');

	/* Scheduling Logic */
	DECLARE @days table (
		abbreviation sysname,
		day_name sysname, 
		bit_map int 
	);

	INSERT INTO @days (
		[abbreviation],
		[day_name],
		[bit_map]
	)
	VALUES	
		(N'Su', N'Sunday', 1),
		(N'Sun', N'Sunday', 1),
		(N'M', N'Monday', 2),
		(N'T', N'Tuesday', 4),
		(N'Tu', N'Tuesday', 4),
		(N'W', N'Wednesday', 8),
		(N'Th', N'Thursday', 16),
		(N'Thu', N'Thursday', 16),
		(N'F', N'Friday', 32),
		(N'Sa', N'Saturday', 64),
		(N'Sat', N'Saturday', 64);

	DECLARE @daysOfWeek int;

	SELECT 
		@daysOfWeek = SUM(x.[bit_map])
	FROM 
		@days x 
		INNER JOIN (
			SELECT 
				CAST([result] AS sysname) [abbreviation]
			FROM 
				dbo.[split_string](@ExecutionDays, N',', 1)
		) y ON [x].[abbreviation] = [y].[abbreviation];


	/* Job Creation */
	DECLARE @jobId uniqueidentifier; 
	DECLARE @dateAsInt int;
	DECLARE @startTimeAsInt int; 
	DECLARE @scheduleName sysname;

	EXEC dbo.[create_agent_job]
		@TargetJobName = @JobName,
		@JobCategoryName = @JobCategoryName,
		@JobEnabled = 0,
		@AddBlankInitialJobStep = 1,
		@OperatorToAlertOnErrorss = @OperatorName,
		@OverWriteExistingJobDetails = @OverWriteExistingJobs,
		@JobID = @jobId OUTPUT;

	SET @dateAsInt = CAST(CONVERT(sysname, GETDATE(), 112) AS int);
	SET @startTimeAsInt = CAST((LEFT(REPLACE(CONVERT(sysname, CAST(@JobStartTime AS datetime), 108), N':', N''), 6)) AS int);
	SET @scheduleName = @JobName + N' Schedule';

	EXEC msdb.dbo.sp_add_jobschedule 
		@job_id = @jobId,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = 8,  -- weekly
		@freq_interval = @daysOfWeek,  -- every bit-map days... 					
		@freq_subday_type = 1,  -- at specified time... 							
		@freq_subday_interval = 0, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 1, -- every 1 weeks
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;

	EXEC msdb..sp_add_jobstep
		@job_id = @jobId,
		@step_id = 2,		-- place-holder already defined for step 1
		@step_name = N'Check Database Consistency',
		@subsystem = N'TSQL',
		@command = @dbccJobStep,
		@on_success_action = 1,		-- quit reporting success
		@on_fail_action = 2,		-- quit reporting failure 
		@database_name = N'master',
		@retry_attempts = 0,
		@retry_interval = 0;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.define_masterkey_encryption','P') IS NOT NULL
	DROP PROC dbo.[define_masterkey_encryption];
GO

CREATE PROC dbo.[define_masterkey_encryption]
	@MasterEncryptionKeyPassword		sysname		= NULL, 
	@BackupPath							sysname		= NULL, 
	@BackupEncryptionPassword			sysname		= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF NULLIF(@BackupPath, N'') IS NOT NULL BEGIN 
		IF NULLIF(@BackupEncryptionPassword, N'') IS NULL BEGIN 
			RAISERROR('Backup of Master Encryption Key can NOT be done without specifying a password (you''ll need this to recover the key IF necessary).', 16, 1);
			RETURN -2;
		END;

		DECLARE @error nvarchar(MAX);
		EXEC dbo.[establish_directory] 
			@TargetDirectory = @BackupPath, 
			@Error = @error OUTPUT;
		
		IF @error IS NOT NULL BEGIN
			RAISERROR(@error, 16, 1);
			RETURN - 5;
		END;
	END;

	IF NULLIF(@MasterEncryptionKeyPassword, N'') IS NULL 
		SET @MasterEncryptionKeyPassword = CAST(NEWID() AS sysname);
	
	DECLARE @command nvarchar(MAX);
	IF NOT EXISTS (SELECT NULL FROM master.sys.[symmetric_keys] WHERE [symmetric_key_id] = 101) BEGIN 
		SET @command = N'USE [master]; CREATE MASTER KEY ENCRYPTION BY PASSWORD = ''' + @MasterEncryptionKeyPassword + N'''; ';

		EXEC sp_executesql @command;

		PRINT 'MASTER KEY defined with password of: ' + @MasterEncryptionKeyPassword
	  
		IF NULLIF(@BackupPath, N'') IS NOT NULL BEGIN 
			-- TODO: verify backup location. 
		
			DECLARE @hostName sysname; 
			SELECT @hostName = @@SERVERNAME;

			SET @command = N'USE [master]; BACKUP MASTER KEY TO FILE = N''' + @BackupPath + N'\' + @hostName + N'_Master_Encryption_Key.key''
				ENCRYPTION BY PASSWORD = ''' + @BackupEncryptionPassword + N'''; '; 

			EXEC sp_executesql @command;

			PRINT 'Master Key Backed up to ' + @BackupPath + N' with Password of: ' + @BackupEncryptionPassword;
		END;	  
	  
	  RETURN 0;

	END; 

	-- otherwise, if we're still here... 
	PRINT 'Master Key Already Exists';	

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_dbfile_movement_template','P') IS NOT NULL
	DROP PROC dbo.[script_dbfile_movement_template];
GO

CREATE PROC dbo.[script_dbfile_movement_template]
	@TargetDatabase						sysname, 
	@TargetFiles						sysname,										-- {ALL} | {LOG} {DATA} | logical_filename, logical_filename2 
	@NewDirectory						sysname,
	@RollbackImmediate					bit				= 0,
	@RollbackSeconds					int				= 5	
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @TargetDatabase = NULLIF(@TargetDatabase, N'');
	SET @TargetFiles = NULLIF(@TargetFiles, N'');
	SET @NewDirectory = NULLIF(@NewDirectory, N'');

	SET @RollbackImmediate = ISNULL(@RollbackImmediate, 0);
	SET @RollbackSeconds = ISNULL(@RollbackSeconds, 5);

	DECLARE @rollback sysname = N'AFTER ' + CAST(@RollbackSeconds AS sysname) + N' SECONDS';
	IF @RollbackImmediate = 1 SET @rollback = N'IMMEDIATE';


	IF UPPER(@TargetDatabase) NOT IN (SELECT UPPER([name]) FROM sys.databases) BEGIN
		RAISERROR(N'@TargetDatabase ''%s'' was not found.', 16, 1, @TargetDatabase);
		RETURN -1;
	END;

	DECLARE @filesToMove table (
		[file_id] int NOT NULL, 
		[file_name] sysname NOT NULL, 
		[current_location] nvarchar(2000) NOT NULL, 
		[new_location] nvarchar(2000) NOT NULL
	); 

	DECLARE @sourceDirectory sysname;
	   
	IF UPPER(@TargetFiles) IN (N'{ALL}', N'{DATA}') BEGIN
		INSERT INTO @filesToMove (
			[file_id],
			[file_name],
			[current_location],
			[new_location]
		)
		SELECT 
			[file_id], 
			[name], 
			[physical_name] [current_location], 
			REPLACE([physical_name], dbo.extract_directory_from_fullpath([physical_name]), @NewDirectory)
		FROM 
			[master].sys.[master_files]
		WHERE 
			[database_id] = DB_ID(@TargetDatabase)
			AND [type_desc] = N'ROWS';
	END;

	IF UPPER(@TargetFiles) IN (N'{ALL}', N'{LOG}') BEGIN
		
		INSERT INTO @filesToMove (
			[file_id],
			[file_name],
			[current_location],
			[new_location]
		)
		SELECT 
			[file_id], 
			[name], 
			[physical_name] [current_location], 
			REPLACE([physical_name], dbo.extract_directory_from_fullpath([physical_name]), @NewDirectory)
		FROM 
			[master].sys.[master_files]
		WHERE 
			[database_id] = DB_ID(@TargetDatabase)
			AND [type_desc] = N'LOG';
	END;

	IF UPPER(@TargetFiles) NOT IN (N'{ALL}', N'{DATA}', N'{LOG}') BEGIN 
		
		INSERT INTO @filesToMove (
			[file_id],
			[file_name],
			[current_location],
			[new_location]
		)
		SELECT 
			[file_id], 
			[name], 
			[physical_name] [current_location], 
			REPLACE([physical_name], dbo.extract_directory_from_fullpath([physical_name]), @NewDirectory)
		FROM 
			[master].sys.[master_files]
		WHERE 
			[database_id] = DB_ID(@TargetDatabase)
			AND [name] IN (SELECT [result] FROM dbo.[split_string](@TargetFiles, N',', 1));
	END;

	DECLARE @template nvarchar(MAX) = N'USE [{targetDatabase}]; 
GO

---------------------------------------------------------------------------------------------------------------------------------------------------
-- Knock Offline: 
ALTER DATABASE [{targetDatabase}] SET SINGLE_USER WITH ROLLBACK {rollback}; 

USE [master]; 

ALTER DATABASE [{targetDatabase}] SET OFFLINE; 
GO 

{fileMoves}

---------------------------------------------------------------------------------------------------------------------------------------------------
-- Bring Back Online: 
ALTER DATABASE [{targetDatabase}] SET ONLINE;
ALTER DATABASE [{targetDatabase}] SET MULTI_USER;
GO

SELECT * FROM sys.master_files WHERE database_id = DB_ID(''{targetDatabase}''); 
'; 
	
	DECLARE @filesMoveTemplate nvarchar(MAX) = N'---------------------------------------------------------------------------------------------------------------------------------------------------
-- MOVE {sourceFilePath} to {targetFilePath}
EXEC xp_cmdshell ''copy "{sourceFilePath}" "{targetFilePath}"'';
EXEC xp_cmdshell ''rename "{sourceFilePath}" "{sourceFileName}.old"'';

ALTER DATABASE [{targetDatabase}] 
	MODIFY FILE (NAME = {logicalName}, FILENAME = ''{targetFilePath}'');
GO 

'; 

	DECLARE @filesMove nvarchar(MAX) = N'';
	DECLARE @directives nvarchar(MAX);

	DECLARE @currentLocation sysname, @newLocation sysname, @logicalName sysname;
	DECLARE @sourceFileName sysname;

	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[file_name],
		[current_location],
		[new_location] 
	FROM 
		@filesToMove 
	ORDER BY 
		[file_id];
		
	
	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @logicalName, @currentLocation, @newLocation;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
		
		SET @directives = @filesMoveTemplate;

		SELECT @sourceFileName = dbo.extract_filename_from_fullpath(@currentLocation);

		SET @directives = REPLACE(@directives, N'{sourceFilePath}', @currentLocation);
		SET @directives = REPLACE(@directives, N'{sourceFileName}', @sourceFileName);
		SET @directives = REPLACE(@directives, N'{targetFilePath}', @newLocation);
		SET @directives = REPLACE(@directives, N'{logicalName}', @logicalName);

		SET @filesMove = @filesMove + @directives;
	
		FETCH NEXT FROM [walker] INTO @logicalName, @currentLocation, @newLocation;
	END;
	
	CLOSE [walker];
	DEALLOCATE [walker];

	DECLARE @sql nvarchar(MAX) = @template; 

	SET @sql = REPLACE(@sql, N'{fileMoves}', @filesMove);
	SET @sql = REPLACE(@sql, N'{targetDatabase}', @TargetDatabase);
	SET @sql = REPLACE(@sql, N'{rollback}', @rollback);


	EXEC [dbo].[print_long_string] @sql;

	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_login','P') IS NOT NULL
	DROP PROC dbo.[script_login];
GO

CREATE PROC dbo.[script_login]
    @LoginName                              sysname,       
    @BehaviorIfLoginExists                  sysname                 = N'NONE',            -- { NONE | ALTER | DROP_AND_CREATE }
	@DisableExpiryChecks					bit						= 0, 
    @DisablePolicyChecks					bit						= 0,
	@ForceMasterAsDefaultDB					bit						= 0, 
	@IncludeDefaultLanguage					bit						= 0,
    @Output                                 nvarchar(MAX)           = N''        OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @name sysname, @loginType nvarchar(60);

	SELECT 
		@name = [name],
		@loginType = [type_desc]
	FROM 
		sys.[server_principals]
	WHERE
		[name] = @LoginName
		AND [type] NOT IN ('R');

    IF @name IS NULL BEGIN 
		DECLARE @message nvarchar(MAX) = N'-- No Login matching the name: [' + QUOTENAME(@LoginName) + N'] exists on the current server.';

		IF EXISTS (SELECT NULL FROM sys.[server_principals] WHERE [is_fixed_role] = 0 AND [type] = 'R' AND [name] = @LoginName) BEGIN
			SET @message = N'-- Server Principal: [' + @LoginName + N'] is a Server Role. Use dbo.script_server_role instead of script_login.';
		END;

        IF @Output IS NULL 
            SET @Output = @message;
        ELSE 
            PRINT @message;

        RETURN -2;
    END;

	DECLARE @result int;
	DECLARE @formatted nvarchar(MAX);

	IF @loginType = N'WINDOWS_LOGIN' BEGIN

		EXEC @result = dbo.[script_windows_login]
			@LoginName = @name,
			@BehaviorIfLoginExists = @BehaviorIfLoginExists,
			@ForceMasterAsDefaultDB = @ForceMasterAsDefaultDB,
			@IncludeDefaultLanguage = @IncludeDefaultLanguage,
			@Output = @formatted OUTPUT;
		
		IF @result <> 0 
			RETURN @result;

		GOTO ScriptCreated;
	END; 

	IF @loginType = N'SQL_LOGIN' BEGIN

		EXEC @result = dbo.[script_sql_login]
			@LoginName = @name,
			@BehaviorIfLoginExists = @BehaviorIfLoginExists,
			@DisableExpiryChecks = @DisableExpiryChecks,
			@DisablePolicyChecks = @DisablePolicyChecks,
			@ForceMasterAsDefaultDB = @ForceMasterAsDefaultDB,
			@IncludeDefaultLanguage = @IncludeDefaultLanguage,
			@Output = @formatted OUTPUT

		IF @result <> 0 
			RETURN @result;

		GOTO ScriptCreated;
	END; 

	-- If we're still here, we tried to script/print a login type that's not yet supported. 
	RAISERROR('Sorry, S4 does not yet support scripting ''%s'' logins.', 16, 1, @loginType);
	RETURN -20;

ScriptCreated: 

    IF @Output IS NULL BEGIN 
        SET @Output = @formatted;
        RETURN 0;
    END;

    PRINT @formatted;
    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_server_role','P') IS NOT NULL
	DROP PROC dbo.[script_server_role];
GO

CREATE PROC dbo.[script_server_role]
	@RoleName						sysname, 
--	@BehaviorIfRoleExists			sysname = N'NONE', 

	@IncludeMembers					bit = 1, 
	@IncludePermissions				bit = 1,
	@TokenizePrincipalNames			bit = 0,

	@Output							nvarchar(MAX) = N''		OUTPUT, 
	@OutputHash						varchar(2000) = N''		OUTPUT			-- Primarily designed/used-for comparisons BETWEEN synchronized servers. 
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF NOT EXISTS (SELECT NULL FROM sys.[server_principals] WHERE [name] = @RoleName AND [type] = 'R' AND [is_fixed_role] = 0) BEGIN 
		DECLARE @message nvarchar(MAX) = N'-- No Server Role matching the name: [' + @RoleName + N'] exists on the current server.';

		IF @Output IS NULL OR @OutputHash IS NULL BEGIN 
			SET @Output = @message;
			SET @OutputHash = 0;
		  END;
		ELSE 
			PRINT @message;

		RETURN -2;
	END;
	
	DECLARE @principalID int, @role sysname, @owner sysname;

	SELECT 
		@principalID = [principal_id],
		@role = [name], 
		@owner = (SELECT x.[name] FROM sys.[server_principals] x WHERE sp.[owning_principal_id] = x.[principal_id])
	FROM 
		sys.[server_principals] sp
	WHERE 
		sp.[name] = @RoleName;

-- TODO: process... @BehaviorIfExists... 
--		honestly, don't think I want to drop these things? ... 

	DECLARE @definition nvarchar(MAX) = N'USE [master];
GO

----------------------------------------------------------------------------------
-- Definition: 
----------------------------------------------------------------------------------
CREATE SERVER ROLE [' + @role + N'] AUTHORIZATION [' + @owner + N']; 
GO

';

	IF @IncludePermissions = 1 AND EXISTS (SELECT NULL FROM sys.[server_permissions] WHERE [grantee_principal_id] = @principalID) BEGIN 

		SET @definition = @definition + N'	---------------------------------------------------------------------------
	-- Permissions:
';		
		
		/*
			CONTEXT: 
				all server-level permission types are defined here: 
					https://learn.microsoft.com/en-us/sql/relational-databases/system-catalog-views/sys-server-permissions-transact-sql?view=sql-server-ver16 

				[class] lets us know which kind of granular object a non 'ANY/ALL' targets (e.g., endpoint, principal (role/login/etc.))
					though... I can't ever see that class 108 (AGs) are EVER used for anything granular (i.e., current perms are all/any..)
					and...docs point out that class 100 will ALWAYS be 0 (major). 
					I also can't see that MINOR is EVER used. 
		*/

		CREATE TABLE #rolePermissions (
			row_id int IDENTITY(1,1) NOT NULL, 
			[class] int NOT NULL, 
			[state] char(1) NOT NULL, 
			[permission_name] sysname NOT NULL, 
			[major_id] int NOT NULL, 
			[minor_id] int NOT NULL, 
			[is_granular] bit NOT NULL,  --see comment in final projection about bug/problem
			[target_type] sysname NULL, 
			[target_name] sysname NULL
		); 

		INSERT INTO [#rolePermissions] (
			[class],
			[state],
			[permission_name],
			[major_id],
			[minor_id], 
			[is_granular]
		)
		SELECT 
			[class], 
			[state], 
			[permission_name], 
			[major_id],
			[minor_id], 
			CASE WHEN [major_id] = 0 THEN 0 ELSE 1 END
		FROM 
			sys.[server_permissions] 
		WHERE 
			[grantee_principal_id] = @principalID;

		UPDATE [#rolePermissions] 
		SET 
			[target_type] = CASE 
				WHEN [class] = 105 THEN N'ENDPOINT'
				--WHEN [class] = 108 THEN N'AVAILABILITY GROUP'  -- can't see that these are actually in use.
				WHEN [class] = 101 THEN (SELECT CASE WHEN x.[type_desc] = N'SERVER_ROLE' THEN N'ROLE' ELSE N'LOGIN' END FROM sys.[server_principals] x WHERE x.[principal_id] = [major_id])
				ELSE N''
			END, 
			[target_name] = CASE 
				WHEN [class] = 105 THEN (SELECT x.[name] FROM sys.[endpoints] x WHERE [x].[endpoint_id] = [major_id])
				--WHEN [class] = 108 THEN (SELECT 'ag') 
				WHEN [class] = 101 THEN (SELECT x.[name] FROM sys.[server_principals] x WHERE x.[principal_id] = major_id)
				ELSE N''
			END
		WHERE 
			[major_id] IS NOT NULL;

		-- Projection: 
		SELECT 
			@definition = @definition + N'	' +
			CASE 
				WHEN [state] IN ('G', 'W') THEN N'GRANT ' 
				WHEN [state] = 'D' THEN N'DENY '
				WHEN [state] = 'R' THEN N'REVOKE '
			END + 
			[permission_name] + 
			CASE 
				WHEN [major_id] <> 0 THEN N' ON ' + [target_type] + N'::[' +  [target_name] + N']'
				ELSE N''
			END + 	
			N' TO [' + @RoleName + N']' +
			CASE 
				WHEN [state] = 'W' THEN N' WITH GRANT OPTION' 
				WHEN [state] IN ('R', 'D') THEN N' CASCADE'
				ELSE N'' 
			END + 
			N';
	GO

'
		FROM 
			[#rolePermissions] 
		ORDER BY
			-- wow... what crazy bug... 
			-- CASE WHEN [major_id] = 0 THEN 0 ELSE 1 END, [class], [state], [permission_name];
			[is_granular], [class], [state], [permission_name];


	END;

	IF @IncludeMembers = 1 AND EXISTS (SELECT NULL FROM sys.server_role_members WHERE [role_principal_id] = @principalID) BEGIN 

		SET @definition = @definition + N'	---------------------------------------------------------------------------
	-- Role Members:
';

		SELECT 
			@definition = @definition + N'	ALTER SERVER ROLE [' + @role + N'] ADD MEMBER [' + [sp].[name] + N'];
	GO

'
		FROM 
			sys.[server_role_members] srm 
			INNER JOIN sys.[server_principals] sp ON srm.[member_principal_id] = sp.[principal_id]
		WHERE 
			[role_principal_id] = @principalID
		ORDER BY 
			sp.[name];

	END;

	IF @Output IS NULL OR @OutputHash IS NULL BEGIN 
		SET @Output = @definition;
	
		IF @TokenizePrincipalNames = 1 BEGIN
			SET @definition = REPLACE(@definition, @@SERVERNAME + N'\', N'LOCAL_SERVER_NAME_FOR_TOKENIZATION_ONLY\');
			SET @OutputHash = HASHBYTES('SHA2_512', @definition);
		  END;
		ELSE BEGIN
			SET @OutputHash = HASHBYTES('SHA2_512', @definition);
		END;
		RETURN 0;
	END;

	PRINT @definition;
	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_logins','P') IS NOT NULL
	DROP PROC dbo.[script_logins];
GO

CREATE PROC dbo.[script_logins]
	@ExcludedLogins							nvarchar(MAX)			= NULL, 
	@ExcludeMSAndServiceLogins				bit						= 1,
	@ExcludeLocalPrincipalLogins			bit						= 1,
	@BehaviorIfLoginExists                  sysname                 = N'DROP_AND_CREATE',            -- { NONE | ALTER | DROP_AND_CREATE }
    @DisablePolicyChecks					bit						= 1,
	@DisableExpiryChecks					bit						= 1, 
	@ForceMasterAsDefaultDB					bit						= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');

	DECLARE @ingnoredLogins table (
		[login_name] sysname NOT NULL 
	);

	IF @ExcludedLogins IS NOT NULL BEGIN
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [result] [login_name] FROM dbo.[split_string](@ExcludedLogins, N',', 1) ORDER BY row_id;
	END;

	IF @ExcludeMSAndServiceLogins = 1 BEGIN
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [result] [login_name] FROM dbo.[split_string](N'##MS%, NT AUTHORITY\%, NT SERVICE\%', N',', 1) ORDER BY row_id;		
	END;

	IF @ExcludeLocalPrincipalLogins = 1 BEGIN
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [name] FROM sys.[server_principals] WHERE [type] = 'U' AND [name] LIKE @@SERVERNAME + N'\%';
	END;
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @output nvarchar(MAX);

	SELECT 
        CASE WHEN sp.[is_disabled] = 1 THEN 0 ELSE 1 END [enabled],
		sp.[name], 
		sp.[sid],
		sp.[type], 
		sp.[default_database_name],
		sl.[password_hash], 
		sl.[is_expiration_checked], 
		sl.[is_policy_checked], 
		sp.[default_language_name]
	INTO 
		#Logins
	FROM 
		sys.[server_principals] sp
		LEFT OUTER JOIN sys.[sql_logins] sl ON sp.[sid] = sl.[sid]
	WHERE 
		sp.[type] NOT IN ('R');

	IF EXISTS (SELECT NULL FROM @ingnoredLogins) BEGIN 
		DELETE l 
		FROM 
			[#Logins] l
			INNER JOIN @ingnoredLogins x ON l.[name] LIKE x.[login_name];
	END;

	SET @output = N'';

	SELECT 
		@output = @output + 
		CASE 
			WHEN [type] = N'S' THEN 
				dbo.[format_sql_login] (
					[enabled], 
					@BehaviorIfLoginExists, 
					[name], 
					N'0x' + CONVERT(nvarchar(MAX), [password_hash], 2) + N' ', 
					N'0x' + CONVERT(nvarchar(MAX), [sid], 2), 
					CASE WHEN @ForceMasterAsDefaultDB = 1 THEN N'master' ELSE [default_database_name] END, 
					[default_language_name], 
					CASE WHEN @DisableExpiryChecks = 1 THEN 0 ELSE [is_expiration_checked] END,
					CASE WHEN @DisablePolicyChecks = 1 THEN 0 ELSE [is_policy_checked] END
				)

			WHEN [type] IN (N'U', N'G') THEN 
				dbo.[format_windows_login] (
					[enabled], 
					@BehaviorIfLoginExists, 
					[name], 
					CASE WHEN @ForceMasterAsDefaultDB = 1 THEN N'master' ELSE [default_database_name] END, 
					[default_language_name]
				)
			ELSE 
				N'-- CERTIFICATE and SYMMETRIC KEY login types are NOT currently supported. (Nor are Roles)' 
		END 
			+ @crlf + N'GO' + @crlf
	FROM 
		[#Logins]
	ORDER BY 
		[name];


	IF NULLIF(@output, N'') IS NOT NULL BEGIN
		EXEC dbo.[print_long_string] @output;

		PRINT @crlf;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.fix_orphaned_users','P') IS NOT NULL
	DROP PROC dbo.[fix_orphaned_users];
GO

CREATE PROC dbo.[fix_orphaned_users]
	@TargetDatabases		nvarchar(MAX)		= N'{ALL}',
	@ExcludedDatabases		nvarchar(MAX)		= NULL,
	@ExcludedLogins			nvarchar(MAX)		= NULL, 
	@ExcludedUsers			nvarchar(MAX)		= NULL,
	@PrintOnly				bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	IF NULLIF(@TargetDatabases,'') IS NULL SET @TargetDatabases = N'{ALL}';
	SET @ExcludedDatabases = NULLIF(@ExcludedDatabases, N'');
	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');
	SET @ExcludedUsers = NULLIF(@ExcludedUsers, N'');

	DECLARE @ignored table ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[name] sysname NOT NULL
	);

	IF @ExcludedLogins IS NOT NULL BEGIN 
		INSERT INTO @ignored ([name])
		SELECT [result] FROM [dbo].[split_string](@ExcludedLogins, N', ', 1);
	END;

	IF @ExcludedUsers IS NOT NULL BEGIN 
		INSERT INTO @ignored ([name])
		SELECT [result] FROM [dbo].[split_string](@ExcludedUsers, N', ', 1);
	END;

	CREATE TABLE #orphans (
		UserName sysname, 
		UserSID varbinary(85)
	); 

	CREATE TABLE #failures ( 
		DatabaseName sysname NOT NULL,
		UserName sysname NOT NULL, 
		ErrorMessage nvarchar(MAX)
	);

	DECLARE @currentDatabase sysname;
	DECLARE @dbsToProcess table ( 
		row_id int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL 
	);

	INSERT INTO @dbsToProcess ([database_name])
	EXEC dbo.[list_databases]
		@Targets = @TargetDatabases,
		@Exclusions = @ExcludedDatabases,
		@ExcludeClones = 1,
		@ExcludeSecondaries = 1,
		@ExcludeSimpleRecovery = 0,
		@ExcludeReadOnly = 0,
		@ExcludeRestoring = 1,
		@ExcludeRecovering = 1,
		@ExcludeOffline = 1;

	DECLARE @template nvarchar(MAX) = N'EXEC [{db}]..sp_change_users_login ''Report''; ';
	DECLARE @sql nvarchar(MAX);

	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name]
	FROM 
		@dbsToProcess 
	ORDER BY 
		[row_id];
	
	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @currentDatabase;

	WHILE @@FETCH_STATUS = 0 BEGIN
		SET @sql = REPLACE(@template, N'{db}', @currentDatabase);

		PRINT '----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'
		PRINT '-- DATABASE: ' + @currentDatabase 
		PRINT '----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'

		DELETE FROM [#orphans];

		INSERT INTO #orphans (UserName, UserSID)
		EXEC [sys].[sp_executesql]
			@sql;
		
		IF EXISTS (SELECT NULL FROM @ignored) BEGIN 
			DELETE x 
			FROM 
				[#orphans] x 
				INNER JOIN @ignored i ON [x].[UserName] LIKE i.[name];
		END;
		
		IF EXISTS (SELECT NULL FROM [#orphans]) BEGIN
			DECLARE @target sysname; 

			DECLARE [fixer] CURSOR LOCAL FAST_FORWARD FOR 
			SELECT UserName FROM [#orphans];
		
			OPEN [fixer];
			FETCH NEXT FROM [fixer] INTO @target;
		
			WHILE @@FETCH_STATUS = 0 BEGIN
		
				BEGIN TRY 
					PRINT N'  -- Processing User: [' + @target + N']... ';

					IF NOT EXISTS (SELECT NULL FROM sys.[server_principals] WHERE [name] = @target) BEGIN
						PRINT N'  --	ERROR - Cannot repair orphaned-user [' + @target + N'], because a matching login does NOT exist.';
						
						IF @PrintOnly = 0 BEGIN
							PRINT N'';
							RAISERROR('A matching login for user: [%s] does not exist.', 16, 1, @target); 
						END;
					  END;
					ELSE BEGIN
						SET @sql = N'EXEC [{db}]..sp_change_users_login @Action = ''Update_One'', @UserNamePattern = N''{target}'', @LoginName = N''{target}''; ';
						SET @sql = REPLACE(@sql,  N'{db}', @currentDatabase);
						SET @sql = REPLACE(@sql,  N'{target}', @target);

						IF @PrintOnly = 1 BEGIN 
							PRINT N'  ' + @sql; 
							PRINT N'  GO';
						  END; 
						ELSE BEGIN
							EXEC sp_executesql 
								@sql;
						END;
					END;

					PRINT N'';

				END TRY 
				BEGIN CATCH 
					INSERT INTO [#failures] ([DatabaseName], [UserName], [ErrorMessage])
					VALUES (@currentDatabase, @target, ERROR_MESSAGE());
				END CATCH
			
				FETCH NEXT FROM [fixer] INTO @target;
			END;
		
			CLOSE [fixer];
			DEALLOCATE [fixer];

			/* Just cuz we didn't get an explicit error doesn't ALWAYS mean we were successful in reparing ... */
			IF @PrintOnly = 0 BEGIN
				DELETE [#orphans];

				SET @sql = N'EXEC [{db}]..sp_change_users_login ''Report''; ';
				SET @sql = REPLACE(@sql, N'{db}', @currentDatabase);

				INSERT INTO #orphans (UserName, UserSID)
				EXEC [sys].[sp_executesql]
					@sql;

				IF EXISTS (SELECT NULL FROM @ignored) BEGIN 
					DELETE x 
					FROM 
						[#orphans] x 
						INNER JOIN @ignored i ON [x].[UserName] LIKE i.[name];
				END;		

				IF EXISTS (SELECT NULL FROM [#failures]) BEGIN 
					DELETE FROM [#orphans] WHERE [UserName] IN (SELECT [UserName] FROM [#failures]);
				END;

				IF EXISTS (SELECT NULL FROM [#orphans]) BEGIN 
					INSERT INTO [#failures] ([DatabaseName], [UserName], [ErrorMessage])
					SELECT @currentDatabase, [UserName], N'STILL Orphaned (no error - but NOT repaired).' FROM [#orphans];
				END;
			END;
		END;

		FETCH NEXT FROM [walker] INTO @currentDatabase;
	END;

		IF EXISTS (SELECT NULL FROM [#failures]) BEGIN 
			SELECT 
				[DatabaseName],
				[UserName] [NON-REPAIRED-ORPHAN],
				[ErrorMessage] [ERROR]
			FROM 
				[#failures] 
			ORDER BY 
				[DatabaseName], [UserName];
		END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.drop_orphaned_users','P') IS NOT NULL
	DROP PROC dbo.[drop_orphaned_users];
GO

CREATE PROC dbo.[drop_orphaned_users]
	@TargetDatabase			sysname,
	@ExcludedUsers			nvarchar(MAX)	= NULL,
	@PrintOnly				bit				= 1					-- defaults to 1 cuz... this is potentially ugly/bad... 

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ExcludedUsers = NULLIF(@ExcludedUsers, N'');

	DECLARE @ignored table ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[name] sysname NOT NULL
	);

	IF @ExcludedUsers IS NOT NULL BEGIN 
		INSERT INTO @ignored ([name])
		SELECT [result] FROM [dbo].[split_string](@ExcludedUsers, N', ', 1);
	END;

	CREATE TABLE #orphans (
		UserName sysname, 
		UserSID varbinary(85)
	); 

	CREATE TABLE #failures ( 
		UserName sysname, 
		ErrorMessage nvarchar(MAX)
	);	

	DECLARE @sql nvarchar(MAX) = N'EXEC [{db}]..sp_change_users_login ''Report''; ';
	SET @sql = REPLACE(@sql, N'{db}', @TargetDatabase);

	INSERT INTO #orphans (UserName, UserSID)
	EXEC [sys].[sp_executesql]
		@sql;

	IF EXISTS (SELECT NULL FROM @ignored) BEGIN 
		DELETE x 
		FROM 
			[#orphans] x 
			INNER JOIN @ignored i ON [x].[UserName] LIKE i.[name];
	END;

	IF EXISTS (SELECT NULL FROM [#orphans]) BEGIN
		DECLARE @target sysname; 

		DECLARE [fixer] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT UserName FROM [#orphans];
		
		OPEN [fixer];
		FETCH NEXT FROM [fixer] INTO @target;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			BEGIN TRY 
				SET @sql = N'USE [{db}]; 
DROP USER [{user}];';
				SET @sql = REPLACE(@sql,  N'{db}', @TargetDatabase);
				SET @sql = REPLACE(@sql, N'{user}', @target);

				IF @PrintOnly = 1 BEGIN 
					PRINT @sql; 
					PRINT N'GO';
					PRINT N'';
				  END; 
				ELSE BEGIN
					EXEC sp_executesql 
						@sql;
				END;

			END TRY 
			BEGIN CATCH 
				INSERT INTO [#failures] ([UserName], [ErrorMessage])
				VALUES (@target, ERROR_MESSAGE());
			END CATCH
			
			FETCH NEXT FROM [fixer] INTO @target;
		END;
		
		CLOSE [fixer];

	END;

	IF EXISTS (SELECT NULL FROM [#failures]) BEGIN 
		SELECT 
			[UserName] [NON-REPAIRED-ORPHAN],
			[ErrorMessage] [ERROR]
		FROM 
			[#failures] 
		ORDER BY 
			[UserName];
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];

IF OBJECT_ID('dbo.export_server_logins','P') IS NOT NULL
	DROP PROC dbo.export_server_logins;
GO

CREATE PROC dbo.export_server_logins
	@TargetDatabases						nvarchar(MAX)			= N'{ALL}',
	@ExcludedDatabases						nvarchar(MAX)			= NULL,
	@DatabasePriorities						nvarchar(MAX)			= NULL,
	@ExcludedLogins							nvarchar(MAX)			= NULL, 
	@ExcludedUsers							nvarchar(MAX)			= NULL,
	@OutputPath								nvarchar(2000)			= N'{DEFAULT}',
	@CopyToPath								nvarchar(2000)			= NULL, 	
	@ExcludeMSAndServiceLogins				bit						= 1,
	@BehaviorIfLoginExists                  sysname                 = N'NONE',            -- { NONE | ALTER | DROP_AND_CREATE }
	@DisablePolicyChecks					bit						= 0,
	@DisableExpiryChecks					bit						= 0, 
	@ForceMasterAsDefaultDB					bit						= 0,
	@AddServerNameToFileName				bit						= 1,
	@OperatorName							sysname					= N'Alerts',
	@MailProfileName						sysname					= N'General',
	@EmailSubjectPrefix						nvarchar(50)			= N'[Login Exports] ',	 
	@PrintOnly								bit						= 0	
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	EXEC dbo.verify_advanced_capabilities;

	-----------------------------------------------------------------------------
	-- Input Validation:

	DECLARE @edition sysname;
	SELECT @edition = CASE SERVERPROPERTY('EngineEdition')
		WHEN 2 THEN 'STANDARD'
		WHEN 3 THEN 'ENTERPRISE'
		WHEN 4 THEN 'EXPRESS'
		ELSE NULL
	END;

	IF @edition = N'STANDARD' OR @edition IS NULL BEGIN
		-- check for Web:
		IF @@VERSION LIKE '%web%' SET @edition = 'WEB';
	END;
	
	IF @edition IS NULL BEGIN
		RAISERROR('Unsupported SQL Server Edition detected. This script is only supported on Express, Web, Standard, and Enterprise (including Evaluation and Developer) Editions.', 16, 1);
		RETURN -2;
	END;

	IF (@PrintOnly = 0) AND (@edition <> 'EXPRESS') BEGIN -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 

		-- Operator Checks:
		IF ISNULL(@OperatorName, '') IS NULL BEGIN
			RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
			RETURN -4;
		 END;
		ELSE BEGIN
			IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
				RAISERROR('Invalid Operator Name Specified.', 16, 1);
				RETURN -4;
			END;
		END;

		-- Profile Checks:
		DECLARE @databaseMailProfile nvarchar(255);
		EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @databaseMailProfile OUT, @no_output = N'no_output';
 
		IF @databaseMailProfile != @MailProfileName BEGIN
			RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
			RETURN -5;
		END; 
	END;

	IF UPPER(@OutputPath) = N'{DEFAULT}' BEGIN
		SELECT @OutputPath = dbo.load_default_path('BACKUP');
	END;

	IF NULLIF(@OutputPath, N'') IS NULL BEGIN
		RAISERROR('@OutputPath cannot be NULL and must be a valid path.', 16, 1);
		RETURN -6;
	END;

	IF @PrintOnly = 1 BEGIN
		 
		EXEC dbo.[script_logins]  
		    @TargetDatabases = @TargetDatabases, 
		    @ExcludedDatabases = @ExcludedDatabases, 
		    @DatabasePriorities = @DatabasePriorities, 
		    @ExcludedLogins = @ExcludedLogins, 
		    @ExcludedUsers = @ExcludedUsers, 
		    @ExcludeMSAndServiceLogins = @ExcludeMSAndServiceLogins, 
			@BehaviorIfLoginExists = @BehaviorIfLoginExists,
		    @DisablePolicyChecks = @DisablePolicyChecks, 
		    @DisableExpiryChecks = @DisableExpiryChecks, 
		    @ForceMasterAsDefaultDB = @ForceMasterAsDefaultDB; 

		RETURN 0; 
	END; 

	-- if we're still here, we need to dynamically output/execute dbo.script_logins so that output is directed to a file (and copied if needed)
	--		while catching and alerting on any errors or problems. 

	DECLARE @errorDetails nvarchar(MAX);
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);

	-- normalize paths: 
	IF(RIGHT(@OutputPath, 1) = '\')
		SET @OutputPath = LEFT(@OutputPath, LEN(@OutputPath) - 1);

	IF(RIGHT(ISNULL(@CopyToPath, N''), 1) = '\')
		SET @CopyToPath = LEFT(@CopyToPath, LEN(@CopyToPath) - 1);

	DECLARE @outputFileName varchar(2000);
	SET @outputFileName = @OutputPath + '\' + CASE WHEN @AddServerNameToFileName = 1 THEN @@SERVERNAME + '_' ELSE '' END + N'Logins.sql';

	DECLARE @errors table ( 
		error_id int IDENTITY(1,1) NOT NULL, 
		error nvarchar(MAX) 
	);

	DECLARE @xpCmdShellOutput table (
		result_id int IDENTITY(1,1) NOT NULL, 
		result nvarchar(MAX) NULL
	);

	-- Set up a 'translation' of the sproc call (for execution via xp_cmdshell): 
	DECLARE @sqlCommand varchar(MAX); 
	SET @sqlCommand = N'EXEC admindb.dbo.script_logins @TargetDatabases = N''{0}'', @ExcludedDatabases = N''{1}'', @DatabasePriorities = N''{2}'', @ExcludedLogins = N''{3}'', @ExcludedUsers = N''{4}'', '
		+ '@ExcludeMSAndServiceLogins = {5}, @BehaviorIfLoginExists = N''{9}'', @DisablePolicyChecks = {6}, @DisableExpiryChecks = {7}, @ForceMasterAsDefaultDB = {8};';

	SET @sqlCommand = REPLACE(@sqlCommand, N'{0}', CAST(@TargetDatabases AS varchar(MAX)));
	SET @sqlCommand = REPLACE(@sqlCommand, N'{1}', CAST(ISNULL(@ExcludedDatabases, N'') AS varchar(MAX)));
	SET @sqlCommand = REPLACE(@sqlCommand, N'{2}', CAST(ISNULL(@DatabasePriorities, N'') AS varchar(MAX)));
	SET @sqlCommand = REPLACE(@sqlCommand, N'{3}', CAST(ISNULL(@ExcludedLogins, N'') AS varchar(MAX)));
	SET @sqlCommand = REPLACE(@sqlCommand, N'{4}', CAST(ISNULL(@ExcludedUsers, N'') AS varchar(MAX)));
	SET @sqlCommand = REPLACE(@sqlCommand, N'{5}', CASE WHEN @ExcludeMSAndServiceLogins = 1 THEN '1' ELSE '0' END);
	SET @sqlCommand = REPLACE(@sqlCommand, N'{6}', CASE WHEN @DisablePolicyChecks = 1 THEN '1' ELSE '0' END);
	SET @sqlCommand = REPLACE(@sqlCommand, N'{7}', CASE WHEN @DisableExpiryChecks = 1 THEN '1' ELSE '0' END);
	SET @sqlCommand = REPLACE(@sqlCommand, N'{8}', CASE WHEN @ForceMasterAsDefaultDB = 1 THEN '1' ELSE '0' END);
	SET @sqlCommand = REPLACE(@sqlCommand, N'{9}', ISNULL(@BehaviorIfLoginExists, N'NONE'));

	IF LEN(@sqlCommand) > 8000 BEGIN 
		INSERT INTO @errors (error) VALUES ('Combined length of all input parameters to dbo.script_logins exceeds 8000 characters and can NOT be executed dynamically. Export of logins can not and did NOT proceed as expected.')
		GOTO REPORTING;
	END; 

	DECLARE @command varchar(8000) = 'sqlcmd {0} -Q "{1}" -o "{2}" ';

	-- replace parameters: 
	SET @command = REPLACE(@command, '{0}', CASE WHEN UPPER(@@SERVICENAME) = 'MSSQLSERVER' THEN '' ELSE ' -S .\' + UPPER(@@SERVICENAME) END);
	SET @command = REPLACE(@command, '{1}', @sqlCommand);
	SET @command = REPLACE(@command, '{2}', @outputFileName);

	BEGIN TRY

		INSERT INTO @xpCmdShellOutput ([result])
		EXEC master.sys.[xp_cmdshell] @command;

		DELETE FROM @xpCmdShellOutput WHERE [result] IS NULL; 

		IF EXISTS (SELECT NULL FROM @xpCmdShellOutput) BEGIN 
			SET @errorDetails = N'';
			SELECT 
				@errorDetails = @errorDetails + [result] + @crlf + @tab
			FROM 
				@xpCmdShellOutput 
			ORDER BY 
				[result_id];

			SET @errorDetails = N'Unexpected problem while attempting to write logins to disk: ' + @crlf + @crlf + @tab + @errorDetails + @crlf + @crlf + N'COMMAND: [' + @command + N']';

			INSERT INTO @errors (error) VALUES (@errorDetails);
		END


		-- Verify that the file was written as expected: 
		SET @command = 'for %a in ("' + @outputFileName + '") do @echo %~ta';
		DELETE FROM @xpCmdShellOutput; 

		INSERT INTO @xpCmdShellOutput ([result])
		EXEC master.sys.[xp_cmdshell] @command;

		DECLARE @timeStamp datetime; 
		SELECT @timeStamp = MAX(CAST([result] AS datetime)) FROM @xpCmdShellOutput WHERE [result] IS NOT NULL;

		IF DATEDIFF(MINUTE, @timeStamp, GETDATE()) > 2 BEGIN 
			SET @errorDetails = N'TimeStamp for [' + @outputFileName + N'] reads ' + CONVERT(nvarchar(30), @timeStamp, 120) + N'. Current Execution Time is: ' + CONVERT(nvarchar(30), GETDATE(), 120) + N'. File writing operations did NOT throw an error, but time-stamp difference shows ' + @outputFileName + N' file was NOT written as expected.' ;
			
			INSERT INTO @errors (error) VALUES (@errorDetails);
		END;

		-- copy the file if/as needed:
		IF @CopyToPath IS NOT NULL BEGIN

			DELETE FROM @xpCmdShellOutput;
			SET @command = 'COPY "{0}" "{1}\"';

			SET @command = REPLACE(@command, '{0}', @outputFileName);
			SET @command = REPLACE(@command, '{1}', @CopyToPath);

			INSERT INTO @xpCmdShellOutput ([result])
			EXEC master.sys.[xp_cmdshell] @command;

			DELETE FROM @xpCmdShellOutput WHERE [result] IS NULL OR [result] LIKE '%1 file(s) copied.%'; 

			IF EXISTS (SELECT NULL FROM @xpCmdShellOutput) BEGIN 

				SET @errorDetails = N'';
				SELECT 
					@errorDetails = @errorDetails + [result] + @crlf + @tab
				FROM 
					@xpCmdShellOutput 
				ORDER BY 
					[result_id];

				SET @errorDetails = N'Unexpected problem while copying file from @OutputPath to @CopyFilePath : ' + @crlf + @crlf + @tab + @errorDetails + @crlf + @crlf + N'COMMAND: [' + @command + N']';

				INSERT INTO @errors (error) VALUES (@errorDetails);
			END 
		END;

	END TRY 
	BEGIN CATCH
		SET @errorDetails = N'Unexpected Exception while executing command: [' + ISNULL(@command, N'#ERROR#') + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();

		INSERT INTO @errors (error) VALUES (@errorDetails);
	END CATCH
	

REPORTING: 
	IF EXISTS (SELECT NULL FROM @errors) BEGIN
		DECLARE @emailErrorMessage nvarchar(MAX) = N'The following errors were encountered: ' + @crlf + @crlf;

		SELECT 
			@emailErrorMessage = @emailErrorMessage + N'- ' + [error] + @crlf
		FROM 
			@errors
		ORDER BY 
			error_id;

		DECLARE @emailSubject nvarchar(2000);
		SET @emailSubject = @EmailSubjectPrefix + N' - ERROR';
	
		IF @edition <> 'EXPRESS' BEGIN;
			EXEC msdb.dbo.sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName,
				@subject = @emailSubject, 
				@body = @emailErrorMessage;
		END;		

	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.prevent_user_access','P') IS NOT NULL
	DROP PROC dbo.[prevent_user_access];
GO

CREATE PROC dbo.[prevent_user_access]
	@TargetDatabases					nvarchar(MAX),							-- { {ALL} | {USER} | {SYSTEM} }, etc.   -- standard tokens or names,etc./
	@ExcludedDatabases					nvarchar(MAX)	= NULL,
	@ProhibitedLogins					nvarchar(MAX)	= NULL,					-- allows wildcards with ` as escape
	@ProhibitedUsernames				nvarchar(MAX)	= NULL,					-- allows wildcards with ` as escape
	@Action								sysname			= N'REPORT',			-- { REPORT | REMOVE | REMOVE_AND_REPORT }
	@OperatorName						sysname			= N'Alerts',
    @MailProfileName					sysname			= N'General',
    @EmailSubjectPrefix					nvarchar(50)	= N'[Prohibited User Processing] ',

	@PrintOnly							bit				= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @TargetDatabases = ISNULL(NULLIF(@TargetDatabases, N''), N'{ALL}');
	SET @ExcludedDatabases = NULLIF(@ExcludedDatabases, N'');
	SET @ProhibitedLogins = NULLIF(@ProhibitedLogins, N'');
	SET @ProhibitedUsernames = NULLIF(@ProhibitedUsernames, N'');

	SET @Action = ISNULL(NULLIF(@Action, N''), N'REPORT');

	-- TODO: Validate inputs/etc. 
	-- @TargetDBs can't be NULL
	-- @ProhibitedLogins / @ProhibitedUsernames can't BOTH be null/empty. 
	-- @Action has to be IN (REPORT, REMOVE, REMOVE+REPORT)...

	DECLARE @targetDBs table (
		[entry_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL
	); 

	INSERT INTO @targetDBs ([database_name])
	EXEC dbo.[list_databases]
		@Targets = @TargetDatabases,
		@Exclusions =@ExcludedDatabases,
		@ExcludeClones = 1,
		@ExcludeSecondaries = 1,
		@ExcludeSimpleRecovery = 0,
		@ExcludeReadOnly = 1,
		@ExcludeRestoring = 1,
		@ExcludeRecovering = 1,
		@ExcludeOffline = 1;

	CREATE TABLE #targets ( 
		[entry_id] int IDENTITY(1,1) NOT NULL, 
		[target_type] sysname NOT NULL, 
		[target_value] sysname NOT NULL 
	);

	CREATE TABLE #matches ( 
		[match_id] int IDENTITY(1,1) NOT NULL, 
		[principal_id] int NOT NULL,
		[match_type] sysname NOT NULL, 
		[match_name] sysname NOT NULL, 
		[match_target] sysname NOT NULL
	);

	CREATE TABLE #databasePrincipals (
		[row_id] int IDENTITY(1,1) NOT NULL,
		[database_name] sysname NOT NULL,
		[user_name] sysname NOT NULL,
		[user_sid] varbinary(85) NULL,
		[type_desc] nvarchar(60) NULL,
		[user_create_date] datetime NOT NULL,
		[login_name] sysname NULL,
		[login_sid] varbinary(85) NULL,
		[is_disabled] bit NULL,
		[login_create_date] datetime NULL,
		[default_database_name] sysname NULL, 
		[match_target] sysname NULL
	);

	DECLARE @messages table (
		message_id int IDENTITY(1,1) NOT NULL, 
		[database] sysname NOT NULL, 
		[message] nvarchar(MAX) NOT NULL, 
		[command] nvarchar(MAX) NULL,
		[outcome] sysname NULL, 
		[error] nvarchar(MAX) NULL
	);

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @line nvarchar(MAX) = N'-------------------------------------------------------------------------------------------------------------------------------';
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @message nvarchar(MAX); 
	DECLARE @error nvarchar(MAX);
	DECLARE @removeSql nvarchar(MAX);

	IF @ProhibitedLogins IS NOT NULL BEGIN 
		INSERT INTO [#targets] (
			[target_type],
			[target_value]
		)
		SELECT 
			N'LOGIN', 
			[result]
		FROM 
			dbo.[split_string](@ProhibitedLogins, N',', 1)
		ORDER BY 
			[row_id];
	END; 

	IF @ProhibitedUsernames IS NOT NULL BEGIN 
		INSERT INTO [#targets] (
			[target_type],
			[target_value]
		)
		SELECT 
			N'USER', 
			[result]
		FROM 
			dbo.[split_string](@ProhibitedUsernames, N',', 1)
		ORDER BY 
			[row_id];
	END;

	DECLARE @principalsTemplate nvarchar(MAX) = N'
SELECT 
	N''{0}'' [database_name],
	[d].[name] [user_name],
	[d].[sid] [user_sid],
	[d].[type_desc],
	[d].[create_date] [user_create_date],
	[s].[name] [login_name],
	[s].[sid] [login_sid],
	[s].[is_disabled],
	[s].[create_date] [login_create_date],
	[s].[default_database_name]
FROM 
	[{0}].sys.[database_principals] d
	LEFT OUTER JOIN master.sys.[server_principals] s ON d.[sid] = s.[sid]
WHERE 
	[d].[type] NOT IN (''R'')
	AND [d].[principal_id] NOT IN (0, 1, 2, 3, 4)
ORDER BY 
	[d].[principal_id]; ';

	DECLARE @currentDatabase sysname;
	DECLARE @userName sysname, @loginName sysname, @loginType sysname, @isLoginDisabled bit, @matchValue sysname;
	DECLARE @sql nvarchar(MAX);

	DECLARE @id int = 1;  /* avoid using nested cursors by using an UGLY while loop here - so'z we can use cursors down below if/as needed: */
	WHILE EXISTS (SELECT NULL FROM @targetDBs WHERE [entry_id] = @id) BEGIN
		SELECT @currentDatabase = [database_name] FROM @targetDBs WHERE [entry_id] = @id;

		TRUNCATE TABLE [#databasePrincipals];
		TRUNCATE TABLE [#matches];

		SET @sql = REPLACE(@principalsTemplate, N'{0}', @currentDatabase);

		INSERT INTO [#databasePrincipals] (
			[database_name],
			[user_name],
			[user_sid],
			[type_desc],
			[user_create_date],
			[login_name],
			[login_sid],
			[is_disabled],
			[login_create_date],
			[default_database_name]
		)
		EXEC sp_executesql @sql;

		-- matching LOGINS:
		INSERT INTO [#matches] (
			[match_type],
			[principal_id],
			[match_name], 
			[match_target]
		)
		SELECT 
			N'LOGIN', 
			p.[row_id],
			p.[login_name], 
			t.[target_value]
		FROM 
			[#databasePrincipals] p 
			INNER JOIN [#targets] t ON p.[login_name] LIKE t.[target_value] ESCAPE N'`'
		WHERE 
			t.[target_type] = N'LOGIN';

		-- matching USERS:
		INSERT INTO [#matches] (
			[match_type],
			[principal_id],
			[match_name], 
			[match_target]
		)
		SELECT 
			N'USER', 
			p.[row_id],
			p.[user_name], 
			t.[target_value]
		FROM 
			[#databasePrincipals] p 
			INNER JOIN [#targets] t ON p.[user_name] LIKE t.[target_value] ESCAPE N'`'
		WHERE 
			t.[target_type] = N'USER'
			AND [p].[row_id] NOT IN (SELECT [principal_id] FROM [#matches]); /* -- avoid DUPLICATES */

		DELETE FROM [#databasePrincipals] WHERE [row_id] NOT IN (SELECT principal_id FROM [#matches]);
		
		UPDATE x 
		SET 
			x.[match_target] = m.[match_target]
		FROM 
			[#databasePrincipals] x
			INNER JOIN [#matches] m ON x.[row_id] = m.[principal_id];

		/* For each REMAINING entry, process as per @Action ... */
		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[user_name], 
			[login_name], 
			[type_desc] [login_type], 
			[is_disabled], 
			[match_target]
		FROM 
			[#databasePrincipals]
		ORDER BY 
			[row_id];
		
		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @userName, @loginName, @loginType, @isLoginDisabled, @matchValue;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			SET @error = NULL; 
			SET @message = NULL;

			SET @removeSql = @tab + @tab + N'USE [{db}];' + @crlf + @tab + @tab + N'IF EXISTS (SELECT NULL FROM [{db}].[sys].[database_principals] WHERE [name] = ''{user}'') BEGIN ' + @crlf 
				+ @tab + @tab + @tab + N'DROP USER [{user}]; ' + @crlf 
				+ @tab + @tab + N'END;';

			SET @removeSql = REPLACE(@removeSql, N'{db}', @currentDatabase);
			SET @removeSql = REPLACE(@removeSql, N'{user}', @userName);

			IF UPPER(@Action) = N'REPORT' BEGIN 
				
				SET @message = N'User [' + @userName + N'] (matching prohibited pattern [' + @matchValue + N']) currently exists in database [' + @currentDatabase + N']. ';
				IF @loginName IS NULL BEGIN 
					SET @message = @message + @crlf + @tab + N'NOTE: This user is current orphaned (there is no corresponding login).'	
				  END;
				ELSE BEGIN 
					SET @message = @message + @crlf + @tab + N'NOTE: This user is currently mapped to Login [' + @loginName + N'] - which is ' + CASE WHEN @isLoginDisabled = 1 THEN 'DISABLED' ELSE N'ENABLED' END + N'. ';
				END;

				SET @message = @message + @crlf + @tab + @tab +  N'To remove this user run the following: ' + @crlf 
					+ @tab + @tab + @line + @crlf 
					+ @removeSql + @crlf
					+ @tab + @tab + @line;

				INSERT INTO @messages (
					[database],
					[message]
				)
				SELECT 
					@currentDatabase, 
					@message;
			END;

			IF UPPER(@Action) LIKE '%REMOVE%' BEGIN 
				
				SET @message = N'REMOVING user [' + @userName + N'] from database [' + @currentDatabase + N'] because it matches prohibited pattern of [' + @matchValue + N']. ';
				IF @loginName IS NULL BEGIN 
					SET @message = @message + @crlf + @tab + N'NOTE: Target user is current orphaned (there is no corresponding login). LOGIN will NOT be modified.'; 	
				  END;
				ELSE BEGIN 
					SET @message = @message + @crlf + @tab + N'NOTE: Target user is currently mapped to Login [' + @loginName + N'] - which is ' + CASE WHEN @isLoginDisabled = 1 THEN 'DISABLED' ELSE N'ENABLED' END + N'. LOGIN will NOT be modified.';
				END;

				BEGIN TRY 
					
					IF @PrintOnly = 1 BEGIN 
						PRINT N'-- @PrintOnly = 1; Otherwise, WOULD exectute the following code: '; 
						PRINT @removeSql;
					  END;
					ELSE BEGIN 
						EXEC sp_executesql @removeSql;				
					END;

					INSERT INTO @messages (
						[database],
						[message], 
						[command],
						[outcome]
					)
					VALUES	(
						@currentDatabase, 
						@message,
						@removeSql,
						N'SUCCESS'
					);
				END TRY 
				BEGIN CATCH
					SET @error = CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();

					INSERT INTO @messages (
						[database],
						[message], 
						[command],
						[outcome], 
						[error]
					)
					VALUES	(
						@currentDatabase, 
						@message, 
						@removeSql,
						N'FAILURE', 
						@error
					);

				END CATCH;
			END;

			FETCH NEXT FROM [walker] INTO @userName, @loginName, @loginType, @isLoginDisabled, @matchValue;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

		SET @id = @id + 1;
	END;

	IF UPPER(@Action) = N'REMOVE' BEGIN 
		/* only report on errors with remove(only) operations */
		DELETE FROM @messages WHERE [outcome] <> 'FAILURE';
	END;

	IF EXISTS(SELECT NULL FROM @messages) BEGIN 
		
		DECLARE @body nvarchar(MAX) = N'';
		DECLARE @subject nvarchar(MAX) = @EmailSubjectPrefix; 

		SELECT
			@body = @body + N'- ' + [message] + @crlf + @tab 
			+ CASE WHEN [command] IS NOT NULL THEN 'EXECUTED COMMAND: ' + @crlf + @tab + @line + @crlf + [command] + @crlf + @tab + @line ELSE N'' END
			+ CASE WHEN [outcome] = N'FAILURE' THEN @crlf + @tab + 'EXECUTION OUTCOME: FAILURE -> ' + [error] WHEN [outcome] = 'SUCCESS' THEN @crlf + @tab + @tab + 'EXECUTION OUTCOME: SUCCESS' ELSE N'' END + @crlf + @crlf
		FROM 
			@messages 
		ORDER BY 
			ISNULL([outcome], N'xxx'), [message_id];  /* failure, success, and xxxx */

		IF EXISTS (SELECT NULL FROM @messages WHERE [outcome] = N'FAILURE') BEGIN 
			SET @body = N'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' + @crlf + N'!	NOTE: ERRORS occurred. ' + @crlf + N'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!' + @crlf + @crlf;
			SET @subject = @subject + N'- ERRORS';
		  END
		ELSE BEGIN 
			SET @subject = @subject + N'- SUCCESS';
		END;

		IF @PrintOnly = 1 BEGIN 
			EXEC dbo.[print_long_string] @body;
		  END;
		ELSE BEGIN 
			EXEC msdb..sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName,
				@subject = @subject, 
				@body = @body;
		END;
	END;
	   
	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_security_mappings','P') IS NOT NULL
	DROP PROC dbo.[script_security_mappings];
GO

CREATE PROC dbo.[script_security_mappings]
	@TargetDatabases					nvarchar(MAX),				-- { {ALL} | {USER} | {SYSTEM} }, etc.   -- standard tokens or names,etc./
	@ExcludedDatabases					nvarchar(MAX)		= NULL,	
	@ExcludedLogins						nvarchar(MAX)		= NULL, 
	@ExcludedUsers						nvarchar(MAX)		= NULL, 
	@Output								xml					= N'<default/>'			OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @TargetDatabases = ISNULL(NULLIF(@TargetDatabases, N''), N'{ALL}');
	SET @ExcludedDatabases = NULLIF(@ExcludedDatabases, N'');

	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');
	SET @ExcludedUsers = NULLIF(@ExcludedUsers, N'');

	DECLARE @targetDBs table (
		[entry_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL
	); 

	INSERT INTO @targetDBs ([database_name])
	EXEC dbo.[list_databases]
		@Targets = @TargetDatabases,
		@Exclusions =@ExcludedDatabases,
		@ExcludeClones = 1,
		@ExcludeSecondaries = 1,
		@ExcludeSimpleRecovery = 0,
		@ExcludeReadOnly = 1,
		@ExcludeRestoring = 1,
		@ExcludeRecovering = 1,
		@ExcludeOffline = 1;

	CREATE TABLE #exclusions (
		[exclusion_id] int IDENTITY(1,1) NOT NULL, 
		[exclusion_type] sysname NOT NULL, 
		[exclusion] sysname NOT NULL 
	);

	CREATE TABLE #results ( 
		[result_id] int IDENTITY(1,1) NOT NULL, 
		[database] sysname NOT NULL,
		[result] xml NOT NULL 
	);

	IF @ExcludedLogins IS NOT NULL BEGIN 
		INSERT INTO [#exclusions] (
			[exclusion_type],
			[exclusion]
		)
		SELECT 
			N'LOGIN', 
			[result]
		FROM 
			dbo.[split_string](@ExcludedLogins, N',', 1)
		ORDER BY 
			[row_id];
	END; 

	IF @ExcludedUsers IS NOT NULL BEGIN 
		INSERT INTO [#exclusions] (
			[exclusion_type],
			[exclusion]
		)
		SELECT 
			N'USER', 
			[result]
		FROM 
			dbo.[split_string](@ExcludedUsers, N',', 1)
		ORDER BY 
			[row_id];
	END;

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @line nvarchar(MAX) = N'-------------------------------------------------------------------------------------------------------------------------------';
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @message nvarchar(MAX); 
	DECLARE @error nvarchar(MAX);
	DECLARE @removeSql nvarchar(MAX);
	
	DECLARE @mappingsTemplate nvarchar(MAX) = N'WITH core AS ( 

	SELECT 
		[principals].[name] [user], 
		[l].[name] [login],
		[roles].[name] [role]
	FROM 
		[{0}].sys.[database_role_members] rm 
		INNER JOIN [{0}].sys.[database_principals] principals ON rm.[member_principal_id] = principals.[principal_id]
		INNER JOIN [{0}].sys.[database_principals] roles ON rm.[role_principal_id] = roles.[principal_id] 
		LEFT OUTER JOIN master.sys.server_principals l ON principals.[sid] = l.[sid]
	WHERE 
		[principals].[principal_id] NOT IN (0, 1, 2, 3, 4){excludedLogins}{excludedUsers}

) 

SELECT @result = (SELECT 
	[user] [@user], 
	(SELECT TOP 1 x.[login] FROM core x WHERE [core].[user] = x.[user]) [@login],  -- hack-ish... 
	(SELECT x.[role] FROM core x WHERE core.[user] = x.[user] FOR XML PATH(''''), TYPE) [roles]
FROM 
	core 
GROUP BY 
	[core].[user]
ORDER BY 
	[core].[user]
FOR 
	XML PATH (''user''), TYPE); ';
	
	IF @ExcludedLogins IS NULL BEGIN 
		SET @mappingsTemplate = REPLACE(@mappingsTemplate, N'{excludedLogins}', N'')
	  END;
	ELSE BEGIN 
		SET @mappingsTemplate = REPLACE(@mappingsTemplate, N'{excludedLogins}', N' AND ISNULL([l].[name], N''`~~`|`~~`'') NOT IN (SELECT [exclusion] FROM #exclusions WHERE [exclusion_type] = ''LOGIN'')')
	END;	

	IF @ExcludedUsers IS NULL BEGIN 
		SET @mappingsTemplate = REPLACE(@mappingsTemplate, N'{excludedUsers}', N'')
	  END;
	ELSE BEGIN 
		SET @mappingsTemplate = REPLACE(@mappingsTemplate, N'{excludedUsers}', N' AND [principals].[name] NOT IN (SELECT [exclusion] FROM #exclusions WHERE [exclusion_type] = ''USER'')')
	END;	

	DECLARE @currentDatabase sysname;

	DECLARE @sql nvarchar(MAX);
	DECLARE @result xml;

	DECLARE @id int = 1;  /* avoid using nested cursors by using an UGLY while loop here - so'z we can use cursors down below if/as needed: */
	WHILE EXISTS (SELECT NULL FROM @targetDBs WHERE [entry_id] = @id) BEGIN
		SELECT @currentDatabase = [database_name] FROM @targetDBs WHERE [entry_id] = @id;

		SET @sql = REPLACE(@mappingsTemplate, N'{0}', @currentDatabase);
			   
		EXEC sp_executesql 
			@sql, 
			N'@result xml OUTPUT', 
			@result = @result OUTPUT;

		INSERT INTO [#results] (
			[database],
			[result]
		)
		VALUES	(
			@currentDatabase, 
			@result
		);

		SET @id = @id + 1;
	END;

	-- Hack-ish: 
	DECLARE @stringOutput nvarchar(MAX) = N'';

	SELECT 
		@stringOutput = @stringOutput + N'<database name="' + [database] + N'">' + CAST([result] AS nvarchar(MAX)) + N'</database>'
	FROM 
		[#results] 
	ORDER BY 
		[result_id]

	SET @stringOutput = N'<databases>' + @stringOutput + N'</databases>';
	
	/* Send results via @Output if being called for by-parameter usage: */
	IF (SELECT dbo.is_xml_empty(@Output)) = 1 BEGIN
		SET @Output = CAST(@stringOutput AS xml);
		RETURN 0;
	END;

	/* -- Otherwise, Project: */
	SELECT CAST(@stringOutput AS xml) [output];

	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.import_security_mappings','P') IS NOT NULL
	DROP PROC dbo.[import_security_mappings];
GO

CREATE PROC dbo.[import_security_mappings]
	@MappingXml							xml, 
	@ExcludedDatabases					nvarchar(MAX)		= NULL,						-- Excluded from the list of dbs in the @MappingXml
	@ExcludedLogins						nvarchar(MAX)		= NULL,					 
	@ExcludedUsers						nvarchar(MAX)		= NULL,
	@WarnOnDbOwnerPlusOtherRoles		bit					= 1, 
	@OperatorName						sysname				= N'Alerts',
    @MailProfileName					sysname				= N'General',
    @EmailSubjectPrefix					nvarchar(50)		= N'[Import Security Mappings] ',
	@PrintOnly							bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ExcludedDatabases = NULLIF(@ExcludedDatabases, N'');
	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');
	SET @ExcludedUsers = NULLIF(@ExcludedUsers, N'');

	CREATE TABLE #hydrated ( 
		row_id int IDENTITY(1,1) NOT NULL, 
		[database] sysname NOT NULL, 
		[user] sysname NOT NULL, 
		[login] sysname NULL, 
		[roles] nvarchar(MAX) NULL, 
		[outcome] sysname NULL, 
		[notes] nvarchar(MAX) NULL, 
		[exception] nvarchar(MAX) NULL
	); 

	DECLARE @hydrateSQL nvarchar(MAX) = N'	WITH shredded AS ( 
		SELECT 
			[data].[db].value(N''@name[1]'', N''sysname'') [database], 
			[user].[x].value(N''@user[1]'', N''sysname'') [user], 
			[user].[x].value(N''@login[1]'', N''sysname'') [login], 
			[roles].[r].value(N''.'', N''sysname'') [role]
		FROM 
			@MappingXml.nodes(N''//database'') [data]([db])
			CROSS APPLY [data].[db].nodes(N''user'') [user]([x])
			CROSS APPLY [user].[x].nodes(N''roles/role'') [roles]([r])
	), 
	aggregated AS ( 
		SELECT 
			[database],
			[user],
			{agg}  
		FROM 
			[shredded]
		GROUP BY 
			[database], [user]
	)

	SELECT 
		[a].[database],
		[a].[user],
		(SELECT TOP (1) ISNULL([x].[login], [x].[user]) FROM [shredded] [x] WHERE [x].[database] = [a].[database] AND [a].[user] = [x].[user]) [login],
		[a].[roles]
	FROM 
		[aggregated] [a]
	ORDER BY 
		[a].[database], [a].[user]; '; 

	IF (SELECT [admindb].dbo.[get_engine_version]()) < 14.0 BEGIN 
		SET @hydrateSQL = REPLACE(@hydrateSQL, N'{agg}', N'STUFF( (SELECT N'','' + s2.[role] FROM [shredded] s2 WHERE [shredded].[database] = s2.[database] AND [shredded].[user] = s2.[user] FOR XML PATH(N'''')), 1, 1, N'' '') [roles]');
	  END; 
	ELSE BEGIN
		SET @hydrateSQL = REPLACE(@hydrateSQL, N'{agg}', N'STRING_AGG([role], N'','') [roles]');
	END;

	INSERT INTO [#hydrated] (
		[database],
		[user],
		[login],
		[roles]
	)
	EXEC sp_executesql 
		@hydrateSQL, 
		N'@MappingXml xml', 
		@MappingXml = @MappingXml;

	IF @ExcludedDatabases IS NOT NULL BEGIN 
		DELETE x 
		FROM 
			[#hydrated] x 
			INNER JOIN dbo.[split_string](@ExcludedDatabases, N', ', 1) dbs ON x.[database] LIKE dbs.[result];
	END;

	IF @ExcludedLogins IS NOT NULL BEGIN 
		DELETE x 
		FROM 
			[#hydrated] x 
			INNER JOIN dbo.[split_string](@ExcludedLogins, N',', 1) l ON x.[login] LIKE l.[result];
	END;

	IF @ExcludedUsers IS NOT NULL BEGIN 
		DELETE x 
		FROM 
			[#hydrated] x 
			INNER JOIN dbo.[split_string](@ExcludedUsers, N',', 1) u ON x.[user] LIKE u.[result];
	END;

	DECLARE @rowId int, @database sysname, @user sysname, @login sysname, @roles nvarchar(MAX);
	DECLARE @sql nvarchar(MAX);
	DECLARE @role sysname;
	DECLARE @message nvarchar(MAX);
	DECLARE @error nvarchar(MAX);
	DECLARE @userExists bit = 0;

	SET @rowId = 0;
	WHILE 1 = 1 BEGIN  /* avoid using nested cursors by using an UGLY while loop here - so'z we can use cursors down below if/as needed: */
		SET @rowId = (SELECT TOP 1 [row_id] FROM [#hydrated] WHERE [row_id] > @rowId ORDER BY [row_id]); 

		IF @rowId IS NULL BEGIN 
			BREAK;
		END;

		SELECT 
			@database = [database],
			@user = [user],
			@login = [login],
			@roles = [roles]
		FROM 
			[#hydrated] 
		WHERE 
			[row_id] = @rowId;

		IF @roles LIKE '%db_owner%' AND @roles LIKE '%,%' BEGIN 
			IF @WarnOnDbOwnerPlusOtherRoles = 1 BEGIN 
				SET @message = N'WARNING: User ' + @user + N' in the [' + @database + N'] is a member of the [db_owner] and 1 or more other roles. Membership in [db_owner] is the super-set of all other roles/options available.';
				UPDATE [#hydrated] SET [notes] = @message WHERE [row_id] = @rowId;
			END;
		END;

		SET @userExists = 0;
		SET @sql = N'IF EXISTS (SELECT NULL FROM [{db}].sys.database_principals WHERE [name] = @user) SET @userExists = 1 ELSE SET @userExists = 0;'; 
		SET @sql = REPLACE(@sql, N'{db}', @database); 

		EXEC sp_executesql 
			@sql, 
			N'@user sysname, @userExists bit OUTPUT', 
			@user = @user, 
			@userExists = @userExists OUTPUT;
		
		IF (@userExists = 0) AND (EXISTS (SELECT NULL FROM sys.[server_principals] WHERE [name] = @login)) BEGIN 
			SET @sql = 'USE [' + @database + N']; CREATE USER [' + @user + N'] FOR LOGIN [' + @login + N'];'

			BEGIN TRY 
				
				IF @PrintOnly = 1 BEGIN 
					PRINT @sql;
				  END;
				ELSE BEGIN 
					EXEC sp_executesql 
						@sql

					UPDATE [#hydrated] 
					SET 
						[notes] = N'NOTE: Login [' + @login + N'] was created for user [' + @user + N'] in database [' + @database + N'].'
					WHERE 
						[row_id] = @rowId;

					SET @userExists = 1;
				END;
			END TRY 
			BEGIN CATCH
				SET @error = CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();

				UPDATE [#hydrated]
				SET 
					[outcome] = N'FAILURE', 
					[exception] = @error + N' '
				WHERE 
					[row_id] = @rowId;

			END CATCH
		END;

		IF @userExists = 1 BEGIN 

			DECLARE [roler] CURSOR LOCAL FAST_FORWARD FOR 
			SELECT 
				[result] [role] 
			FROM 
				dbo.[split_string](@roles, N',', 1) 
			ORDER BY 
				[row_id]; 
		
			OPEN [roler];
			FETCH NEXT FROM [roler] INTO @role;

			WHILE @@FETCH_STATUS = 0 BEGIN
		
				SET @sql = N'USE [' + @database + N']; ALTER ROLE [' + @role + N'] ADD MEMBER [' + @user + N']; '; /* this command is idempotent by design ... no need to do if checks/etc. */

				BEGIN TRY 

					IF @PrintOnly = 1 BEGIN 
						PRINT @sql
					  END; 
					ELSE BEGIN 

						EXEC sp_executesql 
							@sql;

						UPDATE [#hydrated] 
						SET 
							[outcome] = N'SUCCESS' 
						WHERE 
							[row_id] = @rowId; 
					END;

				END TRY 
				BEGIN CATCH 
					SET @error = CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();

					UPDATE [#hydrated]
					SET 
						[outcome] = N'FAILURE', 
						[exception] = ISNULL(@error, N'') + @error
					WHERE 
						[row_id] = @rowId;

				END CATCH;
		
				FETCH NEXT FROM [roler] INTO @role;
			END;
		
			CLOSE [roler];
			DEALLOCATE [roler];

		  END;
		ELSE BEGIN
			/* User doesn't exist - and there is/was no matching LOGIN to bind/use for creation of the needed user, so ... we're going to SKIP... */
			SET @message = N'WARNING: Target User [' + @user + N'] did not exist in database [' + @database + N'] nor was a matching login for [' + @login + N'] found on the server. Mapping could NOT continue.';
			UPDATE [#hydrated] 
			SET 
				[outcome] = N'NOT PROCESSED', 
				[notes] = @message
			WHERE 
				[row_id] = @rowId;
		END;
	END;

	/* Reporting/Output */
	IF EXISTS (SELECT NULL FROM [#hydrated] WHERE [notes] IS NOT NULL OR [exception] IS NOT NULL) BEGIN 
		DECLARE @success int; 
		DECLARE @skipped int; 
		DECLARE @warning int;
		DECLARE @failed int;

		DECLARE @appendXml bit = 0;
		SET @success = (SELECT COUNT(*) FROM [#hydrated] WHERE [outcome] = N'SUCCESS');
		SET @failed = (SELECT COUNT(*) FROM [#hydrated] WHERE [exception] IS NOT NULL);
		SET @warning = (SELECT COUNT(*) FROM [#hydrated] WHERE [notes] LIKE N'WARN%');
		SET @skipped = (SELECT COUNT(*) FROM [#hydrated] WHERE [outcome] = N'NOT PROCESSED');

		DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
		DECLARE @tab nchar(1) = NCHAR(9);

		DECLARE @body nvarchar(MAX) = N'EXECUTION OUTCOME: ' + @crlf 
			+ @tab + N'User-Mappings Successfully Processed		: ' + CAST(@success AS sysname) + @crlf 
			+ @tab + N'User-Mappings Errors Encountered			: ' + CAST(@failed AS sysname) + @crlf 
			+ @tab + N'User-Mappings SKipped (No Usser/Login)		: ' + CAST(@skipped AS sysname) + @crlf 
			+ @tab + N'Total number of processing warnings			: ' + CAST(@warning AS sysname) + @crlf;

		IF @failed > 0 BEGIN 
			SET @body = @body + @crlf + @crlf + N'ERRORS: '; 

			SELECT 
				@body = @body + @crlf + @tab + N'> User [' + [user] + N'] in database [' + [database] + N'] encountered the following exception: ' + @crlf + @tab + @tab + @tab + [exception]
			FROM 
				[#hydrated]
			WHERE 
				[exception] IS NOT NULL 
			ORDER BY 
				[row_id];

			SET @appendXml = 1;
		END;

		IF @warning > 0 BEGIN 
			SET @body = @body + @crlf + @crlf + N'WARNINGS: '; 

			SELECT 
				@body = @body + @crlf + @tab + N'> User [' + [user] + N'] in database [' + [database] + N'] encountered the following WARNING: ' + @crlf + @tab + @tab + @tab + [notes]
			FROM 
				[#hydrated]
			WHERE 
				[notes] IS NOT NULL
			ORDER BY 
				[row_id];

			SET @appendXml = 1;
		END;

		IF @appendXml = 1 AND @PrintOnly = 0 BEGIN 
			SET @body = @body + @crlf + @crlf + @crlf + N'Mapping XML: ' + @crlf + @tab + CAST(@MappingXml AS nvarchar(MAX));
		END;
		
		IF @PrintOnly = 1 BEGIN 
			EXEC dbo.[print_long_string] @body;
		  END; 
		ELSE BEGIN 
			DECLARE @subject sysname = @EmailSubjectPrefix; 
			IF @failed > 0 BEGIN 
				SET @subject = @subject + N' - ERRORS';
			  END;
			ELSE BEGIN 
				SET @subject = @subject + N' - NOTES/WARNINGS';
			END;

			EXEC msdb..sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName,
				@subject = @subject, 
				@body = @body;			
		END;

	END;

	RETURN 0
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
-- Restores:
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.load_backup_files','P') IS NOT NULL
	DROP PROC dbo.load_backup_files;
GO

CREATE PROC dbo.load_backup_files 
	@DatabaseToRestore			sysname,
	@SourcePath					nvarchar(400), 
	@Mode						sysname,				-- FULL | DIFF | LOG | LIST			-- where LIST = 'raw'/translated results.
	@LastAppliedFile			nvarchar(400)			= NULL,	  -- Hmmm. 260 chars is max prior to Windows Server 2016 - and need a REGISTRY tweak to support 1024: https://www.intel.com/content/www/us/en/support/programmable/articles/000075424.html 
-- TODO: 
-- REFACTOR: call this @BackupFinishTimeOfLastAppliedBackup ... er, well, that's what this IS... it's NOT the FINISH time of the last APPLY operation. 
	@LastAppliedFinishTime		datetime				= NULL, 
	@StopAt						datetime				= NULL,
	@Output						xml						= N'<default/>'	    OUTPUT
AS
	SET NOCOUNT ON; 
	SET ANSI_WARNINGS OFF;  -- for NULL/aggregates

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -----------------------------------------------------------------------------
    -- Dependencies Validation:
	EXEC dbo.verify_advanced_capabilities;

	IF @Mode NOT IN (N'FULL',N'DIFF',N'LOG',N'LIST') BEGIN;
		RAISERROR('Configuration Error: Invalid @Mode specified.', 16, 1);
		SET @Output = NULL;
		RETURN -1;
	END; 

	DECLARE @firstLSN decimal(25,0), @lastLSN decimal(25,0);

	IF @Mode IN (N'DIFF', N'LOG') BEGIN

		IF @LastAppliedFinishTime IS NULL AND @LastAppliedFile IS NOT NULL BEGIN 
			DECLARE @fullPath nvarchar(260) = dbo.[normalize_file_path](@SourcePath + N'\' + @LastAppliedFile);

			EXEC dbo.load_header_details 
				@BackupPath = @fullPath, 
				@BackupDate = @LastAppliedFinishTime OUTPUT, 
				@BackupSize = NULL, 
				@Compressed = NULL, 
				@Encrypted = NULL, 
				@FirstLSN = @firstLSN OUTPUT, 
				@LastLSN = @lastLSN OUTPUT;
		END;
		
		IF @LastAppliedFinishTime IS NULL BEGIN 
			RAISERROR(N'Execution in ''DIFF'' or ''LOG'' Mode requires either a valid @LastAppliedFile or @LastAppliedFinishTime for filtering.', 16, 1);
			RETURN -20;
		END;
	END;

	CREATE TABLE #results ([id] int IDENTITY(1,1) NOT NULL, [output] varchar(500), [timestamp] datetime NULL);

	DECLARE @command varchar(2000);
	SET @command = 'dir "' + @SourcePath + '\" /B /A-D /OD';

	INSERT INTO #results ([output])
	EXEC xp_cmdshell 
		@stmt = @command;

	-- High-level Cleanup: 
	DELETE FROM #results WHERE [output] IS NULL OR [output] NOT LIKE '%' + @DatabaseToRestore + '%';

	UPDATE #results
	SET 
		[timestamp] = dbo.[parse_backup_filename_timestamp]([output])
	WHERE 
		[output] IS NOT NULL;

	IF EXISTS (SELECT NULL FROM #results WHERE [timestamp] IS NULL) BEGIN 
		DECLARE @fileName varchar(500);
		DECLARE @headerFullPath nvarchar(1024);  -- using optimal LONG value... even though it might not be configured. https://www.intel.com/content/www/us/en/support/programmable/articles/000075424.html 
		DECLARE @headerBackupTime datetime;
		DECLARE @rowId int;

		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[id],
			[output]
		FROM 
			#results 
		WHERE 
			[timestamp] IS NULL
		ORDER BY 
			[id];

		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @rowId, @fileName;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
			SET @headerFullPath = @SourcePath + N'\' + @fileName;

			BEGIN TRY 
				EXEC dbo.[load_header_details]
					@BackupPath = @headerFullPath,
					@BackupDate = @headerBackupTime OUTPUT, 
					@BackupSize = NULL,
					@Compressed = NULL,
					@Encrypted = NULL,
					@FirstLSN = NULL,
					@LastLSN = NULL; 

				IF @headerBackupTime IS NOT NULL BEGIN 
					UPDATE #results 
					SET 
						[timestamp] = @headerBackupTime
					WHERE 
						[id] = @rowId;
				END;
			END TRY 
			BEGIN CATCH
				-- Strangely enough: DO NOTHING here. The file in question is NOT a backup file. But, we'll ASSUME it was put in here by someone who WANTED it here - for whatever reason.
			END CATCH
		
			FETCH NEXT FROM [walker] INTO @rowId, @fileName;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

		DELETE FROM #results WHERE [timestamp] IS NULL;  -- again, assume that any .bak/.trn files that don't adhere to conventions and/or which aren't legit backups are in place explicitly.
	END;

	CREATE TABLE #orderedResults ( 
		[id] int IDENTITY(1,1) NOT NULL, 
		[output] varchar(500) NOT NULL, 
		[timestamp] datetime NULL, 
		[duplicate_id] int NULL, 
		[first_lsn] decimal(25,0) NULL,
		[last_lsn] decimal(25,0) NULL, 
		[modified_timestamp] datetime NULL, 
		[should_include] bit DEFAULT(0) NOT NULL
	);

	INSERT INTO #orderedResults (
		[output],
		[timestamp]
	)
	SELECT 
		[output], 
		[timestamp]
	FROM 
		#results 
	WHERE 
		[output] IS NOT NULL
	ORDER BY 
		[timestamp], [output];  /* [output] is FILENAME, and needs to be included as an ORDER BY (ASC) to ensure that ties between FULL & LOG push LOG to the end, and that ties between DIFF & LOG push LOG to the end... */

	/* 
		Account for special/edge-case where FULL or DIFF + 'next' LOG backup both have the SAME timestamp (down to the second) 
		And, the way this is done is: 
			a) identify duplicate timestamps (to the second). 
			b) check start/end LSNs for LOG, 
			c) compare vs DIFF/FULL and see if overlaps 
			d) if, so, 'bump' timestamp of LOG forward by .5 seconds - so it's now 'after' the FULL/DIFF.
	*/
	IF EXISTS (SELECT NULL FROM #orderedResults GROUP BY [timestamp] HAVING COUNT(*) > 1) BEGIN 

		WITH duplicates AS ( 		
			SELECT  
				[timestamp], 
				COUNT(*) [x], 
				ROW_NUMBER() OVER (ORDER BY [timestamp]) [duplicate_id]
			FROM 
				#orderedResults 
			GROUP BY	
				[timestamp]
			HAVING 
				COUNT(*) > 1
		) 

		UPDATE x 
		SET 
			x.[duplicate_id] = d.[duplicate_id]
		FROM 
			#orderedResults x 
			INNER JOIN [duplicates] d ON [x].[timestamp] = [d].[timestamp];
		
		DECLARE @duplicateTimestampFile varchar(500);
		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[output]
		FROM 
			#orderedResults 
		WHERE  
			[duplicate_id] IS NOT NULL 
		ORDER BY 
			[duplicate_id];
		
		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @duplicateTimestampFile;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			SET @headerFullPath = @SourcePath + N'\' + @duplicateTimestampFile;
			SET @firstLSN = NULL;
			SET @lastLSN = NULL;			
		
			EXEC dbo.[load_header_details]
				@BackupPath = @headerFullPath,
				@BackupDate = NULL,
				@BackupSize = NULL,
				@Compressed = NULL,
				@Encrypted = NULL,
				@FirstLSN = @firstLSN OUTPUT,
				@LastLSN = @lastLSN OUTPUT; 

			UPDATE #orderedResults 
			SET 
				[first_lsn] = @firstLSN, 
				[last_lsn] = @lastLSN
			WHERE 
				[output] = @duplicateTimestampFile;

			FETCH NEXT FROM [walker] INTO @duplicateTimestampFile;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

		DECLARE @duplicateID int = 1; 
		DECLARE @maxDuplicateID int = (SELECT MAX(duplicate_id) FROM #orderedResults); 

		DECLARE @logFirstLSN decimal(25,0), @logLastLSN decimal(25,0), @fullOrDiffLastLSN decimal(25,2);

		WHILE @duplicateID <= @maxDuplicateID BEGIN 

			SELECT
				@logFirstLSN = first_lsn, 
				@logLastLSN = last_lsn
			FROM 
				#orderedResults 
			WHERE 
				[duplicate_id] = @duplicateID 
				AND [output] LIKE 'LOG%'

			SELECT 
				@fullOrDiffLastLSN = last_lsn 
			FROM 
				#orderedResults 
			WHERE 
				[duplicate_id] = @duplicateID 
				AND [output] NOT LIKE 'LOG%'

			IF @logFirstLSN <= @fullOrDiffLastLSN AND @logLastLSN >= @fullOrDiffLastLSN BEGIN 
				UPDATE #orderedResults 
				SET 
					[modified_timestamp] = DATEADD(MILLISECOND, 500, [timestamp])
				WHERE 
					[duplicate_id] = @duplicateID 
					AND [output] LIKE 'LOG%'
			END;

			SET @duplicateID = @duplicateID +1; 
		END;

		IF EXISTS (SELECT NULL FROM #orderedResults WHERE [modified_timestamp] IS NOT NULL) BEGIN 
			UPDATE #orderedResults 
			SET 
				[timestamp] = [modified_timestamp]
			WHERE 
				[modified_timestamp] IS NOT NULL;
		END;
		
	END;

	/*
		Need to account for a scenario where FULL/DIFF backup EXTENDS to or past the end of a T-LOG Backup running concurrently
		What follows below is a BIT of a hack... because it only looks for LSNs when we're dealing with FULL/DIFF and a LOG backup. 
			i.e., the non-HACK way would be to effectively ONLY(ish) look at LSNs. 	
	*/
	IF UPPER(@Mode) IN (N'LOG', N'LIST') AND (@LastAppliedFile IS NULL AND @LastAppliedFinishTime IS NOT NULL) BEGIN 
		/* This is a fairly nasty hack... */
		SELECT @LastAppliedFile = output FROM #orderedResults WHERE id = (SELECT MAX(id) FROM #orderedResults WHERE ([output] LIKE N'FULL%' OR [output] LIKE N'DIFF%') AND [timestamp] < @LastAppliedFinishTime)
	END;

	IF @LastAppliedFile LIKE N'FULL%' OR @LastAppliedFile LIKE N'DIFF%' BEGIN
		DECLARE @currentFileName varchar(500);
		DECLARE @lowerId int = ISNULL((SELECT id FROM #orderedResults WHERE [output] = @LastAppliedFile), 2) - 1; 
		IF @lowerId < 1 SET @lowerId = 1;

		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[output]
		FROM 
			#orderedResults
		WHERE 
			id >= @lowerID
			-- TODO / vNEXT: if/when there's an @StopTime feature added, put an upper bound on any rows > @StopTime - i.e., AND timestamp < @StopAt.
		ORDER BY 
			[id];

		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @currentFileName;
	
		WHILE @@FETCH_STATUS = 0 BEGIN
	
			SET @headerFullPath = @SourcePath + N'\' + @currentFileName;
			SET @firstLSN = NULL;
			SET @lastLSN = NULL;			
		
			EXEC dbo.[load_header_details]
				@BackupPath = @headerFullPath,
				@BackupDate = NULL,
				@BackupSize = NULL,
				@Compressed = NULL,
				@Encrypted = NULL,
				@FirstLSN = @firstLSN OUTPUT,
				@LastLSN = @lastLSN OUTPUT; 

			UPDATE #orderedResults 
			SET 
				[first_lsn] = @firstLSN, 
				[last_lsn] = @lastLSN
			WHERE 
				[output] = @currentFileName;
	
			FETCH NEXT FROM [walker] INTO @currentFileName;
		END;
	
		CLOSE [walker];
		DEALLOCATE [walker];

		SELECT @fullOrDiffLastLSN = last_lsn FROM #orderedResults WHERE [output] = @LastAppliedFile;

		WITH tweaker AS ( 
			SELECT 
				r.[output], 
				CASE WHEN [r].[first_lsn] <= @fullOrDiffLastLSN AND r.[last_lsn] >= @fullOrDiffLastLSN THEN 1 ELSE 0 END [should_include]
			FROM 
				#orderedResults r
		)

		UPDATE x 
		SET 
			[x].[should_include] = t.should_include
		FROM 
			#orderedResults x
			INNER JOIN [tweaker] t ON [x].[output] = [t].[output]
		WHERE 
			t.[should_include] = 1
			AND x.[output] LIKE N'LOG%';


		/* Additional 'special use case' for scenarios where MULTIPLE T-LOGs have been executing while a DIFF or FULL was being created */
		UPDATE #orderedResults 
		SET 
			should_include = 1 
		WHERE 
			[output] LIKE N'%LOG%' 
			AND [timestamp] <= @LastAppliedFinishTime 
			AND [id] > (SELECT MAX(id) FROM #orderedResults WHERE should_include = 1);

		/* This is a bit of an odd/weird hack - i.e., I could also exclude [should_include] = 1 from DELETE operations down below) */
		UPDATE #orderedResults 
		SET 
			[timestamp] = DATEADD(MILLISECOND, 500, @LastAppliedFinishTime) 
		WHERE 
			should_include = 1; 
	END;

	IF UPPER(@Mode) = N'LIST' BEGIN 

		IF (SELECT dbo.is_xml_empty(@Output)) = 1 BEGIN -- if explicitly initialized to NULL/empty... 
			
			SELECT @Output = (SELECT
				[id] [file/@id],
				[output] [file/@file_name],
				[timestamp] [file/@timestamp]
			FROM 
				#orderedResults 
			ORDER BY 
				id 
			FOR XML PATH(''), ROOT('files'));

			RETURN 0;

		END;

		SELECT 
			[id],
			[output] [file_name],
			[timestamp] 
		FROM 
			#orderedResults 
		ORDER BY 
			[id];

        RETURN 0;
    END;

	IF UPPER(@Mode) = N'FULL' BEGIN
		IF @StopAt IS NOT NULL BEGIN 
			-- grab the most recent full before the STOP AT directive (vs the last/most-recent of all time):
			DELETE FROM [#orderedResults] WHERE id <> ISNULL((SELECT MAX(id) FROM [#orderedResults] WHERE [output] LIKE 'FULL%' AND [timestamp] < @StopAt), -1);
		  END;
		ELSE BEGIN
			-- most recent full only: 
			DELETE FROM #orderedResults WHERE id <> ISNULL((SELECT MAX(id) FROM #orderedResults WHERE [output] LIKE 'FULL%'), -1);
		END;
	END;

	IF UPPER(@Mode) = N'DIFF' BEGIN 
		DELETE FROM #orderedResults WHERE [timestamp] <= @LastAppliedFinishTime;

		-- now dump everything but the most recent DIFF - if there is one: 
		IF EXISTS(SELECT NULL FROM #orderedResults WHERE [output] LIKE 'DIFF%') BEGIN
			IF @StopAt IS NULL BEGIN
				DELETE FROM #orderedResults WHERE id <> (SELECT MAX(id) FROM #orderedResults WHERE [output] LIKE 'DIFF%'); 
			  END
			ELSE BEGIN
				DELETE FROM [#orderedResults] WHERE id <> ISNULL((SELECT MAX(id) FROM [#orderedResults] WHERE [output] LIKE 'DIFF%' AND [timestamp] < @StopAt), -1);	
			END;
		  END;
		ELSE
			DELETE FROM #orderedResults;
	END;

	IF UPPER(@Mode) = N'LOG' BEGIN
		DELETE FROM #orderedResults WHERE [timestamp] <= @LastAppliedFinishTime;
		DELETE FROM #orderedResults WHERE [output] NOT LIKE 'LOG%';

		IF @StopAt IS NOT NULL 
			DELETE FROM [#orderedResults] WHERE id > (SELECT MIN(id) FROM [#orderedResults] WHERE [output] LIKE 'LOG%' AND [timestamp] > @StopAt);
	END;

    IF (SELECT dbo.is_xml_empty(@Output)) = 1 BEGIN 
        
		SELECT @Output = (SELECT
			[id] [file/@id],
			[output] [file/@file_name]
		FROM 
			#orderedResults 
		ORDER BY 
			id 
		FOR XML PATH(''), ROOT('files'));

        RETURN 0;
    END;

    SELECT 
        [output]
    FROM 
        #orderedResults
    ORDER BY 
        [id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.load_header_details','P') IS NOT NULL
	DROP PROC dbo.load_header_details;
GO

CREATE PROC dbo.load_header_details 
	@BackupPath					nvarchar(800),				-- looks like this should be 1024 and varchar? or nvarchar? See - https://www.intel.com/content/www/us/en/support/programmable/articles/000075424.html 
	@SourceVersion				decimal(4,2)	            = NULL,
	@BackupDate					datetime		            OUTPUT, 
	@BackupSize					bigint			            OUTPUT, 
	@Compressed					bit				            OUTPUT, 
	@Encrypted					bit				            OUTPUT, 
	@FirstLSN					decimal(25,0)				= NULL	OUTPUT, 
	@LastLSN					decimal(25,0)				= NULL	OUTPUT
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-- TODO: 
	--		make sure file/path exists... 

	DECLARE @executingServerVersion decimal(4,2);
	SELECT @executingServerVersion = (SELECT dbo.get_engine_version());

	IF NULLIF(@SourceVersion, 0) IS NULL SET @SourceVersion = @executingServerVersion;

	CREATE TABLE #header (
		BackupName nvarchar(128) NULL, -- backups generated by S4 ALWAYS have this value populated - but it's NOT required by SQL Server (obviously).
		BackupDescription nvarchar(255) NULL, 
		BackupType smallint NOT NULL, 
		ExpirationDate datetime NULL, 
		Compressed bit NOT NULL, 
		Position smallint NOT NULL, 
		DeviceType tinyint NOT NULL, --
		Username nvarchar(128) NOT NULL, 
		ServerName nvarchar(128) NOT NULL, 
		DatabaseName nvarchar(128) NOT NULL,
		DatabaseVersion int NOT NULL, 
		DatabaseCreationDate datetime NOT NULL, 
		BackupSize numeric(20,0) NOT NULL, 
		FirstLSN numeric(25,0) NOT NULL, 
		LastLSN numeric(25,0) NOT NULL, 
		CheckpointLSN numeric(25,0) NOT NULL, 
		DatabaseBackupLSN numeric(25,0) NOT NULL, 
		BackupStartDate datetime NOT NULL, 
		BackupFinishDate datetime NOT NULL, 
		SortOrder smallint NULL, 
		[CodePage] smallint NOT NULL, 
		UnicodeLocaleID int NOT NULL, 
		UnicodeComparisonStyle int NOT NULL,
		CompatibilityLevel tinyint NOT NULL, 
		SoftwareVendorID int NOT NULL, 
		SoftwareVersionMajor int NOT NULL, 
		SoftwareVersionMinor int NOT NULL, 
		SoftwareVersionBuild int NOT NULL, 
		MachineName nvarchar(128) NOT NULL, 
		Flags int NOT NULL, 
		BindingID uniqueidentifier NOT NULL, 
		RecoveryForkID uniqueidentifier NULL, 
		Collation nvarchar(128) NOT NULL, 
		FamilyGUID uniqueidentifier NOT NULL, 
		HasBulkLoggedData bit NOT NULL, 
		IsSnapshot bit NOT NULL, 
		IsReadOnly bit NOT NULL, 
		IsSingleUser bit NOT NULL, 
		HasBackupChecksums bit NOT NULL, 
		IsDamaged bit NOT NULL, 
		BeginsLogChain bit NOT NULL, 
		HasIncompleteMetaData bit NOT NULL, 
		IsForceOffline bit NOT NULL, 
		IsCopyOnly bit NOT NULL, 
		FirstRecoveryForkID uniqueidentifier NOT NULL, 
		ForkPointLSN numeric(25,0) NULL, 
		RecoveryModel nvarchar(60) NOT NULL, 
		DifferntialBaseLSN numeric(25,0) NULL, 
		DifferentialBaseGUID uniqueidentifier NULL, 
		BackupTypeDescription nvarchar(60) NOT NULL, 
		BackupSetGUID uniqueidentifier NULL, 
		CompressedBackupSize bigint NOT NULL  -- 2008 / 2008 R2  (10.0  / 10.5)
	);

	IF @SourceVersion >= 11.0 BEGIN -- columns added to 2012 and above:
		ALTER TABLE [#header]
			ADD Containment tinyint NOT NULL; -- 2012 (11.0)
	END; 

	IF @SourceVersion >= 13.0 BEGIN  -- columns added to 2016 and above:
		ALTER TABLE [#header]
			ADD 
				KeyAlgorithm nvarchar(32) NULL, 
				EncryptorThumbprint varbinary(20) NULL, 
				EncryptorType nvarchar(32) NULL;
	END;

	IF @SourceVersion >= 16.0 BEGIN -- columns added to SQL Server 2022 and above: 
		ALTER TABLE [#header]
			ADD 
				LastValidRestoreTime datetime NULL, -- NOT documented as of 2023-01-18 
				TimeZone int NULL,		-- ditto, not documented ... 
				CompressionAlgorithm nvarchar(32) NULL;
	END;

	DECLARE @command nvarchar(MAX); 

	SET @command = N'RESTORE HEADERONLY FROM DISK = N''{0}'';';
	SET @command = REPLACE(@command, N'{0}', @BackupPath);
	
	INSERT INTO [#header] 
	EXEC sp_executesql @command;

	DECLARE @encryptionValue bit = 0;
	IF @SourceVersion >= 13.0 BEGIN

		EXEC sys.[sp_executesql]
			@stmt = N'SELECT @encryptionValue = CASE WHEN EncryptorThumbprint IS NOT NULL THEN 1 ELSE 0 END FROM [#header];', 
			@params = N'@encryptionValue bit OUTPUT',
			@encryptionValue = @encryptionValue OUTPUT; 
	END;

	-- Return Output Details: 
	SELECT 
		@BackupDate = [BackupFinishDate], 
		@BackupSize = CAST((ISNULL([CompressedBackupSize], [BackupSize])) AS bigint), 
		@Compressed = [Compressed], 
		@Encrypted = ISNULL(@encryptionValue, 0), 
		@FirstLSN = [FirstLSN], 
		@LastLSN = [LastLSN]
	FROM 
		[#header];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.parse_backup_filename_timestamp','FN') IS NOT NULL
	DROP FUNCTION dbo.[parse_backup_filename_timestamp];
GO

CREATE FUNCTION dbo.[parse_backup_filename_timestamp] (@filename varchar(500))
RETURNS datetime
	WITH RETURNS NULL ON NULL INPUT
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
		DECLARE @datestring sysname;
		DECLARE @fileOnly varchar(500) = dbo.[extract_filename_from_fullpath](@filename);
    	
    	DECLARE @parts table (
			row_id int NOT NULL, 
			file_part sysname NOT NULL
		);

		INSERT INTO @parts (
			[row_id],
			[file_part]
		)
		SELECT 
			[row_id],
			CAST([result] AS sysname)
		FROM 
			dbo.[split_string](@filename, N'_', 1)


		-- KIND of an elaborate work-around to find the date-stamp WITHOUT using TRY_CAST... 
		DECLARE @anchor int;
		WITH core AS ( 
			SELECT 
				[row_id], 
				[file_part], 
				LEN([file_part]) [len]
			FROM 
				@parts
			WHERE 
				[file_part] LIKE N'%[0-9]%' AND LEN([file_part]) IN (2,4,6)
		), 
		leading AS ( 
			SELECT 
				[c].[row_id],
				[c].[file_part],
				[c].[len], 
				ISNULL((SELECT CAST([len] AS sysname) FROM core c2 WHERE c2.[row_id] = c.[row_id] - 3), N'') + N'-'
				+ ISNULL((SELECT CAST([len] AS sysname) FROM core c2 WHERE c2.[row_id] = c.[row_id] - 2), N'') + N'-'
				+ ISNULL((SELECT CAST([len] AS sysname) FROM core c2 WHERE c2.[row_id] = c.[row_id] - 1), N'') + N'-' 
				+ CAST([c].[len] AS sysname)
				[pattern]
			FROM 
				core c
		) 

		SELECT TOP 1
			@anchor = [leading].[row_id]
		FROM 
			leading
		WHERE 
			[leading].[pattern] = N'4-2-2-6'
		ORDER BY 
			[leading].[row_id] DESC;

		DECLARE @date sysname = N'';
		DECLARE @time sysname;
		SELECT 
			@date = @date + file_part + CASE WHEN [row_id] = (@anchor - 1) THEN '' ELSE '-' END
		FROM 
			@parts
		WHERE 
			[row_id] IN ((@anchor - 3), (@anchor - 2), (@anchor - 1))
		ORDER BY 
			[row_id];

		SELECT @time = file_part FROM @parts WHERE [row_id] = (@anchor);  -- 7
		SET @time = LEFT(@time, 2) + N':' + SUBSTRING(@time, 3, 2) + N':' + RIGHT(@time, 2);
    	
    	SET @datestring = @date + N' ' + @time;

		RETURN CAST(@datestring AS datetime);
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.restore_databases','P') IS NOT NULL
    DROP PROC dbo.restore_databases;
GO

CREATE PROC dbo.restore_databases 
    @DatabasesToRestore				nvarchar(MAX),
    @DatabasesToExclude				nvarchar(MAX)	= NULL,
    @Priorities						nvarchar(MAX)	= NULL,
    @BackupsRootPath				nvarchar(MAX)	= N'{DEFAULT}',
    @RestoredRootDataPath			nvarchar(MAX)	= N'{DEFAULT}',
    @RestoredRootLogPath			nvarchar(MAX)	= N'{DEFAULT}',
    @RestoredDbNamePattern			nvarchar(40)	= N'{0}_s4test',
    @AllowReplace					nchar(7)		= NULL,				-- NULL or the exact term: N'REPLACE'...
    @SkipLogBackups					bit				= 0,
	@ExecuteRecovery				bit				= 1,
    @CheckConsistency				bit				= 1,
	@RpoWarningThreshold			nvarchar(20)	= NULL,				-- Only evaluated if non-NULL. CAN be specified as 'vector' or ... as 'vector, vector' - in which case apply as FULL + SIMPLE recovery RPOs.
	@SkipSanityChecks				bit				= 0,				-- ONLY evaluated if @RpoChecks are NULL. Similar to RPO tests - if restore is > 26 hours old, sends alerts about possible config error. 
    @DropDatabasesAfterRestore		bit				= 0,				-- Only works if set to 1, and if we've RESTORED the db in question. 
    @MaxNumberOfFailedDrops			int				= 1,				-- number of failed DROP operations we'll tolerate before early termination.
    @Directives						nvarchar(400)	= NULL,				-- { PRESERVE_FILENAMES | RESTRICTED_USER | KEEP_REPLICATION | KEEP_CDC | [ ENABLE_BROKER | ERROR_BROKER_CONVERSATIONS | NEW_BROKER ] }
	@OperatorName					sysname			= N'Alerts',
    @MailProfileName				sysname			= N'General',
    @EmailSubjectPrefix				nvarchar(50)	= N'[RESTORE TEST] ',
    @PrintOnly						bit				= 0
AS
    SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -----------------------------------------------------------------------------
    -- Dependencies Validation:
	DECLARE @return int;
    EXEC @return = dbo.verify_advanced_capabilities;
	IF @return <> 0 
		RETURN @return;

	-----------------------------------------------------------------------------
    -- Set Defaults:
    IF UPPER(@BackupsRootPath) = N'{DEFAULT}' BEGIN
        SELECT @BackupsRootPath = dbo.load_default_path('BACKUP');
    END;

    IF UPPER(@RestoredRootDataPath) = N'{DEFAULT}' BEGIN
        SELECT @RestoredRootDataPath = dbo.load_default_path('DATA');
    END;

    IF UPPER(@RestoredRootLogPath) = N'{DEFAULT}' BEGIN
        SELECT @RestoredRootLogPath = dbo.load_default_path('LOG');
    END;

    -----------------------------------------------------------------------------
    -- Validate Inputs: 
    IF @PrintOnly = 0 BEGIN -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 
        
        -- Operator Checks:
        IF ISNULL(@OperatorName, '') IS NULL BEGIN
            RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
            RETURN -2;
         END;
        ELSE BEGIN 
            IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
                RAISERROR('Invalild Operator Name Specified.', 16, 1);
                RETURN -2;
            END;
        END;

        -- Profile Checks:
        DECLARE @DatabaseMailProfile nvarchar(255)
        EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output'
 
        IF @DatabaseMailProfile <> @MailProfileName BEGIN
            RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
            RETURN -2;
        END; 
    END;

	IF @ExecuteRecovery = 0 AND @DropDatabasesAfterRestore = 1 BEGIN
		RAISERROR(N'@ExecuteRecovery cannot be set to false (0) when @DropDatabasesAfterRestore is set to true (1).', 16, 1);
		RETURN -5;
	END;

    IF @MaxNumberOfFailedDrops <= 0 BEGIN
        RAISERROR('@MaxNumberOfFailedDrops must be set to a value of 1 or higher.', 16, 1);
        RETURN -6;
    END;

    IF NULLIF(@AllowReplace, N'') IS NOT NULL AND UPPER(@AllowReplace) <> N'REPLACE' BEGIN
        RAISERROR('The @AllowReplace switch must be set to NULL or the exact term N''REPLACE''.', 16, 1);
        RETURN -4;
    END;

    IF NULLIF(@AllowReplace, N'') IS NOT NULL AND @DropDatabasesAfterRestore = 1 BEGIN
        RAISERROR('Databases cannot be explicitly REPLACED and DROPPED after being replaced. If you wish DBs to be restored (on a different server for testing) with SAME names as PROD, simply leave suffix empty (but not NULL) and leave @AllowReplace NULL.', 16, 1);
        RETURN -6;
    END;

    IF UPPER(@DatabasesToRestore) IN (N'{SYSTEM}', N'{USER}') BEGIN
        RAISERROR('The tokens {SYSTEM} and {USER} cannot be used to specify which databases to restore via dbo.restore_databases. Use either {READ_FROM_FILESYSTEM} (plus any exclusions via @DatabasesToExclude), or specify a comma-delimited list of databases to restore.', 16, 1);
        RETURN -10;
    END;

    IF RTRIM(LTRIM(@DatabasesToExclude)) = N''
        SET @DatabasesToExclude = NULL;

    IF (@DatabasesToExclude IS NOT NULL) AND (UPPER(@DatabasesToRestore) <> N'{READ_FROM_FILESYSTEM}') BEGIN
        RAISERROR('@DatabasesToExclude can ONLY be specified when @DatabasesToRestore is defined as the {READ_FROM_FILESYSTEM} token. Otherwise, if you don''t want a database restored, don''t specify it in the @DatabasesToRestore ''list''.', 16, 1);
        RETURN -20;
    END;

    IF (NULLIF(@RestoredDbNamePattern,'')) IS NULL BEGIN
        RAISERROR('@RestoredDbNamePattern can NOT be NULL or empty. Use the place-holder token ''{0}'' to represent the name of the original database (e.g., ''{0}_test'' would become ''dbname_test'' when restoring a database named ''dbname - whereas ''{0}'' would simply be restored as the name of the db to restore per database).', 16, 1);
        RETURN -22;
    END;

	DECLARE @vector bigint; 
	DECLARE @vectorSimple bigint = NULL;
	DECLARE @vError nvarchar(MAX) = NULL;
	
	IF NULLIF(@RpoWarningThreshold, N'') IS NOT NULL BEGIN 
		IF @RpoWarningThreshold LIKE N'%,%' BEGIN
			DECLARE @threshold sysname;

			SELECT @threshold = [result] FROM [dbo].[split_string](@RpoWarningThreshold, N',', 1) WHERE [row_id] = 1;

			EXEC [dbo].[translate_vector]
				@Vector = @threshold, 
				@ValidationParameterName = N'@RpoWarningThreshold (FULL-RECOVERY Specifier)', 
				@TranslationDatePart = N'SECOND', 
				@Output = @vector OUTPUT, 
				@Error = @vError OUTPUT;

			IF @vError IS NOT NULL BEGIN 
				RAISERROR(@vError, 16, 1);
				RETURN -28;
			END;

			SELECT @threshold = [result] FROM [dbo].[split_string](@RpoWarningThreshold, N',', 1) WHERE [row_id] = 2;

			EXEC [dbo].[translate_vector]
				@Vector = @threshold, 
				@ValidationParameterName = N'@RpoWarningThreshold (SIMPLE-RECOVERY Specifier)', 
				@TranslationDatePart = N'SECOND', 
				@Output = @vectorSimple OUTPUT, 
				@Error = @vError OUTPUT;

			IF @vError IS NOT NULL BEGIN 
				RAISERROR(@vError, 16, 1);
				RETURN -29;
			END;			
		  END;
		ELSE BEGIN

			EXEC [dbo].[translate_vector]
				@Vector = @RpoWarningThreshold, 
				@ValidationParameterName = N'@RpoWarningThreshold', 
				@TranslationDatePart = N'SECOND', 
				@Output = @vector OUTPUT, 
				@Error = @vError OUTPUT;

			IF @vError IS NOT NULL BEGIN 
				RAISERROR(@vError, 16, 1);
				RETURN -20;
			END;
		END;
	END;

	DECLARE @stopAt datetime = NULL;
	DECLARE @directivesText nvarchar(200) = N'';
	IF NULLIF(@Directives, N'') IS NOT NULL BEGIN
		SET @Directives = UPPER(LTRIM(RTRIM(@Directives)));
		
		DECLARE @allDirectives table ( 
			row_id int NOT NULL, 
			directive sysname NOT NULL, 
			detail sysname NULL
		);

		INSERT INTO @allDirectives ([row_id], [directive])
		SELECT * FROM dbo.[split_string](@Directives, N',', 1);

		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] LIKE 'STOPAT:%') BEGIN 
			UPDATE @allDirectives 
			SET 
				[directive] = N'STOPAT',
				[detail] = SUBSTRING([directive], CHARINDEX(N':', [directive]) + 1, LEN([directive]))
			WHERE 
				[directive] LIKE 'STOPAT:%'

			SELECT @stopAt = CAST([detail] AS datetime) FROM @allDirectives WHERE [directive] = N'STOPAT';
		END;

		-- verify that only supported directives are defined: 
		IF EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] NOT IN (N'STOPAT', N'RESTRICTED_USER', N'KEEP_REPLICATION', N'KEEP_CDC', N'ENABLE_BROKER', N'ERROR_BROKER_CONVERSATIONS' , N'NEW_BROKER', N'PRESERVE_FILENAMES')) BEGIN
			RAISERROR(N'Invalid @Directives value specified. Permitted values are { STOPAT:<datetime> | RESTRICTED_USER | KEEP_REPLICATION | KEEP_CDC | PRESERVE_FILENAMES | [ ENABLE_BROKER | ERROR_BROKER_CONVERSATIONS | NEW_BROKER ] }.', 16, 1);
			RETURN -20;
		END;

		-- make sure we're ONLY specifying a single BROKER directive (i.e., all three options are supported, but they're (obviously) mutually exclusive).
		IF (SELECT COUNT(*) FROM @allDirectives WHERE [directive] LIKE '%BROKER%') > 1 BEGIN 
			RAISERROR(N'Invalid @Directives values specified. ENABLE_BROKER, ERROR_BROKER_CONVERSATIONS, and NEW_BROKER directives are ALLOWED - but only one can be specified as part of a restore operation. Consult Books Online for more info.', 16, 1);
			RETURN -21;
		END;

		SELECT @directivesText = @directivesText + [directive] + N', ' 
		FROM @allDirectives 
		WHERE 
			[directive] <> N'STOPAT'
		ORDER BY [row_id];
	END;

	-----------------------------------------------------------------------------
    -- 'Global' Variables:
    DECLARE @isValid bit;
    DECLARE @earlyTermination nvarchar(MAX) = N'';
    DECLARE @emailErrorMessage nvarchar(MAX);
    DECLARE @emailSubject nvarchar(300);
    DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
    DECLARE @tab char(1) = CHAR(9);
    DECLARE @executionID uniqueidentifier = NEWID();
    DECLARE @executeDropAllowed bit;
    DECLARE @failedDropCount int = 0;
	DECLARE @isPartialRestore bit = 0;

	-- normalize paths: 
	SET @BackupsRootPath = dbo.[normalize_file_path](@BackupsRootPath)

    -- Verify Paths: 
    EXEC dbo.check_paths @BackupsRootPath, @isValid OUTPUT;
    IF @isValid = 0 BEGIN
        SET @earlyTermination = N'@BackupsRootPath (' + @BackupsRootPath + N') is invalid - restore operations terminated prematurely.';
        GOTO FINALIZE;
    END;
    
    EXEC dbo.check_paths @RestoredRootDataPath, @isValid OUTPUT;
    IF @isValid = 0 BEGIN
        SET @earlyTermination = N'@RestoredRootDataPath (' + @RestoredRootDataPath + N') is invalid - restore operations terminated prematurely.';
        GOTO FINALIZE;
    END;

    EXEC dbo.check_paths @RestoredRootLogPath, @isValid OUTPUT;
    IF @isValid = 0 BEGIN
        SET @earlyTermination = N'@RestoredRootLogPath (' + @RestoredRootLogPath + N') is invalid - restore operations terminated prematurely.';
        GOTO FINALIZE;
    END;

    -----------------------------------------------------------------------------
    -- Construct list of databases to restore:
    DECLARE @dbsToRestore table (
        [entry_id] int IDENTITY(1,1) NOT NULL, 
        [database_name] sysname NOT NULL
    ); 

	-- If the {READ_FROM_FILESYSTEM} token is specified, replace {READ_FROM_FILESYSTEM} in @DatabasesToRestore with a serialized list of db-names pulled from @BackupRootPath:
	IF ((SELECT dbo.[count_matches](@DatabasesToRestore, N'{READ_FROM_FILESYSTEM}')) > 0) BEGIN
		DECLARE @databases xml = NULL;
		DECLARE @serialized nvarchar(MAX) = '';

		EXEC dbo.[load_backup_database_names]
		    @TargetDirectory = @BackupsRootPath,
		    @SerializedOutput = @databases OUTPUT;

		WITH shredded AS ( 
			SELECT 
				[data].[row].value('@id[1]', 'int') [row_id], 
				[data].[row].value('.[1]', 'sysname') [database_name]
			FROM 
				@databases.nodes('//database') [data]([row])
		) 

		SELECT 
			@serialized = @serialized + [database_name] + N','
		FROM 
			shredded 
		ORDER BY 
			row_id;

		IF @serialized = N'' BEGIN
			RAISERROR(N'No sub-folders (potential database backups) found at path specified by @BackupsRootPath. Please double-check your input.', 16, 1);
			RETURN -30;
		  END;
		ELSE
			SET @serialized = LEFT(@serialized, LEN(@serialized) - 1);

		SET @DatabasesToRestore = REPLACE(@DatabasesToRestore, N'{READ_FROM_FILESYSTEM}', @serialized); 
	END;
    
    INSERT INTO @dbsToRestore ([database_name])
    EXEC dbo.list_databases
        @Targets = @DatabasesToRestore,         
        @Exclusions = @DatabasesToExclude,		-- only works if {READ_FROM_FILESYSTEM} is specified for @Input... 
        @Priorities = @Priorities,

		-- ALLOW these to be included ... they'll throw exceptions if REPLACE isn't specified. But if it is SPECIFIED, then someone is trying to EXPLICTLY overwrite 'bunk' databases with a restore... 
		@ExcludeSecondaries = 0,
		@ExcludeRestoring = 0,
		@ExcludeRecovering = 0,	
		@ExcludeOffline = 0;

    IF NOT EXISTS (SELECT NULL FROM @dbsToRestore) BEGIN
        RAISERROR('No Databases Specified to Restore. Please Check inputs for @DatabasesToRestore + @DatabasesToExclude and retry.', 16, 1);
        RETURN -20;
    END;

    DECLARE @databaseToRestore sysname;
    DECLARE @restoredName sysname;
	DECLARE @restoreStart datetime;

    DECLARE @fullRestoreTemplate nvarchar(MAX) = N'RESTORE DATABASE [{0}] FROM DISK = N''{1}''' + NCHAR(13) + NCHAR(10) + NCHAR(9) + N'WITH {partial}' + NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + '{move}, ' + NCHAR(13) + NCHAR(10) + NCHAR(9) + N'NORECOVERY;'; 
    DECLARE @move nvarchar(MAX);
    DECLARE @restoreLogId int;
    DECLARE @sourcePath nvarchar(500);
    DECLARE @statusDetail nvarchar(MAX);
    DECLARE @pathToDatabaseBackup nvarchar(600);
    DECLARE @outcome varchar(4000);
	DECLARE @serializedFileList xml = NULL; 
	DECLARE @backupName sysname;
	DECLARE @fileListXml nvarchar(MAX);
	DECLARE @stopAtLog int = NULL;

	DECLARE @restoredFileName nvarchar(MAX);
	DECLARE @ndfCount int = 0;

	-- dbo.execute_command variables: 
	DECLARE @execResults xml;
	DECLARE @errorMessage nvarchar(MAX);

	DECLARE @ignoredLogFiles int = 0;

	CREATE TABLE #logFilesToRestore ( 
		id int IDENTITY(1,1) NOT NULL, 
		log_file sysname NOT NULL
	);
	DECLARE @currentLogFileID int = 0;

	DECLARE @restoredFiles table (
		ID int IDENTITY(1,1) NOT NULL, 
		[FileName] nvarchar(400) NOT NULL, 
		Detected datetime NOT NULL, 
		BackupCreated datetime NULL, 
		Applied datetime NULL, 
		BackupSize bigint NULL, 
		Compressed bit NULL, 
		[Encrypted] bit NULL, 
		[Comment] nvarchar(MAX) NULL
	); 

	DECLARE @backupDate datetime, @backupSize bigint, @compressed bit, @encrypted bit;

    IF @CheckConsistency = 1 BEGIN
        IF OBJECT_ID('tempdb..#DBCC_OUTPUT') IS NOT NULL 
            DROP TABLE #DBCC_OUTPUT;

        CREATE TABLE #DBCC_OUTPUT(
                RowID int IDENTITY(1,1) NOT NULL, 
                Error int NULL,
                [Level] int NULL,
                [State] int NULL,
                MessageText nvarchar(2048) NULL,
                RepairLevel nvarchar(22) NULL,
                [Status] int NULL,
                [DbId] int NULL, -- was smallint in SQL2005
                DbFragId int NULL,      -- new in SQL2012
                ObjectId int NULL,
                IndexId int NULL,
                PartitionId bigint NULL,
                AllocUnitId bigint NULL,
                RidDbId smallint NULL,  -- new in SQL2012
                RidPruId smallint NULL, -- new in SQL2012
                [File] smallint NULL,
                [Page] int NULL,
                Slot int NULL,
                RefDbId smallint NULL,  -- new in SQL2012
                RefPruId smallint NULL, -- new in SQL2012
                RefFile smallint NULL,
                RefPage int NULL,
                RefSlot int NULL,
                Allocation smallint NULL
        );
    END;

    CREATE TABLE #FileList (
        LogicalName nvarchar(128) NOT NULL, 
        PhysicalName nvarchar(260) NOT NULL,
        [Type] CHAR(1) NOT NULL, 
        FileGroupName nvarchar(128) NULL, 
        Size numeric(20,0) NOT NULL, 
        MaxSize numeric(20,0) NOT NULL, 
        FileID bigint NOT NULL, 
        CreateLSN numeric(25,0) NOT NULL, 
        DropLSN numeric(25,0) NULL, 
        UniqueId uniqueidentifier NOT NULL, 
        ReadOnlyLSN numeric(25,0) NULL, 
        ReadWriteLSN numeric(25,0) NULL, 
        BackupSizeInBytes bigint NOT NULL, 
        SourceBlockSize int NOT NULL, 
        FileGroupId int NOT NULL, 
        LogGroupGUID uniqueidentifier NULL, 
        DifferentialBaseLSN numeric(25,0) NULL, 
        DifferentialBaseGUID uniqueidentifier NOT NULL, 
        IsReadOnly bit NOT NULL, 
        IsPresent bit NOT NULL, 
        TDEThumbprint varbinary(32) NULL
    );

    -- SQL Server 2016 adds SnapshotURL of nvarchar(360) for azure stuff:
	IF (SELECT dbo.get_engine_version()) >= 13.0 BEGIN
        ALTER TABLE #FileList ADD SnapshotURL nvarchar(360) NULL;
    END;

    DECLARE restorer CURSOR LOCAL FAST_FORWARD FOR 
    SELECT 
        [database_name]
    FROM 
        @dbsToRestore
    WHERE
        LEN([database_name]) > 0
    ORDER BY 
        entry_id;

    DECLARE @command nvarchar(2000);

    OPEN restorer;

    FETCH NEXT FROM restorer INTO @databaseToRestore;
    WHILE @@FETCH_STATUS = 0 BEGIN
        
		-- reset every 'loop' through... 
		SET @ignoredLogFiles = 0;
        SET @statusDetail = NULL; 
		SET @isPartialRestore = 0;
		SET @serializedFileList = NULL;
        DELETE FROM @restoredFiles;
		
		SET @restoredName = REPLACE(@RestoredDbNamePattern, N'{0}', @databaseToRestore);
        IF (@restoredName = @databaseToRestore) AND (@RestoredDbNamePattern <> '{0}') -- then there wasn't a {0} token - so set @restoredName to @RestoredDbNamePattern
            SET @restoredName = @RestoredDbNamePattern;  -- which seems odd, but if they specified @RestoredDbNamePattern = 'Production2', then that's THE name they want...

        IF @PrintOnly = 0 BEGIN
            INSERT INTO dbo.restore_log (execution_id, [database], restored_as, restore_start, error_details)
            VALUES (@executionID, @databaseToRestore, @restoredName, GETDATE(), '#UNKNOWN ERROR#');

            SELECT @restoreLogId = SCOPE_IDENTITY();
        END;

        -- Verify Path to Source db's backups:
        SET @sourcePath = @BackupsRootPath + N'\' + @databaseToRestore;
        EXEC dbo.check_paths @sourcePath, @isValid OUTPUT;
        IF @isValid = 0 BEGIN 
			SET @statusDetail = N'The backup path: ' + @sourcePath + ' is invalid.';
			GOTO NextDatabase;
        END;
        
		-- Process attempt to overwrite an existing database: 
		IF EXISTS (SELECT NULL FROM master.sys.databases WHERE [name] = @restoredName) BEGIN

			-- IF we're going to allow an explicit REPLACE, start by putting the target DB into SINGLE_USER mode: 
			IF @AllowReplace = N'REPLACE' BEGIN
				
				BEGIN TRY 

					IF EXISTS(SELECT NULL FROM sys.databases WHERE [name] = @restoredName AND state_desc = 'ONLINE') BEGIN

						SET @command = N'ALTER DATABASE ' + QUOTENAME(@restoredName) + ' SET SINGLE_USER WITH ROLLBACK IMMEDIATE;' + @crlf
							+ N'DROP DATABASE ' + QUOTENAME(@restoredName) + N';' + @crlf + @crlf;
							
						IF @PrintOnly = 1 BEGIN
							PRINT @command;
							END;
						ELSE BEGIN
							
							EXEC dbo.[execute_command]
								@Command = @command, 
								@DelayBetweenAttempts = N'8 seconds',
								@IgnoredResults = N'{COMMAND_SUCCESS},{USE_DB_SUCCESS},{SINGLE_USER}', 
								@Outcome = @execResults OUTPUT, 
								@ErrorMessage = @errorMessage OUTPUT;

							IF dbo.[transient_error_occurred](@execResults) = 1 BEGIN 
								SET @statusDetail = N'NOTE: Transient Error Detected with SINGLE_USER > DROP operations::> ' + CAST(@execResults AS nvarchar(MAX));
							END;
							
							IF @errorMessage IS NOT NULL BEGIN 
								SET @statusDetail = N'Error with SINGLE_USER > DROP operations::>  Error(s): ' + @errorMessage + N' ExecutionDetails: ' + CAST(@execResults AS nvarchar(MAX));
							END;
						END;

					  END;
					ELSE BEGIN -- at this point, the targetDB exists ... and it's NOT 'ONLINE' so... it's restoring, suspect, whatever, and we've been given explicit instructions to replace it:
						
						SET @command = N'DROP DATABASE ' + QUOTENAME(@restoredName) + N';' + @crlf + @crlf;

						IF @PrintOnly = 1 BEGIN 
							PRINT @command;
						  END;
						ELSE BEGIN 
							
							EXEC dbo.[execute_command]
								@Command = @command, 
								@DelayBetweenAttempts = N'8 seconds',
								@IgnoredResults = N'{COMMAND_SUCCESS},{USE_DB_SUCCESS},{SINGLE_USER}', 
								@Outcome = @execResults OUTPUT, 
								@ErrorMessage = @errorMessage OUTPUT;
							

							IF dbo.[transient_error_occurred](@execResults) = 1 BEGIN 
								SET @statusDetail = N'NOTE: Transient Error Detected with DROP DATABASE::> ' + CAST(@execResults AS nvarchar(MAX));
							END; 

							IF @errorMessage IS NOT NULL BEGIN 
								SET @statusDetail = N'Error with DROP DATABASE::> Error(s): ' + @errorMessage + N' ExecutionDetails: ' + CAST(@execResults AS nvarchar(MAX));
							END;
						END;

					END;

				END TRY
				BEGIN CATCH
					SELECT @statusDetail = N'Unexpected Exception while setting target database: [' + @restoredName + N'] into SINGLE_USER mode and/or attempting to DROP target database for explicit REPLACE operation. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
				END CATCH

				IF @statusDetail IS NOT NULL
					GOTO NextDatabase;

			  END;
			ELSE BEGIN
				SET @statusDetail = N'Cannot restore database [' + @databaseToRestore + N'] as [' + @restoredName + N'] - because target database already exists. Consult documentation for WARNINGS and options for using @AllowReplace parameter.';
				GOTO NextDatabase;
			END;
        END;

		-- Check for a FULL backup: 
		--			NOTE: If dbo.load_backup_files does NOT return any results and if @databaseToRestore is a {SYSTEM} database, then dbo.load_backup_files ...
		--				will check @SourcePath + @ServerName as well - i.e., it accounts for @AppendServerNameToSystemDbs 
		EXEC dbo.load_backup_files 
            @DatabaseToRestore = @databaseToRestore, 
            @SourcePath = @sourcePath, 
            @Mode = N'FULL', 
			@StopAt = @stopAt,
            @Output = @serializedFileList OUTPUT;
		
		IF(SELECT dbo.[is_xml_empty](@serializedFileList)) = 1 BEGIN
			IF @stopAt IS NOT NULL BEGIN 
				SET @statusDetail = N'No FULL backup found for database [' + @databaseToRestore + N'] with STOPAT of ''' + CONVERT(sysname, @stopAt, 121) + N''' in "' + @sourcePath + N'".';
			  END; 
			ELSE 
				SET @statusDetail = N'No FULL backups found for database [' + @databaseToRestore + N'] in "' + @sourcePath + N'".';

			GOTO NextDatabase;	
		END;

        -- Load Backup details/etc. 
		WITH shredded AS ( 
			SELECT 
				[data].[row].value('@file_name', 'nvarchar(max)') [file_name]
			FROM 
				@serializedFileList.nodes('//file') [data]([row])
		) 
		SELECT @backupName = (SELECT TOP 1 [file_name] FROM [shredded]);
		
		SET @pathToDatabaseBackup = @sourcePath + N'\' + @backupName;

		-- define the list of files to be processed:
		INSERT INTO @restoredFiles ([FileName], [Detected])
		SELECT 
			@backupName, 
			GETDATE(); -- detected (i.e., when this file was 'found' and 'added' for processing).  

        -- Query file destinations:
        SET @move = N'';
        SET @command = N'RESTORE FILELISTONLY FROM DISK = N''' + @pathToDatabaseBackup + ''';';

        IF @PrintOnly = 1 BEGIN
            PRINT N'-- ' + @command;
        END;

        BEGIN TRY 
            DELETE FROM #FileList;
            INSERT INTO #FileList -- shorthand syntax is usually bad, but... whatever. 
            EXEC sys.sp_executesql @command;
        END TRY
        BEGIN CATCH
            SELECT @statusDetail = N'Unexpected Error Restoring FileList: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
            
            GOTO NextDatabase;
        END CATCH;
    
        -- Make sure we got some files (i.e. RESTORE FILELIST doesn't always throw exceptions if the path you send it sucks):
        IF ((SELECT COUNT(*) FROM #FileList) < 2) BEGIN
            SET @statusDetail = N'The backup located at [' + @pathToDatabaseBackup + N'] is invalid, corrupt, or does not contain a viable FULL backup.';
            GOTO NextDatabase;
        END;

		IF EXISTS (SELECT NULL FROM [#FileList] WHERE [IsPresent] = 0) BEGIN
			SET @isPartialRestore = 1;
		END;
        
        -- Map File Destinations:
		DECLARE @logicalFileName sysname, @fileId bigint, @type char(1), @fileName sysname;
        DECLARE mover CURSOR LOCAL FAST_FORWARD FOR 
        SELECT 
			LogicalName, 
			FileID, 
			[Type], 
			(SELECT TOP 1 (result) FROM dbo.split_string([name], N'.', 1) ORDER BY [row_id]) [FileName]
        FROM 
            (
				SELECT 
					LogicalName, 
					FileID, 
					[Type], 
					(SELECT TOP 1 (result) FROM dbo.split_string(PhysicalName, N'\', 1) ORDER BY [row_id] DESC) [name]
				FROM 
					#FileList 
				WHERE 
					[IsPresent] = 1 -- allow for partial restores
			) translated
        ORDER BY 
            FileID;

        OPEN mover; 
        FETCH NEXT FROM mover INTO @logicalFileName, @fileId, @type, @fileName;

        WHILE @@FETCH_STATUS = 0 BEGIN 

			-- NOTE: FULL filename (path + name) can NOT be > 260 (259?) chars long. 
			SET @restoredFileName = @fileName;
			
			IF NOT EXISTS (SELECT NULL FROM @allDirectives WHERE [directive] = N'PRESERVE_FILENAMES') BEGIN 

				IF @databaseToRestore <> @restoredName
					SET @restoredFileName = @restoredName;

				IF @ndfCount > 0 
					SET @restoredFileName = @restoredFileName + CAST((@ndfCount + 1) AS sysname);
			END;

            SET @move = @move + N'MOVE ''' + @logicalFileName + N''' TO ''' + CASE WHEN @fileId = 2 THEN @RestoredRootLogPath ELSE @RestoredRootDataPath END + N'\' + @restoredFileName + '.';
            IF @fileId = 1
                SET @move = @move + N'mdf';
            IF @fileId = 2
                SET @move = @move + N'ldf';

            IF @fileId NOT IN (1, 2) BEGIN
                SET @move = @move + N'ndf';
				SET @ndfCount = @ndfCount + 1;
			END;

            SET @move = @move + N''', '

            FETCH NEXT FROM mover INTO @logicalFileName, @fileId, @type, @fileName;
        END;

        CLOSE mover;
        DEALLOCATE mover;

        SET @move = LEFT(@move, LEN(@move) - 1); -- remove the trailing ", "... 

        -- Set up the Restore Command and Execute:
        SET @command = REPLACE(@fullRestoreTemplate, N'{0}', @restoredName);
        SET @command = REPLACE(@command, N'{1}', @pathToDatabaseBackup);
        SET @command = REPLACE(@command, N'{move}', @move);
		SET @command = REPLACE(@command, N'{partial}', (CASE WHEN @isPartialRestore = 1 THEN N'PARTIAL, ' ELSE N'' END));
		
        BEGIN TRY 
            IF @PrintOnly = 1 BEGIN
                PRINT @command;
              END;
            ELSE BEGIN
                SET @outcome = NULL;
                EXEC dbo.execute_uncatchable_command @command, 'RESTORE', @Result = @outcome OUTPUT;

                SET @statusDetail = @outcome;
            END;
        END TRY 
        BEGIN CATCH
            SELECT @statusDetail = N'Unexpected Exception while executing FULL Restore from File: "' + @pathToDatabaseBackup + N'". Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();			
        END CATCH

		-- Update MetaData: 
		BEGIN TRY
			EXEC dbo.load_header_details @BackupPath = @pathToDatabaseBackup, @BackupDate = @backupDate OUTPUT, @BackupSize = @backupSize OUTPUT, @Compressed = @compressed OUTPUT, @Encrypted = @encrypted OUTPUT;

			UPDATE @restoredFiles 
			SET 
				[Applied] = GETDATE(), 
				[BackupCreated] = @backupDate, 
				[BackupSize] = @backupSize, 
				[Compressed] = @compressed, 
				[Encrypted] = @encrypted
			WHERE 
				[FileName] = @backupName;
		END TRY 
		BEGIN CATCH 
			SELECT @statusDetail = ISNULL(@statusDetail, N'') + N'Error updating list of restored files after FULL. Error: ' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
		END CATCH;

        IF @statusDetail IS NOT NULL BEGIN
            GOTO NextDatabase;
        END;
        
		-- Restore any DIFF backups if present:
        SET @serializedFileList = NULL;
		EXEC dbo.load_backup_files 
            @DatabaseToRestore = @databaseToRestore, 
            @SourcePath = @sourcePath, 
            @Mode = N'DIFF', 
			@StopAt = @stopAt,
			@LastAppliedFinishTime = @backupDate, 
            @Output = @serializedFileList OUTPUT;
		
		IF (SELECT dbo.[is_xml_empty](@serializedFileList)) = 0 BEGIN 

			WITH shredded AS ( 
				SELECT 
					[data].[row].value('@file_name', 'nvarchar(max)') [file_name]
				FROM 
					@serializedFileList.nodes('//file') [data]([row])
			) 
			SELECT @backupName = (SELECT TOP 1 [file_name] FROM [shredded]);

			SET @pathToDatabaseBackup = @sourcePath + N'\' + @backupName

            SET @command = N'RESTORE DATABASE ' + QUOTENAME(@restoredName) + N' FROM DISK = N''' + @pathToDatabaseBackup + N''' WITH NORECOVERY;';

			INSERT INTO @restoredFiles ([FileName], [Detected])
			SELECT @backupName, GETDATE();

            BEGIN TRY
                IF @PrintOnly = 1 BEGIN
                    PRINT @command;
                  END;
                ELSE BEGIN
                    SET @outcome = NULL;
                    EXEC dbo.execute_uncatchable_command @command, 'RESTORE', @Result = @outcome OUTPUT;

                    SET @statusDetail = @outcome;
                END;
            END TRY
            BEGIN CATCH
                SELECT @statusDetail = N'Unexpected Exception while executing DIFF Restore from File: "' + @pathToDatabaseBackup + N'". Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
            END CATCH
				
			BEGIN TRY
				-- Update MetaData: 
				EXEC dbo.load_header_details @BackupPath = @pathToDatabaseBackup, @BackupDate = @backupDate OUTPUT, @BackupSize = @backupSize OUTPUT, @Compressed = @compressed OUTPUT, @Encrypted = @encrypted OUTPUT;

				UPDATE @restoredFiles 
				SET 
					[Applied] = GETDATE(), 
					[BackupCreated] = @backupDate, 
					[BackupSize] = @backupSize, 
					[Compressed] = @compressed, 
					[Encrypted] = @encrypted
				WHERE 
					[FileName] = @backupName;
			END TRY
			BEGIN CATCH 
				SELECT @statusDetail = ISNULL(@statusDetail, N'') + N'Error updating list of restored files after DIFF. Error: ' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
			END CATCH;

            IF @statusDetail IS NOT NULL BEGIN
                GOTO NextDatabase;
            END;
		END;

        -- Restore any LOG backups if specified and if present:
        IF @SkipLogBackups = 0 BEGIN
			
			-- reset values per every 'loop' of main processing body:
			DELETE FROM #logFilesToRestore;

            SET @serializedFileList = NULL;
			EXEC dbo.load_backup_files 
                @DatabaseToRestore = @databaseToRestore, 
                @SourcePath = @sourcePath, 
                @Mode = N'LOG', 
				@StopAt = @stopAt,
				@LastAppliedFinishTime = @backupDate,
                @Output = @serializedFileList OUTPUT;

			WITH shredded AS ( 
				SELECT 
					[data].[row].value('@id[1]', 'int') [id], 
					[data].[row].value('@file_name', 'nvarchar(max)') [file_name]
				FROM 
					@serializedFileList.nodes('//file') [data]([row])
			) 

			INSERT INTO #logFilesToRestore ([log_file])
			SELECT [file_name] FROM [shredded] ORDER BY [id];

			-- re-update the counter: 
			SET @currentLogFileID = ISNULL((SELECT MIN(id) FROM #logFilesToRestore), @currentLogFileID + 1);

			IF @stopAt IS NOT NULL BEGIN 
				SELECT @stopAtLog = MAX(id) FROM [#logFilesToRestore];
			END;

			-- start a loop to process files while they're still available: 
			WHILE EXISTS (SELECT NULL FROM #logFilesToRestore WHERE [id] = @currentLogFileID) BEGIN

				SELECT @backupName = log_file FROM #logFilesToRestore WHERE id = @currentLogFileID;
				SET @pathToDatabaseBackup = @sourcePath + N'\' + @backupName;

				INSERT INTO @restoredFiles ([FileName], [Detected])
				SELECT @backupName, GETDATE();

				IF @stopAt IS NOT NULL AND @currentLogFileID = @stopAtLog BEGIN 
					SET @command = N'RESTORE LOG ' + QUOTENAME(@restoredName) + N' FROM DISK = N''' + @pathToDatabaseBackup + N''' WITH NORECOVERY, STOPAT = ''' + CONVERT(sysname, @stopAt, 121) + ''';';
				  END;
				ELSE 
					SET @command = N'RESTORE LOG ' + QUOTENAME(@restoredName) + N' FROM DISK = N''' + @pathToDatabaseBackup + N''' WITH NORECOVERY;';
                
                BEGIN TRY 
                    IF @PrintOnly = 1 BEGIN
                        PRINT @command;
                      END;
                    ELSE BEGIN
                        SET @outcome = NULL;
                        EXEC dbo.execute_uncatchable_command @command, 'RESTORE', @Result = @outcome OUTPUT;

                        SET @statusDetail = @outcome;
                    END;
                END TRY
                BEGIN CATCH
					SELECT @statusDetail = N'Unexpected Exception while executing LOG Restore from File: "' + @backupName + N'". Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
                END CATCH

				BEGIN TRY
					-- Update MetaData: 
					EXEC dbo.load_header_details @BackupPath = @pathToDatabaseBackup, @BackupDate = @backupDate OUTPUT, @BackupSize = @backupSize OUTPUT, @Compressed = @compressed OUTPUT, @Encrypted = @encrypted OUTPUT;

					UPDATE @restoredFiles 
					SET 
						[Applied] = GETDATE(), 
						[BackupCreated] = @backupDate, 
						[BackupSize] = @backupSize, 
						[Compressed] = @compressed, 
						[Encrypted] = @encrypted, 
						[Comment] = @statusDetail
					WHERE 
						[FileName] = @backupName;

					/* swallow these errors for now... */
					IF @statusDetail LIKE '%Msg 4326%too early%' BEGIN
						SET @statusDetail = NULL;
					END;

				END TRY 
				BEGIN CATCH 
					SELECT @statusDetail = ISNULL(@statusDetail, N'') + N'Error updating list of restored files after LOG. Error: ' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
				END CATCH;

                IF @statusDetail IS NOT NULL BEGIN
                    GOTO NextDatabase;
                END;
				
				IF @stopAt IS NULL BEGIN
					-- Check for any new files if we're now 'out' of files to process: 
					--		 TODO: I think there's a bug NOT in the logic below, but in even GETTING to a point where this logic could be called. 
					--				e.g., assume @SkipLogFiles = 0 ... and that there are NO log files available after getting a FULL or DIFF (because we've just barely had a FULL/DIFF created and no T-LOG backups have happened). 
					--					then, assume that the FULL|DIFF takes ... 8-15 minutes to restore - and that there have been 1-N T-LOG backups in that time? Do we even GET to the logic below?
					--				i don't THINK so... cuz we only got into this branch of logic BECAUSE there WERE extant T-LOGs when we initially checked... 
					--			And, of course, the STOPAT checks above only complicate this bit of logic (not much ... cuz ... they're different logical paths... but, still.)
					IF @currentLogFileID = (SELECT MAX(id) FROM #logFilesToRestore) BEGIN

						-- if there are any new log files, we'll get those... and they'll be added to the list of files to process (along with newer (higher) ids)... 
						SET @serializedFileList = NULL;
						EXEC dbo.load_backup_files 
							@DatabaseToRestore = @databaseToRestore, 
							@SourcePath = @sourcePath, 
							@Mode = N'LOG', 
							@LastAppliedFinishTime = @backupDate,
							@Output = @serializedFileList OUTPUT;

						WITH shredded AS ( 
							SELECT 
								[data].[row].value('@id[1]', 'int') [id], 
								[data].[row].value('@file_name', 'nvarchar(max)') [file_name]
							FROM 
								@serializedFileList.nodes('//file') [data]([row])
						) 

						INSERT INTO #logFilesToRestore ([log_file])
						SELECT [file_name] FROM [shredded] WHERE [file_name] NOT IN (SELECT [log_file] FROM #logFilesToRestore)
						ORDER BY [id];
					END;
				END;

				-- increment: 
				SET @currentLogFileID = @currentLogFileID + 1;
			END;
        END;

        -- Recover the database if instructed: 
		IF @ExecuteRecovery = 1 BEGIN
			SET @command = N'RESTORE DATABASE ' + QUOTENAME(@restoredName) + N' WITH {directives}RECOVERY;';
			SET @command = REPLACE(@command, N'{directives}', @directivesText);

			BEGIN TRY
				IF @PrintOnly = 1 BEGIN
					PRINT @command;
				  END;
				ELSE BEGIN
					SET @outcome = NULL;

                    -- TODO: do I want to specify a DIFFERENT (subset/set) of 'filters' for RESTORE and RECOVERY? (don't really think so, unless there are ever problems with 'overlap' and/or confusion.
					EXEC dbo.execute_uncatchable_command @command, 'RESTORE', @Result = @outcome OUTPUT;

					SET @statusDetail = @outcome;
				END;
			END TRY	
			BEGIN CATCH
				SELECT @statusDetail = N'Unexpected Exception while attempting to RECOVER database [' + @restoredName + N'. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
				
				UPDATE dbo.[restore_log]
				SET 
					[recovery] = 'FAILED'
				WHERE 
					restore_id = @restoreLogId;

			END CATCH

			IF @statusDetail IS NOT NULL BEGIN
				GOTO NextDatabase;
			END;
		END;

        -- If we've made it here, then we need to update logging/meta-data:
        IF @PrintOnly = 0 BEGIN
            UPDATE dbo.restore_log 
            SET 
                restore_succeeded = 1,
				[recovery] = CASE WHEN @ExecuteRecovery = 0 THEN 'NORECOVERY' ELSE 'RECOVERED' END, 
                restore_end = GETDATE(), 
                error_details = NULL
            WHERE 
                restore_id = @restoreLogId;
        END;

        -- Run consistency checks if specified:
        IF @CheckConsistency = 1 BEGIN

            SET @command = N'DBCC CHECKDB([' + @restoredName + N']) WITH NO_INFOMSGS, ALL_ERRORMSGS, TABLERESULTS;'; -- outputting data for review/analysis. 

            IF @PrintOnly = 0 BEGIN 
                UPDATE dbo.restore_log
                SET 
                    consistency_start = GETDATE(),
                    consistency_succeeded = 0, 
                    error_details = '#UNKNOWN ERROR CHECKING CONSISTENCY#'
                WHERE
                    restore_id = @restoreLogId;
            END;

            BEGIN TRY 
                IF @PrintOnly = 1 
                    PRINT @command;
                ELSE BEGIN 
                    DELETE FROM #DBCC_OUTPUT;
                    INSERT INTO #DBCC_OUTPUT (Error, [Level], [State], MessageText, RepairLevel, [Status], [DbId], DbFragId, ObjectId, IndexId, PartitionId, AllocUnitId, RidDbId, RidPruId, [File], [Page], Slot, RefDbId, RefPruId, RefFile, RefPage, RefSlot, Allocation)
                    EXEC sp_executesql @command; 

                    IF EXISTS (SELECT NULL FROM #DBCC_OUTPUT) BEGIN -- consistency errors: 
                        SET @statusDetail = N'CONSISTENCY ERRORS DETECTED against database ' + QUOTENAME(@restoredName) + N'. Details: ' + @crlf;
                        SELECT @statusDetail = @statusDetail + MessageText + @crlf FROM #DBCC_OUTPUT ORDER BY RowID;

                        UPDATE dbo.restore_log
                        SET 
                            consistency_end = GETDATE(),
                            consistency_succeeded = 0,
                            error_details = @statusDetail
                        WHERE 
                            restore_id = @restoreLogId;

                      END;
                    ELSE BEGIN -- there were NO errors:
                        UPDATE dbo.restore_log
                        SET
                            consistency_end = GETDATE(),
                            consistency_succeeded = 1, 
                            error_details = NULL
                        WHERE 
                            restore_id = @restoreLogId;

                    END;
                END;

            END TRY	
            BEGIN CATCH
                SELECT @statusDetail = N'Unexpected Exception while running consistency checks. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
                GOTO NextDatabase;
            END CATCH

        END;

-- Primary Restore/Restore-Testing complete - log file lists, and cleanup/prep for next db to process... 
NextDatabase:

        -- Record any error details as needed:
        IF @statusDetail IS NOT NULL BEGIN

            IF @PrintOnly = 1 BEGIN
                PRINT N'ERROR: ' + @statusDetail;
              END;
            ELSE BEGIN
                UPDATE dbo.restore_log
                SET 
                    error_details = @statusDetail
                WHERE 
                    restore_id = @restoreLogId;
            END;

			SET @statusDetail = NULL;
          END;
		ELSE BEGIN 
			IF (SELECT COUNT(*) FROM @dbsToRestore) < 8 BEGIN /* If there are LOTS of DBs, then this'll 'fill up' the SQL Server Agent job-history 'buffer' so'z we don't get any error details if/when they happen. */
				PRINT N'-- Operations for database [' + @restoredName + N'] completed successfully.' + @crlf + @crlf;
			END;
		END; 

		-- serialize restored file details and push into dbo.restore_log
		SELECT @fileListXml = (
			SELECT 
				ROW_NUMBER() OVER (ORDER BY ID) [@id],
				[FileName] [name], 
				BackupCreated [created],
				Detected [detected], 
				Applied [applied], 
				BackupSize [size], 
				Compressed [compressed], 
				[Encrypted] [encrypted], 
				[Comment] [comments]
			FROM 
				@restoredFiles 
			ORDER BY 
				ID
			FOR XML PATH('file'), ROOT('files')
		);
		
		IF @PrintOnly = 1
			PRINT N'-- ' + @fileListXml; 
		ELSE BEGIN
			UPDATE dbo.[restore_log] 
			SET 
				restored_files = @fileListXml  -- may be null in some cases (i.e., no FULL backup found or db backups not found/etc.) but... meh. 
			WHERE 
				[restore_id] = @restoreLogId;
		END;

        -- Drop the database if specified and if all SAFE drop precautions apply:
        IF @DropDatabasesAfterRestore = 1 BEGIN
            
            -- Make sure we can/will ONLY restore databases that we've restored in this session:
			SELECT @restoreStart = restore_start 
			FROM dbo.[restore_log] 
			WHERE [database] = @databaseToRestore AND [restored_as] = @restoredName AND [execution_id] = @executionID;
			
			SET @executeDropAllowed = 0;
			IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @restoredName AND [create_date] >= @restoreStart)
				SET @executeDropAllowed = 1;

            IF @PrintOnly = 1 AND @DropDatabasesAfterRestore = 1
                SET @executeDropAllowed = 1; 
            
            IF (@executeDropAllowed = 1) AND EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @restoredName) BEGIN -- this is a db we restored (or tried to restore) in this 'session' - so we can drop it:
                
				SET @command = N'DROP DATABASE ' + QUOTENAME(@restoredName) + N';';

				IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @restoredName AND [state_desc] = N'ONLINE') BEGIN
					SET @command = N'ALTER DATABASE ' + QUOTENAME(@restoredName) + ' SET SINGLE_USER WITH ROLLBACK IMMEDIATE;' + @crlf
						+ N'DROP DATABASE ' + QUOTENAME(@restoredName) + N';' + @crlf + @crlf;
				END;

                BEGIN TRY 
                    IF @PrintOnly = 1 
                        PRINT @command;
                    ELSE BEGIN
                        UPDATE dbo.restore_log 
                        SET 
                            [dropped] = N'ATTEMPTED'
                        WHERE 
                            restore_id = @restoreLogId;

						EXEC dbo.[execute_command]
							@Command = @command, 
							@DelayBetweenAttempts = N'8 seconds',
							@IgnoredResults = N'{COMMAND_SUCCESS},{USE_DB_SUCCESS},{SINGLE_USER}', 
							@Outcome = @execResults OUTPUT, 
							@ErrorMessage = @errorMessage OUTPUT;

						IF dbo.[transient_error_occurred](@execResults) = 1 BEGIN 
							SET @statusDetail = N'NOTE: Transient Error Detected with CLEANUP + DROP operations::> ' + CAST(@execResults AS nvarchar(MAX));
						END;
							
						IF @errorMessage IS NOT NULL BEGIN 
							SET @statusDetail = N'Error with CLEANUP + DROP operations::>  Error(s): ' + @errorMessage + N' ExecutionDetails: ' + CAST(@execResults AS nvarchar(MAX));
						END;

                        IF EXISTS (SELECT NULL FROM master.sys.databases WHERE [name] = @restoredName) BEGIN
                            SET @statusDetail = @statusDetail + @crlf + N'Executed command to DROP database [' + @restoredName + N']. No exceptions encountered, but database still in place POST-DROP.';

                            SET @failedDropCount = @failedDropCount +1;
                          END;
                        ELSE -- happy / expected outcome:
                            UPDATE dbo.restore_log
                            SET 
                                dropped = 'DROPPED'
                            WHERE 
                                restore_id = @restoreLogId;
                    END;

                END TRY 
                BEGIN CATCH
                    SELECT @statusDetail = N'Unexpected Exception while attempting to DROP database [' + @restoredName + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();

                    SET @failedDropCount = @failedDropCount +1;
                END CATCH;

				IF @statusDetail IS NOT NULL BEGIN 
                    UPDATE dbo.restore_log
                    SET 
                        dropped = 'ERROR', 
						[error_details] = ISNULL(error_details, N'') + @statusDetail
                    WHERE 
                        restore_id = @restoreLogId;
				END;
            END;

          END;
        ELSE BEGIN
            UPDATE dbo.restore_log 
            SET 
                dropped = 'LEFT ONLINE' -- same as 'NOT DROPPED' but shows explicit intention.
            WHERE
                restore_id = @restoreLogId;
        END;

        -- Check-up on total number of 'failed drops':
		IF @DropDatabasesAfterRestore = 1 BEGIN 
			SELECT @failedDropCount = COUNT(*) FROM dbo.[restore_log] WHERE [execution_id] = @executionID AND [dropped] IN ('ATTEMPTED', 'ERROR');

			IF @failedDropCount >= @MaxNumberOfFailedDrops BEGIN 
				-- we're done - no more processing (don't want to risk running out of space with too many restore operations.
				SET @earlyTermination = N'Max number of databases that could NOT be dropped after restore/testing was reached. Early terminatation forced to reduce risk of causing storage problems.';
				GOTO FINALIZE;
			END;
		END;

        FETCH NEXT FROM restorer INTO @databaseToRestore;
    END

    -----------------------------------------------------------------------------
FINALIZE:

    -- close/deallocate any cursors left open:
    IF (SELECT CURSOR_STATUS('local','restorer')) > -1 BEGIN
        CLOSE restorer;
        DEALLOCATE restorer;
    END;

    IF (SELECT CURSOR_STATUS('local','mover')) > -1 BEGIN
        CLOSE mover;
        DEALLOCATE mover;
    END;

    IF (SELECT CURSOR_STATUS('local','logger')) > -1 BEGIN
        CLOSE logger;
        DEALLOCATE logger;
    END;

	-- Process RPO Warnings: 
	DECLARE @rpoWarnings nvarchar(MAX) = NULL;
	DECLARE @rpoMessage nvarchar(MAX) = N'';

	IF (NULLIF(@RpoWarningThreshold, N'') IS NOT NULL) OR @SkipSanityChecks = 0 BEGIN
		SELECT 
			[database], 
			[restored_files],
			[restore_end]
		INTO #subset
		FROM 
			dbo.[restore_log] 
		WHERE 
			[execution_id] = @executionID
		ORDER BY
			[restore_id];

		WITH core AS ( 
			SELECT 
				s.[database], 
				s.restored_files.value('(/files/file[@id = max(/files/file/@id)]/created)[1]', 'datetime') [most_recent_backup],
				s.[restore_end]
			FROM 
				#subset s
		)

		SELECT 
			IDENTITY(int, 1, 1) [id],
			c.[database], 
			c.[most_recent_backup], 
			c.[restore_end], 
			CASE WHEN ((DATEDIFF(DAY, [c].[most_recent_backup], [c].[restore_end])) < 20) THEN -1 ELSE (DATEDIFF(DAY, [c].[most_recent_backup], [c].[restore_end])) END [days_old], 
			CASE WHEN ((DATEDIFF(DAY, [c].[most_recent_backup], [c].[restore_end])) > 20) THEN -1 ELSE (DATEDIFF(MILLISECOND, [c].[most_recent_backup], [c].[restore_end])) END [vector]
		INTO 
			#stale 
		FROM 
			[core] c
		WHERE 
			[c].[restore_end] IS NOT NULL;
	END;

	IF NULLIF(@RpoWarningThreshold, N'') IS NOT NULL BEGIN 
		IF @RpoWarningThreshold LIKE N'%,%' BEGIN 
			WITH full_recovery AS ( 
				SELECT 
					[s].[database]
				FROM 
					#stale s
					INNER JOIN sys.databases d ON s.[database] = d.[name]
				WHERE 
					[d].[recovery_model_desc] <> N'SIMPLE'
			) 

			-- NOTE: using some borderline-cheesy logic to get the 'FULL' part of @RpoWarningThreshold for these warnings:
			SELECT 
				@rpoMessage = @rpoMessage 
				+ @crlf + N'  WARNING: database ' + QUOTENAME([x].[database]) + N' exceeded recovery point objectives: '
				+ @crlf + @tab + N'- recovery_point_objective  : ' + REPLACE(REPLACE(@RpoWarningThreshold, @threshold, N''), N',', '')
				+ @crlf + @tab + @tab + N'- most_recent_backup: ' + CONVERT(sysname, [x].[most_recent_backup], 120) 
				+ @crlf + @tab + @tab + N'- restore_completion: ' + CONVERT(sysname, [x].[restore_end], 120)
				+  CASE WHEN [x].[vector] = -1 THEN 
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + CAST([x].[days_old] AS sysname) + N' days'
					ELSE 
						+ @crlf + @tab + @tab + @tab + N'- actual recovery point     : ' + dbo.[format_timespan]([x].vector)
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + dbo.[format_timespan](([x].vector - (@vector * 1000)))
					END + @crlf
			FROM 
				[#stale] x
				INNER JOIN [full_recovery] [f] ON [x].[database] = [f].[database] 
			WHERE  
				(x.[vector] > (@vector * 1000)) OR [x].[days_old] > 20 
			ORDER BY 
				CASE WHEN [x].[days_old] > 20 THEN [x].[days_old] ELSE 0 END DESC, 
				[x].[vector];

			IF @rpoMessage <> N''
				SET @rpoMessage = @rpoMessage + @crlf;

			-- Now check vs @vectorSimple (i.e., SIMPLE recovery databases).
			WITH simple_recovery AS ( 
				SELECT 
					[s].[database]
				FROM 
					#stale s
					INNER JOIN sys.databases d ON s.[database] = d.[name]
				WHERE 
					[d].[recovery_model_desc] = N'SIMPLE'
			) 

			-- NOTE: SORTA ditto on cheesy logic for 'SIMPLE' recovery part ... (i.e., not as cheesy, but still kind of using 'stealthed' info).
			SELECT 
				@rpoMessage = @rpoMessage 
				+ @crlf + N'  WARNING: database ' + QUOTENAME([x].[database]) + N' exceeded recovery point objectives: '
				+ @crlf + @tab + N'- recovery_point_objective  : ' + @threshold
				+ @crlf + @tab + @tab + N'- most_recent_backup: ' + CONVERT(sysname, [x].[most_recent_backup], 120) 
				+ @crlf + @tab + @tab + N'- restore_completion: ' + CONVERT(sysname, [x].[restore_end], 120)
				+  CASE WHEN [x].[vector] = -1 THEN 
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + CAST([x].[days_old] AS sysname) + N' days'
					ELSE 
						+ @crlf + @tab + @tab + @tab + N'- actual recovery point     : ' + dbo.[format_timespan]([x].vector)
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + dbo.[format_timespan](([x].vector - (@vector * 1000)))
					END + @crlf
			FROM 
				[#stale] x
				INNER JOIN [simple_recovery] [s] ON [x].[database] = [s].[database] 
			WHERE  
				(x.[vector] > (@vectorSimple * 1000)) OR [x].[days_old] > 20 
			ORDER BY 
				CASE WHEN [x].[days_old] > 20 THEN [x].[days_old] ELSE 0 END DESC, 
				[x].[vector];
		  END;
		ELSE BEGIN
			SELECT 
				@rpoMessage = @rpoMessage 
				+ @crlf + N'  WARNING: database ' + QUOTENAME([x].[database]) + N' exceeded recovery point objectives: '
				+ @crlf + @tab + N'- recovery_point_objective  : ' + @RpoWarningThreshold
				+ @crlf + @tab + @tab + N'- most_recent_backup: ' + CONVERT(sysname, [x].[most_recent_backup], 120) 
				+ @crlf + @tab + @tab + N'- restore_completion: ' + CONVERT(sysname, [x].[restore_end], 120)
				+  CASE WHEN [x].[vector] = -1 THEN 
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + CAST([x].[days_old] AS sysname) + N' days'
					ELSE 
						+ @crlf + @tab + @tab + @tab + N'- actual recovery point     : ' + dbo.[format_timespan]([x].vector)
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + dbo.[format_timespan](([x].vector - (@vector * 1000)))
					END + @crlf
			FROM 
				[#stale] x
			WHERE  
				(x.[vector] > (@vector * 1000)) OR [x].[days_old] > 20 
			ORDER BY 
				CASE WHEN [x].[days_old] > 20 THEN [x].[days_old] ELSE 0 END DESC, 
				[x].[vector];
		  END;

		IF LEN(@rpoMessage) > 2
			SET @rpoWarnings = N'WARNINGS: ' 
				+ @crlf + @rpoMessage + @crlf + @crlf;

	  END;
	ELSE BEGIN 
		-- If we didn't set EXPLICIT checks for RPOs, run sanity checks - unless they've been disabled. 
		IF @SkipSanityChecks = 0 BEGIN
			/* There's a NIGHTMARE scenario where we've got backups running + nightly restore tests. Then we change where backups are being pointed/sent, 
				BUT we forget to change where the restore-tests pull from. At which point, we might go days, weeks, months with 'nightly restore tests'
				that are restoring days/weeks/months STALE backups... we THINK we're covered/protected, but we're not. 
				Sanity checks look for a gap of 26+ hours - and are enabled by DEFAULT.
			*/
			SET @vector = 26 * 60 * 60; -- 60 seconds * 60 minutes * 26 hours... 

			SELECT 
				@rpoMessage = @rpoMessage 
				+ @crlf + N'  WARNING: database ' + QUOTENAME([x].[database]) + N' failed Configuration Sanity Checks: '
				+ @crlf + @tab + N'- sanity_check_objective  : 26 hours'
				+ @crlf + @tab + @tab + N'- most_recent_backup: ' + CONVERT(sysname, [x].[most_recent_backup], 120) 
				+ @crlf + @tab + @tab + N'- restore_completion: ' + CONVERT(sysname, [x].[restore_end], 120)
				+  CASE WHEN [x].[vector] = -1 THEN 
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + CAST([x].[days_old] AS sysname) + N' days'
					ELSE 
						+ @crlf + @tab + @tab + @tab + N'- actual recovery point     : ' + dbo.[format_timespan]([x].vector)
						+ @crlf + @tab + @tab + @tab + N'- recovery point exceeded by: ' + dbo.[format_timespan](([x].vector - (@vector * 1000)))
					END + @crlf
			FROM 
				[#stale] x
			WHERE  
				(x.[vector] > (@vector * 1000)) OR [x].[days_old] > 20 
			ORDER BY 
				CASE WHEN [x].[days_old] > 20 THEN [x].[days_old] ELSE 0 END DESC, 
				[x].[vector];

			IF LEN(@rpoMessage) > 2
				SET @rpoWarnings = N'CONFIGURATION CHECK WARNING(s): ' 
					+ @crlf + @rpoMessage + @crlf + @crlf;			
		END;
	END;

    -- Assemble details on errors - if there were any (i.e., logged errors OR any reason for early termination... 
    IF (NULLIF(@earlyTermination,'') IS NOT NULL) OR (EXISTS (SELECT NULL FROM dbo.restore_log WHERE execution_id = @executionID AND error_details IS NOT NULL)) BEGIN

        SET @emailErrorMessage = N'ERRORS: ' + @crlf;

        SELECT 
			@emailErrorMessage = @emailErrorMessage 
			+ @crlf + N'   ERROR: problem with database ' + QUOTENAME([database]) + N'.' 
			+ @crlf + @tab + N'- source_database:' + QUOTENAME([database])
			+ @crlf + @tab + N'- restored_as: ' + QUOTENAME([restored_as]) + CASE WHEN [restore_succeeded] = 1 THEN N'' ELSE ' (attempted - but failed) ' END 
			+ @crlf
			+ @crlf + @tab + N'   - error_detail: ' + [error_details] 
			+ @crlf + @crlf
        FROM 
            dbo.restore_log
        WHERE 
            execution_id = @executionID
            AND error_details IS NOT NULL
        ORDER BY 
            restore_id;

        -- notify too that we stopped execution due to early termination:
        IF NULLIF(@earlyTermination, '') IS NOT NULL BEGIN
            SET @emailErrorMessage = @emailErrorMessage + @tab + N'- ' + @earlyTermination;
        END;
    END;
    
    IF @emailErrorMessage IS NOT NULL OR @rpoWarnings IS NOT NULL BEGIN

		SET @emailErrorMessage = ISNULL(@rpoWarnings, '') + ISNULL(@emailErrorMessage, '');

        IF @PrintOnly = 1
            PRINT N'ERROR: ' + @emailErrorMessage;
        ELSE BEGIN
            SET @emailSubject = @EmailSubjectPrefix + N' - ERROR';

            EXEC msdb..sp_notify_operator
                @profile_name = @MailProfileName,
                @name = @OperatorName,
                @subject = @emailSubject, 
                @body = @emailErrorMessage;
        END;
    END;

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.copy_database','P') IS NOT NULL
	DROP PROC dbo.copy_database;
GO

CREATE PROC dbo.copy_database 
	@SourceDatabaseName					sysname, 
	@TargetDatabaseName					sysname, 
	@BackupsRootDirectory				nvarchar(2000)	= N'{DEFAULT}', 
	@CopyToBackupDirectory					nvarchar(2000)	= NULL,
	@DataPath							sysname			= N'{DEFAULT}', 
	@LogPath							sysname			= N'{DEFAULT}',
	@RenameLogicalFileNames				bit				= 1, 
	@OperatorName						sysname			= N'Alerts',
	@MailProfileName					sysname			= N'General', 
	@PrintOnly							bit				= 0
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF NULLIF(@SourceDatabaseName,'') IS NULL BEGIN
		RAISERROR('@SourceDatabaseName cannot be Empty/NULL. Please specify the name of the database you wish to copy (from).', 16, 1);
		RETURN -1;
	END;

	IF NULLIF(@TargetDatabaseName, '') IS NULL BEGIN
		RAISERROR('@TargetDatabaseName cannot be Empty/NULL. Please specify the name of new database that you want to create (as a copy).', 16, 1);
		RETURN -1;
	END;

	-- Make sure the target database doesn't already exist: 
	IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @TargetDatabaseName) BEGIN
		RAISERROR('@TargetDatabaseName already exists as a database. Either pick another target database name - or drop existing target before retrying.', 16, 1);
		RETURN -5;
	END;

	-- Allow for default paths:
	IF UPPER(@BackupsRootDirectory) = N'{DEFAULT}' BEGIN
		SELECT @BackupsRootDirectory = dbo.load_default_path('BACKUP');
	END;

	IF UPPER(@DataPath) = N'{DEFAULT}' BEGIN
		SELECT @DataPath = dbo.load_default_path('DATA');
	END;

	IF UPPER(@LogPath) = N'{DEFAULT}' BEGIN
		SELECT @LogPath = dbo.load_default_path('LOG');
	END;

	DECLARE @retention nvarchar(10) = N'110w'; -- if we're creating/copying a new db, there shouldn't be ANY backups. Just in case, give it a very wide berth... 
	DECLARE @copyToRetention nvarchar(10) = NULL;
	IF @CopyToBackupDirectory IS NOT NULL 
		SET @copyToRetention = @retention;

	PRINT N'-- Attempting to Restore a backup of [' + @SourceDatabaseName + N'] as [' + @TargetDatabaseName + N']';
	
	DECLARE @restored bit = 0;
	DECLARE @errorMessage nvarchar(MAX); 

	BEGIN TRY 
		EXEC dbo.restore_databases
			@DatabasesToRestore = @SourceDatabaseName,
			@BackupsRootPath = @BackupsRootDirectory,
			@RestoredRootDataPath = @DataPath,
			@RestoredRootLogPath = @LogPath,
			@RestoredDbNamePattern = @TargetDatabaseName,
			@SkipLogBackups = 0,
			@CheckConsistency = 0, 
			@DropDatabasesAfterRestore = 0,
			@OperatorName = @OperatorName, 
			@MailProfileName = @MailProfileName, 
			@EmailSubjectPrefix = N'[COPY DATABASE OPERATION] : ', 
			@PrintOnly = @PrintOnly;

	END TRY
	BEGIN CATCH
		SET @errorMessage = ISNULL(@errorMessage, '') + N'Unexpected Exception while restoring copy of database. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE() + N' ';
	END CATCH

	-- 'sadly', restore_databases does a great job of handling most exceptions during execution - meaning that if we didn't get errors, that doesn't mean there weren't problems. So, let's check up: 
	IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @TargetDatabaseName AND state_desc = N'ONLINE') OR (@PrintOnly = 1)
		SET @restored = 1; -- success (the db wasn't there at the start of this sproc, and now it is (and it's online). 
	ELSE BEGIN 
		-- then we need to grab the latest error: 
		SELECT @errorMessage = error_details FROM dbo.restore_log WHERE restore_id = (
			SELECT MAX(restore_id) FROM dbo.restore_log WHERE operation_date = GETDATE() AND [database] = @SourceDatabaseName AND restored_as = @TargetDatabaseName);

		IF @errorMessage IS NULL BEGIN -- hmmm weird:
			SET @errorMessage = N'Unknown error with restore operation - execution did NOT complete as expected. Please Check Email for additional details/insights.';
			RETURN -20;
		END;

	END

	IF @errorMessage IS NULL
		PRINT N'-- Restore Complete. Kicking off backup [' + @TargetDatabaseName + N'].';
	ELSE BEGIN
		PRINT @errorMessage;
		RETURN -10;
	END;
	
	-- Make sure the DB owner is set correctly: 
	DECLARE @sql nvarchar(MAX) = N'ALTER AUTHORIZATION ON DATABASE::[' + @TargetDatabaseName + N'] TO sa;';
	
	IF @PrintOnly = 1 
		PRINT @sql
	ELSE 
		EXEC sp_executesql @sql;

	IF @RenameLogicalFileNames = 1 BEGIN

		DECLARE @renameTemplate nvarchar(200) = N'ALTER DATABASE ' + QUOTENAME(@TargetDatabaseName) + N' MODIFY FILE (NAME = {0}, NEWNAME = {1});' + NCHAR(13) + NCHAR(10); 
		SET @sql = N'';
		
		WITH renamed AS ( 

			SELECT 
				[name] [old_file_name], 
				REPLACE([name], @SourceDatabaseName, @TargetDatabaseName) [new_file_name], 
				[file_id]
			FROM 
				sys.[master_files] 
			WHERE 
				([database_id] = DB_ID(@TargetDatabaseName)) OR 
				(@PrintOnly = 1 AND [database_id] = DB_ID(@SourceDatabaseName))

		) 

		SELECT 
			@sql = @sql + REPLACE(REPLACE(@renameTemplate, N'{0}', [old_file_name]), N'{1}', [new_file_name])
		FROM 
			renamed
		ORDER BY 
			[file_id];

		IF @PrintOnly = 1 
			PRINT @sql; 
		ELSE 
			EXEC sys.sp_executesql @sql;

	END;


	DECLARE @backedUp bit = 0;
	IF @restored = 1 BEGIN
		
		BEGIN TRY
			EXEC dbo.backup_databases
				@BackupType = N'FULL',
				@DatabasesToBackup = @TargetDatabaseName,
				@BackupDirectory = @BackupsRootDirectory,
				@BackupRetention = @retention,
				@CopyToBackupDirectory = @CopyToBackupDirectory, 
				@CopyToRetention = @copyToRetention,
				@OperatorName = @OperatorName, 
				@MailProfileName = @MailProfileName, 
				@EmailSubjectPrefix = N'[COPY DATABASE OPERATION] : ', 
				@PrintOnly = @PrintOnly;

			SET @backedUp = 1;
		END TRY
		BEGIN CATCH
			SET @errorMessage = ISNULL(@errorMessage, '') + N'Unexpected Exception while executing backup of new/copied database. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE() + N' ';
		END CATCH

	END;

	IF @restored = 1 AND @backedUp = 1 
		PRINT N'Operation Complete.';
	ELSE BEGIN
		PRINT N'Errors occurred during execution:';
		PRINT @errorMessage;
	END;

	RETURN 0;
GO
	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.apply_logs','P') IS NOT NULL
	DROP PROC dbo.apply_logs;
GO

CREATE PROC dbo.apply_logs 
	@SourceDatabases					nvarchar(MAX)		= NULL,						-- explicitly named dbs - e.g., N'db1, db7, db28' ... and, only works, obviously, if dbs specified are in non-recovered mode (or standby).
	@Exclusions							nvarchar(MAX)		= NULL,
	@Priorities							nvarchar(MAX)		= NULL, 
	@BackupsRootPath					nvarchar(MAX)		= N'{DEFAULT}',
	@TargetDbMappingPattern				sysname				= N'{0}',					-- MAY not use/allow... 
	@RecoveryType						sysname				= N'NORECOVERY',			-- options are: NORECOVERY | STANDBY | RECOVERY
	@StaleAlertThreshold				nvarchar(10)		= NULL,						-- NULL means... don't bother... otherwise, if the restoring_db is > @threshold... raise an alert... 
	@AlertOnStaleOnly					bit					= 0,						-- when true, then failures won't trigger alerts - only if/when stale-threshold is exceeded is an alert sent.
	@OperatorName						sysname				= N'Alerts', 
    @MailProfileName					sysname				= N'General', 
    @EmailSubjectPrefix					sysname				= N'[APPLY LOGS] - ', 
	@PrintOnly							bit					= 0
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -----------------------------------------------------------------------------
    -- Dependencies Validation:
    EXEC dbo.verify_advanced_capabilities;;

    -----------------------------------------------------------------------------
    -- Validate Inputs: 
    IF @PrintOnly = 0 BEGIN -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 
        
        -- Operator Checks:
        IF ISNULL(@OperatorName, '') IS NULL BEGIN
            RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
            RETURN -2;
         END;
        ELSE BEGIN 
            IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
                RAISERROR('Invalild Operator Name Specified.', 16, 1);
                RETURN -2;
            END;
        END;

        -- Profile Checks:
        DECLARE @DatabaseMailProfile nvarchar(255)
        EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output'
 
        IF @DatabaseMailProfile <> @MailProfileName BEGIN
            RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
            RETURN -2;
        END; 
    END;

    IF UPPER(@SourceDatabases) IN (N'{SYSTEM}', N'{USER}') BEGIN
        RAISERROR('The tokens {SYSTEM} and {USER} cannot be used to specify which databases to restore via dbo.apply_logs. Only explicitly defined/named databases can be targetted - e.g., N''myDB, anotherDB, andYetAnotherDbName''.', 16, 1);
        RETURN -10;
    END;

    IF (NULLIF(@TargetDbMappingPattern,'')) IS NULL BEGIN
        RAISERROR('@TargetDbMappingPattern can NOT be NULL or empty. Use the place-holder token ''{0}'' to represent the name of the original database (e.g., ''{0}_test'' would become ''dbname_test'' when restoring a database named ''dbname'').', 16, 1);
        RETURN -22;
    END;

	IF UPPER(@RecoveryType) = N'RECOVER' SET @RecoveryType = N'RECOVERY';
	IF(@RecoveryType) NOT IN (N'NORECOVERY', N'RECOVERY', N'STANDBY') BEGIN 
		RAISERROR(N'Allowable @RecoveryType options are { NORECOVERY | RECOVERY | STANDBY }. The value [%s] is not supported.', 16, 1, @RecoveryType);
		RETURN -32;
	END;

	DECLARE @vectorError nvarchar(MAX);
	DECLARE @vector bigint;  -- represents # of MILLISECONDS that a 'restore' operation is allowed to be stale

	IF NULLIF(@StaleAlertThreshold, N'') IS NOT NULL BEGIN

		EXEC [dbo].[translate_vector]
			@Vector = @StaleAlertThreshold, 
			@ValidationParameterName = N'@StaleAlertThreshold', 
			@ProhibitedIntervals = NULL, 
			@TranslationDatePart = N'SECOND', 
			@Output = @vector OUTPUT, 
			@Error = @vectorError OUTPUT;

		IF @vectorError IS NOT NULL BEGIN
			RAISERROR(@vectorError, 16, 1); 
			RETURN -30;
		END;
	END;

	-----------------------------------------------------------------------------
    -- Allow for default paths:
    IF UPPER(@BackupsRootPath) = N'{DEFAULT}' BEGIN
        SELECT @BackupsRootPath = dbo.load_default_path('BACKUP');
    END;

    -- 'Global' Variables:
    DECLARE @isValid bit;
	DECLARE @earlyTermination nvarchar(MAX) = N'';

	-- normalize paths: 
	IF(RIGHT(@BackupsRootPath, 1) = '\')
		SET @BackupsRootPath = LEFT(@BackupsRootPath, LEN(@BackupsRootPath) - 1);
    
	-- Verify Paths: 
    EXEC dbo.check_paths @BackupsRootPath, @isValid OUTPUT;
    IF @isValid = 0 BEGIN
        SET @earlyTermination = N'@BackupsRootPath (' + @BackupsRootPath + N') is invalid - restore operations terminated prematurely.';
        GOTO FINALIZE;
    END;

    -----------------------------------------------------------------------------
	-- If the {READ_FROM_FILESYSTEM} token is specified, replace {READ_FROM_FILESYSTEM} in @DatabasesToRestore with a serialized list of db-names pulled from @BackupRootPath:
	IF ((SELECT dbo.[count_matches](@SourceDatabases, N'{READ_FROM_FILESYSTEM}')) > 0) BEGIN
		DECLARE @databases xml = NULL;
		DECLARE @serialized nvarchar(MAX) = '';

		EXEC dbo.[load_backup_database_names]
		    @TargetDirectory = @BackupsRootPath,
		    @SerializedOutput = @databases OUTPUT;

		WITH shredded AS ( 
			SELECT 
				[data].[row].value('@id[1]', 'int') [row_id], 
				[data].[row].value('.[1]', 'sysname') [database_name]
			FROM 
				@databases.nodes('//database') [data]([row])
		) 

		SELECT 
			@serialized = @serialized + [database_name] + N','
		FROM 
			shredded 
		ORDER BY 
			row_id;

		SET @serialized = LEFT(@serialized, LEN(@serialized) - 1);

        SET @databases = NULL;
		EXEC dbo.load_backup_database_names
			@TargetDirectory = @BackupsRootPath, 
			@SerializedOutput = @databases OUTPUT;

		SET @SourceDatabases = REPLACE(@SourceDatabases, N'{READ_FROM_FILESYSTEM}', @serialized); 
	END;

    -----------------------------------------------------------------------------
	-- start processing:
	DECLARE @executionID uniqueidentifier = NEWID();
	DECLARE @sourceDbName sysname;
	DECLARE @targetDbName sysname;
	DECLARE @fileList xml;
	DECLARE @latestPreviousFileRestored sysname;
	DECLARE @sourcePath sysname; 
	DECLARE @backupFilesList xml = NULL;
	DECLARE @currentLogFileID int;
	DECLARE @backupName sysname;
	DECLARE @pathToTLogBackup sysname;
	DECLARE @command nvarchar(2000);
	DECLARE @outcome varchar(4000);
	DECLARE @statusDetail nvarchar(500);
	DECLARE @appliedFileList nvarchar(MAX);
	DECLARE @restoreStart datetime;
	DECLARE @logsWereApplied bit = 0;
	DECLARE @operationSuccess bit;
	DECLARE @noFilesApplied bit = 0;

	DECLARE @outputSummary nvarchar(MAX);
    DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
    DECLARE @tab char(1) = CHAR(9);

	DECLARE @offset sysname;
	DECLARE @tufPath sysname;
	DECLARE @restoredFiles xml;

	-- meta-data variables:
	DECLARE @backupDate datetime, @backupSize bigint, @compressed bit, @encrypted bit;

    -- Construct list of databases to process:
	DECLARE @applicableDatabases table (
		entry_id int IDENTITY(1,1) NOT NULL, 
		source_database_name sysname NOT NULL,
		target_database_name sysname NOT NULL
	);

	DECLARE @possibleDatabases table ( 
		row_id int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL
	); 

	INSERT INTO @possibleDatabases ([database_name])
	EXEC dbo.list_databases 
        @Targets = @SourceDatabases,         
        @Exclusions = @Exclusions,		
        @Priorities = @Priorities,

		@ExcludeSimpleRecovery = 1, 
		@ExcludeRestoring = 0, -- we're explicitly targetting just these in fact... 
		@ExcludeRecovering = 1; -- we don't want these... (they're 'too far gone')

	INSERT INTO @applicableDatabases ([source_database_name], [target_database_name])
	SELECT [database_name] [source_database_name], REPLACE(@TargetDbMappingPattern, N'{0}', [database_name]) [target_database_name] FROM @possibleDatabases ORDER BY [row_id];

	-- exclude online DBs - as we, obviously, can't apply logs to them:
	DELETE FROM @applicableDatabases WHERE [target_database_name] IN (SELECT [name] FROM sys.databases WHERE [state_desc] = N'ONLINE');

	-- also exclude DBs where target isn't online or doesn't exist: 
	DELETE FROM @applicableDatabases WHERE [target_database_name] NOT IN (SELECT [name] FROM sys.databases);

    IF NOT EXISTS (SELECT NULL FROM @applicableDatabases) BEGIN
        SET @earlyTermination = N'Databases specified for apply_logs operation: [' + @SourceDatabases + ']. However, none of the databases specified can have T-LOGs applied - as there are no databases in STANDBY or NORECOVERY mode.';
        GOTO FINALIZE;
    END;
	
	-- Begin application of logs:
    PRINT '-- Databases To Attempt Log Application Against: ' + @serialized;

	DECLARE @logFilesToRestore table ( 
		id int IDENTITY(1,1) NOT NULL, 
		log_file sysname NOT NULL
	);

	DECLARE @appliedFiles table (
		ID int IDENTITY(1,1) NOT NULL, 
		[FileName] nvarchar(400) NOT NULL, 
		Detected datetime NOT NULL, 
		BackupCreated datetime NULL, 
		Applied datetime NULL, 
		BackupSize bigint NULL, 
		Compressed bit NULL, 
		[Encrypted] bit NULL
	); 

	DECLARE @warnings table (
		warning_id int IDENTITY(1,1) NOT NULL, 
		warning nvarchar(MAX) NOT NULL 
	);

    DECLARE restorer CURSOR LOCAL FAST_FORWARD FOR 
    SELECT 
        [source_database_name],
		[target_database_name]
    FROM 
        @applicableDatabases
    ORDER BY 
        entry_id;

	OPEN [restorer]; 

	FETCH NEXT FROM [restorer] INTO @sourceDbName, @targetDbName;

	WHILE @@FETCH_STATUS = 0 BEGIN 
		
		SET @restoreStart = GETDATE();
		SET @noFilesApplied = 0;  
		DELETE FROM @appliedFiles;

		-- determine last successfully applied t-log:
		SELECT @fileList = [restored_files] FROM dbo.[restore_log] WHERE [restore_id] = (SELECT MAX(restore_id) FROM [dbo].[restore_log] WHERE [database] = @sourceDbName AND [restored_as] = @targetDbName AND [restore_succeeded] = 1);

		IF @fileList IS NULL BEGIN 
			SET @statusDetail = N'Attempt to apply logs from ' + QUOTENAME(@sourceDbName) + N' to ' + QUOTENAME(@targetDbName) + N' could not be completed. No details in dbo.restore_log for last backup-file used during restore/application process. Please use dbo.restore_databases to ''seed'' databases.';
			GOTO NextDatabase;
		END; 

		SELECT @latestPreviousFileRestored = @fileList.value('(/files/file[@id = max(/files/file/@id)]/name)[1]', 'sysname');

		IF @latestPreviousFileRestored IS NULL BEGIN 
			SET @statusDetail = N'Attempt to apply logs from ' + QUOTENAME(@sourceDbName) + N' to ' + QUOTENAME(@targetDbName) + N' could not be completed. The column: restored_files in dbo.restore_log is missing data on the last file applied to ' + QUOTENAME(@targetDbName) + N'. Please use dbo.restore_databases to ''seed'' databases.';
			GOTO NextDatabase;
		END; 

		SET @sourcePath = @BackupsRootPath + N'\' + @sourceDbName;

		SET @backupFilesList = NULL;
		EXEC dbo.load_backup_files 
			@DatabaseToRestore = @sourceDbName, 
			@SourcePath = @sourcePath, 
			@Mode = N'LOG', 
			@LastAppliedFile = @latestPreviousFileRestored, 
			@Output = @backupFilesList OUTPUT;
		
		-- reset values per every 'loop' of main processing body:
		DELETE FROM @logFilesToRestore;

		WITH shredded AS ( 
			SELECT 
				[data].[row].value('@id[1]', 'int') [id], 
				[data].[row].value('@file_name', 'nvarchar(max)') [file_name]
			FROM 
				@backupFilesList.nodes('//file') [data]([row])
		) 

		INSERT INTO @logFilesToRestore ([log_file])
		SELECT [file_name] FROM [shredded] ORDER BY [id];
		
		SET @logsWereApplied = 0;

		IF EXISTS(SELECT NULL FROM @logFilesToRestore) BEGIN

			-- switch any dbs in STANDBY back to NORECOVERY.
			IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @targetDbName AND [is_in_standby] = 1) BEGIN

				SET @command = N'ALTER DATABASE ' + QUOTENAME(@targetDbName) + N' SET SINGLE_USER WITH ROLLBACK IMMEDIATE; 
GO
RESTORE DATABASE ' + QUOTENAME(@targetDbName) + N' WITH NORECOVERY;';

				IF @PrintOnly = 1 BEGIN 
					PRINT @command;
				  END; 
				ELSE BEGIN 

					BEGIN TRY 
						SET @outcome = NULL; 
						DECLARE @result varchar(4000);
						EXEC dbo.[execute_uncatchable_command] @command, N'UN-STANDBY', @Result = @outcome OUTPUT;

						SET @statusDetail = @outcome;

					END TRY	
					BEGIN CATCH
						SELECT @statusDetail = N'Unexpected Exception while attempting to remove database ' + QUOTENAME(@targetDbName) + N' from STANDBY mode. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
						GOTO NextDatabase;
					END CATCH

					-- give it a second, and verify the state: 
					WAITFOR DELAY '00:00:05';

					IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @targetDbName AND [is_in_standby] = 1) BEGIN
						SET @statusDetail = N'Database ' + QUOTENAME(@targetDbName) + N' was set to RESTORING but, 05 seconds later, is still in STANDBY mode.';
					END;
				END;

				-- if there were ANY problems with the operations above, we can't apply logs: 
				IF @statusDetail IS NOT NULL 
					GOTO NextDatabase;
			END;

			-- re-update the counter: 
			SET @currentLogFileID = ISNULL((SELECT MIN(id) FROM @logFilesToRestore), @currentLogFileID + 1);
			
			WHILE EXISTS (SELECT NULL FROM @logFilesToRestore WHERE [id] = @currentLogFileID) BEGIN

				SELECT @backupName = log_file FROM @logFilesToRestore WHERE id = @currentLogFileID;
				SET @pathToTLogBackup = @sourcePath + N'\' + @backupName;

				INSERT INTO @appliedFiles ([FileName], [Detected])
				SELECT @backupName, GETDATE();

				SET @command = N'RESTORE LOG ' + QUOTENAME(@targetDbName) + N' FROM DISK = N''' + @pathToTLogBackup + N''' WITH NORECOVERY;';
                
				BEGIN TRY 
					IF @PrintOnly = 1 BEGIN
						PRINT @command;
					  END;
					ELSE BEGIN
						SET @outcome = NULL;
						EXEC dbo.execute_uncatchable_command @command, 'RESTORE', @result = @outcome OUTPUT;
						SET @statusDetail = @outcome;
					END;
				END TRY
				BEGIN CATCH
					SELECT @statusDetail = N'Unexpected Exception while executing LOG Restore from File: "' + @backupName + N'". Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
					-- don't go to NextDatabase - we need to record meta data FIRST... 
				END CATCH

				-- Update MetaData: 
				EXEC dbo.load_header_details @BackupPath = @pathToTLogBackup, @BackupDate = @backupDate OUTPUT, @BackupSize = @backupSize OUTPUT, @Compressed = @compressed OUTPUT, @Encrypted = @encrypted OUTPUT;

				UPDATE @appliedFiles 
				SET 
					[Applied] = GETDATE(), 
					[BackupCreated] = @backupDate, 
					[BackupSize] = @backupSize, 
					[Compressed] = @compressed, 
					[Encrypted] = @encrypted
				WHERE 
					[FileName] = @backupName;

				IF @statusDetail IS NOT NULL BEGIN
					GOTO NextDatabase;
				END;

				-- Check for any new files if we're now 'out' of files to process: 
				IF @currentLogFileID = (SELECT MAX(id) FROM @logFilesToRestore) BEGIN

                    SET @backupFilesList = NULL;
					-- if there are any new log files, we'll get those... and they'll be added to the list of files to process (along with newer (higher) ids)... 
					EXEC dbo.load_backup_files 
                        @DatabaseToRestore = @sourceDbName, 
                        @SourcePath = @sourcePath, 
                        @Mode = N'LOG', 
						@LastAppliedFinishTime = @backupDate,
                        @Output = @backupFilesList OUTPUT;

					WITH shredded AS ( 
						SELECT 
							[data].[row].value('@id[1]', 'int') [id], 
							[data].[row].value('@file_name', 'nvarchar(max)') [file_name]
						FROM 
							@backupFilesList.nodes('//file') [data]([row])
					) 

					INSERT INTO @logFilesToRestore ([log_file])
					SELECT [file_name] FROM [shredded] WHERE [file_name] NOT IN (SELECT [log_file] FROM @logFilesToRestore)
					ORDER BY [id];

				END;

				-- signify files applied: 
				SET @logsWereApplied = 1;

				-- increment: 
				SET @currentLogFileID = @currentLogFileID + 1;
			END;
		  END;
		ELSE BEGIN 
			-- No Log Files found/available for application (either it's too early or something ugly has happened and backups aren't pushing files). 
			SET @noFilesApplied = 1; -- which will SKIP inserting a row for this db/operation BUT @StaleAlertThreshold will still get checked (to alert if something ugly is going on.

		END;

		IF UPPER(@RecoveryType) = N'STANDBY' AND @logsWereApplied = 1 BEGIN 
						
			SET @offset = RIGHT(CAST(CAST(RAND() AS decimal(12,11)) AS varchar(20)),7);
			SELECT @tufPath = [physical_name] FROM sys.[master_files]  WHERE database_id = DB_ID(@targetDbName) AND [file_id] = 1;

			SET @tufPath = LEFT(@tufPath, LEN(@tufPath) - (CHARINDEX(N'\', REVERSE(@tufPath)) - 1)); -- strip the filename... 

			SET @command = N'RESTORE DATABASE ' + QUOTENAME(@targetDbName) + N' WITH STANDBY = N''' + @tufPath + @targetDbName + N'_' + @offset + N'.tuf'';
ALTER DATABASE ' + QUOTENAME(@targetDbName) + N' SET MULTI_USER;';

			IF @PrintOnly = 1 BEGIN 
				PRINT @command;
			  END;
			ELSE BEGIN
				BEGIN TRY
					SET @outcome = NULL;
					EXEC dbo.execute_uncatchable_command @command, 'RESTORE', @result = @outcome OUTPUT;

					SET @statusDetail = @outcome;
				END TRY
				BEGIN CATCH
					SET @statusDetail = N'Exception when attempting to put database ' + QUOTENAME(@targetDbName) + N' into STANDBY mode. [Command: ' + @command + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
				END CATCH
			END;
		END; 

		IF UPPER(@RecoveryType) = N'RECOVERY' AND @logsWereApplied = 1 BEGIN

			SET @command = N'RESTORE DATABASE ' + QUOTENAME(@targetDbName) + N' WITH RECCOVERY;';

			IF @PrintOnly = 1 BEGIN 
				PRINT @command;
			  END;
			ELSE BEGIN
				BEGIN TRY
					SET @outcome = NULL;
					EXEC dbo.execute_uncatchable_command @command, 'RESTORE', @result = @outcome OUTPUT;

					SET @statusDetail = @outcome;
				END TRY
				BEGIN CATCH
					SET @statusDetail = N'Exception when attempting to RECOVER database ' + QUOTENAME(@targetDbName) + N'. [Command: ' + @command + N']. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N' - ' + ERROR_MESSAGE();
				END CATCH
			END;
		END;

NextDatabase:

		-- Execute Stale Checks if configured/defined: 
		DECLARE @latestApplied datetime;
		IF NULLIF(@StaleAlertThreshold, N'') IS NOT NULL BEGIN

			IF @logsWereApplied = 1 BEGIN 
				SELECT @latestApplied = MAX([BackupCreated]) FROM @appliedFiles;  -- REFACTOR: call this variable @mostRecentBackup instead of @latestApplied... 
			  END;
			ELSE BEGIN -- grab it from the LAST successful operation 

				SELECT @restoredFiles = [restored_files] FROM dbo.[restore_log] WHERE [restore_id] = (SELECT MAX(restore_id) FROM [dbo].[restore_log] WHERE [database] = @sourceDbName AND [restored_as] = @targetDbName AND [restore_succeeded] = 1);

				IF @restoredFiles IS NULL BEGIN 
					
					PRINT 'warning ... could not get previous file details for stale check....';
				END; 

				SELECT @latestApplied = @restoredFiles.value('(/files/file[@id = max(/files/file/@id)]/created)[1]', 'datetime')
			END;

			IF DATEDIFF(SECOND, @latestApplied, GETDATE()) > @vector BEGIN 
				INSERT INTO @warnings ([warning])
				VALUES ('Database ' + QUOTENAME(@targetDbName) + N' has exceeded the amount of time allowed since successfully restoring live data to the applied/target database. Specified threshold: ' + @StaleAlertThreshold + N', CreationTime of Last live backup: ' + CONVERT(sysname, @latestApplied, 121) + N'.');
			END;

		END;

		-- serialize restored file details and push into dbo.restore_log
		SELECT @appliedFileList = (
			SELECT 
				ROW_NUMBER() OVER (ORDER BY ID) [@id],
				[FileName] [name], 
				BackupCreated [created],
				Detected [detected], 
				Applied [applied], 
				BackupSize [size], 
				Compressed [compressed], 
				[Encrypted] [encrypted]
			FROM 
				@appliedFiles 
			ORDER BY 
				ID
			FOR XML PATH('file'), ROOT('files')
		);

		IF @PrintOnly = 1
			PRINT @appliedFileList; 
		ELSE BEGIN
			
			IF @logsWereApplied = 0
				SET @operationSuccess = 0 
			ELSE 
				SET @operationSuccess =  CASE WHEN NULLIF(@statusDetail,'') IS NULL THEN 1 ELSE 0 END;

			IF @noFilesApplied = 0 BEGIN
				INSERT INTO dbo.[restore_log] ([execution_id], [operation_date], [operation_type], [database], [restored_as], [restore_start], [restore_end], [restore_succeeded], [restored_files], [recovery], [dropped], [error_details])
				VALUES (@executionID, GETDATE(), 'APPLY-LOGS', @sourceDbName, @targetDbName, @restoreStart, GETDATE(), @operationSuccess, @appliedFileList, @RecoveryType, 'LEFT-ONLINE', NULLIF(@statusDetail, ''));
			END;
		END;

		-- Report on outcome for manual operations/interactions: 
		IF @logsWereApplied = 1 BEGIN
			SET @outputSummary = N'Applied the following Logs: ' + @crlf;

			SELECT 
				@outputSummary = @outputSummary + @tab + [FileName] + @crlf
			FROM 
				@appliedFiles 
			ORDER BY 
				ID;

			EXEC [dbo].[print_long_string] @outputSummary;
		END; ELSE BEGIN
			IF NULLIF(@statusDetail,'') IS NULL
				PRINT N'Success. No new/applicable logs found.';
		END;

		FETCH NEXT FROM [restorer] INTO @sourceDbName, @targetDbName;
	END; 

	CLOSE [restorer];
	DEALLOCATE [restorer];

FINALIZE:

	-- check for and close cursor (if open/etc.)
	IF (SELECT CURSOR_STATUS('local','restorer')) > -1 BEGIN;
		CLOSE [restorer];
		DEALLOCATE [restorer];
	END;

	DECLARE @messageSeverity sysname = N'';
	DECLARE @message nvarchar(MAX) = N'';

	IF EXISTS (SELECT NULL FROM @warnings) BEGIN 
		SET @messageSeverity = N'WARNING';

		SET @message = N'The following WARNINGS were raised: ' + @crlf;

		SELECT 
			@message = @message + @crlf
			+ @tab + N'- ' + [warning]
		FROM 
			@warnings 
		ORDER BY [warning_id];

		SET @message = @message + @crlf + @crlf;
	END;

	IF (NULLIF(@earlyTermination,'') IS NOT NULL) OR (EXISTS (SELECT NULL FROM dbo.restore_log WHERE execution_id = @executionID AND error_details IS NOT NULL)) BEGIN

		IF @messageSeverity <> '' 
			SET @messageSeverity = N'ERROR & WARNING';
		ELSE 
			SET @messageSeverity = N'ERROR';

		SET @message = @message + N'The following ERRORs were encountered: ' + @crlf;

		IF NULLIF(@earlyTermination, N'') IS NOT NULL 
			SET @message = @message + @earlyTermination;

		SELECT 
			@message  = @message + @crlf
			+ @tab + N'- Database: ' + QUOTENAME([database]) + CASE WHEN [restored_as] <> [database] THEN N' (being restored as ' + QUOTENAME([restored_as]) + N') ' ELSE N' ' END + ': ' + [error_details]
		FROM 
			dbo.restore_log 
		WHERE 
			[execution_id] = @executionID AND error_details IS NOT NULL
		ORDER BY 
			[restore_id];
	END; 

	IF NULLIF(@message, N'') IS NOT NULL BEGIN 

		IF @AlertOnStaleOnly = 1 BEGIN
			IF @messageSeverity NOT LIKE '%WARNING%' BEGIN
				PRINT 'Apply Errors Detected - but not raised because @AlertOnStaleOnly is set to true.';
				RETURN 0; -- early termination... 
			END;
		END;

		DECLARE @subject nvarchar(2000) = ISNULL(@EmailSubjectPrefix, N'') + @messageSeverity;

		IF @PrintOnly = 1 BEGIN 
			PRINT @subject;
			PRINT @message;
		  END;
		ELSE BEGIN 
            EXEC msdb..sp_notify_operator
                @profile_name = @MailProfileName,
                @name = @OperatorName,
                @subject = @subject, 
                @body = @message;
		END;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_recovery_metrics','P') IS NOT NULL
	DROP PROC dbo.list_recovery_metrics;
GO

CREATE PROC dbo.list_recovery_metrics 
	@TargetDatabases				nvarchar(MAX)		= N'{ALL}', 
	@ExcludedDatabases				nvarchar(MAX)		= NULL,				-- e.g., 'demo, test, %_fake, etc.'
	@Priorities						nvarchar(MAX)		= NULL,
	@Mode							sysname				= N'SUMMARY',		-- SUMMARY | SLA | RPO | RTO | ERROR | DEVIATION
	@Scope							sysname				= N'WEEK'			-- LATEST | DAY | WEEK | MONTH | QUARTER
AS 
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -----------------------------------------------------------------------------
    -- Validate Inputs: 
	-- TODO: validate inputs.... 

	-----------------------------------------------------------------------------
	-- Establish target databases and execution instances:
	CREATE TABLE #targetDatabases (
		[database_name] sysname NOT NULL
	);

	CREATE TABLE #executionIDs (
		execution_id uniqueidentifier NOT NULL
	);

	INSERT INTO [#targetDatabases] ([database_name])
	EXEC dbo.[list_databases]
		@Targets = @TargetDatabases,
		@Exclusions = @ExcludedDatabases,
		@Priorities = @Priorities;

	IF UPPER(@Scope) = N'LATEST'
		INSERT INTO [#executionIDs] ([execution_id])
		SELECT TOP(1) [execution_id] FROM dbo.[restore_log] ORDER BY [restore_id] DESC;

	IF UPPER(@Scope) = N'DAY'
		INSERT INTO [#executionIDs] ([execution_id])
		SELECT [execution_id] FROM dbo.[restore_log] WHERE [operation_date] >= CAST(GETDATE() AS [date]) GROUP BY [execution_id];
	
	IF UPPER(@Scope) = N'WEEK'
		INSERT INTO [#executionIDs] ([execution_id])
		SELECT [execution_id] FROM dbo.[restore_log] WHERE [operation_date] >= CAST(DATEADD(WEEK, -1, GETDATE()) AS [date]) GROUP BY [execution_id];	

	IF UPPER(@Scope) = N'MONTH'
		INSERT INTO [#executionIDs] ([execution_id])
		SELECT [execution_id] FROM dbo.[restore_log] WHERE [operation_date] >= CAST(DATEADD(MONTH, -1, GETDATE()) AS [date]) GROUP BY [execution_id];	

	IF UPPER(@Scope) = N'QUARTER'
		INSERT INTO [#executionIDs] ([execution_id])
		SELECT [execution_id] FROM dbo.[restore_log] WHERE [operation_date] >= CAST(DATEADD(QUARTER, -1, GETDATE()) AS [date]) GROUP BY [execution_id];	
	

	-----------------------------------------------------------------------------
	-- Extract core/key details into a temp table (to prevent excessive CPU iteration later on via sub-queries/operations/presentation-types). 
	SELECT 
		l.[restore_id], 
		l.[execution_id], 
		ROW_NUMBER() OVER (ORDER BY l.[restore_id]) [row_number],
		l.[operation_date],
		l.[database], 
		l.[restored_as], 
		l.[restore_succeeded], 
		l.[restore_start], 
		l.[restore_end],
		CASE 
			WHEN l.[restore_succeeded] = 1 THEN DATEDIFF(MILLISECOND, l.[restore_start], l.[restore_end])
			ELSE 0
		END [restore_duration], 
		l.[consistency_succeeded], 
		CASE
			WHEN ISNULL(l.[consistency_succeeded], 0) = 1 THEN DATEDIFF(MILLISECOND, l.[consistency_start], l.[consistency_end])
			ELSE 0
		END [consistency_check_duration], 				
		l.[restored_files], 
		ISNULL(restored_files.value('count(/files/file)', 'int'), 0) [restored_file_count],
		ISNULL(restored_files.exist('/files/file/name[contains(., "DIFF_")]'), 0) [diff_restored],
		restored_files.value('(/files/file[@id = max(/files/file/@id)]/created)[1]', 'datetime') [latest_backup],
		l.[error_details]
	INTO 
		#facts 
	FROM 
		dbo.[restore_log] l 
		INNER JOIN [#targetDatabases] d ON l.[database] = d.[database_name]
		INNER JOIN [#executionIDs] e ON l.[execution_id] = e.[execution_id];

				-- vNEXT: 
				--		so. if there's just one db being restored per 'test' (i.e., execution) then ... only show that db's name... 
				--			but, if there are > 1 ... show all dbs in an 'xml list'... 
				--			likewise, if there's just a single db... report on rpo... total. 
				--			but, if there are > 1 dbs... show rpo_total, rpo_min, rpo_max, rpo_avg... AND... then ... repos by db.... i.e., 4 columns for total, min, max, avg and then a 5th/additional column for rpos by db as xml... 
				--			to pull this off... just need a dynamic query/projection that has {db_list} and {rpo} tokens for columns... that then get replaced as needed. 
				--				though, the trick, of course, will be to tie into the #tempTables and so on... 

	-- generate aggregate details as well: 
	SELECT 
		x.execution_id, 
		CAST((SELECT  
		CASE 
			-- note: using slightly diff xpath directives in each of these cases/options:
			WHEN [x].[database] = x.[restored_as] THEN CAST((SELECT f2.[restored_as] [restored_db] FROM [#facts] f2 WHERE x.execution_id = f2.[execution_id] ORDER BY f2.[database] FOR XML PATH(''), ROOT('dbs')) AS XML)
			ELSE CAST((SELECT f2.[database] [@source_db], f2.[restored_as] [*] FROM [#facts] f2 WHERE x.execution_id = f2.[execution_id] ORDER BY f2.[database] FOR XML PATH('restored_db'), ROOT('dbs')) AS XML)
		END [databases]
		) AS xml) [databases],
-- TODO: when I query/project this info (down below in various modes) use xpath or even a NASTY REPLACE( where I look for '<error source="[$db_name]" />') ... to remove 'empty' nodes (databases) and, ideally, just have <errors/> if/when there were NO errors.
		CAST((SELECT [database] [@source], error_details [*] FROM [#facts] f3 WHERE x.execution_id = f3.[execution_id] AND f3.[error_details] IS NOT NULL ORDER BY f3.[database] FOR XML PATH('error'), ROOT('errors')) AS xml) [errors]

-- TODO: need a 'details' column somewhat like: 
		--	<detail database="restored_db_name_here" restored_file_count="N" rpo_milliseconds="nnnn" /> ... or something similar... 
	INTO 
		#aggregates
	FROM 
		#facts x;


	IF UPPER(@Mode) IN (N'SLA', N'RPO', N'RTO') BEGIN 

		SELECT 
			[restore_id], 
			[execution_id],
			COUNT(restore_id) OVER (PARTITION BY [execution_id]) [tested_count],
			[database], 
			[restored_as],
			--DATEDIFF(DAY, [latest_backup], [restore_end]) [rpo_gap_days], 
			--DATEDIFF(DAY, [restore_start], [restore_end]) [rto_gap_days],
			DATEDIFF(MILLISECOND, [latest_backup], [restore_end]) [rpo_gap], 
			DATEDIFF(MILLISECOND, [restore_start], [restore_end]) [rto_gap]
		INTO 
			#metrics
		FROM 
			#facts;
	END; 

	-----------------------------------------------------------------------------
	-- SUMMARY: 
	IF UPPER(@Mode) = N'SUMMARY' BEGIN
	
		DECLARE @compatibilityCommand nvarchar(MAX) = N'
		SELECT 
			f.[operation_date], 
			f.[database] + N'' -> '' + f.[restored_as] [operation],
			f.[restore_succeeded], 
			--f.[consistency_succeeded] [check_succeeded],
			f.[restored_file_count],
			f.[diff_restored], 
			dbo.format_timespan(f.[restore_duration]) [restore_duration],
			
			
			-- MKC: this is ... busted.
			--dbo.format_timespan(SUM(f.[restore_duration]) OVER (PARTITION BY f.[execution_id] ORDER BY f.[restore_id])) [cummulative_restore],
			
			-- MKC: these ... don''t make ANY sense in a RECOVERY METRICS report:
			--dbo.format_timespan(f.[consistency_check_duration]) [check_duration], 
			--dbo.format_timespan(SUM(f.[consistency_check_duration]) OVER (PARTITION BY f.[execution_id] ORDER BY f.[restore_id])) [cummulative_check], 
			CASE 
				WHEN DATEDIFF(DAY, f.[latest_backup], f.[restore_end]) > 20 THEN CAST(DATEDIFF(DAY, f.[latest_backup], f.[restore_end]) AS nvarchar(20)) + N'' days'' 
				ELSE dbo.format_timespan(DATEDIFF(MILLISECOND, f.[latest_backup], f.[restore_end])) 
			END [rpo_gap], 
			ISNULL(f.[error_details], N'''') [error_details]
		FROM 
			#facts f
		ORDER BY 
			f.[row_number] DESC; ';

		IF (SELECT dbo.[get_engine_version]()) <= 10.5 BEGIN 
			-- TODO: the fix here won't be too hard. i.e., I just need to do the following: 
			--		a) figure out how to 'order' the rows in #facts as needed... i.e., either by a ROW_NUMBER() ... windowing function (assuming that's supported) or by means of some other option... 
			--		b) instead of using SUM() OVER ()... 
			--				just 1) create an INNER JOIN against #facts f2 ON f1.previousRowIDs <= f2.currentRowID - as per this approach: https://stackoverflow.com/a/2120639/11191
			--				then 2) just SUM against f2 instead... and that should work just fine. 
			
			-- as in... i'd create/define a DIFFERENT @compatibilityCommand 'body'... then let that be RUN below via sp_executesql... 


			RAISERROR('The SUMMARY mode is currently NOT supported in SQL Server 2008 and 2008R2.', 16, 1); 
			RETURN -100;
		END; 

		EXEC sys.[sp_executesql] @compatibilityCommand;
	END; 

	-----------------------------------------------------------------------------
	-- SLA: 
	IF UPPER(@Mode) = N'SLA' BEGIN
		DECLARE @dbTestCount int; 
		SELECT @dbTestCount = MAX([tested_count]) FROM [#metrics];

		IF @dbTestCount < 2 BEGIN
			WITH core AS ( 
				SELECT 
					f.execution_id, 
					MAX(f.[row_number]) [rank_id],
					MIN(f.[operation_date]) [test_date],
					COUNT(f.[database]) [tested_db_count],
					SUM(CAST(f.[restore_succeeded] AS int)) [restore_succeeded_count],
					SUM(CAST(f.[consistency_succeeded] AS int)) [check_succeeded_count], 
					SUM(CASE WHEN NULLIF(f.[error_details], N'') IS NULL THEN 0 ELSE 1 END) [error_count], 
					SUM(f.[restore_duration]) restore_duration, 
					SUM(f.[consistency_check_duration]) [consistency_duration], 

					-- NOTE: these really only work when there's a single db per execution_id being processed... 
					MAX(f.[restore_end]) [most_recent_restore],
					MAX(f.[latest_backup]) [most_recent_backup]
				FROM 
					#facts f
				GROUP BY 
					f.[execution_id]
			) 

			SELECT 
				x.[test_date],
				a.[databases],
				x.[tested_db_count],
				x.[restore_succeeded_count],
				x.[check_succeeded_count],
				x.[error_count],
				CASE 
					WHEN x.[error_count] = 0 THEN CAST('<errors />' AS xml)
					ELSE a.[errors]   -- TODO: strip blanks and such...   i.e., if there are 50 dbs tested, and 2x had errors, don't want to show 48x <error /> and 2x <error>blakkljdfljjlfsdfj</error>. Instead, just want to show... the 2x <error> blalsdfjldflk</errro> rows... (inside of an <errors> node... 
				END [errors],
				dbo.format_timespan(x.[restore_duration]) [recovery_time_gap],
				dbo.format_timespan(DATEDIFF(MILLISECOND, x.[most_recent_backup], x.[most_recent_restore])) [recovery_point_gap]
			FROM 
				core x
				INNER JOIN [#aggregates] a ON x.[execution_id] = a.[execution_id]
			ORDER BY 
				x.[test_date], x.[rank_id];
		  END;
		ELSE BEGIN 

			WITH core AS ( 
				SELECT 
					f.execution_id, 
					MAX(f.[row_number]) [rank_id],
					MIN(f.[operation_date]) [test_date],
					COUNT(f.[database]) [tested_db_count],
					SUM(CAST(f.[restore_succeeded] AS int)) [restore_succeeded_count],
					SUM(CAST(f.[consistency_succeeded] AS int)) [check_succeeded_count], 
					SUM(CASE WHEN NULLIF(f.[error_details], N'') IS NULL THEN 0 ELSE 1 END) [error_count], 
					SUM(f.[restore_duration]) restore_duration, 
					SUM(f.[consistency_check_duration]) [consistency_duration]
				FROM 
					#facts f
				GROUP BY 
					f.[execution_id]
			), 
			metrics AS ( 
				SELECT 
					[execution_id],
					MAX([rpo_gap]) [max_rpo_gap], 
					AVG([rpo_gap]) [avg_rpo_gap],
					MIN([rpo_gap]) [min_rpo_gap], 
					MAX([rto_gap]) [max_rto_gap], 
					AVG([rto_gap]) [avg_rto_gap],
					MIN([rto_gap]) [min_rto_gap]
				FROM
					#metrics  
				GROUP BY 
					[execution_id]
			) 

			SELECT 
				x.[test_date],
				x.[execution_id],

-- TODO: this top(1) is a hack. Need to figure out a cleaner way to run AGGREGATES in #aggregates when > 1 db is being restored ... 
				(SELECT TOP (1) a.[databases] FROM #aggregates a WHERE a.[execution_id] = x.[execution_id]) [databases],
				x.[tested_db_count],
				x.[restore_succeeded_count],
				x.[check_succeeded_count],
				x.[error_count],
				CASE 
					WHEN x.[error_count] = 0 THEN CAST('<errors />' AS xml)
-- TODO: also a hack... 
					ELSE (SELECT TOP(1) a.[errors] FROM [#aggregates] a WHERE a.[execution_id] = x.execution_id)   
					--ELSE (SELECT y.value('(/errors/error/@source_db)[1]','sysname') [@source_db], y.value('.', 'nvarchar(max)') [*] FROM ((SELECT TOP(1) a.[errors] FROM [#aggregates] a WHERE a.[execution_id] = x.[execution_id])).nodes() AS x(y) WHERE y.value('.','nvarchar(max)') <> N'' FOR XML PATH('error'), ROOT('errors'))
				END [errors],
				
				dbo.format_timespan(m.[max_rto_gap]) [max_rto_gap],
				dbo.format_timespan(m.[avg_rto_gap]) [avg_rto_gap],
				dbo.format_timespan(m.[min_rto_gap]) [min_rto_gap],
				'blah as xml' recovery_time_details,  --'xclklsdlfs' [---rpo_metrics--]  -- i need... avg rpo, min_rpo, max_rpo... IF there's > 1 db being restored... otherwise, just the rpo, etc. 

				dbo.format_timespan(m.[max_rpo_gap]) [max_rpo_gap],
				dbo.format_timespan(m.[avg_rpo_gap]) [avg_rpo_gap],
				dbo.format_timespan(m.[min_rpo_gap]) [min_rpo_gap],
				'blah as xml' recovery_point_details  -- <detail database="restored_db_name_here" restored_file_count="N" rpo_milliseconds="nnnn" /> ... or something similar... 
			FROM 
				core x
				INNER JOIN metrics m ON x.[execution_id] = m.[execution_id]
			ORDER BY 
				x.[test_date], x.[rank_id];

		END;
		

	END; 

	-----------------------------------------------------------------------------
	-- RPO: 
	IF UPPER(@Mode) = N'RPO' BEGIN

		PRINT 'RPO';

	END; 

	-----------------------------------------------------------------------------
	-- RTO: 
	IF UPPER(@Mode) = N'RTO' BEGIN

		PRINT 'RTO';
		
	END; 

	-----------------------------------------------------------------------------
	-- ERROR: 
	IF UPPER(@Mode) = N'ERROR' BEGIN

		PRINT 'ERROR';

	END; 

	-----------------------------------------------------------------------------
	-- DEVIATION: 
	IF UPPER(@Mode) = N'DEVIATION' BEGIN

		PRINT 'DEVIATION';

	END; 

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Performance
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_top','P') IS NOT NULL
	DROP PROC dbo.[list_top];
GO

CREATE PROC dbo.[list_top]
	@TopRequests			int			= 20
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	SET @TopRequests = ISNULL(@TopRequests, 20);
	
	SELECT
		r.session_id, 
		r.blocking_session_id [blocked_by],

		DB_NAME(r.database_id) [db_name],	
		t.[text],
		r.cpu_time,
		r.reads,
		r.writes,
		r.total_elapsed_time [elapsed_time], 
		r.wait_time, 
		r.last_wait_type,
		ISNULL(CAST((g.granted_memory_kb / 1024.0) as decimal(20,2)),0) AS granted_mb, -- memory grants
		r.[status],
		r.command, 
		s.[program_name],
		s.[host_name],
		r.percent_complete,
		CASE s.transaction_isolation_level 
			WHEN 0 THEN 'Unspecified' 
	        WHEN 1 THEN 'ReadUncomitted' 
	        WHEN 2 THEN 'Readcomitted' 
	        WHEN 3 THEN 'Repeatable' 
	        WHEN 4 THEN 'Serializable' 
	        WHEN 5 THEN 'Snapshot' 
		END isolation_level,		
		r.open_transaction_count [open_tran],
		TRY_CAST(tqp.query_plan AS xml) [statement_plan],
		p.query_plan [batch_plan],  -- plan for entire operation/query
		r.plan_handle
	FROM 
		sys.dm_exec_requests r
		INNER JOIN (
			SELECT TOP (@TopRequests) session_id FROM sys.dm_exec_requests 
			WHERE session_id > 50
				AND last_wait_type NOT IN (
					'BROKER_TO_FLUSH','HADR_FILESTREAM_IOMGR_IOCOMPLETION', 
					'BROKER_EVENTHANDLER','BROKER_TRANSMITTER','BROKER_TASK_STOP', 'BROKER_RECEIVE_WAITFOR', 'BROKER_TO_FLUSH', 
					'MISCELLANEOUS', 
					'FT_IFTSHC_MUTEX', 
					'DBMIRRORING_CMD','DBMIRROR_EVENTS_QUEUE', 'DBMIRROR_WORKER_QUEUE', 
					'VDI_CLIENT_OTHER', 'HADR_WORK_QUEUE', 'HADR_NOTIFICATION_DEQUEUE'
				)
				AND [command] NOT IN ('BRKR TASK')
			ORDER BY cpu_time DESC		
		) x ON r.session_id = x.session_id
		INNER JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
		OUTER APPLY sys.dm_exec_sql_text(r.sql_handle) t
		OUTER APPLY sys.dm_exec_query_plan(r.plan_handle) p
		OUTER APPLY sys.dm_exec_text_query_plan(r.plan_handle, r.statement_start_offset, r.statement_end_offset) tqp
		LEFT OUTER JOIN sys.dm_exec_query_memory_grants g ON r.session_id = g.session_id
	WHERE	
		r.session_id != @@SPID
	ORDER BY 
		r.cpu_time DESC;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_processes','P') IS NOT NULL
	DROP PROC dbo.list_processes;
GO

CREATE PROC dbo.list_processes 
	@TopNRows								int			= -1,		-- TOP is only used if @TopNRows > 0. 
	@OrderBy								sysname		= N'CPU',	-- CPU | DURATION | READS | WRITES | MEMORY
	@ExcludeMirroringProcesses				bit			= 1,		-- optional 'ignore' wait types/families.
	@ExcludeNegativeDurations				bit			= 1,		-- exclude service broker and some other system-level operations/etc. 
	@ExcludeBrokerProcesses					bit			= 1,		-- need to document that it does NOT block ALL broker waits (and, that it ONLY blocks broker WAITs - i.e., that's currently the ONLY way it excludes broker processes - by waits).
	@ExcludeFTSDaemonProcesses				bit			= 1,
    --@ExcludeCDCProcesses                    bit         = 1,      -- vNEXT: looks like, sadly, either have to watch for any/some/all? of the following: program_name = SQLAgent Job ID that ... is a CDC task (sigh)... statement_text = 'waitfor delay @waittime' (see this all the time), and/or NAME of the object_id/sproc being executed is ... sys.sp_cdc_scan...  and that's JUST to ignore the LOG READER when it's idle... might have to look at other waits when active/etc. 
	@ExcludeSystemProcesses					bit			= 1,			-- spids < 50... 
	@ExcludeSelf							bit			= 1,	
	@IncludePlanHandle						bit			= 0,	
	@IncludeIsolationLevel					bit			= 0,
	@IncludeBlockingSessions				bit			= 1,		-- 'forces' inclusion of spids CAUSING blocking even if they would not 'naturally' be pulled back by TOP N, etc. 
	@IncudeDetailedMemoryStats				bit			= 0,		-- show grant info... 
	@IncludeExtendedDetails					bit			= 1,
    @IncludeTempdbUsageDetails              bit         = 1,
	@ExtractCost							bit			= 1	
AS 
	SET NOCOUNT ON; 

	IF UPPER(@OrderBy) NOT IN (N'CPU', N'DURATION', N'READS', N'WRITES', 'MEMORY') BEGIN 
		RAISERROR('@OrderBy may only be set to the following values { CPU | DURATION | READS | WRITES | MEMORY } (and is implied as being in DESC order.', 16, 1);
		RETURN -1;
	END;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	CREATE TABLE #core (
		[row_source] sysname NOT NULL,
		[session_id] smallint NOT NULL,
		[blocked_by] smallint NULL,
		[isolation_level] smallint NULL,
		[status] nvarchar(30) NOT NULL,
		[wait_type] nvarchar(60) NULL,
        [wait_resource] nvarchar(256) NOT NULL,
		[command] nvarchar(32) NULL,
		[granted_memory] bigint NULL,
		[requested_memory] bigint NULL,
        [query_cost] float NULL,
		[ideal_memory] bigint NULL,
		[cpu] int NOT NULL,
		[reads] bigint NOT NULL,
		[writes] bigint NOT NULL,
		[duration] int NOT NULL,
		[wait_time] int NULL,
		[database_id] smallint NULL,
		[login_name] sysname NULL,
		[program_name] sysname NULL,
		[host_name] sysname NULL,
		[percent_complete] real NULL,
		[open_tran] int NULL,
        [tempdb_details] nvarchar(MAX) NULL,
		[sql_handle] varbinary(64) NULL,
		[plan_handle] varbinary(64) NULL, 
		[statement_start_offset] int NULL, 
		[statement_end_offset] int NULL,
		[statement_source] sysname NOT NULL DEFAULT N'REQUEST', 
		[row_number] int IDENTITY(1,1) NOT NULL,
		[text] nvarchar(max) NULL
	);

	DECLARE @topSQL nvarchar(MAX) = N'
	WITH [core] AS (
		SELECT {TOP}
			N''ACTIVE_PROCESS'' [row_source],
			r.[session_id], 
			r.[blocking_session_id] [blocked_by],
			s.[transaction_isolation_level] [isolation_level],
			r.[status],
			r.[wait_type],
            r.[wait_resource],
			r.[command],
			g.[granted_memory_kb],
			g.[requested_memory_kb],
			g.[ideal_memory_kb],
            g.[query_cost],
			r.[cpu_time] [cpu], 
			r.[reads], 
			r.[writes], 
			r.[total_elapsed_time] [duration],
			r.[wait_time],
			r.[database_id],
			s.[login_name],
			s.[program_name],
			s.[host_name],
			r.[percent_complete],
			r.[open_transaction_count] [open_tran],
            {TempDBDetails},
			r.[sql_handle],
			r.[plan_handle],
			r.[statement_start_offset], 
			r.[statement_end_offset]
		FROM 
			sys.dm_exec_requests r
			INNER JOIN sys.dm_exec_sessions s ON r.session_id = s.session_id
			LEFT OUTER JOIN sys.dm_exec_query_memory_grants g ON r.session_id = g.session_id AND r.[plan_handle] = g.[plan_handle]
		WHERE
			-- TODO: if wait_types to exclude gets ''stupid large'', then instead of using an IN()... go ahead and create a CTE/derived-table/whatever and do a JOIN instead... 
			ISNULL(r.wait_type, '''') NOT IN(''BROKER_TO_FLUSH'',''HADR_FILESTREAM_IOMGR_IOCOMPLETION'', ''BROKER_EVENTHANDLER'', ''BROKER_TRANSMITTER'',''BROKER_TASK_STOP'', ''MISCELLANEOUS'' {ExcludeMirroringWaits} {ExcludeFTSWaits} {ExcludeBrokerWaits})
			{ExcludeSystemProcesses}
			{ExcludeSelf}
			{ExcludeNegative}
			{ExcludeFTS}
		{TopOrderBy}
	){blockersCTE} 
	
	SELECT 
		[row_source],
		[session_id],
		[blocked_by],
		[isolation_level],
		[status],
		[wait_type],
        [wait_resource],
		[command],
		[granted_memory_kb],
		[requested_memory_kb],
		[ideal_memory_kb],
        [query_cost],
		[cpu],
		[reads],
		[writes],
		[duration],
		[wait_time],
		[database_id],
		[login_name],
		[program_name],
		[host_name],
		[percent_complete],
		[open_tran],
        [tempdb_details],
		[sql_handle],
		[plan_handle],
		[statement_start_offset],
		[statement_end_offset]
	FROM 
		[core] 

	{blockersUNION} 

	{OrderBy};';

	DECLARE @blockersCTE nvarchar(MAX) = N', 
	[blockers] AS ( 
		SELECT 
			N''BLOCKING_SPID'' [row_source],
			[s].[session_id],
			ISNULL([r].[blocking_session_id], x.[blocked]) [blocked_by],
			[s].[transaction_isolation_level] [isolation_level],
			[s].[status],
			ISNULL([r].[wait_type], x.[lastwaittype]) [wait_type],
            ISNULL([r].[wait_resource], N'''') [wait_resource],
			ISNULL([r].[command], x.[cmd]) [command],
			ISNULL([g].[granted_memory_kb],	(x.[memusage] * 8096)) [granted_memory_kb],
			ISNULL([g].[requested_memory_kb], -1) [requested_memory_kb],
			ISNULL([g].[ideal_memory_kb], -1) [ideal_memory_kb],
            ISNULL([g].[query_cost], -1) [query_cost],
			ISNULL([r].[cpu_time], 0 - [s].[cpu_time]) [cpu],
			ISNULL([r].[reads], 0 - [s].[reads]) [reads],
			ISNULL([r].[writes], 0 - [s].[writes]) [writes],
			ISNULL([r].[total_elapsed_time], 0 - [s].[total_elapsed_time]) [duration],
			ISNULL([r].[wait_time],	x.[waittime]) [wait_time],
			[x].[dbid] [database_id],					-- sys.dm_exec_sessions has this - from 2012+ 
			[s].[login_name],
			[s].[program_name],
			[s].[host_name],
			0 [percent_complete],
			x.[open_tran] [open_tran],	  -- sys.dm_exec_sessions has this - from 2012+
            {TempDBDetails},
			ISNULL([r].[sql_handle], (SELECT c.most_recent_sql_handle FROM sys.[dm_exec_connections] c WHERE c.[most_recent_session_id] = s.[session_id])) [sql_handle],
			[r].[plan_handle],
			ISNULL([r].[statement_start_offset], x.[stmt_start]) [statement_start_offset],
			ISNULL([r].[statement_end_offset], x.[stmt_end]) [statement_end_offset]

		FROM 
			sys.dm_exec_sessions s 
			INNER JOIN sys.[sysprocesses] x ON s.[session_id] = x.[spid] -- ugh... i hate using this BUT there are details here that are just NOT anywhere else... 
			LEFT OUTER JOIN sys.dm_exec_requests r ON s.session_id = r.[session_id] 
			LEFT OUTER JOIN sys.[dm_exec_query_memory_grants] g ON s.[session_id] = g.[session_id] AND r.[plan_handle] = g.[plan_handle] 
		WHERE 
			s.[session_id] NOT IN (SELECT session_id FROM [core])
			AND s.[session_id] IN (SELECT blocked_by FROM [core])
	) ';

	DECLARE @blockersUNION nvarchar(MAX) = N'
	UNION 

	SELECT 
		[row_source],
		[session_id],
		[blocked_by],
		[isolation_level],
		[status],
		[wait_type],
        [wait_resource],
		[command],
		[granted_memory_kb],
		[requested_memory_kb],
		[ideal_memory_kb],
        [query_cost],
		[cpu],
		[reads],
		[writes],
		[duration],
		[wait_time],
		[database_id],
		[login_name],
		[program_name],
		[host_name],
		[percent_complete],
		[open_tran],
        [tempdb_details],
		[sql_handle],
		[plan_handle],
		[statement_start_offset],
		[statement_end_offset] 
	FROM 
		[blockers]	
	';

    DECLARE @mergedTempdbMetricsAsACorrelatedSubQuery nvarchar(MAX) = N'
	        N''<tempdb_usage>'' + 
		        ISNULL((
			            (SELECT 
				            COUNT(*) [@allocation_count],
				            CAST(ISNULL((SUM(u.user_objects_alloc_page_count / 128.0)), 0) as decimal(22,1)) [@tempdb_mb], 
				            CAST(ISNULL((SUM(u.internal_objects_alloc_page_count / 128.0)), 0) as decimal(22,1)) [@spill_mb]
			            FROM 
				            sys.dm_db_task_space_usage u 
			            WHERE 
				            u.session_id = s.session_id AND (u.user_objects_alloc_page_count > 0 OR u.internal_objects_alloc_page_count > 0)
			            GROUP BY 
				            u.session_id
			            FOR 
				            XML PATH(''request'')))
		            , N''<request />'')
		        + 
		        ISNULL((
		            (SELECT 
			            COUNT(*) [@allocation_count],
			            CAST(ISNULL((SUM(u.user_objects_alloc_page_count / 128.0)), 0) as decimal(22,1)) [@tempdb_mb], 
			            CAST(ISNULL((SUM(u.internal_objects_alloc_page_count / 128.0)), 0) as decimal(22,1)) [@spill_mb]
		            FROM 
			            sys.dm_db_session_space_usage u 
		            WHERE 
			            u.session_id = s.session_id AND (u.user_objects_alloc_page_count > 0 OR u.internal_objects_alloc_page_count > 0)
		            GROUP BY 
			            u.session_id
		            FOR 
			            XML PATH(''session'')))
		            , N''<session />'') + N''</tempdb_usage>'' [tempdb_details]';

	SET @topSQL = REPLACE(@topSQL, N'{OrderBy}', N'ORDER BY [row_source], ' + QUOTENAME(LOWER(@OrderBy)) + N' DESC');

    -- must be processed before @IncludeBlockingSessions:
    IF @IncludeTempdbUsageDetails = 1 BEGIN 
        SET @topSQL = REPLACE(@topSQL, N'{TempDBDetails}', @mergedTempdbMetricsAsACorrelatedSubQuery);
        SET @blockersCTE = REPLACE(@blockersCTE, N'{TempDBDetails}', @mergedTempdbMetricsAsACorrelatedSubQuery);
      END; 
    ELSE BEGIN 
        SET @topSQL = REPLACE(@topSQL, N'{TempDBDetails}', N'NULL [tempdb_details]');
        SET @blockersCTE = REPLACE(@blockersCTE, N'{TempDBDetails}', N'NULL [tempdb_details]');
    END;

	IF @IncludeBlockingSessions = 1 BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{blockersCTE} ', @blockersCTE);
		SET @topSQL = REPLACE(@topSQL, N'{blockersUNION} ', @blockersUNION);
	  END;
	ELSE BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{blockersCTE} ', N'');
		SET @topSQL = REPLACE(@topSQL, N'{blockersUNION} ', N'');
	END;

	IF @TopNRows > 0 BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{TOP}', N'TOP(' + CAST(@TopNRows AS sysname) + N') ');
		SET @topSQL = REPLACE(@topSQL, N'{TopOrderBy}', N'ORDER BY ' + CASE LOWER(@OrderBy) WHEN 'cpu' THEN 'r.[cpu_time]' WHEN 'duration' THEN 'r.[total_elapsed_time]' WHEN 'memory' THEN 'g.[granted_memory_kb]' ELSE LOWER(@OrderBy) END + N' DESC');
	  END;
	ELSE BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{TOP}', N'');
		SET @topSQL = REPLACE(@topSQL, N'{TopOrderBy}', N'');
	END; 

	IF @ExcludeSystemProcesses = 1 BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSystemProcesses}', N'AND (r.[session_id] > 50) AND (r.[database_id] <> 0) AND (r.[session_id] NOT IN (SELECT [session_id] FROM sys.[dm_exec_sessions] WHERE [is_user_process] = 0)) ');
	  END;	
	ELSE BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSystemProcesses}', N'');
	END;

	IF @ExcludeMirroringProcesses = 1 BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeMirroringWaits}', N',''DBMIRRORING_CMD'',''DBMIRROR_EVENTS_QUEUE'', ''DBMIRROR_WORKER_QUEUE''');
	  END;
	ELSE BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeMirroringWaits}', N'');
	END;

	IF @ExcludeSelf = 1 BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSelf}', N'AND r.[session_id] <> @@SPID');
	  END;
	ELSE BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSelf}', N'');
	END; 

	IF @ExcludeNegativeDurations = 1 BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeNegative}', N'AND r.[total_elapsed_time] > 0 ');
	  END;
	ELSE BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeNegative}', N'');
	END; 

	IF @ExcludeFTSDaemonProcesses = 1 BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeFTSWaits}', N', ''FT_COMPROWSET_RWLOCK'', ''FT_IFTS_RWLOCK'', ''FT_IFTS_SCHEDULER_IDLE_WAIT'', ''FT_IFTSHC_MUTEX'', ''FT_IFTSISM_MUTEX'', ''FT_MASTER_MERGE'', ''FULLTEXT GATHERER'' ');
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeFTS}', N'AND r.[command] NOT LIKE ''FT%'' ');
	  END;
	ELSE BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeFTSWaits}', N'');
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeFTS}', N'');
	END; 

	IF @ExcludeBrokerProcesses = 1 BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeBrokerWaits}', N', ''BROKER_RECEIVE_WAITFOR'', ''BROKER_TASK_STOP'', ''BROKER_TO_FLUSH'', ''BROKER_TRANSMITTER'' ');
	  END;
	ELSE BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeBrokerWaits}', N'');
	END;

--EXEC dbo.[print_long_string] @Input = @topSQL;
--RETURN 0;

	INSERT INTO [#core] (
		[row_source],
		[session_id],
		[blocked_by],
		[isolation_level],
		[status],
		[wait_type],
        [wait_resource],
		[command],
		[granted_memory],
		[requested_memory],
		[ideal_memory],
        [query_cost],
		[cpu],
		[reads],
		[writes],
		[duration],
		[wait_time],
		[database_id],
		[login_name],
		[program_name],
		[host_name],
		[percent_complete],
		[open_tran],
        [tempdb_details],
		[sql_handle],
		[plan_handle],
		[statement_start_offset],
		[statement_end_offset]
	)
	EXEC sys.[sp_executesql] @topSQL; 

	IF NOT EXISTS (SELECT NULL FROM [#core]) BEGIN 
		RETURN 0; -- short-circuit - there's nothing to see here... 
	END;

	-- populate sql_handles for sessions without current requests: 
	UPDATE x 
	SET 
		x.[sql_handle] = c.[most_recent_sql_handle],
		x.[statement_source] = N'CONNECTION'
	FROM 
		[#core] x 
		INNER JOIN sys.[dm_exec_connections] c ON x.[session_id] = c.[most_recent_session_id]
	WHERE 
		x.[sql_handle] IS NULL;

	-- load statements: 
-- TODO: MAY need to use a non_blocked_handles CTE here as well. BUT, IF necessary, note that we can work against dbs in SINGLE_USER state... 
	SELECT 
		x.[session_id], 
		t.[text] [batch_text], 
		SUBSTRING(t.[text], (x.[statement_start_offset]/2) + 1, ((CASE WHEN x.[statement_end_offset] = -1 THEN DATALENGTH(t.[text]) ELSE x.[statement_end_offset] END - x.[statement_start_offset])/2) + 1) [statement_text]
	INTO 
		#statements 
	FROM 
		[#core] x 
		OUTER APPLY sys.[dm_exec_sql_text](x.[sql_handle]) t;

	-- load plans: 
	WITH non_blocked_plans AS ( 
		SELECT 
			session_id,
			plan_handle 
		FROM 
			[#core] 
		WHERE 
			[database_id] NOT IN (SELECT [database_id] FROM dbo.[list_nonaccessible_databases]())
	)  
	SELECT 
		x.[session_id], 
		p.query_plan [batch_plan]
	INTO 
		#plans 
	FROM 
		non_blocked_plans x 
		OUTER APPLY sys.dm_exec_query_plan(x.plan_handle) p

    CREATE TABLE #statementPlans (
        session_id int NOT NULL, 
        [statement_plan] xml 
    );

	DECLARE @loadPlans nvarchar(MAX) = N'
	WITH non_blocking_statements AS (
		SELECT 
			session_id,
			plan_handle, 
			statement_start_offset, 
			statement_end_offset
		FROM 
			[#core] 
		WHERE 
			[database_id] NOT IN (SELECT [database_id] FROM dbo.[list_nonaccessible_databases]())
	)
	
	SELECT 
		x.session_id, 
		' + CASE WHEN (SELECT dbo.[get_engine_version]()) > 10.5 THEN N'TRY_CAST' ELSE N'CAST' END + N'(q.[query_plan] AS xml) [statement_plan]
	FROM 
		non_blocking_statements x 
		OUTER APPLY sys.dm_exec_text_query_plan(x.[plan_handle], x.statement_start_offset, x.statement_end_offset) q ';

    INSERT INTO [#statementPlans] (
        [session_id],
        [statement_plan]
    )
	EXEC [sys].[sp_executesql] @loadPlans;
	
	IF @ExtractCost = 1 BEGIN
		WITH XMLNAMESPACES (DEFAULT 'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
        SELECT
            p.[session_id],
--TODO: look at whether or not a more explicit path with provide any perf benefits (less tempdb usage, less CPU/less time, etc.)
            p.batch_plan.value('(/ShowPlanXML/BatchSequence/Batch/Statements/StmtSimple/@StatementSubTreeCost)[1]', 'float') [plan_cost]
		INTO 
			#costs
        FROM
            [#plans] p;
    END;

    DECLARE @tempdbExtractionCTE nvarchar(MAX) = N'
    WITH extracted AS (
        SELECT 
            session_id,
            details.value(''(tempdb_usage[1]/request[1]/@tempdb_mb)'', N''decimal(22,1)'') [request_tempdb_mb],
            details.value(''(tempdb_usage[1]/request[1]/@spill_mb)'', N''decimal(22,1)'') [request_spills_mb],
            details.value(''(tempdb_usage[1]/session[1]/@tempdb_mb)'', N''decimal(22,1)'') [session_tempdb_mb],
            details.value(''(tempdb_usage[1]/session[1]/@spill_mb)'', N''decimal(22,1)'') [session_spills_mb]
        FROM 
            (SELECT 
                [session_id],
                CAST([tempdb_details] AS xml) [details]
            FROM 
                [#core]) x
    )
    ' ;

    DECLARE @tempdbDetailsSummary nvarchar(MAX) = N'
        CAST(ISNULL(x.[session_spills_mb], 0.0) AS sysname) + N'' '' + CASE WHEN NULLIF(x.[request_spills_mb], 0.0) IS NULL THEN N'''' ELSE N'' ('' + CAST(x.[request_spills_mb] AS sysname) + N'')'' END[spills_mb - s (r)],
        CAST(ISNULL(x.[session_tempdb_mb], 0.0) AS sysname) + N'' '' + CASE WHEN NULLIF(x.[request_tempdb_mb], 0.0) IS NULL THEN N'''' ELSE N'' ('' + CAST(x.[request_tempdb_mb] AS sysname) + N'')'' END[tempdb_mb - s (r)],
    ';

	DECLARE @projectionSQL nvarchar(MAX) = N'{tempdbExtractionCTE}
    SELECT 
		c.[session_id],
		c.[blocked_by],  
		CASE WHEN c.[database_id] = 0 THEN ''resourcedb'' ELSE DB_NAME(c.database_id) END [db_name],
		{isolation_level}
		c.[command], 
        c.[status], 
		c.[wait_type],
        c.[wait_resource],
		t.[batch_text],  
		--t.[statement_text],
		{extractCost}        
		c.[cpu],
		c.[reads],
		c.[writes],
		{memory}
		dbo.format_timespan(c.[duration]) [elapsed_time], 
		dbo.format_timespan(c.[wait_time]) [wait_time],
        {tempdbDetails}
		ISNULL(c.[program_name], '''') [program_name],
		c.[login_name],
		c.[host_name],
		{plan_handle}
		{extended_details}
		sp.[statement_plan],
        p.[batch_plan]
	FROM 
		[#core] c
		INNER JOIN #statements t ON c.session_id = t.session_id
		LEFT OUTER JOIN #plans p ON c.session_id = p.session_id
		LEFT OUTER JOIN #statementPlans sp ON c.session_id = sp.session_id
		{extractJoin}
        {tempdbUsageJoin}
	ORDER BY
		[row_number];'

	IF @IncludeIsolationLevel = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{isolation_level}', N'CASE c.isolation_level WHEN 0 THEN ''Unspecified'' WHEN 1 THEN ''ReadUncomitted'' WHEN 2 THEN ''Readcomitted'' WHEN 3 THEN ''Repeatable'' WHEN 4 THEN ''Serializable'' WHEN 5 THEN ''Snapshot'' END [isolation_level],');
	  END;
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{isolation_level}', N'');
	END;

	IF @IncudeDetailedMemoryStats = 1 BEGIN
		SET @projectionSQL = REPLACE(@projectionSQL, N'{memory}', N'ISNULL(CAST((c.granted_memory / 1024.0) as decimal(20,2)),0) [granted_mb], ISNULL(CAST((c.requested_memory / 1024.0) as decimal(20,2)),0) [requested_mb], ISNULL(CAST((c.ideal_memory  / 1024.0) as decimal(20,2)),0) [ideal_mb],');
	  END;
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{memory}', N'ISNULL(CAST((c.granted_memory / 1024.0) as decimal(20,2)),0) [granted_mb],');
	END; 

	IF @IncludePlanHandle = 1 BEGIN
		SET @projectionSQL = REPLACE(@projectionSQL, N'{plan_handle}', N'c.[statement_source], c.[plan_handle], ');
	  END; 
	ELSE BEGIN
		SET @projectionSQL = REPLACE(@projectionSQL, N'{plan_handle}', N'');
	END; 

	IF @IncludeExtendedDetails = 1 BEGIN
		SET @projectionSQL = REPLACE(@projectionSQL, N'{extended_details}', N'c.[percent_complete], c.[open_tran], (SELECT COUNT(x.session_id) FROM sys.dm_os_waiting_tasks x WHERE x.session_id = c.session_id) [thread_count], ')
	  END;
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{extended_details}', N'');
	END; 

	IF @ExtractCost = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{extractCost}', N'CASE WHEN [pc].[plan_cost] IS NULL AND [c].[query_cost] IS NOT NULL THEN CAST(CAST([c].[query_cost] AS decimal(20,2)) AS sysname) + N''g'' ELSE CAST(CAST([pc].[plan_cost] AS decimal(20,2)) AS sysname) END [cost], ');
		SET @projectionSQL = REPLACE(@projectionSQL, N'{extractJoin}', N'LEFT OUTER JOIN #costs pc ON c.[session_id] = pc.[session_id]');
	  END
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{extractCost}', N'');
		SET @projectionSQL = REPLACE(@projectionSQL, N'{extractJoin}', N'');
	END;

    IF @IncludeTempdbUsageDetails = 1 BEGIN 
        SET @projectionSQL = REPLACE(@projectionSQL, N'{tempdbDetails}', @tempdbDetailsSummary);
        SET @projectionSQL = REPLACE(@projectionSQL, N'{tempdbExtractionCTE}', @tempdbExtractionCTE);
        SET @projectionSQL = REPLACE(@projectionSQL, N'{tempdbUsageJoin}', N'LEFT OUTER JOIN extracted x ON c.[session_id] = x.[session_id] ');
      END;
    ELSE BEGIN 
        SET @projectionSQL = REPLACE(@projectionSQL, N'{tempdbDetails}', N'');
        SET @projectionSQL = REPLACE(@projectionSQL, N'{tempdbExtractionCTE}', N'');
        SET @projectionSQL = REPLACE(@projectionSQL, N'{tempdbUsageJoin}', N'');
    END;

--EXEC dbo.print_long_string @projectionSQL;
--RETURN 0;

	-- final output:
	EXEC sys.[sp_executesql] @projectionSQL;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_parallel_processes','P') IS NOT NULL
	DROP PROC dbo.[list_parallel_processes];
GO

CREATE PROC dbo.[list_parallel_processes]

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SELECT 
		[spid] [session_id],
		[ecid] [execution_id],
		[blocked],
		[dbid] [database_id],
		[cmd] [command],
		[lastwaittype] [wait_type],
		[waitresource] [wait_resource],
		[waittime] [wait_time],
		[status],
		[open_tran],
		[cpu],
		[physical_io],
		[memusage],
		[login_time],
		[last_batch],
		
		[hostname],
		[program_name],
		[loginame],
		[sql_handle],
		[stmt_start],
		[stmt_end]
	INTO
		#ecids
	FROM 
		sys.[sysprocesses] 
	WHERE 
		spid IN (SELECT session_id FROM sys.[dm_os_waiting_tasks] WHERE [session_id] IS NOT NULL GROUP BY [session_id] HAVING COUNT(*) > 1);

	IF NOT EXISTS(SELECT NULL FROM [#ecids]) BEGIN 
		-- short circuit.
		RETURN 0;
	END;


	--TODO: if 2016+ get dop from sys.dm_exec_requests... (or is waiting_tasks?)
	--TODO: execute a cleanup/sanitization of this info + extract code and so on... 
	SELECT 
		[session_id],
		[execution_id],
		[blocked],
		DB_NAME([database_id]) [database_name],
		[command],
		[wait_type],
		[wait_resource],
		[wait_time],
		[status],
		[open_tran],
		[cpu],
		[physical_io],
		[memusage],
		[login_time],
		[last_batch],
		[hostname],
		[program_name],
		[loginame]--,
		--[sql_handle],
		--[stmt_start],
		--[stmt_end]
	FROM 
		[#ecids] 
	ORDER BY 
		-- TODO: whoever is using the most CPU (by session_id) then by ecid... 
		[session_id], 
		[execution_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_transactions','P') IS NOT NULL
	DROP PROC dbo.list_transactions;
GO

CREATE PROC dbo.list_transactions 
	@TopNRows						int			= -1, 
	@OrderBy						sysname		= N'DURATION',  -- DURATION | LOG_COUNT | LOG_SIZE   
	@ExcludeSystemProcesses			bit			= 0,            -- USUALLY, if we're looking at Transactions, we want to see EVERYTHING that's holding a resource - system or otherwise. 
    @ExcludeSchemaLocksOnly         bit         = 1,            -- in the vast majority of cases... don't want to see who has a connection into the db (ONLY)... sp_who/sp_who2 would do a fine job of that... 
	@ExcludeSelf					bit			= 1, 
	@IncludeContext					bit			= 1,	
	@IncludeStatements				bit			= 1, 
	@IncludePlans					bit			= 0, 
	@IncludeBoundSessions			bit			= 0, -- seriously, i bet .00x% of transactions would ever even use this - IF that ... 
	@IncludeDTCDetails				bit			= 0, 
	@IncludeLockedResources			bit			= 1, 
	@IncludeVersionStoreDetails		bit			= 0
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	CREATE TABLE #core (
		[row_number] int IDENTITY(1,1) NOT NULL,
		[session_id] int NOT NULL,
		[transaction_id] bigint NULL,
		[database_id] int NULL,
		[duration] int NULL,
		[enlisted_db_count] int NULL, 
		[tempdb_enlisted] bit NULL,
		[transaction_type] sysname NULL,
		[transaction_state] sysname NULL,
		[enlist_count] int NOT NULL,
		[is_user_transaction] bit NOT NULL,
		[is_local] bit NOT NULL,
		[is_enlisted] bit NOT NULL,
		[is_bound] bit NOT NULL,
		[open_transaction_count] int NOT NULL,
		[log_record_count] bigint NULL,
		[log_bytes_used] bigint NULL
	);

	DECLARE @topSQL nvarchar(MAX) = N'
	SELECT {TOP}
		[dtst].[session_id],
		[dtat].[transaction_id],
		[dtdt].[database_id],
		DATEDIFF(MILLISECOND, [dtdt].[begin_time], GETDATE()) [duration],
		[dtdt].[enlisted_db_count], 
		[dtdt].[tempdb_enlisted],
		CASE [dtat].[transaction_type]
			WHEN 1 THEN ''Read/Write''
			WHEN 2 THEN ''Read-Only''
			WHEN 3 THEN ''System''
			WHEN 4 THEN ''Distributed''
			ELSE ''#Unknown#''
		END [transaction_type],
		CASE [dtat].[transaction_state]
			WHEN 0 THEN ''Initializing''
			WHEN 1 THEN ''Initialized''
			WHEN 2 THEN ''Active''
			WHEN 3 THEN ''Ended (read-only)''
			WHEN 4 THEN ''DTC commit started''
			WHEN 5 THEN ''Awaiting resolution''
			WHEN 6 THEN ''Committed''
			WHEN 7 THEN ''Rolling back...''
			WHEN 8 THEN ''Rolled back''
		END [transaction_state],
		[dtst].[enlist_count], -- # of active requests enlisted... 
		[dtst].[is_user_transaction],
		[dtst].[is_local],
		[dtst].[is_enlisted],
		[dtst].[is_bound],		-- active or not... 
		[dtst].[open_transaction_count], 
		[dtdt].[log_record_count],
		[dtdt].[log_bytes_used]
	FROM 
		sys.[dm_tran_active_transactions] dtat WITH(NOLOCK)
		INNER JOIN sys.[dm_tran_session_transactions] dtst WITH(NOLOCK) ON [dtat].[transaction_id] = [dtst].[transaction_id]
		LEFT OUTER JOIN ( 
			SELECT 
				x.transaction_id,
				MAX(x.database_id) [database_id], -- max isn''t always logical/best. But with tempdb_enlisted + enlisted_db_count... it''s as good as it gets... 
				MIN(x.[database_transaction_begin_time]) [begin_time],
				SUM(CASE WHEN x.database_id = 2 THEN 1 ELSE 0 END) [tempdb_enlisted],
				COUNT(x.database_id) [enlisted_db_count],
				MAX(x.[database_transaction_log_record_count]) [log_record_count],
				MAX(x.[database_transaction_log_bytes_used]) [log_bytes_used]
			FROM 
				sys.[dm_tran_database_transactions] x WITH(NOLOCK)
			GROUP BY 
				x.transaction_id
		) dtdt ON [dtat].[transaction_id] = [dtdt].[transaction_id]
        {ExcludeSchemaLocksOnly}
	WHERE 
		1 = 1 
		{ExcludeSystemProcesses}
		{ExcludeSelf}
	{OrderBy};';

	-- This is a bit ugly... but works... 
	DECLARE @orderByOrdinal nchar(2) = N'3'; -- duration. 
	IF UPPER(@OrderBy) = N'LOG_COUNT' SET @orderByOrdinal = N'12'; 
	IF UPPER(@OrderBy) = N'LOG_SIZE' SET @orderByOrdinal = N'13';

	IF @TopNRows > 0 BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{TOP}', N'TOP(' + CAST(@TopNRows AS sysname) + N') ');
		SET @topSQL = REPLACE(@topSQL, N'{OrderBy}', N'ORDER BY ' + @orderByOrdinal + N' DESC');
	  END;
	ELSE BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{TOP}', N'');
		SET @topSQL = REPLACE(@topSQL, N'{OrderBy}', N'ORDER BY ' + @orderByOrdinal + N' DESC');
	END; 

	IF @ExcludeSystemProcesses = 1 BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSystemProcesses}', N'AND dtst.[session_id] > 50 AND [dtst].[is_user_transaction] = 1 AND (dtst.[session_id] NOT IN (SELECT session_id FROM sys.[dm_exec_sessions] WHERE [is_user_process] = 0))  ');
		END;	
	ELSE BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSystemProcesses}', N'');
	END;

	IF @ExcludeSelf = 1 BEGIN
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSelf}', N'AND dtst.[session_id] <> @@SPID');
	  END;
	ELSE BEGIN 
		SET @topSQL = REPLACE(@topSQL, N'{ExcludeSelf}', N'');
	END; 

    IF @ExcludeSchemaLocksOnly = 1 BEGIN 
        SET @topSQL = REPLACE(@topSQL, N'{ExcludeSchemaLocksOnly}', N'INNER JOIN (SELECT request_session_id [session_id] FROM sys.dm_tran_locks GROUP BY request_session_id HAVING COUNT(*) > 1) [schema_only] ON [dtst].session_id = [schema_only].[session_id]');
      END;
    ELSE BEGIN
        SET @topSQL = REPLACE(@topSQL, N'{ExcludeSchemaLocksOnly}', N'');
    END;


	INSERT INTO [#core] ([session_id], [transaction_id], [database_id], [duration], [enlisted_db_count], [tempdb_enlisted], [transaction_type], [transaction_state], [enlist_count], 
		[is_user_transaction], [is_local], [is_enlisted], [is_bound], [open_transaction_count], [log_record_count], [log_bytes_used])
	EXEC sys.[sp_executesql] @topSQL;

	CREATE TABLE #handles (
		session_id int NOT NULL, 
		statement_source sysname NOT NULL DEFAULT N'REQUEST',
		statement_handle varbinary(64) NULL, 
		plan_handle varbinary(64) NULL, 
		[status] nvarchar(30) NULL, 
		isolation_level varchar(14) NULL, 
		blocking_session_id int NULL, 
		wait_time int NULL, 
		wait_resource nvarchar(256) NULL, 
		[wait_type] nvarchar(60) NULL,
		last_wait_type nvarchar(60) NULL, 
		cpu_time int NULL, 
		[statement_start_offset] int NULL, 
		[statement_end_offset] int NULL
	);

	CREATE TABLE #statements (
		session_id int NOT NULL,
		statement_source sysname NOT NULL DEFAULT N'REQUEST',
		[statement] nvarchar(MAX) NULL
	);

	CREATE TABLE #plans (
		session_id int NOT NULL,
		query_plan xml NULL
	);

	INSERT INTO [#handles] ([session_id], [statement_handle], [plan_handle], [status], [isolation_level], [blocking_session_id], [wait_time], [wait_resource], [wait_type], [last_wait_type], [cpu_time], [statement_start_offset], [statement_end_offset])
	SELECT 
		c.[session_id], 
		r.[sql_handle] [statement_handle], 
		r.[plan_handle], 
		ISNULL(r.[status], N'sleeping'), 
		CASE r.transaction_isolation_level 
			WHEN 0 THEN 'Unspecified' 
	        WHEN 1 THEN 'ReadUncomitted' 
	        WHEN 2 THEN 'Readcomitted' 
	        WHEN 3 THEN 'Repeatable' 
	        WHEN 4 THEN 'Serializable' 
	        WHEN 5 THEN 'Snapshot' 
			ELSE NULL
		END isolation_level,
		r.[blocking_session_id], 
		r.[wait_time], 
		r.[wait_resource], 
		r.[wait_type],
		r.[last_wait_type], 
		r.[cpu_time], 
		r.[statement_start_offset], 
		r.[statement_end_offset]
	FROM 
		[#core] c 
		LEFT OUTER JOIN sys.[dm_exec_requests] r WITH(NOLOCK) ON c.[session_id] = r.[session_id];

	UPDATE h
	SET 
		h.[statement_handle] = CAST(p.[sql_handle] AS varbinary(64)), 
		h.[statement_source] = N'SESSION'
	FROM 
		[#handles] h
		LEFT OUTER JOIN sys.[sysprocesses] p ON h.[session_id] = p.[spid] -- AND h.[request_handle] IS NULL don't really think i need this pushed-down predicate... but might be worth a stab... 
	WHERE 
		h.[statement_handle] IS NULL;

	IF @IncludeStatements = 1 OR @IncludeContext = 1 BEGIN
		
		INSERT INTO [#statements] ([session_id], [statement_source], [statement])
		SELECT 
			h.[session_id], 
			h.[statement_source], 
			t.[text] [statement]
		FROM 
			[#handles] h
			OUTER APPLY sys.[dm_exec_sql_text](h.[statement_handle]) t;
	END; 

	IF @IncludePlans = 1 BEGIN

		INSERT INTO [#plans] ([session_id], [query_plan])
		SELECT 
			h.session_id, 
			p.[query_plan]
		FROM 
			[#handles] h 
			OUTER APPLY sys.[dm_exec_query_plan](h.[plan_handle]) p
	END

    IF @IncludeLockedResources = 1 BEGIN 
        SELECT 
            dtl.[request_session_id] [session_id], 
            dtl.[resource_type],
            dtl.[resource_subtype], 
            dtl.[request_mode], 
            dtl.[request_status], 
            dtl.[request_reference_count], 
            dtl.[request_owner_type], 
            dtl.[request_owner_id], 
            dtl.[resource_associated_entity_id],
            dtl.[resource_database_id], 
            dtl.[resource_lock_partition],
            x.[waiting_task_address], 
            x.[wait_duration_ms], 
            x.[wait_type], 
            x.[blocking_session_id], 
            x.[blocking_task_address], 
            x.[resource_description]
        INTO 
            #lockedResources
        FROM 
            [#core] c
            INNER JOIN sys.[dm_tran_locks] dtl ON c.[session_id] = dtl.[request_session_id]
            LEFT OUTER JOIN sys.[dm_os_waiting_tasks] x WITH(NOLOCK) ON x.[session_id] = c.[session_id]
    END;

	-- correlated sub-query:
	DECLARE @lockedResourcesSQL nvarchar(MAX) = N'
		CAST((SELECT 
			--x.[resource_type] [@resource_type],
			--x.[request_session_id] [@owning_session_id],
			--DB_NAME(x.[resource_database_id]) [@database],
			CASE WHEN x.[resource_subtype] IS NOT NULL THEN x.[resource_subtype] ELSE NULL END [@resource_subtype],
            
            CASE WHEN x.resource_type = N''PAGE'' THEN x.[resource_associated_entity_id] ELSE NULL END [identifier/@associated_hobt_id],
            RTRIM(x.[resource_type] + N'': '' + CAST(x.[resource_database_id] AS sysname) + N'':'' + CASE WHEN x.[resource_type] = N''PAGE'' THEN CAST(x.[resource_description] AS sysname) ELSE CAST(x.[resource_associated_entity_id] AS sysname) END
				+ CASE WHEN x.[resource_type] = N''KEY'' THEN N'' '' + CAST(x.[resource_description] AS sysname) ELSE '''' END
				+ CASE WHEN x.[resource_type] = N''OBJECT'' AND x.[resource_lock_partition] <> 0 THEN N'':'' + CAST(x.[resource_lock_partition] AS sysname) ELSE '''' 
				END) [identifier], 
			
			--x.[request_type] [transaction/@request_type],	-- will ALWAYS be ''LOCK''... 
			x.[request_mode] [transaction/@request_mode], 
			x.[request_status] [transaction/@request_status],
			x.[request_reference_count] [transaction/@reference_count],  -- APPROXIMATE (ont definitive).
			x.[request_owner_type] [transaction/@owner_type],
			x.[request_owner_id] [transaction/@transaction_id],		-- transactionID of the owner... can be ''overloaded'' with negative values (-4 = filetable has a db lock, -3 = filetable has a table lock, other options outlined in BOL).
			x.[waiting_task_address] [waits/waiting_task_address],
			x.[wait_duration_ms] [waits/wait_duration_ms], 
			x.[wait_type] [waits/wait_type],
			x.[blocking_session_id] [waits/blocking/blocking_session_id], 
			x.[blocking_task_address] [waits/blocking/blocking_task_address], 
			x.[resource_description] [waits/blocking/resource_description]
		FROM 
            #lockedResources x
		WHERE 
			x.[session_id] = c.session_id
		FOR XML PATH (''resource''), ROOT(''locked_resources'')) AS xml) [locked_resources],	';
	
	DECLARE @contextSQL nvarchar(MAX) = N'
CAST((
	SELECT 
		-- transaction
			c2.transaction_id [transaction/@transaction_id], 
			c2.transaction_state [transaction/current_state],
			c2.transaction_type [transaction/transaction_type], 
			h2.isolation_level [transaction/isolation_level], 
			c2.enlist_count [transaction/active_request_count], 
			c2.open_transaction_count [transaction/open_transaction_count], 
		
			-- statement
				h2.statement_source [transaction/statement/statement_source], 
				ISNULL(h2.[statement_start_offset], 0) [transaction/statement/sql_handle/@offset_start], 
				ISNULL(h2.[statement_end_offset], 0) [transaction/statement/sql_handle/@offset_end],
				ISNULL(CONVERT(nvarchar(128), h2.[statement_handle], 1), '''') [transaction/statement/sql_handle], 
				h2.plan_handle [transaction/statement/plan_handle],
				ISNULL(s2.statement, N'''') [transaction/statement/sql_text],
			--/statement

			-- waits
				dbo.format_timespan(h2.wait_time) [transaction/waits/@wait_time], 
				h2.wait_resource [transaction/waits/wait_resource], 
				h2.wait_type [transaction/waits/wait_type], 
				h2.last_wait_type [transaction/waits/last_wait_type],
			--/waits

			-- databases 
				c2.enlisted_db_count [transaction/databases/enlisted_db_count], 
				c2.tempdb_enlisted [transaction/databases/is_tempdb_enlisted], 
				DB_NAME(c2.database_id) [transaction/databases/primary_db], 
			--/databases
		--/transaction 

		-- time 
			dbo.format_timespan(h2.cpu_time) [time/cpu_time], 
			dbo.format_timespan(h2.wait_time) [time/wait_time], 
			dbo.format_timespan(c2.duration) [time/duration], 
			dbo.format_timespan(DATEDIFF(MILLISECOND, des2.last_request_start_time, GETDATE())) [time/time_since_last_request_start], 
			ISNULL(CONVERT(sysname, des2.[last_request_start_time], 121), '''') [time/last_request_start]
		--/time
	FROM 
		[#core] c2 
		LEFT OUTER JOIN #handles h2 ON c2.session_id = h2.session_id
		LEFT OUTER JOIN sys.dm_exec_sessions des2 ON c2.session_id = des.session_id
		LEFT OUTER JOIN #statements s2 ON c2.session_id = s2.session_id
	WHERE 
		c2.session_id = c.session_id
		AND h2.session_id = c.session_id 
		AND des2.session_id = c.session_id
		AND s2.session_id = c.session_id
	FOR XML PATH(''''), ROOT(''context'')
	) as xml) [context],	';

	DECLARE @versionStoreSQL nvarchar(MAX) = N'
CAST((
	SELECT 
		[dtvs].[version_sequence_num] [@version_id],
		[dtst].[session_id] [@owner_session_id], 
		[dtvs].[database_id] [versioned_rowset/@database_id],
		[dtvs].[rowset_id] [versioned_rowset/@hobt_id],
		SUM([dtvs].[record_length_first_part_in_bytes]) + SUM([dtvs].[record_length_second_part_in_bytes]) [versioned_rowset/@total_bytes], 
		MAX([dtasdt].[elapsed_time_seconds]) [version_details/@total_seconds_old],
		CASE WHEN MAX(ISNULL([dtasdt].[commit_sequence_num],0)) = 0 THEN 1 ELSE 0 END [version_details/@is_active_transaction],
		MAX(CAST([dtasdt].[is_snapshot] AS tinyint)) [version_details/@is_snapshot],
		MAX([dtasdt].[max_version_chain_traversed]) [version_details/@max_chain_traversed], 
		MAX([dtvs].[status]) [version_details/@using_multipage_storage]
	FROM 
		sys.[dm_tran_session_transactions] dtst
		LEFT OUTER JOIN sys.[dm_tran_locks] dtl ON [dtst].[transaction_id] = dtl.[request_owner_id]
		LEFT OUTER JOIN sys.[dm_tran_version_store] dtvs ON dtl.[resource_database_id] = dtvs.[database_id] AND dtl.[resource_associated_entity_id] = [dtvs].[rowset_id]
		LEFT OUTER JOIN sys.[dm_tran_active_snapshot_database_transactions] dtasdt ON dtst.[session_id] = c.[session_id]
	WHERE 
		dtst.[session_id] = c.[session_id]
		AND [dtvs].[rowset_id] IS NOT NULL
	GROUP BY 
		[dtst].[session_id], [dtvs].[database_id], [dtvs].[rowset_id], [dtvs].[version_sequence_num]
	ORDER BY 
		[dtvs].[version_sequence_num]
	FOR XML PATH(''version''), ROOT(''versions'')
	) as xml) [version_store_data], '

	DECLARE @projectionSQL nvarchar(MAX) = N'
	SELECT 
        [c].[session_id],
		ISNULL([h].blocking_session_id, 0) [blocked_by],
        {lockedResourceCount}
        DB_NAME([c].[database_id]) [database],
        dbo.format_timespan([c].[duration]) [duration],
		h.[status],
		{statement}
		des.[login_name],
		des.[program_name], 
		des.[host_name],
		ISNULL(c.log_record_count, 0) [log_record_count], 
		ISNULL(c.log_bytes_used, 0) [log_bytes_used],
		--N'''' + ISNULL(CAST(c.log_record_count as sysname), ''0'') + N'' - '' + ISNULL(CAST(c.log_bytes_used as sysname),''0'') + N''''		[log_used (count - bytes)],
		{context}
		{locked_resources}
		{version_store}
		{plan}
		{bound}
		CASE WHEN [c].[is_user_transaction] = 1 THEN ''EXPLICIT'' ELSE ''IMPLICIT'' END [transaction_type]
	FROM 
		[#core] c 
		LEFT OUTER JOIN #handles h ON c.session_id = h.session_id
		LEFT OUTER JOIN sys.dm_exec_sessions des ON c.session_id = des.session_id
		{statementJOIN}
		{planJOIN}
	ORDER BY 
		[c].[row_number];';

	IF @IncludeContext = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{context}', @contextSQL);
	  END; 
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{context}', N'');
	END;

	IF @IncludeStatements = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{statement}', N'[s].[statement],');
		SET @projectionSQL = REPLACE(@projectionSQL, N'{statementJOIN}', N'LEFT OUTER JOIN #statements s ON c.session_id = s.session_id');
	  END;
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{statement}', N'');
		SET @projectionSQL = REPLACE(@projectionSQL, N'{statementJOIN}', N'');
	END; 

	IF @IncludePlans = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{plan}', N'[p].[query_plan],');
		SET @projectionSQL = REPLACE(@projectionSQL, N'{planJOIN}', N'LEFT OUTER JOIN #plans p ON c.session_id = p.session_id');
	  END;
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{plan}', N'');
		SET @projectionSQL = REPLACE(@projectionSQL, N'{planJOIN}', N'');
	END;

	IF @IncludeLockedResources = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{locked_resources}', @lockedResourcesSQL);
        SET @projectionSQL = REPLACE(@projectionSQL, N'{lockedResourceCount}', N'ISNULL((SELECT COUNT(*) FROM #lockedResources x WHERE x.session_id = c.session_id), 0) [lock_count], ');
	  END;
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{locked_resources}', N'');
        SET @projectionSQL = REPLACE(@projectionSQL, N'{lockedResourceCount}', N'');
	END;

	IF @IncludeVersionStoreDetails = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{version_store}', @versionStoreSQL);
	  END; 
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{version_store}', N'');
	END;

	IF @IncludeBoundSessions = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{bound}', N', [c].[is_bound]');
	  END; 
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{bound}', N'');
	END;

	IF @IncludeDTCDetails = 1 BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{dtc}', N'<dtc_detail is_local="'' + ISNULL(CAST(c.is_local as char(1)), ''0'') + N''" is_enlisted="'' + ISNULL(CAST(c.is_enlisted as char(1)), ''0'') + N''" />');
	  END;
	ELSE BEGIN 
		SET @projectionSQL = REPLACE(@projectionSQL, N'{dtc}', N'');
	END;

--EXEC dbo.[print_string] @Input = @projectionSQL;
--RETURN;

	-- final output:
	EXEC sys.[sp_executesql] @projectionSQL;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_collisions', 'P') IS NOT NULL
	DROP PROC dbo.list_collisions;
GO

CREATE PROC dbo.list_collisions 
	@TargetDatabases								nvarchar(max)	= N'{ALL}',  -- allowed values: {ALL} | {SYSTEM} | {USER} | 'name, other name, etc'; -- this is an EXCLUSIVE list... as in, anything not explicitly mentioned is REMOVED. 
	@IncludePlans									bit				= 1, 
	@IncludeContext									bit				= 1,
	@UseInputBuffer									bit				= 0,     -- for any statements (query_handles) that couldn't be pulled from sys.dm_exec_requests and then (as a fallback) from sys.sysprocesses, this specifies if we should use DBCC INPUTBUFFER(spid) or not... 
	@ExcludeFullTextCollisions						bit				= 1   
	--@MinimumWaitThresholdInMilliseconds				int			= 200	
	--@ExcludeSystemProcesses							bit			= 1		-- TODO: this needs to be restricted to ... blocked only? or... how's that work... (what if i don't care that a system process is blocked... but that system process is blocking a user process? then what?
AS 
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF NULLIF(@TargetDatabases, N'') IS NULL
		SET @TargetDatabases = N'{ALL}';

	WITH blocked AS (
		SELECT 
			session_id, 
			blocking_session_id
		FROM 
			sys.[dm_os_waiting_tasks]
		WHERE 
			session_id <> blocking_session_id
			AND blocking_session_id IS NOT NULL
	), 
	collisions AS ( 
		SELECT 
			session_id 
		FROM 
			blocked 
		UNION 
		SELECT 
			blocking_session_id
		FROM 
			blocked
		WHERE 
			blocked.blocking_session_id NOT IN (SELECT session_id FROM blocked)  
	)

	SELECT 
		s.session_id, 
		ISNULL(r.database_id, (SELECT TOP (1) [dbid] FROM sys.sysprocesses WHERE spid = s.[session_id])) [database_id],	
		r.wait_time, 
		s.session_id [blocked_session_id],
		r.blocking_session_id,
		r.command,
		ISNULL(r.[status], 'connected') [status],
--		ISNULL(CAST(r.[total_elapsed_time] AS bigint), CASE WHEN NULLIF(s.last_request_start_time, '1900-01-01 00:00:00.000') IS NULL THEN NULL ELSE DATEDIFF_BIG(MILLISECOND, s.last_request_start_time, GETDATE()) END) [duration],
		r.total_elapsed_time, 
		NULLIF(s.last_request_start_time, '1900-01-01 00:00:00.000') [last_request_start_time], 
		
		ISNULL(r.wait_resource, '') wait_resource,
		r.[last_wait_type] [wait_type],
		s.[is_user_process],
		CASE [dtat].[transaction_type]
			WHEN 1 THEN 'Read/Write'
			WHEN 2 THEN 'Read-Only'
			WHEN 3 THEN 'System'
			WHEN 4 THEN 'Distributed'
			ELSE '#Unknown#'
		END [transaction_scope],		
		CASE [dtat].[transaction_state]
			WHEN 0 THEN 'Initializing'
			WHEN 1 THEN 'Initialized'
			WHEN 2 THEN 'Active'
			WHEN 3 THEN 'Ended (read-only)'
			WHEN 4 THEN 'DTC commit started'
			WHEN 5 THEN 'Awaiting resolution'
			WHEN 6 THEN 'Committed'
			WHEN 7 THEN 'Rolling back...'
			WHEN 8 THEN 'Rolled back'
			ELSE NULL
		END [transaction_state],
		CASE r.transaction_isolation_level 
			WHEN 0 THEN 'Unspecified' 
	        WHEN 1 THEN 'ReadUncomitted' 
	        WHEN 2 THEN 'Readcomitted' 
	        WHEN 3 THEN 'Repeatable' 
	        WHEN 4 THEN 'Serializable' 
	        WHEN 5 THEN 'Snapshot' 
			ELSE NULL
		END [isolation_level],
		CASE WHEN dtst.is_user_transaction = 1 THEN 'EXPLICIT' ELSE 'IMPLICIT' END [transaction_type], 
--MKC: This needs a bit more work... 
		--(SELECT MAX(open_tran) FROM sys.sysprocesses p WHERE s.session_id = p.spid) [open_transaction_count], 
		CAST(N'REQUEST' AS sysname) [statement_source],
		r.[sql_handle] [statement_handle], 
		r.plan_handle, 
		r.statement_start_offset, 
		r.statement_end_offset
	INTO 
		#core
	FROM 
		sys.[dm_exec_sessions] s 
		INNER JOIN [collisions] c ON s.[session_id] = c.[session_id]
		LEFT OUTER JOIN sys.[dm_exec_requests] r ON s.[session_id] = r.[session_id]
		LEFT OUTER JOIN sys.dm_tran_session_transactions dtst ON r.session_id = dtst.session_id
		LEFT OUTER JOIN sys.dm_tran_active_transactions dtat ON dtst.transaction_id = dtat.transaction_id;

	IF @ExcludeFullTextCollisions = 1 BEGIN 
		DELETE FROM [#core]
		WHERE [command] LIKE 'FT%';
	END;

	IF @TargetDatabases <> N'{ALL}' BEGIN
		
		DECLARE @dbNames table ( 
			[database_name] sysname NOT NULL 
		); 
		
		INSERT INTO @dbNames ([database_name])
		EXEC dbo.list_databases 
			@Targets = @TargetDatabases, 
			@ExcludeSecondaries = 1, 
			@ExcludeReadOnly = 1;

		DELETE FROM #core 
		WHERE 
			database_id NOT IN (SELECT database_id FROM sys.databases WHERE [name] IN (SELECT [database_name] FROM @dbNames));
	END; 

	-- HACK: roll this logic up into the parent query (if the perf is better) ... sometime when it's not 2AM and I'm not working in a hotel...	
	DELETE FROM #core 
	WHERE 
		session_id IS NULL
		OR (blocking_session_id IS NULL AND session_id NOT IN (
			SELECT blocking_session_id FROM #core WHERE blocking_session_id IS NOT NULL AND blocking_session_id <> 0
			)
		);

	--NOTE: this is part of both the PROBLEM... and the hack above:
	UPDATE #core SET blocking_session_id = 0 WHERE blocking_session_id IS NULL;	

	--NOTE: this is no longer a hack, there's just something stupid going on with my core/main CTEs and 'collisions' detection logic... it's returning 'false' positives
	--			likely due to the fact that I'm being a moron with regards to NULLs and ISNULL(x, 0) and so on... 
	--		at any rate the hack continues: 
	--			(or, in other words, pretend this is TDD.. the code in this sproc is red/green .. done but needs a MAJOR refactor (to make it less ugly/tedious/perf-heavy).
	DELETE FROM #core WHERE blocking_session_id = 0 AND blocked_session_id NOT IN (SELECT blocking_session_id FROM #core);

	IF NOT EXISTS(SELECT NULL FROM [#core]) BEGIN
		RETURN 0; -- short-circuit.
	END;

	-- populate sql_handles for sessions without current requests: 
	UPDATE c 
	SET 
		c.statement_handle = x.[most_recent_sql_handle],
		c.statement_source = N'CONNECTION'
	FROM 
		#core c 
		LEFT OUTER JOIN sys.[dm_exec_connections] x ON c.session_id = x.[most_recent_session_id]
	WHERE 
		c.statement_handle IS NULL;

	--------------------------------------------------------
	-- Extract Statements: 
	SELECT 
		c.[session_id], 
		c.[statement_source], 
		t.[text] [statement]
	INTO 
		#statements 
	FROM 
		#core c 
		OUTER APPLY sys.[dm_exec_sql_text](c.[statement_handle]) t;
	
	IF @UseInputBuffer = 1 BEGIN
		
		DECLARE @sql nvarchar(MAX); 

		DECLARE filler CURSOR LOCAL FAST_FORWARD READ_ONLY FOR 
		SELECT 
			session_id 
		FROM 
			[#statements] 
		WHERE 
			[statement] IS NULL; 

		DECLARE @spid int; 
		DECLARE @bufferStatement nvarchar(MAX);

		CREATE TABLE #inputbuffer (EventType nvarchar(30), Params smallint, EventInfo nvarchar(4000))

		OPEN filler; 
		FETCH NEXT FROM filler INTO @spid;

		WHILE @@FETCH_STATUS = 0 BEGIN 
			TRUNCATE TABLE [#inputbuffer];

			SET @sql = N'EXEC DBCC INPUTBUFFER(' + STR(@spid) + N');';
			
			BEGIN TRY 
				INSERT INTO [#inputbuffer]
				EXEC @sql;

				SET @bufferStatement = (SELECT TOP (1) EventInfo FROM [#inputbuffer]);
			END TRY 
			BEGIN CATCH 
				SET @bufferStatement = N'#Error Extracting Statement from DBCC INPUTBUFFER();';
			END CATCH

			UPDATE [#statements] 
			SET 
				[statement_source] = N'BUFFER', 
				[statement] = @bufferStatement 
			WHERE 
				[session_id] = @spid;

			FETCH NEXT FROM filler INTO @spid;
		END;
		
		CLOSE filler; 
		DEALLOCATE filler;

	END;

	IF @IncludePlans = 1 BEGIN 
		
		SELECT 
			c.[session_id], 
			p.[query_plan]
		INTO 
			#plans
		FROM 
			[#core] c 
			OUTER APPLY sys.[dm_exec_query_plan](c.[plan_handle]) p;
	END; 

	IF @IncludeContext = 1 BEGIN; 
		
		SELECT 
			c.[session_id], 
			(
				SELECT 
					[c].[statement_source],
					[c].[statement_handle],
					[c].[plan_handle],
					[c].[statement_start_offset],
					[c].[statement_end_offset],
					[c].[statement_source],	
					[s].[login_name], 
					[s].[host_name], 
					[s].[program_name], 
					[s].[host_process_id]
				FROM 
					#core c2 
					LEFT OUTER JOIN sys.[dm_exec_sessions] s ON c2.[session_id] = [s].[session_id]
				WHERE 
					c2.[session_id] = c.[session_id]
				FOR 
					XML PATH('context')
			) [context]
		INTO 
			#context
		FROM 
			#core  c;
	END;
	
	-------------------------------------------
	-- Generate Blocking Chains: 
	WITH chainedSessions AS ( 
		
		SELECT 
			0 [level], 
			session_id, 
			blocking_session_id, 
			blocked_session_id,
			CAST((N' ' + CHAR(187) + N' ' + CAST([blocked_session_id] AS sysname)) AS nvarchar(400)) [blocking_chain]
		FROM 
			#core 
		WHERE 
			[blocking_session_id] = 0 -- anchor to root... 

		UNION ALL 

		SELECT 
			([x].[level] + 1) [level], 
			c.session_id, 
			c.[blocking_session_id], 
			c.[blocked_session_id],
			CAST((x.[blocking_chain] + N' > ' + CAST(c.[blocked_session_id] AS sysname)) AS nvarchar(400)) [blocking_chain]
		FROM 
			[#core] c
			INNER JOIN [chainedSessions] x ON [c].[blocking_session_id] = x.blocked_session_id
	)

	SELECT 
		[session_id], 
		[level],
		[blocking_chain]
	INTO 
		#chain 
	FROM 
		[chainedSessions]
	ORDER BY 
		[level], [session_id];

	DECLARE @finalProjection nvarchar(MAX);

	SET @finalProjection = N'
	SELECT 
		CASE WHEN ISNULL(c.[database_id], 0) = 0 THEN ''resourcedb'' ELSE DB_NAME(c.[database_id]) END [database],
		[x].[blocking_chain],
        CASE WHEN c.[blocking_session_id] = 0 THEN N'' - '' ELSE REPLICATE(''   '', x.[level]) + CAST([c].[blocking_session_id] AS sysname) END [blocking_session_id],
        REPLICATE(''   '', x.[level]) + CAST(([c].[blocked_session_id]) AS sysname) [session_id],
        [c].[command],
        [c].[status],
        RTRIM(LTRIM([s].[statement])) [statement],
		[c].[wait_time],
		[c].[wait_type],
		[c].[wait_resource],
	
		CASE WHEN c.[total_elapsed_time] IS NOT NULL THEN dbo.format_timespan([c].[total_elapsed_time]) ELSE CASE WHEN c.[last_request_start_time] IS NOT NULL AND DATEDIFF(DAY, c.[last_request_start_time], GETDATE()) < 20 THEN dbo.format_timespan(DATEDIFF(MILLISECOND, c.[last_request_start_time], GETDATE())) ELSE ''> 20 days'' END END [duration],
		
		CASE WHEN [c].[is_user_process] = 1 THEN 0 ELSE 1 END [is_system],
        ISNULL([c].[transaction_scope], '') [transaction_scope],
        ISNULL([c].[transaction_state], N'') [transaction_state],
        [c].[isolation_level],
        [c].[transaction_type]
		{context}
		{query_plan}
	FROM 
		[#core] c 
		LEFT OUTER JOIN #chain x ON [c].[session_id] = [x].[session_id]
		LEFT OUTER JOIN [#context] cx ON [c].[session_id] = [cx].[session_id]
		LEFT OUTER JOIN [#statements] s ON c.[session_id] = s.[session_id]{plans_join}
	ORDER BY 
		x.level, c.total_elapsed_time DESC;
	';

	IF @IncludeContext = 1
		SET @finalProjection = REPLACE(@finalProjection, N'{context}', N' ,CAST(cx.[context] AS xml) [context] ');
	ELSE 
		SET @finalProjection = REPLACE(@finalProjection, N'{context}', N'');

	IF @IncludePlans = 1 BEGIN
		SET @finalProjection = REPLACE(@finalProjection, N'{query_plan}', N' ,[p].[query_plan] ');
		SET @finalProjection = REPLACE(@finalProjection, N'{plans_join}', NCHAR(13) + NCHAR(10) + NCHAR(9) + N'LEFT OUTER JOIN [#plans] p ON [c].[session_id] = [p].[session_id]');
	  END;
	ELSE BEGIN 
		SET @finalProjection = REPLACE(@finalProjection, N'{query_plan}', N'');
		SET @finalProjection = REPLACE(@finalProjection, N'{plans_join}', N'');
	END;

	-- final projection:
	EXEC sp_executesql @finalProjection;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_cpu_history','P') IS NOT NULL
	DROP PROC dbo.[list_cpu_history];
GO

CREATE PROC dbo.[list_cpu_history]
	@LastNMinutesOnly					int				= 256,				-- default to max allowable
	@SerializedOutput					xml				= N'<default/>'	    OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @LastNMinutesOnly = ISNULL(@LastNMinutesOnly, 256); 

	IF @LastNMinutesOnly > 256 OR @LastNMinutesOnly < 1 BEGIN 
		RAISERROR('@LastNMinutesOnly must be >= 1 minute and < 256 minutes. Leave NULL for default of 256 minutes.', 16, 1);
		RETURN -1;
	END;

	-- https://troubleshootingsql.com/2009/12/30/how-to-find-out-the-cpu-usage-information-for-the-sql-server-process-using-ring-buffers/
	DECLARE @ticksSinceServerStart bigint = (SELECT [cpu_ticks] / ([cpu_ticks] / [ms_ticks]) FROM [sys].[dm_os_sys_info] WITH (NOLOCK));
	DECLARE @now datetime = GETDATE();

	WITH core AS ( 
		SELECT TOP(@LastNMinutesOnly) 
			[timestamp], 
			CAST([record] AS xml) [record]
		FROM 
			sys.[dm_os_ring_buffers] WITH(NOLOCK)
		WHERE 
			[ring_buffer_type] = N'RING_BUFFER_SCHEDULER_MONITOR'
		ORDER BY 
			[timestamp] DESC

	), 
	extracted AS ( 
		SELECT 
			DATEADD(MILLISECOND, -1 * (@ticksSinceServerStart - [timestamp]), @now) [timestamp],
			[record].value(N'(./Record/@id)[1]', N'int') [record_id],
			[record].value(N'(./Record/SchedulerMonitorEvent/SystemHealth/SystemIdle)[1]', N'int') [system_idle],
			[record].value(N'(./Record/SchedulerMonitorEvent/SystemHealth/ProcessUtilization)[1]', N'int') [sql_usage]
		FROM 
			core
	)
		
	SELECT 
		DATEADD(MINUTE, DATEDIFF(MINUTE, 0, [timestamp]), 0) [timestamp],
		[record_id],
		[system_idle],
		[sql_usage]
	INTO 
		[#raw_results]
	FROM 
		[extracted];

	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- if @SerializedOutput has been EXPLICITLY initialized as NULL/empty... then REPLY... 

		SELECT @SerializedOutput = (
		SELECT 
			[timestamp],
			[sql_usage] [sql_cpu_usage],
			100 - [sql_usage] - [system_idle] [other_process_usage],
			[system_idle]
		FROM 
			[#raw_results] 
		ORDER BY 
			[record_id]
		FOR XML PATH('entry'), ROOT('history'));
		
		RETURN 0;
	END;

    -- otherwise (if we're still here) ... PROJECT:
	SELECT 
		[timestamp],
		[sql_usage] [sql_cpu_usage],
		N'' [ ],
		100 - [sql_usage] - [system_idle] [other_process_usage],
		[system_idle]
	FROM 
		[#raw_results] 
	WHERE 
		[sql_usage] IS NOT NULL -- hack
	ORDER BY 
		[timestamp] DESC;

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Migration
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_sourcedb_migration_template','P') IS NOT NULL
	DROP PROC dbo.[script_sourcedb_migration_template];
GO

CREATE PROC dbo.[script_sourcedb_migration_template]
	@SourceDatabase					sysname				= NULL, 
	@FinalBackupType				sysname				= N'LOG',			-- { FULL | DIFF | LOG }
	@IncludeSanityMarker			bit					= 1, 
	@SingleUserRollbackSeconds		int					= 5,
	@BackupDirectory				nvarchar(2000)		= N'{DEFAULT}', 
	@CopyToBackupDirectory			nvarchar(2000)		= NULL,
	@OffSiteBackupPath				nvarchar(2000)		= NULL,
	@BackupRetention				sysname				= N'30 days',		
	@CopyToRetention				sysname				= N'30 days', 
	@OffSiteRetention				sysname				= N'30 days',
	@EncryptionCertName				sysname				= NULL,
	@FileMarker						sysname				= N'FINAL_BACKUP', 
	@OperatorName					sysname				= N'Alerts',
	@MailProfileName				sysname				= N'General',
	@EmailSubjectPrefix				nvarchar(50)		= N'[Migration Backup] '
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @SourceDatabase = NULLIF(@SourceDatabase, N'');
	SET @FinalBackupType = ISNULL(NULLIF(@FinalBackupType, N''), N'LOG');
	SET @IncludeSanityMarker = ISNULL(@IncludeSanityMarker, 1);
	SET @SingleUserRollbackSeconds = ISNULL(@SingleUserRollbackSeconds, 5);
	SET @BackupDirectory = ISNULL(@BackupDirectory, N'{DEFAULT}');
	
	SET @CopyToBackupDirectory = NULLIF(@CopyToBackupDirectory, N'');
	SET @OffSiteBackupPath = NULLIF(@OffSiteBackupPath, N'');

	SET @BackupRetention = ISNULL(@BackupRetention, N'30 days');
	SET @CopyToRetention = NULLIF(@CopyToRetention, N'');
	SET @OffSiteRetention = NULLIF(@OffSiteRetention, N'');

	SET @EncryptionCertName = NULLIF(@EncryptionCertName, N'');
	SET @FileMarker = ISNULL(NULLIF(@FileMarker, N''), N'FINAL');

	SET @OperatorName = NULLIF(@OperatorName, N'');
	SET @MailProfileName = NULLIF(@MailProfileName, N'');
	SET @EmailSubjectPrefix = ISNULL(@EmailSubjectPrefix, N'[Migraton Backup] ');
	
	IF @SourceDatabase IS NULL BEGIN 
		RAISERROR(N'@SourceDatabase cannot be NULL or empty.', 16, 1);
		RETURN -2;
	END;

	IF @BackupDirectory IS NULL BEGIN
		RAISERROR(N'@BackupDirectory cannot be NULL or empty. Please specify a valid backup directory or the token {DEFAULT}.', 16, 1);
		RETURN -4;
	END;

	IF UPPER(@FinalBackupType) NOT IN (N'FULL', N'DIFF', N'LOG') BEGIN 
		RAISERROR('Allowed values for @FinalBackupType are { FULL | DIFF | LOG }.', 16, 1);
		RETURN -5;
	END;

	IF UPPER(@BackupDirectory) = N'{DEFAULT}' BEGIN
		SELECT @BackupDirectory = dbo.load_default_path('BACKUP');
	END;

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);

	IF @IncludeSanityMarker = 1 BEGIN

		PRINT N'-----------------------------------------------------------------------------------------------------------------------------------------------------
-- Sanity-Marker Table:
-----------------------------------------------------------------------------------------------------------------------------------------------------';
		PRINT N'USE [' + @SourceDatabase + N'];
GO

IF OBJECT_ID(N''dbo.[___migrationMarker]'', N''U'') IS NOT NULL DROP TABLE dbo.[___migrationMarker];

CREATE TABLE dbo.[___migrationMarker] (
	[data] sysname NULL
); 

INSERT INTO [___migrationMarker] ([data]) SELECT CONCAT(''TimeStamp: '', CONVERT(sysname, GETDATE(), 113));

SELECT * FROM [___migrationMarker];
GO 

USE [master];
GO

';

	END;

	DECLARE @sql nvarchar(MAX) = N'USE [master]; -- Attempting to execute from within [{database_name}] will create realllllly ugly locking problems.
GO

EXEC [admindb].dbo.[backup_databases]
	@BackupType = N''{backup_type}'',
	@DatabasesToBackup = N''{database_name}'',
	@BackupDirectory = N''{backup_directory}'',{copy_to}{offsite_to}
	@BackupRetention = N''{backup_retention}'',{copy_to_retention}{offsite_retention}
	@RemoveFilesBeforeBackup = 0,{encryption}
--	@AddServerNameToSystemBackupPath = 0,
	@Directives = N''{directives}'',  -- FINAL (backup) : <file_name_marker> : <set_single_user_rollback_seconds>
	@LogSuccessfulOutcomes = 1,{operator}{profile}{subject}
	@PrintOnly = 0; ';

	SET @sql = REPLACE(@sql, N'{backup_type}', @FinalBackupType);
	SET @sql = REPLACE(@sql, N'{database_name}', @SourceDatabase);
	SET @sql = REPLACE(@sql, N'{backup_directory}', @BackupDirectory);
	SET @sql = REPLACE(@sql, N'{backup_retention}', @BackupRetention);
	SET @sql = REPLACE(@sql, N'{marker}', @FileMarker);
	SET @sql = REPLACE(@sql, N'{directives}', N'FINAL:' + @FileMarker + N':' + CAST(@SingleUserRollbackSeconds AS sysname));

	IF @CopyToBackupDirectory IS NOT NULL BEGIN 
		SET @sql = REPLACE(@sql, N'{copy_to}',  @crlf + @tab + N'@CopyToBackupDirectory = N''' + @CopyToBackupDirectory + N''', ');
		SET @sql = REPLACE(@sql, N'{copy_to_retention}',  @crlf + @tab + N'@CopyToRetention = N''' + @CopyToRetention + N''', ');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{copy_to}', N'');
		SET @sql = REPLACE(@sql, N'{copy_to_retention}', N'');
	END;

	IF @OffSiteBackupPath IS NOT NULL BEGIN 
		SET @sql = REPLACE(@sql, N'{offsite_to}',  @crlf + @tab + N'@OffSiteBackupPath = N''' + @OffSiteBackupPath + N''',');
		SET @sql = REPLACE(@sql, N'{offsite_retention}',  @crlf + @tab + N'@OffSiteRetention = N''' + @OffSiteRetention + N''', ');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{offsite_to}', N'');
		SET @sql = REPLACE(@sql, N'{offsite_retention}', N'');
	END;

	IF @EncryptionCertName IS NOT NULL BEGIN 
		SET @sql = REPLACE(@sql, N'{encryption}',  @crlf + @tab + N'@EncryptionCertName = N''' + @EncryptionCertName + N''',' + @crlf + @tab + N'@EncryptionAlgorithm = N''AES_256'', ');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{encryption}', N'');
	END;

	IF NULLIF(@OperatorName, N'Alerts') IS NOT NULL BEGIN 
		SET @sql = REPLACE(@sql, N'{operator}', @crlf + @tab + N'@OperatorName = N''' + @OperatorName + N''',');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{operator}', N'');
	END;

	IF NULLIF(@MailProfileName, N'General') IS NOT NULL BEGIN 
		SET @sql = REPLACE(@sql, N'{profile}', @crlf + @tab + N'@MailProfileName = N''' + @MailProfileName + N''',');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{profile}', N'');
	END;

	IF @EmailSubjectPrefix IS NOT NULL BEGIN 
		SET @sql = REPLACE(@sql, N'{subject}', @crlf + N'--' + @tab + N'@EmailSubjectPrefix = N''' + @EmailSubjectPrefix  + N''',');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{subject}', N'');
	END;

	PRINT N'-----------------------------------------------------------------------------------------------------------------------------------------------------
-- Final Backup (SINGLE_USER) + OFFLINE:
----------------------------------------------------------------------------------------------------------------------------------------------------- ';

	EXEC [admindb].dbo.[print_long_string] @sql;

	PRINT N'GO';

	RETURN 0;
GO	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_targetdb_migration_template','P') IS NOT NULL
	DROP PROC dbo.[script_targetdb_migration_template];
GO

CREATE PROC dbo.[script_targetdb_migration_template]
	@TargetDatabase					sysname				= NULL, 
	@TargetCompatLevel				sysname				= N'{LATEST}',			-- { {LATEST} | 150 | 140 | 130 | 120 } 
	@CheckSanityMarker				bit					= 1, 
	--@EnableBroker					sysname				= NULL, -- ' ... steps/modes to enable broker here - and integrate those into RECOVERY... 
	@UpdateStatistics				bit					= 1, 
	@CheckForOrphans				bit					= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @TargetDatabase = NULLIF(@TargetDatabase, N'');
	SET @TargetCompatLevel = ISNULL(NULLIF(@TargetCompatLevel, N''), N'{LATEST}');

	SET @CheckSanityMarker = ISNULL(@CheckSanityMarker, 1);

	SET @UpdateStatistics = ISNULL(@UpdateStatistics, 1);
	SET @CheckForOrphans = ISNULL(@CheckForOrphans, 1);

	IF @TargetDatabase IS NULL BEGIN 
		RAISERROR(N'@TargetDatabase cannot be NULL or empty.', 16, 1);
		RETURN -2;
	END;

	IF UPPER(@TargetCompatLevel) = N'{LATEST}' BEGIN
		DECLARE @output decimal(4,2) = (SELECT admindb.dbo.[get_engine_version]());
		IF @output = 10.50 SET @output = 10.00; 

		SET @TargetCompatLevel = LEFT(REPLACE(CAST(@output AS sysname), N'.', N''), 3);
	END;

	PRINT '------------------------------------------------------------------------	
-- Execute RECOVERY if/as needed: 
USE [master];
GO


IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = N''' + @TargetDatabase + N''' AND [state_desc] = N''RESTORING'') BEGIN
	RESTORE DATABASE [' + @TargetDatabase + N'] WITH RECOVERY;
END;
GO


ALTER DATABASE [' + @TargetDatabase + N'] SET COMPATIBILITY_LEVEL = ' + @TargetCompatLevel + N'; 
GO

ALTER DATABASE [' + @TargetDatabase + N'] SET MULTI_USER;
GO

ALTER AUTHORIZATION ON DATABASE::[' + @TargetDatabase + N'] TO sa;
GO

IF EXISTS (SELECT NULL FROM sys.databases WHERE [name] = N''' + @TargetDatabase + ''' AND [target_recovery_time_in_seconds] = 0) BEGIN 
	ALTER DATABASE [' + @TargetDatabase + N'] SET TARGET_RECOVERY_TIME = 60 SECONDS;
END;
GO

ALTER DATABASE [' + @TargetDatabase + N'] SET PAGE_VERIFY CHECKSUM;
GO

------------------------------------------------------------------------
-- NOTE/TODO: 
--		Address CDC, REPL, BROKER, TRUSTWORTHY and any other directives necessary. (NOTE THAT SOME OF THESE SHOULD BE ADDRESSED during RECOVERY process... 

';

	IF @CheckSanityMarker = 1 BEGIN
		PRINT N'

------------------------------------------------------------------------
-- Check for Sanity Table:
SELECT * FROM [' + @TargetDatabase + N']..[___migrationMarker];
GO 		
';


	END;


	IF @CheckForOrphans = 1 BEGIN 

		PRINT N'------------------------------------------------------------------------
-- Check for Orphans: 
EXEC [' + @TargetDatabase + N']..sp_change_users_login ''Report'';
GO

';

	END; 


	IF @UpdateStatistics = 1 BEGIN 

		PRINT N'------------------------------------------------------------------------
EXEC [' + @TargetDatabase + N']..sp_updatestats;
GO

';

	END;

	PRINT N'------------------------------------------------------------------------
-- TODO: Kick off FULL backups, enable jobs, etc. 

';


	IF @CheckSanityMarker = 1 BEGIN

		PRINT N'------------------------------------------------------------------------
-- DROP Sanity Marker Table: 
USE [' + @TargetDatabase + N'];
GO

IF OBJECT_ID(N''dbo.[___migrationMarker]'', N''U'') IS NOT NULL BEGIN
	DROP TABLE dbo.[___migrationMarker];
END;
';

	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.disable_and_script_job_states','P') IS NOT NULL
	DROP PROC dbo.[disable_and_script_job_states];
GO

CREATE PROC dbo.[disable_and_script_job_states]
	@ExcludedJobs				nvarchar(MAX)	= NULL, 
	@SummarizeExcludedJobs		bit				= 1,
	@ScriptDirectives			sysname			= N'ENABLE_AND_DISABLE',	-- { ENABLE | ENABLE_AND_DISABLE }
	@PrintOnly					bit				= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ExcludedJobs = NULLIF(@ExcludedJobs, N'');
	SET @ScriptDirectives = UPPER(ISNULL(NULLIF(@ScriptDirectives, N''), N'ENABLE_AND_DISABLE'));;

	DECLARE @exclusions table (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[job_name] sysname NOT NULL
	); 

	IF @ExcludedJobs IS NOT NULL BEGIN 
		INSERT INTO @exclusions (
			[job_name]
		)
		SELECT [result] FROM [admindb].[dbo].[split_string](@ExcludedJobs, N',', 1) ORDER BY [row_id];
	END;

	SELECT 
		[j].[name], 
		[j].[job_id],
		[j].[enabled],
		CASE WHEN [x].[job_name] IS NULL THEN 0 ELSE 1 END [excluded]
	INTO 
		#jobStates
	FROM 
		[msdb].dbo.[sysjobs] [j]
		LEFT OUTER JOIN @exclusions [x] ON [j].[name] LIKE [x].[job_name]
	ORDER BY 
		[j].[name];


	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @enabled nchar(3) = N'[+]';
	DECLARE @disabled nchar(3) = N'[_]';
	DECLARE @ignoredEnabled nchar(3) = N'[*]';
	DECLARE @ignoredDisabled nchar(3) = N'[.]';

	PRINT N'-----------------------------------------------------------------------------------------------------------------------------------------------------';
	PRINT N'-- PRE-CHANGE JOB STATES:  ' + @disabled + N' = disabled, ' + @enabled + N' = enabled ';
	PRINT N'-----------------------------------------------------------------------------------------------------------------------------------------------------';

	DECLARE @summary nvarchar(MAX) = N'';

	SELECT 
		@summary = @summary + CASE WHEN [enabled] = 1 THEN @enabled ELSE @disabled END + N' - ' + [name] + @crlf
	FROM 
		[#jobStates] 
	WHERE 
		[excluded] = 0 
	ORDER BY 
		[name];

	EXEC [dbo].[print_long_string] @summary;

	IF @SummarizeExcludedJobs = 1 BEGIN 
		IF EXISTS (SELECT NULL FROM [#jobStates] WHERE [excluded] = 1) BEGIN 

			PRINT @crlf;
			PRINT N'--------------------------------------------------------------------------------';
			PRINT N'-- IGNORED JOBS STATES: ' + @ignoredDisabled + N' = disabled (ignored), ' + @ignoredEnabled + N' = enabled (ignored)';
			PRINT N'--------------------------------------------------------------------------------';
			SET @summary = N'';

			SELECT 
				@summary = @summary + CASE WHEN [enabled] = 1 THEN @ignoredEnabled ELSE @ignoredDisabled END + N' - ' + [name] + @crlf
			FROM 
				[#jobStates] 
			WHERE 
				[excluded] = 1 
			ORDER BY 
				[name];

			EXEC dbo.[print_long_string] @summary;
		END;
	END;

	PRINT @crlf;
	PRINT N'---------------------------------------------------------------------------------------------------------------------';
	PRINT N'-- RE-ENABLE' + CASE @ScriptDirectives WHEN N'ENABLE_AND_DISABLE' THEN ' + RE-DISABLE' ELSE N'' END + N' DIRECTIVES: ';
	PRINT N'---------------------------------------------------------------------------------------------------------------------';

	DECLARE @enablingTemplate nvarchar(MAX) = N'
-- Enabling Job [{job_name}]. State When Scripted: ENABLED, JobID: [{job_id}]. Generated: [{timestamp}]
EXEC msdb.dbo.sp_update_job
	@job_name = N''{job_name}'', 
	@enabled = 1;
GO
';

	DECLARE @disablingTemplate nvarchar(MAX) = N'
-- Disabling Job [{job_name}]. State When Scripted: DISABLED, JobID: [{job_id}]. Generated: [{timestamp}]
EXEC msdb.dbo.sp_update_job
	@job_name = N''{job_name}'', 
	@enabled = 0;
GO
';

	DECLARE @sql nvarchar(MAX) = N'';
	DECLARE @jobName sysname, @jobId uniqueidentifier, @jobEnabled bit;

	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[name],
		[job_id],
		[enabled]
	FROM 
		[#jobStates] 
	WHERE 
		[excluded] = 0 
	ORDER BY 
		[name];
	
	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @jobName, @jobId, @jobEnabled;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
	
		IF @jobEnabled = 1 BEGIN 
			SET @sql = REPLACE(@enablingTemplate, N'{job_name}', @jobName);
			SET @sql = REPLACE(@sql, N'{timestamp}', CONVERT(sysname, GETDATE(), 120));
			SET @sql = REPLACE(@sql, N'{job_id}', @jobId);

			PRINT @sql;

		  END; 
		ELSE BEGIN 
			IF @ScriptDirectives = N'ENABLE_AND_DISABLE' BEGIN
				SET @sql = REPLACE(@disablingTemplate, N'{job_name}', @jobName);
				SET @sql = REPLACE(@sql, N'{timestamp}', CONVERT(sysname, GETDATE(), 120));
				SET @sql = REPLACE(@sql, N'{job_id}', @jobId);

				PRINT @sql;				
			END;
		END;
	
		FETCH NEXT FROM [walker] INTO @jobName, @jobId, @jobEnabled;
	END;
	
	CLOSE [walker];
	DEALLOCATE [walker];

	PRINT @crlf;

	IF @PrintOnly = 1 BEGIN 
		PRINT N'---------------------------------------------------------------------------------------------------------------------';
		PRINT N'-- @PrintOnly = 1.  Printing DISABLE commands (vs executing)...';
		PRINT N'---------------------------------------------------------------------------------------------------------------------';		
	END;

	DECLARE [disabler] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[job_id], [name]
	FROM 
		[#jobStates] 
	WHERE 
		[excluded] = 0 
		AND [enabled] = 1 
	ORDER BY 
		[name];
	
	OPEN [disabler];
	FETCH NEXT FROM [disabler] INTO @jobId, @jobName;

	WHILE @@FETCH_STATUS = 0 BEGIN
	
		IF @PrintOnly = 1 BEGIN 
			PRINT N'-- DISABLE JOB: ' + @jobName + N'.';
			PRINT 'EXEC msdb..sp_update_job @job_id = ''' + CAST(@jobId AS sysname) + N''', @enabled = 0; ';
			PRINT N'GO';
			PRINT N'';
		  END;
		ELSE BEGIN 
			EXEC [msdb]..[sp_update_job]
				@job_id = @jobId,
				@enabled = 0;
		END;
	
		FETCH NEXT FROM [disabler] INTO @jobId, @jobName;
	END;
	
	CLOSE [disabler];
	DEALLOCATE [disabler];
	
	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.disable_and_script_logins','P') IS NOT NULL
	DROP PROC dbo.[disable_and_script_logins];
GO

CREATE PROC dbo.[disable_and_script_logins]
	@ExcludeSaLogin					bit				= 1, 
	@ExcludeAllSysAdminMembers		bit				= 0,
	@ExcludeMS##Logins				bit				= 1,
	@ExcludedLogins					nvarchar(MAX)	= NULL, 
	@SummarizeExcludedLogins		bit				= 1,
	@ScriptDirectives				sysname			= N'ENABLE_AND_DISABLE',	-- { ENABLE | ENABLE_AND_DISABLE }
	@PrintOnly						bit				= 0

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');
	SET @ScriptDirectives = UPPER(ISNULL(NULLIF(@ScriptDirectives, N''), N'ENABLE_AND_DISABLE'));

	DECLARE @exclusions table (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[login_name] sysname NOT NULL 
	); 

	IF @ExcludeAllSysAdminMembers = 1 BEGIN 
		INSERT INTO @exclusions ([login_name])
		SELECT
			[sp].[name] [login_name]
		FROM
			[sys].[server_principals] [sp],
			[sys].[server_role_members] [rm],
			[sys].[server_principals] [r]
		WHERE
			[sp].[principal_id] = [rm].[member_principal_id] AND [r].[principal_id] = [rm].[role_principal_id] AND LOWER([r].[name]) IN (N'sysadmin')
		ORDER BY
			[r].[name],
			[sp].[name];
	  END;
	ELSE BEGIN 
		IF @ExcludeSaLogin = 1 BEGIN 
			INSERT INTO @exclusions ([login_name]) VALUES (N'sa');
		END;
	END;

	IF @ExcludeMS##Logins = 1 BEGIN 
		INSERT INTO @exclusions ([login_name]) VALUES (N'##MS_%');
	END;

	IF @ExcludedLogins IS NOT NULL BEGIN 
		INSERT INTO @exclusions (
			[login_name]
		)
		SELECT [result] FROM [admindb].[dbo].[split_string](@ExcludedLogins, N',', 1) ORDER BY [row_id];
	END;

	SELECT 
		[p].[name], 
		CASE WHEN [p].[is_disabled] = 1 THEN 0 ELSE 1 END [enabled],
		[p].[sid],
		CASE WHEN [x].[login_name] IS NULL THEN 0 ELSE 1 END [excluded]
	INTO 
		[#loginStates]
	FROM 
		sys.[server_principals] [p]
		LEFT OUTER JOIN @exclusions [x] ON [p].[name] LIKE [x].[login_name]
	WHERE 
		[p].[type] IN ('U', 'S') --,'G')  TODO: fix groups... 
	ORDER BY 
		[p].[name];

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @enabled nchar(3) = N'[+]';
	DECLARE @disabled nchar(3) = N'[_]';
	DECLARE @ignoredEnabled nchar(3) = N'[*]';
	DECLARE @ignoredDisabled nchar(3) = N'[.]';

	PRINT N'-----------------------------------------------------------------------------------------------------------------------------------------------------';
	PRINT N'-- PRE-CHANGE LOGIN STATES:  ' + @disabled + N' = disabled, ' + @enabled + N' = enabled ';
	PRINT N'-----------------------------------------------------------------------------------------------------------------------------------------------------';

	DECLARE @summary nvarchar(MAX) = N'';

	SELECT 
		@summary = @summary + CASE WHEN [enabled] = 1 THEN @enabled ELSE @disabled END + N' - ' + [name] + @crlf
	FROM 
		[#loginStates] 
	WHERE 
		[excluded] = 0 
	ORDER BY 
		[name];

	EXEC [dbo].[print_long_string] @summary;

	IF @SummarizeExcludedLogins = 1 BEGIN 
	
	PRINT @crlf;
			PRINT N'--------------------------------------------------------------------------------';
			PRINT N'-- IGNORED LOGIN STATES: ' + @ignoredDisabled + N' = disabled (ignored), ' + @ignoredEnabled + N' = enabled (ignored)';
			PRINT N'--------------------------------------------------------------------------------';
			SET @summary = N'';

			SELECT 
				@summary = @summary + CASE WHEN [enabled] = 1 THEN @ignoredEnabled ELSE @ignoredDisabled END + N' - ' + [name] + @crlf
			FROM 
				[#loginStates] 
			WHERE 
				[excluded] = 1 
			ORDER BY 
				[name];

			EXEC dbo.[print_long_string] @summary;
	END;

	PRINT @crlf;
	PRINT N'---------------------------------------------------------------------------------------------------------------------';
	PRINT N'-- RE-ENABLE' + CASE @ScriptDirectives WHEN N'ENABLE_AND_DISABLE' THEN ' + RE-DISABLE' ELSE N'' END + N' DIRECTIVES: ';
	PRINT N'---------------------------------------------------------------------------------------------------------------------';

	DECLARE @enablingTemplate nvarchar(MAX) = N'
-- Enabling Login [{login_name}]. State When Scripted: ENABLED. Generated: [{timestamp}]
ALTER LOGIN [{login_name}] ENABLE;
GO
';

	DECLARE @disablingTemplate nvarchar(MAX) = N'
-- Disabling Login [{login_name}]. State When Scripted: DISABLED. Generated: [{timestamp}]
ALTER LOGIN [{login_name}] DISABLE;
GO
';

	DECLARE @sql nvarchar(MAX) = N'';
	DECLARE @loginName sysname, @loginEnabled bit; 

	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[name], 
		[enabled]
	FROM 
		[#loginStates] 
	WHERE 
		[excluded] = 0 
	ORDER BY 
		[name];
	
	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @loginName, @loginEnabled;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
		
		IF @loginEnabled = 1 BEGIN 
			SET @sql = REPLACE(@enablingTemplate, N'{login_name}', @loginName);
			SET @sql = REPLACE(@sql, N'{timestamp}', CONVERT(sysname, GETDATE(), 120));

			PRINT @sql;

		  END; 
		ELSE BEGIN 
			IF @ScriptDirectives = N'ENABLE_AND_DISABLE' BEGIN
				SET @sql = REPLACE(@disablingTemplate, N'{login_name}', @loginName);
				SET @sql = REPLACE(@sql, N'{timestamp}', CONVERT(sysname, GETDATE(), 120));

				PRINT @sql;				
			END;
		END;		
	
		FETCH NEXT FROM [walker] INTO @loginName, @loginEnabled;
	END;
	
	CLOSE [walker];
	DEALLOCATE [walker];

	PRINT @crlf;

	IF @PrintOnly = 1 BEGIN 
		PRINT N'---------------------------------------------------------------------------------------------------------------------';
		PRINT N'-- @PrintOnly = 1.  Printing DISABLE commands (vs executing)...';
		PRINT N'---------------------------------------------------------------------------------------------------------------------';		
	END;

	SET @disablingTemplate = N'ALTER LOGIN [{login_name}] DISABLE; ';

	DECLARE [disabler] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[name]
	FROM 
		[#loginStates] 
	WHERE 
		[excluded] = 0 
		AND [enabled] = 1 
	ORDER BY 
		[name];
	
	OPEN [disabler];
	FETCH NEXT FROM [disabler] INTO @loginName;

	WHILE @@FETCH_STATUS = 0 BEGIN
	
		SET @sql = REPLACE(@disablingTemplate, N'{login_name}', @loginName);

		IF @PrintOnly = 1 BEGIN 
			PRINT N'-- DISABLE LOGIN: ' + @loginName + N'.'
			PRINT @sql;
			PRINT N'GO';
			PRINT N'';
		  END;
		ELSE BEGIN 
			EXEC sp_executesql 
				@sql;
		END;
	
		FETCH NEXT FROM [disabler] INTO @loginName;
	END;
	
	CLOSE [disabler];
	DEALLOCATE [disabler];
	
	RETURN 0; 
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Monitoring
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_backup_execution','P') IS NOT NULL
	DROP PROC dbo.verify_backup_execution;
GO

CREATE PROC dbo.verify_backup_execution 
	@DatabasesToCheck					nvarchar(MAX),
	@DatabasesToExclude					nvarchar(MAX)		= NULL,
	@FullBackupAlertThresholdHours		int, 
	@LogBackupAlertThresholdMinutes		int,
	@MonitoredJobs						nvarchar(MAX)		= NULL, 
	@AllowNonAccessibleSecondaries		bit					= 0,
	@MinimumElapsedSecondsToConsider	int					= 60,   -- if a specified backup job has been running < @MinimumElapsedSecondsToConsider, then there's NO reason to raise an alert. 
	@MaximumElapsedSecondsToIgnore		int					= 300,			-- if a backup job IS running longer than normal, but is STILL under @MaximumElapsedSecondsToIgnore, then there's no reason to raise an alert. 
	@OperatorName						sysname				= N'Alerts',
	@MailProfileName					sysname				= N'General',
	@EmailSubjectPrefix					nvarchar(50)		= N'[Database Backups - Failed Checkups] ', 
	@PrintOnly							bit					= 0
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Inputs: 

	-- Operator Checks:
	IF ISNULL(@OperatorName, '') IS NULL BEGIN
		RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
		RETURN -4;
		END;
	ELSE BEGIN
		IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
			RAISERROR('Invalild Operator Name Specified.', 16, 1);
			RETURN -4;
		END;
	END;

	-- Profile Checks:
	DECLARE @DatabaseMailProfile nvarchar(255);
	EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output';
 
	IF @DatabaseMailProfile != @MailProfileName BEGIN
		RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
		RETURN -5;
	END;

	-----------------------------------------------------------------------------

	DECLARE @outputs table (
		output_id int IDENTITY(1,1) NOT NULL, 
		[type] sysname NOT NULL, -- warning or error 
		[message] nvarchar(MAX)
	);

	DECLARE @errorMessage nvarchar(MAX) = '';

	-----------------------------------------------------------------------------
	-- Determine which databases to check:
	DECLARE @databaseToCheckForFullBackups table (
		[name] sysname NOT NULL
	);

	DECLARE @databaseToCheckForLogBackups table (
		[name] sysname NOT NULL
	);

	INSERT INTO @databaseToCheckForFullBackups ([name])
	EXEC dbo.list_databases 
		@Targets = @DatabasesToCheck,
		@Exclusions = @DatabasesToExclude; 

	INSERT INTO @databaseToCheckForLogBackups ([name])
	EXEC dbo.list_databases 
		@Targets = @DatabasesToCheck,
		@Exclusions = @DatabasesToExclude, 
		@ExcludeSimpleRecovery = 1;

	-----------------------------------------------------------------------------
	-- Determine which jobs to check:
	DECLARE @specifiedJobs table ( 
		jobname sysname NOT NULL
	);

	DECLARE @jobsToCheck table ( 
		jobname sysname NOT NULL, 
		jobid uniqueidentifier NULL
	);

	INSERT INTO @specifiedJobs (jobname)
	SELECT [result] FROM dbo.split_string(@MonitoredJobs, N',', 1) ORDER BY row_id;

	INSERT INTO @jobsToCheck (jobname, jobid)
	SELECT 
		s.jobname, 
		j.job_id [jobid]
	FROM 
		@specifiedJobs s
		LEFT OUTER JOIN msdb..sysjobs j ON s.jobname COLLATE SQL_Latin1_General_CP1_CI_AS = j.[name];

	-----------------------------------------------------------------------------
	-- backup checks:

	BEGIN TRY

		-- FULL Backup Checks: 
		DECLARE @backupStatuses table (
			backup_id int IDENTITY(1,1) NOT NULL,
			[database_name] sysname NOT NULL, 
			[backup_type] sysname NOT NULL, 
			[minutes_since_last_backup] int
		);

		WITH core AS (
			SELECT 
				b.[database_name] COLLATE SQL_Latin1_General_CP1_CI_AS [database_name],
				CASE b.[type] COLLATE SQL_Latin1_General_CP1_CI_AS	
					WHEN 'D' THEN 'FULL'
					WHEN 'I' THEN 'DIFF'
					WHEN 'L' THEN 'LOG'
					ELSE 'OTHER'  -- options include, F, G, P, Q, [NULL] 
				END [backup_type],
				MAX(b.backup_finish_date) [last_completion]
			FROM 
				@databaseToCheckForFullBackups x
				INNER JOIN msdb.dbo.backupset b ON x.[name] = b.[database_name] COLLATE SQL_Latin1_General_CP1_CI_AS
			WHERE
				b.is_damaged = 0
				AND b.has_incomplete_metadata = 0
				AND b.is_copy_only = 0
			GROUP BY 
				b.[database_name]  COLLATE SQL_Latin1_General_CP1_CI_AS, 
				b.[type]  COLLATE SQL_Latin1_General_CP1_CI_AS
		) 
	
		INSERT INTO @backupStatuses ([database_name], backup_type, minutes_since_last_backup)
		SELECT 
			[database_name],
			[backup_type],
			DATEDIFF(MINUTE, last_completion, GETDATE()) [minutes_since_last_backup]
		FROM 
			core
		ORDER BY 
			[core].[database_name];

		-- Grab a list of any dbs that were specified for checkups, but which aren't on the server - then report on those, and use the temp-table for exclusions from subsequent checks:
		DECLARE @phantoms table (
			[name] sysname NOT NULL
		);

		INSERT INTO @phantoms ([name])
		SELECT [name] FROM @databaseToCheckForFullBackups WHERE [name] NOT IN (SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM master.sys.databases WHERE state_desc = 'ONLINE');

		-- Remove non-accessible secondaries (Mirrored or AG'd) as needed/specified:
		IF @AllowNonAccessibleSecondaries = 1 BEGIN

			DECLARE @activeSecondaries table ( 
				[name] sysname NOT NULL
			);

			INSERT INTO @activeSecondaries ([name])
			SELECT [name] FROM master.sys.databases 
			WHERE [name] IN (SELECT d.[name] FROM master.sys.databases d INNER JOIN master.sys.database_mirroring m ON m.database_id = d.database_id WHERE m.mirroring_guid IS NOT NULL AND m.mirroring_role_desc != 'PRINCIPAL' )
			OR [name] IN (
				SELECT d.name 
				FROM master.sys.databases d 
				INNER JOIN sys.dm_hadr_availability_replica_states hars ON d.replica_id = hars.replica_id
				WHERE hars.role_desc != 'PRIMARY'
			); -- grab any dbs that are in an AG where the current role != PRIMARY. 


			-- remove secondaries from any list of CHECKS and from the list of statuses we've pulled back (because evaluation is a comparison of BOTH sides of the union/join of these sets).
			DELETE FROM @backupStatuses WHERE [database_name] IN (SELECT [name] FROM @activeSecondaries);

			DELETE FROM @phantoms WHERE [name] IN (SELECT [name] FROM @activeSecondaries);
			DELETE FROM @databaseToCheckForFullBackups WHERE [name] IN (SELECT [name] FROM @activeSecondaries);
			DELETE FROM @databaseToCheckForLogBackups WHERE [name] IN (SELECT [name] FROM @activeSecondaries);

		END;

		INSERT INTO @outputs ([type], [message])
		SELECT 
			N'WARNING',
			N'Database [' + [name] + N'] was configured for backup checks/verifications - but is NOT currently listed as an ONLINE database on the server.'
		FROM 
			@phantoms
		ORDER BY 
			[name];

		-- Report on databases that were specified for checks, but which have NEVER been backed-up:
		INSERT INTO @outputs ([type], [message])
		SELECT 
			N'WARNING', 
			N'Database [' + [name] + '] has been configured for regular FULL backup checks/verifications - but has NEVER been backed up.'
		FROM 
			@databaseToCheckForFullBackups
		WHERE 
			[name] NOT IN (SELECT [database_name] FROM @backupStatuses WHERE backup_type = 'FULL')
			AND [name] NOT IN (SELECT [name] FROM @phantoms);
		
		-- Report on databases that were specified for checks, but which haven't had FULL backups in > @FullBackupAlertThresholdHours:
		INSERT INTO @outputs ([type], [message])
		SELECT 
			N'WARNING' [type], 
			N'The last successful FULL backup for database [' + [database_name] + N'] was ' + CAST((minutes_since_last_backup / 60) AS sysname) + N' hours (and ' + CAST((minutes_since_last_backup % 60) AS sysname) + N' minutes) ago - which exceeds the currently specified value of ' + CAST(@FullBackupAlertThresholdHours AS sysname) + N' hours for @FullBackupAlertThresholdHours.'
		FROM 
			@backupStatuses
		WHERE 
			backup_type = 'FULL'
			AND minutes_since_last_backup > 60 * @FullBackupAlertThresholdHours
		ORDER BY 
			minutes_since_last_backup DESC;

		-- Report on User DBs specified for checkups that are set to NON-SIMPLE recovery, and which haven't had their T-Logs backed up:
		INSERT INTO @outputs ([type], [message])
		SELECT 
			N'WARNING',
			N'Database [' + [name] + N'] has been configured for regular LOG backup checks/verifiation - but has NEVER had its Transaction Log backed up.'
		FROM 
			@databaseToCheckForLogBackups
		WHERE 
			[name] NOT IN (SELECT [database_name] FROM @backupStatuses WHERE backup_type = 'LOG')
			AND [name] NOT IN (SELECT [name] FROM @phantoms);

		-- Report on databases in NON-SIMPLE recovery mode that haven't had their T-Logs backed up in > @LogBackupAlertThresholdMinutes:
		INSERT INTO @outputs ([type], [message])
		SELECT 
			N'WARNING', 
			N'The last successful Transaction Log backup for database [' + [database_name] + N'] was ' + CAST((minutes_since_last_backup / 60) AS sysname) + N' hours (and ' + CAST((minutes_since_last_backup % 60) AS sysname) + N' minutes) ago - which exceeds the currently specified value of ' + CAST(@LogBackupAlertThresholdMinutes AS sysname) + N' minutes for @LogBackupAlertThresholdMinutes.'
		FROM 
			@backupStatuses
		WHERE 
			backup_type = 'LOG'
			AND minutes_since_last_backup > @LogBackupAlertThresholdMinutes
		ORDER BY 
			minutes_since_last_backup DESC;
	
	END TRY
	BEGIN CATCH
		SELECT @errorMessage = N'Exception during Backup Checks: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']'; 

		INSERT INTO @outputs ([type], [message])
		VALUES ('EXCEPTION', @errorMessage);

		SET @errorMessage = '';
	END CATCH

	-----------------------------------------------------------------------------
	-- job checks:


	IF (SELECT COUNT(*) FROM @jobsToCheck) > 0 BEGIN

		BEGIN TRY
			-- Warn about any jobs specified for checks that aren't actual jobs (i.e., where the names couldn't match a SQL Agent job).
			INSERT INTO @outputs ([type], [message])
			SELECT 
				N'WARNING', 
				N'Job [' + jobname + '] was configured for a regular checkup - but is NOT a VALID SQL Server Agent Job Name.'
			FROM 
				@jobsToCheck 
			WHERE 
				jobid IS NULL
			ORDER BY 
				jobname;

			-- otherwise, make sure that if the job is currently running, it hasn't exceeded 130% of the time it normally takes to run. 
			DECLARE @currentJobName sysname, @currentJobID uniqueidentifier;
			DECLARE @instanceCounts int, @avgRunDuration int;

			DECLARE @isExecuting bit, @elapsed int;
		
			DECLARE checker CURSOR LOCAL FAST_FORWARD FOR 
			SELECT jobname, jobid FROM @jobsToCheck WHERE jobid IS NOT NULL; 

			OPEN checker;
			FETCH NEXT FROM checker INTO @currentJobName, @currentJobID;

			WHILE @@FETCH_STATUS = 0 BEGIN
				SET @isExecuting = 0;
				SET @elapsed = 0;

				WITH core AS ( 
					SELECT job_id, 
						DATEDIFF(SECOND, run_requested_date, GETDATE()) [elapsed] 
					FROM msdb.dbo.sysjobactivity 
					WHERE run_requested_date IS NOT NULL AND stop_execution_date IS NULL
				)

				SELECT 
					@isExecuting = CASE when job_id IS NULL THEN 0 ELSE 1 END, 
					@elapsed = elapsed 
				FROM 
					core
				WHERE 
					job_id = @currentJobID;

				-- 4.2.3.16822 Only check for 'long-running' jobs if a) duration is > @MinimumElapsedSecondsToConsider (i.e., don't alert for a job running 220% over normal IF 220% over normal is, say, 10 seconds TOTAL)
				--		 _AND_ b) if @elapsed is >  @MaximumElapsedSecondsToIgnore - i.e., don't alert if 'total elapsed' time is, say, 3 minutes - who cares...  (in 15 minutes when we run again, IF this job is still running (and that's a problem), THEN we'll get an alert). 
				IF (@isExecuting = 1) AND (@elapsed > @MinimumElapsedSecondsToConsider) AND (@elapsed > @MaximumElapsedSecondsToIgnore) BEGIN	

					-- check on execution durations:
					SELECT 
						@instanceCounts = COUNT(*), 
						@avgRunDuration = AVG(run_duration) 
					FROM (
						SELECT TOP(20)
							run_duration 
						FROM 
							msdb.dbo.sysjobhistory 
						WHERE 
							job_id = @currentJobID
							AND step_id = 0 AND run_status = 1 -- only grab metrics/durations for the ENTIRE duration of (successful only) executions.
						ORDER BY 
							run_date DESC, 
							run_time DESC
						) latest;
				

					IF @instanceCounts < 6 BEGIN 
						-- Arguably, we could send a 'warning' here ... but that's lame. At present, there is NOT a problem - because we don't have enough history to determine if this execution is 'out of scope' or not. 
						--		so, rather than causing false-alarms/red-herrings, just spit out a bit of info into the job history instead.
						PRINT 'History for job [' + @currentJobName + '] only contains information on the last ' + CAST(@instanceCounts AS sysname) + N' executions of the job. Meaning there is not enough history to determine abnormalities.'

				       END;
					ELSE BEGIN

						-- otherwise, if the current execution duration is > 220% of normal execution - raise an alert... 
						IF @elapsed > @avgRunDuration * 2.2 BEGIN
							INSERT INTO @outputs ([type], [message])
							SELECT 
								N'WARNING',
								N'Job [' + @currentJobName + N'] is currently running, and has been running for ' + CAST(@elapsed AS sysname) + N' seconds - which is greater than 220% of the average time it has taken to execute over the last ' + CAST(@instanceCounts AS sysname) + N' executions.'
						END;
					END;
				
				END;

				FETCH NEXT FROM checker INTO @currentJobName, @currentJobID;
			END;


		END TRY
		BEGIN CATCH
			SELECT @errorMessage = N'Exception during Job Checks: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']'; 

			INSERT INTO @outputs ([type], [message])
			VALUES ('EXCEPTION', @errorMessage);			
		END CATCH

		CLOSE checker;
		DEALLOCATE checker;

	END;  -- /IF JobChecks


	IF EXISTS (SELECT NULL FROM @outputs) BEGIN

		DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
		DECLARE @tab nchar(1) = NCHAR(9); 

		DECLARE @message nvarchar(MAX); 
		DECLARE @subject nvarchar(2000);

		IF EXISTS (SELECT NULL FROM @outputs WHERE [type] = 'EXCEPTION') 
			SET @subject = @EmailSubjectPrefix + N' Exceptions Detected';
		ELSE  
			SET @subject = @EmailSubjectPrefix + N' Warnings Detected';

		SET @message = N'The following problems were encountered during execution:' + @crlf + @crlf;

		--MKC: Insane. The following does NOT work. It returns only the LAST row from a multi-row 'set'. (remove the order-by, and ALL results return. Crazy.)
			--SELECT 
			--	@message = @message + @tab + N'[' + [type] + N'] - ' + [message] + @crlf
			--FROM 
			--	@outputs
			--ORDER BY 
			--	CASE WHEN [type] = 'EXCEPTION' THEN 0 ELSE 1 END ASC, output_id ASC;

		-- So, instead of combining 'types' of outputs, i'm just hacking this to concatenate 2x different result 'sets' or types of results. (I could try a CTE + Windowing Function... or .. something else, but this is easiest for now). 
		SELECT 
			@message = @message + @tab + N'[' + [type] + N'] - ' + [message] + @crlf
		FROM 
			@outputs
		WHERE 
			[type] = 'EXCEPTION'
		ORDER BY 
			output_id ASC;

		-- + this:
		SELECT 
			@message = @message + @tab + N'[' + [type] + N'] - ' + [message] + @crlf
		FROM 
			@outputs
		WHERE 
			[type] = 'WARNING'
		ORDER BY 
			output_id ASC;

		IF @PrintOnly = 1 BEGIN
			
			PRINT @subject;
			PRINT @message;

		  END
		ELSE BEGIN 
			EXEC msdb..sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName,
				@subject = @subject, 
				@body = @message;
		END;

	END;

	RETURN 0;
GO


-----------------------------------
USE admindb;
GO

IF OBJECT_ID('dbo.verify_database_configurations','P') IS NOT NULL
	DROP PROC dbo.verify_database_configurations;
GO

CREATE PROC dbo.verify_database_configurations 
	@DatabasesToExclude				nvarchar(MAX)	= NULL,
	@EnableRcsi						bit				= 0,
	@RcsiExclusions					nvarchar(MAX)	= NULL,
	@CompatabilityExclusions		nvarchar(MAX)	= NULL,
	@ReportDatabasesNotOwnedBySA	bit				= 0,
	@OperatorName					sysname			= N'Alerts',
	@MailProfileName				sysname			= N'General',
	@EmailSubjectPrefix				nvarchar(50)	= N'[Database Configuration Alert] ',
	@PrintOnly						bit				= 0
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	SET @RcsiExclusions = NULLIF(@RcsiExclusions, N'');
	SET @DatabasesToExclude = NULLIF(@DatabasesToExclude, N'');
	SET @CompatabilityExclusions = NULLIF(@CompatabilityExclusions, N'');

	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	IF @PrintOnly = 0 BEGIN -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 
		
		-- Operator Checks:
		IF ISNULL(@OperatorName, '') IS NULL BEGIN
			RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
			RETURN -2;
		 END;
		ELSE BEGIN 
			IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
				RAISERROR('Invalild Operator Name Specified.', 16, 1);
				RETURN -2;
			END;
		END;

		-- Profile Checks:
		DECLARE @DatabaseMailProfile nvarchar(255)
		EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output'
 
		IF @DatabaseMailProfile != @MailProfileName BEGIN
			RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
			RETURN -2;
		END; 
	END;

	-----------------------------------------------------------------------------
	-- Set up / initialization:

	-- start by (messily) grabbing the current version on the server:
	DECLARE @serverVersion int;
	SET @serverVersion = (SELECT CAST((LEFT(CAST(SERVERPROPERTY('ProductVersion') AS sysname), CHARINDEX('.', CAST(SERVERPROPERTY('ProductVersion') AS sysname)) - 1)) AS int)) * 10;

	DECLARE @databasesToCheck table (
		[name] sysname
	);
	
	INSERT INTO @databasesToCheck ([name])
	EXEC dbo.list_databases 
		@Targets = N'{USER}',
		@Exclusions = @DatabasesToExclude;

	DECLARE @excludedComptabilityDatabases table ( 
		[name] sysname NOT NULL
	); 

	IF @CompatabilityExclusions IS NOT NULL BEGIN 
		INSERT INTO @excludedComptabilityDatabases ([name])
		SELECT [result] FROM dbo.split_string(@CompatabilityExclusions, N',', 1) ORDER BY row_id;
	END; 

	DECLARE @excludedRcsiDatabases table (
		[name] sysname NOT NULL
	);

	IF @RcsiExclusions IS NOT NULL BEGIN 
		INSERT INTO @excludedRcsiDatabases ([name])
		SELECT [result] FROM dbo.[split_string](@RcsiExclusions, N',', 1);
	END;

	DECLARE @issues table ( 
		issue_id int IDENTITY(1,1) NOT NULL, 
		[database] sysname NOT NULL, 
		issue varchar(2000) NOT NULL, 
		command nvarchar(2000) NOT NULL, 
		success_message varchar(2000) NOT NULL,
		succeeded bit NOT NULL DEFAULT (0),
		[error_message] nvarchar(MAX) NULL 
	);

	DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
	DECLARE @tab char(1) = CHAR(9);

	-----------------------------------------------------------------------------
	-- Checks: 
	
	-- Compatablity Checks: 
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database],
		N'Compatibility should be ' + CAST(@serverVersion AS sysname) + N'. Currently set to ' + CAST(d.[compatibility_level] AS sysname) + N'.' [issue], 
		N'ALTER DATABASE' + QUOTENAME(d.[name]) + N' SET COMPATIBILITY_LEVEL = ' + CAST(@serverVersion AS sysname) + N';' [command], 
		N'Database Compatibility successfully set to ' + CAST(@serverVersion AS sysname) + N'.'  [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
		LEFT OUTER JOIN @excludedComptabilityDatabases e ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS LIKE e.[name] -- allow LIKE %wildcard% exclusions
	WHERE 
		d.[compatibility_level] <> CAST(@serverVersion AS tinyint)
		AND e.[name] IS  NULL -- only include non-exclusions
	ORDER BY 
		d.[name] ;
		
	-- Page Verify: 
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'Page Verify should be set to CHECKSUM. Currently set to ' + ISNULL(page_verify_option_desc, 'NOTHING') + N'.' [issue], 
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET PAGE_VERIFY CHECKSUM; ' [command], 
		N'Page Verify successfully set to CHECKSUM.' [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		page_verify_option_desc <> N'CHECKSUM'
	ORDER BY 
		d.[name];

	-- OwnerChecks:
	IF @ReportDatabasesNotOwnedBySA = 1 BEGIN
		INSERT INTO @issues ([database], [issue], [command], [success_message])
		SELECT 
			d.[name] [database], 
			N'Should be owned by 0x01 (SysAdmin). Currently owned by 0x' + CONVERT(nvarchar(MAX), owner_sid, 2) + N'.' [issue], 
			N'ALTER AUTHORIZATION ON DATABASE::' + QUOTENAME(d.[name]) + N' TO sa;' [command], 
			N'Database owndership successfully transferred to 0x01 (SysAdmin).' [success_message]
		FROM 
			sys.databases d
			INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
		WHERE 
			owner_sid <> 0x01;
	END;

	-- AUTO_CLOSE:
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'AUTO_CLOSE should be DISABLED. Currently ENABLED.' [issue], 
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET AUTO_CLOSE OFF; ' [command], 
		N'AUTO_CLOSE successfully set to DISABLED.' [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		[is_auto_close_on] = 1
	ORDER BY 
		d.[name];

	-- AUTO_SHRINK:
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'AUTO_SHRINK should be DISABLED. Currently ENABLED.' [issue], 
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET AUTO_SHRINK OFF; ' [command], 
		N'AUTO_SHRINK successfully set to DISABLED.' [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		[is_auto_shrink_on] = 1
	ORDER BY 
		d.[name];
		
	-- RCSI: 
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'RCSI should be ' + CASE WHEN @EnableRcsi = 1 THEN N'ENABLED' ELSE N'DISABLED' END + '. Currently ' + CASE WHEN @EnableRcsi = 1 THEN N'DISABLED' ELSE N'ENABLED' END + '.' [issue], 
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET READ_COMMITTED_SNAPSHOT ' + CASE WHEN @EnableRcsi = 1 THEN N'ON' ELSE N'OFF' END + ' WITH ROLLBACK AFTER 2 SECONDS; ' [command], 
		N'RCSI successfully set to ' + CASE WHEN @EnableRcsi = 1 THEN N'ENABLED' ELSE N'DISABLED' END + '.' [success_message]
	FROM 
		sys.databases d 
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
		LEFT OUTER JOIN @excludedRcsiDatabases e ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS LIKE e.[name] -- allow LIKE %wildcard% exclusions
	WHERE 
		[d].[is_read_committed_snapshot_on] <> @EnableRcsi 
		AND e.[name] IS  NULL -- only include non-exclusions
	ORDER BY 
		d.[name];

	-----------------------------------------------------------------------------
	-- add other checks as needed/required per environment:

    -- vNEXT: figure out how to drop these details into a table and/or something that won't 'change' per environment. 
    --          i.e., say that in environment X we NEED to check for ABC... great. we hard code in here for that. 
    --              then S4 vNext comes out, ALTERS this (assuming there were changes) and the logic for ABC checks is overwritten... 



	-----------------------------------------------------------------------------
	-- (attempted) fixes: 
	IF EXISTS (SELECT NULL FROM @issues) BEGIN 

		DECLARE fixer CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[issue_id], 
			[command] 
		FROM 
			@issues 
		ORDER BY [issue_id];

		DECLARE @currentID int;
		DECLARE @currentCommand nvarchar(2000); 
		DECLARE @errorMessage nvarchar(MAX);

		OPEN [fixer];
		FETCH NEXT FROM [fixer] INTO @currentID, @currentCommand;

		WHILE @@FETCH_STATUS = 0 BEGIN 
			
			SET @errorMessage = NULL;

			BEGIN TRY 
                IF @PrintOnly = 0 BEGIN 
				    EXEC sp_executesql @currentCommand;
                END;

                UPDATE @issues SET [succeeded] = 1 WHERE [issue_id] = @currentID;

			END TRY 
			BEGIN CATCH
				SET @errorMessage = CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
				UPDATE @issues SET [error_message] = @errorMessage WHERE [issue_id] = @currentID;
			END CATCH

			FETCH NEXT FROM [fixer] INTO @currentID, @currentCommand;
		END;

		CLOSE [fixer]; 
		DEALLOCATE fixer;

	END;

	-----------------------------------------------------------------------------
	-- reporting: 
	DECLARE @emailBody nvarchar(MAX) = NULL;
	DECLARE @emailSubject nvarchar(300);
	IF EXISTS (SELECT NULL FROM @issues) BEGIN 
		SET @emailBody = N'';
		
		DECLARE @correctionErrorsOccurred bit = 0;
		DECLARE @correctionsCompletedSuccessfully bit = 0; 

		IF EXISTS (SELECT NULL FROM @issues WHERE [succeeded] = 0) BEGIN -- process ERRORS first. 
			SET @correctionErrorsOccurred = 1;
		END; 

		IF EXISTS (SELECT NULL FROM @issues WHERE [succeeded] = 1) BEGIN -- report on successful changes: 
			SET @correctionsCompletedSuccessfully = 1;
		END;

		IF @correctionErrorsOccurred = 1 BEGIN
			SET @emailSubject = @EmailSubjectPrefix + N' - Errors Addressing Database Settings';
			
			IF @correctionsCompletedSuccessfully = 1 
				SET @emailBody = N'Configuration Problems Detected. Some were automatically corrected; Others encountered errors during attempt to correct:' + @crlf + @crlf;
			ELSE 
				SET @emailBody = N'Configuration Problems Detected.' + @crlf + @crlf + UPPER(' Errors encountred while attempting to correct:') + @crlf + @crlf;

			SELECT 
				@emailBody = @emailBody + @tab + QUOTENAME([database]) + N' - ' + [issue] + @crlf
					+ @tab + @tab + N'ATTEMPTED CORRECTION: -> ' + [command] + @crlf
					+ @tab + @tab + @tab + N'ERROR: ' + ISNULL([error_message], N'##Unknown/Uncaptured##') + @crlf + @crlf
			FROM 
				@issues 
			WHERE 
				[succeeded] = 0 
			ORDER BY [issue_id];

		END;

		IF @correctionsCompletedSuccessfully = 1 BEGIN
			SET @emailSubject = @EmailSubjectPrefix + N' - Database Configuration Settings Successfully Updated';

			IF @correctionErrorsOccurred = 1
				SET @emailBody = @emailBody + @crlf + @crlf;

			SET @emailBody = @emailBody + N'The following database configuration changes were successfully applied:' + @crlf + @crlf;

			SELECT 
				@emailBody = @emailBody + @tab + QUOTENAME([database]) + @crlf
				+ @tab + @tab + N'OUTCOME: ' + [success_message] + @crlf + @crlf
				+ @tab + @tab + @tab + @tab + N'Detected Problem: ' + [issue] + @crlf
				+ @tab + @tab + @tab + @tab + N'Executed Correction: ' + [command] + @crlf + @crlf
			FROM 
				@issues 
			WHERE 
				[succeeded] = 1 
			ORDER BY [issue_id];
		END;

	END;

	-- send/display any problems:
	IF @emailBody IS NOT NULL BEGIN
		IF @PrintOnly = 1 BEGIN 
			PRINT @emailSubject;
            PRINT N'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!';
            PRINT N'! NOTE: _NO CHANGES_ were made. The output below simply ''simulates'' what would have been done had @PrintOnly been set to 0:';
            PRINT N'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!';
			PRINT @emailBody;
		  END;
		ELSE BEGIN 
			EXEC msdb..sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName,
				@subject = @emailSubject, 
				@body = @emailBody;
		END
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_drivespace','P') IS NOT NULL
	DROP PROC dbo.verify_drivespace;
GO

CREATE PROC dbo.verify_drivespace 
	@WarnWhenFreeGBsGoBelow				decimal(12,1)		= NULL,				-- 
	@WarnWhenUsageExceedsPercentage		decimal(4,2)		= NULL,
	@HalveThresholdAgainstCDrive		bit					= 0,				-- In RARE cases where some (piddly) dbs are on the C:\ drive, and there's not much space on the C:\ drive overall, it can make sense to treat the C:\ drive's available space as .5x what we'd see on a 'normal' drive.
	@OperatorName						sysname				= N'Alerts',
	@MailProfileName					sysname				= N'General',
	@EmailSubjectPrefix					nvarchar(50)		= N'[DriveSpace Checks] ', 
	@PrintOnly							bit					= 0
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	SET @OperatorName = ISNULL(NULLIF(@OperatorName, N''), N'Alerts');
	SET @MailProfileName = ISNULL(NULLIF(@MailProfileName, N''), N'General');
	SET @EmailSubjectPrefix = ISNULL(NULLIF(@EmailSubjectPrefix, N''), N'[DriveSpace Checks] ');

	--SET @WarnWhenFreeGBsGoBelow = ISNULL(@WarnWhenFreeGBsGoBelow, 22.0);

	IF @WarnWhenFreeGBsGoBelow IS NOT NULL AND @WarnWhenUsageExceedsPercentage IS NOT NULL BEGIN 
		RAISERROR(N'Values can NOT be specified for BOTH @WarnWhenFreeGBsGoBelow and @WarnWhenUsageExceedsPercentage. Specify one or the other.', 16, 1);
		RETURN -1;
	END;

	IF @WarnWhenUsageExceedsPercentage IS NULL AND @WarnWhenFreeGBsGoBelow IS NULL BEGIN 
		RAISERROR(N'A value MUST be specified for EITHER @WarnWhenFreeGBsGoBelow or @WarnWhenUsageExceedsPercentage.', 16, 1);
		RETURN -1;
	END;

	-- Operator Checks:
	IF ISNULL(@OperatorName, '') IS NULL BEGIN
		RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
		RETURN -4;
		END;
	ELSE BEGIN
		IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
			RAISERROR('Invalild Operator Name Specified.', 16, 1);
			RETURN -4;
		END;
	END;

	-- Profile Checks:
	DECLARE @DatabaseMailProfile nvarchar(255);
	EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output';
 
	IF @DatabaseMailProfile != @MailProfileName BEGIN
		RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
		RETURN -5;
	END;

	DECLARE @GBsOrPercentages sysname = 'GBs';
	IF @WarnWhenUsageExceedsPercentage IS NOT NULL SET @GBsOrPercentages = 'Percentage';
	DECLARE @core table (
		drive sysname NOT NULL, 
		available_gbs decimal(14,2) NOT NULL, 
		total_gbs decimal(14,2) NOT NULL, 
		[%_used] decimal(5,2) NOT NULL
	);

	WITH gbs AS ( 
		SELECT DISTINCT
			s.volume_mount_point [drive],
			CAST(s.available_bytes / 1073741824 as decimal(24,2)) [available_gbs], 
			CAST(s.[total_bytes] / 1073741824 as decimal(24,2)) [total_gbs]
		FROM 
			sys.master_files f
			CROSS APPLY sys.dm_os_volume_stats(f.database_id, f.[file_id]) s
	) 

	INSERT INTO @core (drive, [available_gbs], [total_gbs], [%_used])
	SELECT 
		[drive],
		[available_gbs],
		[total_gbs], 
		CAST(100.0 - ([available_gbs] / [gbs].[total_gbs] * 100.0) AS decimal(5,2)) [%_used]
	FROM 
		gbs 
	ORDER BY 
		[gbs].[drive];

	DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
	DECLARE @tab char(1) = CHAR(9);
	DECLARE @message nvarchar(MAX) = N'';
	
	-- Start with the C:\ drive if it's present (i.e., has dbs on it - which is a 'worst practice'):
	IF @GBsOrPercentages = N'GBs' BEGIN
		SELECT 
			@message = @message + @tab + drive + N' -> ' + CAST(available_gbs AS sysname) +  N' GB free out of ' + CAST([total_gbs] AS sysname) + N'GB total (vs. threshold of ' + CAST((CASE WHEN @HalveThresholdAgainstCDrive = 1 THEN @WarnWhenFreeGBsGoBelow / 2 ELSE @WarnWhenFreeGBsGoBelow END) AS nvarchar(20)) + N' GB) '  + @crlf
		FROM 
			@core
		WHERE 
			UPPER(drive) = N'C:\' AND 
			CASE 
				WHEN @HalveThresholdAgainstCDrive = 1 THEN @WarnWhenFreeGBsGoBelow / 2 
				ELSE @WarnWhenFreeGBsGoBelow
			END > available_gbs;

		-- Now process all other drives: 
		SELECT 
			@message = @message + @tab + drive + N' -> ' + CAST(available_gbs AS sysname) +  N' GB free out of ' + CAST([total_gbs] AS sysname) + N'GB total (vs. threshold of ' + CAST(@WarnWhenFreeGBsGoBelow AS sysname) + N' GB) '  + @crlf
		FROM 
			@core
		WHERE 
			UPPER(drive) <> N'C:\'
			AND @WarnWhenFreeGBsGoBelow > available_gbs;
	  END; 
	ELSE BEGIN 
		SELECT 
			@message = @message + @tab + drive + N' -> ' + CAST([%_used] AS sysname) + '% of disk-space used. (Total GBs: ' + CAST([total_gbs] AS sysname) + N', Free GBs: ' + CAST([available_gbs] AS sysname) + N').' + @crlf
		FROM 
			@core  
		WHERE 
			[%_used] > CAST(@WarnWhenUsageExceedsPercentage AS decimal(5,2));

	END;

	IF LEN(@message) > 3 BEGIN 

		DECLARE @subject nvarchar(200) = ISNULL(@EmailSubjectPrefix, N'') + N'Low Disk Notification';

		IF @GBsOrPercentages = N'GBs' 
			SET @message = N'The following disks on ' + QUOTENAME(@@SERVERNAME) + ' have dropped below target thresholds for free space: ' + @crlf + @crlf + @message;
		ELSE 
			SET @message = N'The following disks on ' + QUOTENAME(@@SERVERNAME) + ' have exceeded the threshold of ' + CAST(@WarnWhenUsageExceedsPercentage AS sysname) + N'% of available space used: ' + @crlf + @crlf + @message;

		IF @PrintOnly = 1 BEGIN 
			PRINT @subject;
			PRINT @message;
		  END;
		ELSE BEGIN 

			EXEC msdb..sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName, -- operator name
				@subject = @subject, 
				@body = @message;			
		END; 
	END; 


	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.process_alerts','P') IS NOT NULL
	DROP PROC dbo.process_alerts;
GO

CREATE PROC dbo.process_alerts 
	@ErrorNumber				int, 
	@Severity					int, 
	@Message					nvarchar(2048),
	@OperatorName				sysname					= N'Alerts',
	@MailProfileName			sysname					= N'General', 
	@PrintOnly					bit						= 0
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @response nvarchar(2000); 
	SELECT @response = response FROM dbo.alert_responses 
	WHERE 
		message_id = @ErrorNumber
		AND is_enabled = 1;

	IF NULLIF(@response, N'') IS NOT NULL BEGIN 

		IF UPPER(@response) = N'[IGNORE]' BEGIN 

			-- this is an explicitly ignored alert. print the error details (which'll go into the SQL Server Agent Job log), then bail/return: 
			PRINT '[IGNORE] Error. Severity: ' + CAST(@Severity AS sysname) + N', ErrorNumber: ' + CAST(@ErrorNumber AS sysname) + N', Message: '  + @Message;
			RETURN 0;
		END;

		-- vNEXT:
			-- add additional processing options here. 
	END;

	------------------------------------
	-- If we're still here, then there were now 'special instructions' for this specific error/alert(so send an email with details): 

	DECLARE @body nvarchar(MAX) = N'DATE/TIME: {0}

DESCRIPTION: {1}

ERROR NUMBER: {2}' ;

	SET @body = REPLACE(@body, '{0}', CONVERT(nvarchar(20), GETDATE(), 100));
	SET @body = REPLACE(@body, '{1}', @Message);
	SET @body = REPLACE(@body, '{2}', @ErrorNumber);

	DECLARE @subject nvarchar(256) = N'SQL Server Alert System: ''Severity {0}'' occurred on {1}';

	SET @subject = REPLACE(@subject, '{0}', @Severity);
	SET @subject = REPLACE(@subject, '{1}', @@SERVERNAME); 
	
	IF @PrintOnly = 1 BEGIN 
			PRINT N'SUBJECT: ' + @subject; 
			PRINT N'BODY: ' + @body;
	  END;
	ELSE BEGIN
		EXEC msdb.dbo.sp_notify_operator
			@profile_name = @MailProfileName, 
			@name = @OperatorName,
			@subject = @subject, 
			@body = @body;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.monitor_transaction_durations','P') IS NOT NULL
	DROP PROC dbo.monitor_transaction_durations;
GO


CREATE PROC dbo.monitor_transaction_durations	
	@ExcludeSystemProcesses				bit					= 1,				
	@ExcludedDatabases					nvarchar(MAX)		= NULL,				-- N'master, msdb'  -- recommended that tempdb NOT be excluded... (long running txes in tempdb are typically going to be a perf issue - typically (but not always).
	@ExcludedLoginNames					nvarchar(MAX)		= NULL, 
	@ExcludedProgramNames				nvarchar(MAX)		= NULL,
	@ExcludedSQLAgentJobNames			nvarchar(MAX)		= NULL,
	@AlertOnlyWhenBlocking				bit					= 0,				-- if there's a long-running TX, but it's not blocking... and this is set to 1, then no alert is raised. 
	@AlertThreshold						sysname				= N'10m',			-- defines how long a transaction has to be running before it's 'raised' as a potential problem.
	@OperatorName						sysname				= N'Alerts',
	@MailProfileName					sysname				= N'General',
	@EmailSubjectPrefix					nvarchar(50)		= N'[ALERT:] ', 
	@PrintOnly							bit					= 0
AS
	
	RAISERROR('Sorry. The S4 stored procedure dbo.monitor_transaction_durations is NOT supported on SQL Server 2008/2008R2 instances.', 16, 1);
	RETURN -100;
GO

DECLARE @monitor_transaction_durations nvarchar(MAX) = N'ALTER PROC dbo.monitor_transaction_durations	
	@ExcludeSystemProcesses				bit					= 1,				
	@ExcludedDatabases					nvarchar(MAX)		= NULL,				-- N''master, msdb''  -- recommended that tempdb NOT be excluded... (long running txes in tempdb are typically going to be a perf issue - typically (but not always).
	@ExcludedLoginNames					nvarchar(MAX)		= NULL, 
	@ExcludedProgramNames				nvarchar(MAX)		= NULL,
	@ExcludedSQLAgentJobNames			nvarchar(MAX)		= NULL,
	@AlertOnlyWhenBlocking				bit					= 0,				-- if there''s a long-running TX, but it''s not blocking... and this is set to 1, then no alert is raised. 
	@AlertThreshold						sysname				= N''10m'',			-- defines how long a transaction has to be running before it''s ''raised'' as a potential problem.
	@OperatorName						sysname				= N''Alerts'',
	@MailProfileName					sysname				= N''General'',
	@EmailSubjectPrefix					nvarchar(50)		= N''[ALERT:] '', 
	@PrintOnly							bit					= 0
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -----------------------------------------------------------------------------
    -- Validate Inputs: 
	SET @AlertThreshold = LTRIM(RTRIM(@AlertThreshold));
	DECLARE @transactionCutoffTime datetime; 

	DECLARE @vectorError nvarchar(MAX); 

	EXEC dbo.[translate_vector_datetime]
	    @Vector = @AlertThreshold,
	    @ValidationParameterName = N''@AlertThreshold'',
	    @ProhibitedIntervals = N''WEEK, MONTH, QUARTER, YEAR'',
	    @Output = @transactionCutoffTime OUTPUT,
	    @Error = @vectorError OUTPUT
	
	IF @vectorError IS NOT NULL BEGIN 
		RAISERROR(@vectorError, 16, 1); 
		RETURN -10;
	END;

	SELECT 
		[dtat].[transaction_id],
        [dtat].[transaction_begin_time], 
		[dtst].[session_id],
        [dtst].[enlist_count] [active_requests],
        [dtst].[is_user_transaction],
        [dtst].[open_transaction_count]
	INTO 
		#LongRunningTransactions
	FROM 
		sys.[dm_tran_active_transactions] dtat
		LEFT OUTER JOIN sys.[dm_tran_session_transactions] dtst ON dtat.[transaction_id] = dtst.[transaction_id]
	WHERE 
		[dtst].[session_id] IS NOT NULL
		AND [dtat].[transaction_begin_time] < @transactionCutoffTime
	ORDER BY 
		[dtat].[transaction_begin_time];

	IF NOT EXISTS(SELECT NULL FROM [#LongRunningTransactions]) 
		RETURN 0;  -- nothing to report on... 
		
	IF @ExcludeSystemProcesses = 1 BEGIN 
		DELETE lrt 
		FROM 
			[#LongRunningTransactions] lrt
			LEFT OUTER JOIN sys.[dm_exec_sessions] des ON lrt.[session_id] = des.[session_id]
		WHERE 
			des.[is_user_process] = 0
			OR des.[session_id] < 50
			OR des.[database_id] IS NULL;  -- also, delete any operations where the db_id is NULL
	END;

	IF NULLIF(@ExcludedDatabases, N'''') IS NOT NULL BEGIN 
		DELETE lrt 
		FROM 
			[#LongRunningTransactions] lrt
			LEFT OUTER JOIN sys.[dm_exec_sessions] des ON lrt.[session_id] = des.[session_id]
		WHERE 
			des.[database_id] IN (SELECT d.database_id FROM sys.databases d LEFT OUTER JOIN dbo.[split_string](@ExcludedDatabases, N'','', 1) ss ON d.[name] = ss.[result] WHERE ss.[result] IS NOT NULL);
	END;

	IF NOT EXISTS(SELECT NULL FROM [#LongRunningTransactions]) 
		RETURN 0;  -- filters removed anything to report on. 

	-- Grab Statements
	WITH handles AS ( 
		SELECT 
			sp.spid [session_id], 
			sp.[sql_handle]
		FROM 
			sys.[sysprocesses] sp
			INNER JOIN [#LongRunningTransactions] lrt ON sp.[spid] = lrt.[session_id]
	)

	SELECT 
		[session_id],
		t.[text] [statement]
	INTO 
		#Statements
	FROM 
		handles h
		OUTER APPLY sys.[dm_exec_sql_text](h.[sql_handle]) t;

	CREATE TABLE #ExcludedSessions (
		session_id int NOT NULL
	);

	-- Process additional exclusions if present: 
	IF ISNULL(@ExcludedLoginNames, N'''') IS NOT NULL BEGIN 

		INSERT INTO [#ExcludedSessions] ([session_id])
		SELECT 
			s.[session_id]
		FROM 
			dbo.[split_string](@ExcludedLoginNames, N'','', 1) x 
			INNER JOIN sys.[dm_exec_sessions] s ON s.[login_name] COLLATE SQL_Latin1_General_CP1_CI_AS LIKE x.[result];
	END;

	IF ISNULL(@ExcludedProgramNames, N'''') IS NOT NULL BEGIN 
		INSERT INTO [#ExcludedSessions] ([session_id])
		SELECT 
			s.[session_id]
		FROM 
			dbo.[split_string](@ExcludedProgramNames, N'','', 1) x 
			INNER JOIN sys.[dm_exec_sessions] s ON s.[program_name] COLLATE SQL_Latin1_General_CP1_CI_AS LIKE x.[result];
	END;

	IF ISNULL(@ExcludedSQLAgentJobNames, N'''') IS NOT NULL BEGIN 
		DECLARE @jobIds table ( 
			job_id nvarchar(200) 
		); 

		INSERT INTO @jobIds ([job_id])
		SELECT 
			N''%'' + CONVERT(nvarchar(200), (CONVERT(varbinary(200), j.job_id , 1)), 1) + N''%'' job_id
		FROM 
			msdb.dbo.sysjobs j
			INNER JOIN admindb.dbo.[split_string](@ExcludedSQLAgentJobNames, N'','', 1) x ON j.[name] COLLATE SQL_Latin1_General_CP1_CI_AS LIKE x.[result];

		INSERT INTO [#ExcludedSessions] ([session_id])
		SELECT 
			s.session_id 
		FROM 
			sys.[dm_exec_sessions] s 
			INNER JOIN @jobIds x ON s.[program_name] COLLATE SQL_Latin1_General_CP1_CI_AS LIKE x.[job_id];
	END; 

	DELETE lrt 
	FROM 
		[#LongRunningTransactions] lrt 
	INNER JOIN 
		[#ExcludedSessions] x ON lrt.[session_id] = x.[session_id];


	IF @AlertOnlyWhenBlocking = 1 BEGIN
		DECLARE @iteration int = 0;

		DECLARE @sessions_that_are_blocking table ( 
			session_id int NOT NULL 
		);

CheckForBlocking:
		
		-- NOTE: ARGUABLY, this should be using sys.dm_exec_requests... only, there''s a HUGE problem with that ''table'' - it only shows in-flight requests that are blocked... (so if something is blocked and NOT in a RUNNING state... it won''t show up). 

		SELECT 
			lrt.session_id 
		FROM 
			[#LongRunningTransactions] lrt 
			--INNER JOIN sys.[dm_exec_requests] r ON lrt.[session_id] = r.[blocking_session_id]
			INNER JOIN sys.[sysprocesses] p ON lrt.[session_id] = p.[blocked]
		WHERE 
			lrt.[session_id] NOT IN (SELECT session_id FROM @sessions_that_are_blocking);

		-- short-circuit if we''ve confirmed that ALL long-running-transactions are blocking:
		IF NOT EXISTS (SELECT NULL FROM [#LongRunningTransactions] t1 LEFT OUTER JOIN @sessions_that_are_blocking t2 ON t1.[session_id] = t2.[session_id] WHERE t2.[session_id] IS NULL) BEGIN 
			GOTO BlockingCheckComplete;
		END;

		WAITFOR DELAY ''00:00:02.000'';
	
		SET @iteration = @iteration + 1; 

		IF @iteration < 10
			GOTO CheckForBlocking;
		
BlockingCheckComplete:
		
		-- remove any long-running transactions that were NOT showing as blocking... 
		DELETE lrt
		FROM 
			[#LongRunningTransactions] lrt 
		WHERE [lrt].[session_id] NOT IN (SELECT [session_id] FROM @sessions_that_are_blocking);

	END;

	IF NOT EXISTS(SELECT NULL FROM [#LongRunningTransactions]) 
		RETURN 0;  -- nothing to report on... 

	-- Assemble output/report: 
	DECLARE @line nvarchar(200) = REPLICATE(N''-'', 200);
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9); 
	DECLARE @messageBody nvarchar(MAX) = N'''';

	SELECT 
		@messageBody = @messageBody + @line + @crlf
		+ ''- session_id ['' + CAST(ISNULL(lrt.[session_id], -1) AS sysname) + N''] has been running in database '' +  QUOTENAME(COALESCE(DB_NAME([dtdt].[database_id]), DB_NAME(sx.[database_id]),''#NULL#'')) + N'' for a duration of: '' + dbo.[format_timespan](DATEDIFF(MILLISECOND, lrt.[transaction_begin_time], GETDATE())) + N''.'' + @crlf 
		+ @tab + N''METRICS: '' + @crlf
		+ @tab + @tab + N''[is_user_transaction: '' + CAST(ISNULL(lrt.[is_user_transaction], N''-1'') AS sysname) + N'']'' + @crlf 
		+ @tab + @tab + N''[open_transaction_count: ''+ CAST(ISNULL(lrt.[open_transaction_count], N''-1'') AS sysname) + N'']'' + @crlf
		+ @tab + @tab + N''[blocked_session_count: '' + CAST(ISNULL((SELECT COUNT(*) FROM sys.[sysprocesses] p WHERE lrt.session_id = p.blocked), 0) AS sysname) + N'']'' + @crlf  
		+ @tab + @tab + N''[active_requests: '' + CAST(ISNULL(lrt.[active_requests], N''-1'') AS sysname) + N'']'' + @crlf 
		+ @tab + @tab + N''[is_tempdb_enlisted: '' + CAST(ISNULL([dtdt].[tempdb_enlisted], N''-1'') AS sysname) + N'']'' + @crlf 
		+ @tab + @tab + N''[log_record (count|bytes): ('' + CAST(ISNULL([dtdt].[log_record_count], N''-1'') AS sysname) + N'') | ( '' + CAST(ISNULL([dtdt].[log_bytes_used], N''-1'') AS sysname) + N'') ]'' + @crlf
		+ @crlf
		+ @tab + N''CONTEXT: '' + @crlf
		+ @tab + @tab + N''[login_name]: '' + CAST(ISNULL(sx.[login_name], N''#NULL#'') AS sysname) + N'']'' + @crlf 
		+ @tab + @tab + N''[program_name]: '' + CAST(ISNULL(sx.[program_name], N''#NULL#'') AS sysname) + N'']'' + @crlf 
		+ @tab + @tab + N''[host_name]: '' + CAST(ISNULL(sx.[host_name], N''#NULL#'') AS sysname) + N'']'' + @crlf 
		+ @crlf
        + @tab + N''STATEMENT'' + @crlf + @crlf
		+ @tab + @tab + REPLACE(ISNULL(s.[statement], N''#EMPTY STATEMENT#''), @crlf, @crlf + @tab + @tab)
	FROM 
		[#LongRunningTransactions] lrt
		LEFT OUTER JOIN sys.[dm_exec_sessions] sx ON lrt.[session_id] = sx.[session_id]
		LEFT OUTER JOIN ( 
			SELECT 
				x.transaction_id,
				MAX(x.database_id) [database_id], -- max isn''''t always logical/best. But with tempdb_enlisted + enlisted_db_count... it''''s as good as it gets... 
				SUM(CASE WHEN x.database_id = 2 THEN 1 ELSE 0 END) [tempdb_enlisted],
				COUNT(x.database_id) [enlisted_db_count],
				MAX(x.[database_transaction_log_record_count]) [log_record_count],
				MAX(x.[database_transaction_log_bytes_used]) [log_bytes_used]
			FROM 
				sys.[dm_tran_database_transactions] x WITH(NOLOCK)
			GROUP BY 
				x.transaction_id
		) dtdt ON lrt.[transaction_id] = dtdt.[transaction_id]
		LEFT OUTER JOIN [#Statements] s ON lrt.[session_id] = s.[session_id]

	DECLARE @message nvarchar(MAX) = N''The following long-running transactions (and associated) details were found - which exceed the @AlertThreshold of [''  + @AlertThreshold + N''].'' + @crlf
		+ @tab + N''(Details about how to resolve/address potential problems follow AFTER identified long-running transactions.)'' + @crlf 
		+ ISNULL(@messageBody, N''#NULL in DETAILS#'')
		+ @crlf 
		+ @crlf 
		+ @line + @crlf
		+ @line + @crlf 
		+ @tab + N''To resolve:  '' + @crlf
		+ @tab + @tab + N''First, execute the following statement against '' + @@SERVERNAME + N'' to ensure that the long-running transaction is still causing problems: '' + @crlf
		+ @crlf
		+ @tab + @tab + @tab + @tab + N''EXEC admindb.dbo.list_transactions;'' + @crlf 
		+ @crlf 
		+ @tab + @tab + N''If the same session_id is still listed and causing problems, you can attempt to KILL the session in question by running '' + @crlf 
		+ @tab + @tab + @tab + N''KILL X - where X is the session_id you wish to terminate. (So, if session_id 234 is causing problems, you would execute KILL 234; )'' + @crlf 
		+ @tab + @tab + N''WARNING: KILLing an in-flight/long-running transaction is NOT an immediate operation. It typically takes around 75% - 150% of the time a '' + @crlf 
		+ @tab + @tab + @tab + @tab + N''transaction has taken to ''''roll-forward'''' in order to ''''KILL'''' or ROLLBACK a long-running operation. '' + @crlf
		+ @tab + @tab + @tab + N''Example: suppose it takes 10 minutes for a long-running transaction (like a large UPDATE or DELETE operation) to complete and/or '' + @crlf 
		+ @tab + @tab + @tab + @tab + N''GET stuck - or it has been running for ~10 minutes when you attempt to KILL it.'' + @crlf
		+ @tab + @tab + @tab + @tab + N''At this point (i.e., 10 minutes into an active transaction), you should ROUGHLY expect the rollback to take ''  + @crlf
		+ @tab + @tab + @tab + @tab + @tab + N'' anywhere from 7 - 15 minutes to execute.'' + @crlf
		+ @tab + @tab + @tab + @tab + N''NOTE: If a short/simple transaction (like running an UPDATE against a single row) executes and the gets ''''orphaned'''' (i.e., it '' + @crlf 
		+ @tab + @tab + @tab + @tab + @tab + N''somehow gets stuck and/or there was an EXPLICIT BEGIN TRAN and the operation is waiting on an explicit COMMIT), '' + @crlf
		+ @tab + @tab + @tab + @tab + @tab + N''then, in this case, the transactional ''''overhead'''' should have been minimal - meaning that a KILL operation should be very QUICK ''  + @crlf 
		+ @tab + @tab + @tab + @tab + @tab + @tab + N''and almost immediate - because you are only rolling-back a few milliseconds'''' or second''''s worth of transactional overhead.'' + @crlf 
		+ @crlf
		+ @tab + @tab + N''Once you KILL a session, the rollback proccess will begin (if there was a transaction in-flight). Keep checking admindb.dbo.list_transactions to see '' + @crlf 
		+ @tab + @tab + @tab + @tab + N''IF the session in question is still running - and once it is DONE running blocked processes and other operations SHOULD start to work as normal again.'' + @crlf
		+ @tab + @tab + @tab + N''IF you would like to see ROLLBACK process you can run: KILL ### WITH STATUSONLY; and SQL Server will USUALLY (but not always) provide a relatively accurate '' + @crlf 
		+ @tab + @tab + @tab + @tab + N''picture of how far along the rollback is. '' + @crlf 
		+ @crlf
		+ @tab + @tab + N''NOTE: If you are unable to determine the ''''root'''' blocker and/or are WILLING to effectively take the ENTIRE database ''''down'''' to fix problems with blocking/time-outs '' + @crlf 
		+ @tab + @tab + @tab + N''due to long-running transactions, you CAN kick the entire database in question into SINGLE_USER mode thereby forcing all '' + @crlf
		+ @tab + @tab + @tab + N''in-flight transactions to ROLLBACK - at the expense of (effectively) KILLing ALL connections into the database AND preventing new connections.'' + @crlf
		+ @tab + @tab + @tab + N''As you might suspect, this is effectively a ''''nuclear'''' option - and can/will result in across-the-board down-time against the database in question. '' + @crlf
		+ @tab + @tab + @tab + N''WARNING: Knocking a database into SINGLE_USER mode will NOT do ANYTHING to ''''speed up'''' or decrease ROLLBACK time for any transactions in flight. '' + @crlf 
		+ @tab + @tab + @tab + @tab + N''In fact, because it KILLs ALL transactions in the target database, it can take LONGER in some cases to ''''go'''' SINGLE_USER mode '' + @crlf
		+ @tab + @tab + @tab + @tab + N''than finding/KILLing a root-blocker. Likewise, taking a database into SINGLE_USER mode is a semi-advanced operation and should NOT be done lightly.'' + @crlf 
		+ @crlf 
		+ @tab + @tab + @tab + N''To force a database into SINGLE_USER mode (and kill all connections/transactions), run the following from within the master database: '' + @crlf
		+ @crlf 
		+ @tab + @tab + @tab + @tab + N''ALTER DATABSE [targetDBNameHere] SET SINGLE_USER WITH ROLLBACK AFTER 5 SECONDS;'' + @crlf 
		+ @crlf 
		+ @tab + @tab + @tab + N''The command above will allow any/all connections and transactions currently active in the target database another 5 seconds to complete - while also '' + @crlf 
		+ @tab + @tab + @tab + @tab + N''blocking any NEW connections into the database. After 5 seconds (and you can obvious set this value as you would like), all in-flight transactions '' + @crlf
		+ @tab + @tab + @tab + @tab + N''will be KILLed and start the ROLLBACK process - and any active connections in the database will also be KILLed and kicked-out of the database in question.'' + @crlf
		+ @tab + @tab + @tab + N''WARNING: Once a database has been put into SINGLE_USER mode it can ONLY be accessed by the session that switched the database into SINGLE_USER mode. As such, if '' + @crlf 
		+ @tab + @tab + @tab + @tab + N''you CLOSE your connection/session - ''''control'''' of the database ''''falls'''' to the next session that '' + @crlf
		+ @tab + @tab + @tab + @tab + N''accesses the database - and all OTHER connections are blocked - which means that IF you close your connection/session, you will have to ACTIVELY fight other '' + @crlf
		+ @tab + @tab + @tab + @tab + N''processes for connection into the database before you can set it to MULTI_USER again - and clear it for production use.'' + @crlf 
		+ @crlf 
		+ @tab + @tab + @tab + N''Once a database has been put into SINGLE_USER mode (i.e., after the command has been executed and ALL in-flight transactions have been rolled-back and all '' + @crlf
		+ @tab + @tab + @tab + @tab + N''connections have been terminated and the state of the database switches to SINGLE_USER mode), any transactional locking and blocking in the target database'' + @crlf
		+ @tab + @tab + @tab + @tab + N''will be corrected. At which point you can then return the database to active service by switching it back to MULTI_USER mode by executing the following: '' + @crlf 
		+ @crlf 
		+ @tab + @tab + @tab + @tab + @tab + N''ALTER DATABASE [targetDatabaseInSINGLE_USERMode] SET MULTI_USER;'' + @crlf 
		+ @crlf 
		+ @tab + @tab + @tab + @tab + N''Note that the command above can ONLY be successfully executed by the session_id that currently ''''owns'''' the SINGLE_USER access into the database in question.'' + @crlf;

	IF @PrintOnly = 1 BEGIN 
		PRINT @message;
	  END;
	ELSE BEGIN 

		DECLARE @subject nvarchar(200); 
		DECLARE @txCount int; 
		SET @txCount = (SELECT COUNT(*) FROM [#LongRunningTransactions]); 

		SET @subject = @EmailSubjectPrefix + ''Long-Running Transaction Detected'';
		IF @txCount > 1 SET @subject = @EmailSubjectPrefix + CAST(@txCount AS sysname) + '' Long-Running Transactions Detected'';

		EXEC msdb..sp_notify_operator
			@profile_name = @MailProfileName,
			@name = @OperatorName,
			@subject = @subject, 
			@body = @message;
	END;

	RETURN 0;

 ';

IF (SELECT dbo.get_engine_version())> 10.5 
	EXEC sp_executesql @monitor_transaction_durations;

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_cpu_thresholds','P') IS NOT NULL
	DROP PROC dbo.[verify_cpu_thresholds];
GO

CREATE PROC dbo.[verify_cpu_thresholds]
	@CpuAlertThreshold					int					= 80, 
	@KernelPercentThreshold				decimal(5,2)		= 5.10,		-- WHEN > 0 will cause 10x kernel-time checks over 10 seconds and if AVERAGE of kernel time % > @Threshold, will send alerts.
	@JobsToIgnoreCpuFrom				nvarchar(MAX)		= NULL, 
	@OperatorName						sysname				= N'Alerts',
	@MailProfileName					sysname				= N'General',
	@EmailSubjectPrefix					nvarchar(50)		= N'[CPU Checks] ', 
	@PrintOnly							bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	SET @CpuAlertThreshold = ISNULL(@CpuAlertThreshold, 80);
	SET @KernelPercentThreshold = ISNULL(@KernelPercentThreshold, 0);
	SET @JobsToIgnoreCpuFrom = NULLIF(@JobsToIgnoreCpuFrom, N'');
	SET @EmailSubjectPrefix = ISNULL(NULLIF(@EmailSubjectPrefix, N''), N'[CPU Checks] ');

	IF @CpuAlertThreshold > 99 OR @CpuAlertThreshold < 1 BEGIN 
		RAISERROR(N'@CpuAlertThreshold values must be between 1 and 99 - and represent overall CPU usage percentage.', 16, 1);
		RETURN -1;
	END;
	
	---------------------------------------------
	-- Dependencies Validation:
	DECLARE @return int, @returnMessage nvarchar(MAX);
    IF @PrintOnly = 0 BEGIN 

	    EXEC @return = dbo.verify_advanced_capabilities;  /* Required for @KernelPercent checks (i.e., we're using powershell) */
        IF @return <> 0
            RETURN @return;

        EXEC @return = dbo.verify_alerting_configuration
            @OperatorName, 
            @MailProfileName;

        IF @return <> 0 
            RETURN @return;
    END;

    ----------------------------------------------
	-- Determine the last time this job ran: 
    DECLARE @now datetime = GETDATE();
	DECLARE @lastCheckupExecutionTime datetime;
    EXEC [dbo].[get_last_job_completion_by_session_id] 
        @SessionID = @@SPID, 
        @ExcludeFailures = 1, 
        @LastTime = @lastCheckupExecutionTime OUTPUT; 

	SET @lastCheckupExecutionTime = ISNULL(@lastCheckupExecutionTime, DATEADD(MINUTE, -20, GETDATE()));

    IF DATEDIFF(MINUTE, @lastCheckupExecutionTime, GETDATE()) > 20
        SET @lastCheckupExecutionTime = DATEADD(MINUTE, -20, GETDATE())

    DECLARE @syncCheckSpanMinutes int = DATEDIFF(MINUTE, @lastCheckupExecutionTime, GETDATE());

    IF @syncCheckSpanMinutes <= 1 
        RETURN 0; -- no sense checking on history if it's just been a minute... 

	----------------------------------------------
	-- get CPU history for the last N minutes:
	DECLARE @cpuHistory xml; 
	EXEC dbo.list_cpu_history 
		@SerializedOutput = @cpuHistory OUTPUT;

	-- and get a list of jobs running in the last N minutes: 
	DECLARE @runningJobs xml;
	EXEC dbo.[list_running_jobs]
		@StartTime = @lastCheckupExecutionTime,
		@EndTime = @now,
		@SerializedOutput = @runningJobs OUTPUT;
	
	CREATE TABLE #running_jobs (
		row_id int IDENTITY(1,1) NOT NULL, 
		job_name sysname NOT NULL, 
		start_time datetime NULL, 
		end_time datetime NULL, 
		[status] sysname NULL 
	);

	WITH shredded AS (
		SELECT 
			[data].[row].value(N'job_name[1]', N'sysname') job_name, 
			[data].[row].value(N'start_time[1]', N'datetime') start_time, 
			[data].[row].value(N'end_time[1]', N'datetime') end_time, 
			[data].[row].value(N'job_status[1]', N'sysname') job_status 			
		FROM 
			@runningJobs.nodes(N'//job') [data]([row])
	)

	INSERT INTO [#running_jobs] (
		[job_name],
		[start_time],
		[end_time],
		[status]
	)
	SELECT 
		[job_name], 
		[start_time], 
		[end_time], 
		[job_status]
	FROM 
		[shredded];

	IF @JobsToIgnoreCpuFrom IS NULL BEGIN 
		DELETE FROM [#running_jobs];  -- there are no 'exceptions' to track against - remove all jobs... 
	  END;
	ELSE BEGIN 
		-- NOTE: it's a bit counter-intuitive, but we only want to keep jobs that we can EXCLUDE cpu-usage from:
		DELETE FROM [#running_jobs] 
		WHERE 
			[job_name] NOT IN (
				SELECT [result] FROM dbo.[split_string](@JobsToIgnoreCpuFrom, N',', 1)
			);
	END;

	----------------------------------------------
	-- manage intersection of CPU history + running jobs: 
	CREATE TABLE #cpu_history (
		row_id int IDENTITY(1,1) NOT NULL, 
		[start_time] datetime NOT NULL, 
		[end_time] datetime NOT NULL,
		sql_cpu_usage int NOT NULL, 
		other_process_usage int NOT NULL, 
		idle_cpu int NOT NULL, 
		--[job_running] bit DEFAULT (0)
		running_jobs nvarchar(MAX) NULL
	);

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'timestamp[1]', N'datetime') [timestamp], 
			[data].[row].value(N'sql_cpu_usage[1]', N'int') [sql_cpu_usage],
			[data].[row].value(N'other_process_usage[1]', N'int') [other_process_usage],
			[data].[row].value(N'system_idle[1]', N'int') [idle_cpu]
		FROM 
			@cpuHistory.nodes(N'//entry') [data]([row])
	)
	INSERT INTO [#cpu_history] (
		[start_time],
		[end_time],
		[sql_cpu_usage],
		[other_process_usage],
		[idle_cpu]
	)
	SELECT 
		[timestamp] [start_time],
		LEAD([timestamp], 1, [timestamp]) OVER (ORDER BY [shredded].[timestamp]) [end_time],
		[sql_cpu_usage],
		[other_process_usage],
		[idle_cpu]
	FROM 
		[shredded] 
	WHERE 
		[shredded].[timestamp] >= @lastCheckupExecutionTime;

	IF EXISTS (SELECT NULL FROM [#running_jobs]) BEGIN 

		DECLARE @minStart datetime, @maxEnd datetime;
		SELECT 
			@minStart = MIN(start_time), 
			@maxEnd = MAX(end_time) 
		FROM 
			[#cpu_history];
		
		-- vNEXT: there are 5x cases to address via set theory: 
		--			a) jobs that don't run at all during our window (shouldn't exist but... whatever) 
		--			b) jobs that start + end within a single 1-minute interval.
		--			c) jobs spanning multiple 1 minute intervals. 
		--			d) jobs running when our first interval starts and running 1 or more intervals. 
		--			e) jobs running 1 or more intervals before our total window ends (i.e., jobs running 'now')
		--	I could NOT seem to even address a, b, c via set-based operations... so I went with a cursor instead. sigh. 
		--	that said, after, cough, over an HOUR of trial/error and then giving up and creating a 'matrix' I could view/proof-against, 
		--			the 'formula' is: (@jobEndTime > boundary.[start_time] AND @jobStaTime < boundary.[end_time])
		DECLARE @jobName sysname, @jobStart datetime, @jobEnd datetime;
		SELECT 
			@minStart = MIN(start_time), 
			@maxEnd = MAX(end_time) 
		FROM 
			[#cpu_history];

		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT job_name, ISNULL(start_time, @minStart), ISNULL(end_time, @maxEnd) FROM [#running_jobs];
		
		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @jobName, @jobStart, @jobEnd;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			UPDATE [#cpu_history] 
			SET 
				[running_jobs] = CASE WHEN [running_jobs] IS NULL THEN @jobName ELSE [running_jobs] + N', ' + @jobName END 
			WHERE 
				(@jobEnd >= [start_time] AND @jobStart <= [end_time])			
		
			FETCH NEXT FROM [walker] INTO @jobName, @jobStart, @jobEnd;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

	END;

	IF @KernelPercentThreshold > 0 BEGIN 
		DECLARE @output xml, @errorMessage nvarchar(MAX);
		EXEC [admindb].dbo.[execute_command]
			@Command = N'(Get-Counter -Counter ''\Processor(_Total)\% Privileged Time'' -MaxSamples 10).CounterSamples.CookedValue;',
			@ExecutionType = N'POSH',
			@IgnoredResults = N'',
			@SafeResults = N'{ALL}',	/* treat all results as safe... */
			@ErrorResults = N'',
			@PrintOnly = 0,
			@Outcome = @output OUTPUT,
			@ErrorMessage = @errorMessage OUTPUT;	
			
		DECLARE @kernelAverage decimal(5,2);
		WITH shredded AS ( 
			SELECT 
				--[data].[row].value(N'@result_id[1]', N'int') [result_id], 
				[data].[row].value(N'.[1]', N'decimal(16,12)') [value]
			FROM 
				@output.nodes(N'//result_row') [data]([row])
		)

		SELECT 
			@kernelAverage = AVG([value])
		FROM 
			[shredded];


		IF @kernelAverage > @KernelPercentThreshold BEGIN
			PRINT 'TODO: figure out how to create an alert about kernel-time > @threshold... '
		END;
	END;

	-- Report on CPU usage exceptions/problems: 
	IF EXISTS (SELECT NULL FROM [#cpu_history] WHERE [running_jobs] IS NULL AND ([sql_cpu_usage] + [other_process_usage]) > @CpuAlertThreshold) BEGIN
		DECLARE @xmlSummary xml;
		DECLARE @subject sysname;
		DECLARE @message nvarchar(MAX);

		SELECT @xmlSummary = (
			SELECT
				start_time, 
				end_time, 
				[sql_cpu_usage], 
				[other_process_usage], 
				[idle_cpu], 
				[running_jobs]
			FROM 
				[#cpu_history] 
			--WHERE 
			--	[running_jobs] IS NULL  -- ignore CPU values from rows where a job-to-ignore-cpu-from is running... 
			--	AND ([sql_cpu_usage] + [other_process_usage]) >= @CpuAlertThreshold
			ORDER BY 
				row_id
			FOR XML PATH('entry'), ROOT('history')
		);

		DECLARE @avg int; 
		DECLARE @avgCount int;
		SELECT 
			@avg = AVG([sql_cpu_usage] + [other_process_usage]), 
			@avgCount = COUNT(*)
		FROM 
			[#cpu_history] 
		WHERE 
			[running_jobs] IS NULL
			AND ([sql_cpu_usage] + [other_process_usage]) > @CpuAlertThreshold;

		SET @subject = @EmailSubjectPrefix + N' - ' + CAST(@CpuAlertThreshold AS sysname) + N'% Utilization Threshold Exceeded. CPU averaged ' + CAST(@avg AS sysname) + N'% utilization ' + CAST(@avgCount AS sysname) + CASE WHEN @avgCount = 1 THEN N' once' ELSE N' minutes' END + N' over last ' + CAST(@syncCheckSpanMinutes AS sysname) + N' minutes.';
		SET @message = N'CPU utlization on ' + @@SERVERNAME + N' during the last ' + CAST(@syncCheckSpanMinutes AS sysname) + N' minutes exceeded @CpuAlertThreshold value of ' + CAST(@CpuAlertThreshold AS sysname) + N'% utilization ' + CASE WHEN @avgCount = 1 THEN N' once.' ELSE CAST(@avgCount AS sysname) END + N' times.';
		SET @message = @message + N'
			Summary Data: 
			
			' + CAST(@xmlSummary AS nvarchar(MAX));

		IF @PrintOnly = 1 BEGIN 
			PRINT @subject;
			PRINT @message;
		  END;
		ELSE BEGIN 
			
			EXEC msdb..sp_notify_operator
				@profile_name = @MailProfileName,
				@name = @OperatorName, -- operator name
				@subject = @subject, 
				@body = @message;	
		END;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_ple_thresholds','P') IS NOT NULL
	DROP PROC dbo.[verify_ple_thresholds];
GO

CREATE PROC dbo.[verify_ple_thresholds]
	@LowPleTheshold						int					= 1000,
	@JobsToIgnoreLowPLEsFrom			nvarchar(MAX)		= NULL,
	@OperatorName						sysname				= N'Alerts',
	@MailProfileName					sysname				= N'General',
	@EmailSubjectPrefix					nvarchar(50)		= N'[PLE Checks] ', 
	@PrintOnly							bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	SET @LowPleTheshold = ISNULL(@LowPleTheshold, 1000);
	SET @JobsToIgnoreLowPLEsFrom = NULLIF(@JobsToIgnoreLowPLEsFrom, N'');
	SET @EmailSubjectPrefix = ISNULL(NULLIF(@EmailSubjectPrefix, N''), N'[PLE Checks] ');

	IF @LowPleTheshold < 100 BEGIN 
		RAISERROR(N'@LowPleTheshold values must be > 100.', 16, 1);
		RETURN -1;
	END;
	
	---------------------------------------------
	-- Dependencies Validation:
	DECLARE @return int, @returnMessage nvarchar(MAX);
    IF @PrintOnly = 0 BEGIN 

	    EXEC @return = dbo.verify_advanced_capabilities;
        IF @return <> 0
            RETURN @return;

        EXEC @return = dbo.verify_alerting_configuration
            @OperatorName, 
            @MailProfileName;

        IF @return <> 0 
            RETURN @return;
    END;

    ----------------------------------------------
	-- Determine the last time this job ran: 
    DECLARE @now datetime = GETDATE();
	DECLARE @lastCheckupExecutionTime datetime;
    EXEC [dbo].[get_last_job_completion_by_session_id] 
        @SessionID = @@SPID, 
        @ExcludeFailures = 1, 
        @LastTime = @lastCheckupExecutionTime OUTPUT; 

	SET @lastCheckupExecutionTime = ISNULL(@lastCheckupExecutionTime, DATEADD(MINUTE, -20, GETDATE()));

    IF DATEDIFF(MINUTE, @lastCheckupExecutionTime, GETDATE()) > 20
        SET @lastCheckupExecutionTime = DATEADD(MINUTE, -20, GETDATE())

    DECLARE @syncCheckSpanMinutes int = DATEDIFF(MINUTE, @lastCheckupExecutionTime, GETDATE());

    IF @syncCheckSpanMinutes <= 1 
        RETURN 0; -- no sense checking on history if it's just been a minute... 

	----------------------------------------------
	-- Get current PLE values:
	DECLARE @currentPLEs bigint; 
	SELECT @currentPLEs = cntr_value 
	FROM sys.[dm_os_performance_counters] 
	WHERE [object_name] = N'SQLServer:Buffer Manager' -- vNEXT: name-change for named instances... 
	AND [counter_name] = N'Page life expectancy';

	IF @currentPLEs > @LowPleTheshold BEGIN -- There's nothing to report - i.e., everything is peachy... 
		RETURN 0;
	END;

	-- otherwise, if we're still here... check to see if the low PLEs are due to a job that we know about and want to ignore low PLEs from (e.g., DBCC CHECKDB() or something similar).
	IF @JobsToIgnoreLowPLEsFrom IS NOT NULL BEGIN 

		CREATE TABLE #running_jobs (
			row_id int IDENTITY(1,1) NOT NULL, 
			job_name sysname NOT NULL, 
			start_time datetime NULL, 
			end_time datetime NULL, 
			[status] sysname NULL 
		);

		-- and get a list of jobs running in the last N minutes: 
		DECLARE @runningJobs xml;
		EXEC dbo.[list_running_jobs]
			@StartTime = @lastCheckupExecutionTime,
			@EndTime = @now,
			@SerializedOutput = @runningJobs OUTPUT;

			WITH shredded AS (
				SELECT 
					[data].[row].value(N'job_name[1]', N'sysname') job_name, 
					[data].[row].value(N'start_time[1]', N'datetime') start_time, 
					[data].[row].value(N'end_time[1]', N'datetime') end_time, 
					[data].[row].value(N'job_status[1]', N'sysname') job_status 			
				FROM 
					@runningJobs.nodes(N'//job') [data]([row])
			)

			INSERT INTO [#running_jobs] (
				[job_name],
				[start_time],
				[end_time],
				[status]
			)
			SELECT 
				[job_name], 
				[start_time], 
				[end_time], 
				[job_status]
			FROM 
				[shredded];

		DELETE FROM [#running_jobs] WHERE [job_name] NOT IN (SELECT [result] FROM dbo.[split_string](@JobsToIgnoreLowPLEsFrom, N',', 1));

		IF EXISTS (SELECT NULL FROM [#running_jobs]) BEGIN  -- PLEs are below specified threshold, but an 'ugly' job (we've configured to 'ignore crapply PLEs from' has been running within the last N minutes, so ... nothing to report.
			RETURN 0;
		END;

	END;
	
	-- if we're still here, PLEs are below thresholds:
	DECLARE @subject sysname;
	DECLARE @message nvarchar(MAX);

	SET @subject = @EmailSubjectPrefix + N' - PLEs are currently at ' + CAST(@currentPLEs AS sysname) + N' and below specified threshold value of ' + CAST(@LowPleTheshold AS sysname) + N'.';
	SET @message = N'Last/Previous PLE check was ' + CAST(@syncCheckSpanMinutes AS sysname) + N' minutes ago. PLEs are currently at ' + CAST(@currentPLEs AS sysname) + N'. Threshold is set at ' + CAST(@LowPleTheshold AS sysname) + N'.';

	IF @PrintOnly = 1 BEGIN 
		PRINT @subject;
		PRINT @message;
	  END;
	ELSE BEGIN 
		EXEC msdb..sp_notify_operator
			@profile_name = @MailProfileName,
			@name = @OperatorName, -- operator name
			@subject = @subject, 
			@body = @message;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_dev_configurations','P') IS NOT NULL
	DROP PROC dbo.[verify_dev_configurations];
GO

CREATE PROC dbo.[verify_dev_configurations]
	@TargetDatabases				nvarchar(MAX)		= NULL, 
	@DatabasesToExclude				nvarchar(MAX)		= NULL, 
	@SendChangeNotifications		bit					= 0, 
	@OperatorName					sysname				= N'Alerts',
	@MailProfileName				sysname				= N'General',
	@EmailSubjectPrefix				nvarchar(50)		= N'[Database Configuration Alert] ',
	@PrintOnly						bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	-----------------------------------------------------------------------------
	-- Validate Inputs: 
	IF @PrintOnly = 0 BEGIN -- we just need to check email info, anything else can be logged and then an email can be sent (unless we're debugging). 
		
		-- Operator Checks:
		IF ISNULL(@OperatorName, '') IS NULL BEGIN
			RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
			RETURN -2;
		 END;
		ELSE BEGIN 
			IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
				RAISERROR('Invalild Operator Name Specified.', 16, 1);
				RETURN -2;
			END;
		END;

		-- Profile Checks:
		DECLARE @DatabaseMailProfile nvarchar(255)
		EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output'
 
		IF @DatabaseMailProfile != @MailProfileName BEGIN
			RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
			RETURN -2;
		END; 
	END;

	-----------------------------------------------------------------------------
	-- Set up / initialization:
	DECLARE @databasesToCheck table (
		[name] sysname
	);
	
	INSERT INTO @databasesToCheck ([name])
	EXEC dbo.list_databases 
		@Targets = @TargetDatabases,
		@Exclusions = @DatabasesToExclude;

	DECLARE @issues table ( 
		issue_id int IDENTITY(1,1) NOT NULL, 
		[database] sysname NOT NULL, 
		issue varchar(2000) NOT NULL, 
		command nvarchar(2000) NOT NULL, 
		success_message varchar(2000) NOT NULL,
		succeeded bit NOT NULL DEFAULT (0),
		[error_message] nvarchar(MAX) NULL 
	);

	DECLARE @crlf char(2) = CHAR(13) + CHAR(10);
	DECLARE @tab char(1) = CHAR(9);


	-----------------------------------------------------------------------------
	-- Checks: 
		
	-- SIMPLE RECOVERY: 
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'Recovery Model should be set to SIMPLE. Currently set to ' + d.[recovery_model_desc] + N'.0' [issue],
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET RECOVERY SIMPLE; ' [command],
		N'Recovery Model successfully set to SIMPLE.' [success_message]
	FROM 
		sys.databases d 
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		[recovery_model_desc] <> N'SIMPLE'
	ORDER BY 
		d.[name];

	-- Page Verify: 
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'Page Verify should be set to CHECKSUM. Currently set to ' + ISNULL(page_verify_option_desc, 'NOTHING') + N'.' [issue], 
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET PAGE_VERIFY CHECKSUM; ' [command], 
		N'Page Verify successfully set to CHECKSUM.' [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		page_verify_option_desc <> N'CHECKSUM'
	ORDER BY 
		d.[name];

	-- OwnerChecks:
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'Should be owned by 0x01 (SysAdmin). Currently owned by 0x' + CONVERT(nvarchar(MAX), owner_sid, 2) + N'.' [issue], 
		N'ALTER AUTHORIZATION ON DATABASE::' + QUOTENAME(d.[name]) + N' TO sa;' [command], 
		N'Database owndership successfully transferred to 0x01 (SysAdmin).' [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		owner_sid <> 0x01;

	-- AUTO_CLOSE:
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'AUTO_CLOSE should be DISABLED. Currently ENABLED.' [issue], 
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET AUTO_CLOSE OFF; ' [command], 
		N'AUTO_CLOSE successfully set to DISABLED.' [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		[is_auto_close_on] = 1
	ORDER BY 
		d.[name];

	-- AUTO_SHRINK:
	INSERT INTO @issues ([database], [issue], [command], [success_message])
	SELECT 
		d.[name] [database], 
		N'AUTO_SHRINK should be DISABLED. Currently ENABLED.' [issue], 
		N'ALTER DATABASE ' + QUOTENAME(d.[name]) + N' SET AUTO_SHRINK OFF; ' [command], 
		N'AUTO_SHRINK successfully set to DISABLED.' [success_message]
	FROM 
		sys.databases d
		INNER JOIN @databasesToCheck x ON d.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[name]
	WHERE 
		[is_auto_shrink_on] = 1
	ORDER BY 
		d.[name];


	-- other checks as needed... 


	-----------------------------------------------------------------------------
	-- (attempted) fixes: 
	IF EXISTS (SELECT NULL FROM @issues) BEGIN 

		DECLARE fixer CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[issue_id], 
			[command] 
		FROM 
			@issues 
		ORDER BY [issue_id];

		DECLARE @currentID int;
		DECLARE @currentCommand nvarchar(2000); 
		DECLARE @errorMessage nvarchar(MAX);

		OPEN [fixer];
		FETCH NEXT FROM [fixer] INTO @currentID, @currentCommand;

		WHILE @@FETCH_STATUS = 0 BEGIN 
			
			SET @errorMessage = NULL;

			BEGIN TRY 
                IF @PrintOnly = 0 BEGIN 
				    EXEC sp_executesql @currentCommand;
                END;

                UPDATE @issues SET [succeeded] = 1 WHERE [issue_id] = @currentID;

			END TRY 
			BEGIN CATCH
				SET @errorMessage = CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
				UPDATE @issues SET [error_message] = @errorMessage WHERE [issue_id] = @currentID;
			END CATCH

			FETCH NEXT FROM [fixer] INTO @currentID, @currentCommand;
		END;

		CLOSE [fixer]; 
		DEALLOCATE fixer;

	END;

	-----------------------------------------------------------------------------
	-- reporting: 
	DECLARE @emailBody nvarchar(MAX) = NULL;
	DECLARE @emailSubject nvarchar(300);
	IF EXISTS (SELECT NULL FROM @issues) BEGIN 
		SET @emailBody = N'';
		
		DECLARE @correctionErrorsOccurred bit = 0;
		DECLARE @correctionsCompletedSuccessfully bit = 0; 

		IF EXISTS (SELECT NULL FROM @issues WHERE [succeeded] = 0) BEGIN -- process ERRORS first. 
			SET @correctionErrorsOccurred = 1;
		END; 

		IF EXISTS (SELECT NULL FROM @issues WHERE [succeeded] = 1) BEGIN -- report on successful changes: 
			SET @correctionsCompletedSuccessfully = 1;
		END;

		IF @correctionErrorsOccurred = 1 BEGIN
			SET @emailSubject = @EmailSubjectPrefix + N' - Errors Addressing Database Settings';
			
			IF @correctionsCompletedSuccessfully = 1 
				SET @emailBody = N'Configuration Problems Detected. Some were automatically corrected; Others encountered errors during attempt to correct:' + @crlf + @crlf;
			ELSE 
				SET @emailBody = N'Configuration Problems Detected.' + @crlf + @crlf + UPPER(' Errors encountred while attempting to correct:') + @crlf + @crlf;

			SELECT 
				@emailBody = @emailBody + @tab + QUOTENAME([database]) + N' - ' + [issue] + @crlf
					+ @tab + @tab + N'ATTEMPTED CORRECTION: -> ' + [command] + @crlf
					+ @tab + @tab + @tab + N'ERROR: ' + ISNULL([error_message], N'##Unknown/Uncaptured##') + @crlf + @crlf
			FROM 
				@issues 
			WHERE 
				[succeeded] = 0 
			ORDER BY [issue_id];

		END;

		IF @correctionsCompletedSuccessfully = 1 BEGIN
			SET @emailSubject = @EmailSubjectPrefix + N' - Database Configuration Settings Successfully Updated';

			IF @correctionErrorsOccurred = 1
				SET @emailBody = @emailBody + @crlf + @crlf;

			SET @emailBody = @emailBody + N'The following database configuration changes were successfully applied:' + @crlf + @crlf;

			SELECT 
				@emailBody = @emailBody + @tab + QUOTENAME([database]) + @crlf
				+ @tab + @tab + N'OUTCOME: ' + [success_message] + @crlf + @crlf
				+ @tab + @tab + @tab + @tab + N'Detected Problem: ' + [issue] + @crlf
				+ @tab + @tab + @tab + @tab + N'Executed Correction: ' + [command] + @crlf + @crlf
			FROM 
				@issues 
			WHERE 
				[succeeded] = 1 
			ORDER BY [issue_id];
		END;

	END;

	-- send/display any problems:
	IF @emailBody IS NOT NULL BEGIN
		IF @PrintOnly = 1 BEGIN 
			PRINT @emailSubject;
            PRINT N'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!';
            PRINT N'! NOTE: _NO CHANGES_ were made. The output below simply ''simulates'' what would have been done had @PrintOnly been set to 0:';
            PRINT N'!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!';
			PRINT @emailBody;
		  END;
		ELSE BEGIN 
			
			IF @SendChangeNotifications = 1 BEGIN
				EXEC msdb..sp_notify_operator
					@profile_name = @MailProfileName,
					@name = @OperatorName,
					@subject = @emailSubject, 
					@body = @emailBody;
			  END;
			ELSE BEGIN 
				-- Print to job output - so there's a 'history' (ish) of these changes:
				PRINT @emailSubject;
				EXEC admindb.dbo.[print_long_string] @emailBody;
			END;
		END
	END;

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Diagnostics
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_index_metrics','P') IS NOT NULL
	DROP PROC dbo.[list_index_metrics];
GO

CREATE PROC dbo.[list_index_metrics]
	@TargetDatabase								sysname				= NULL,						-- can/will be derived by execution context. 
	@TargetTables								nvarchar(MAX)		= N'{ALL}',   
--	@ExcludedTables								nvarchar(MAX)		= NULL, 
	@ExcludeSystemTables						bit					= 1,
	@IncludeFragmentationMetrics				bit					= 0,						-- really don't care about this - 99% of the time... 
	@MinRequiredTableRowCount					int					= 0,						-- ignore tables with < rows than this value... (but, note: this is per TABLE, not per IX cuz filtered indexes might only have a few rows on a much larger table).
	@OrderBy									sysname				= N'ROW_COUNT',				-- { ROW_COUNT | FRAGMENTATION | SIZE | BUFFER_SIZE | READS | WRITES }
	@IncludeDefinition							bit					= 1,						 -- include/generate the exact definition needed for the IX... 
	@SerializedOutput				xml				= N'<default/>'	    OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
		
	IF @TargetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @TargetDatabase OUTPUT;
		
		IF @TargetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for @TargetDatabase and/or S4 was unable to determine calling-db-context. Please specify a valid database name for @TargetDatabase and retry. ', 16, 1);
			RETURN -5;
		END;
	END;

	SET @TargetTables = ISNULL(NULLIF(@TargetTables, N''), N'{ALL}'); 
--	SET @ExcludedTables = NULLIF(@ExcludedTables, N'');

	DECLARE @sql nvarchar(MAX);

-- TODO: @ExcludedTables ... and i think I only allow that to work with/against {ALL}
--		as in, if {ALL} then @Excluded can be set, otherwise... i guess there's a potential for @TargetTables to be a LIKE? 
	IF @TargetTables <> N'{ALL}' BEGIN 
		CREATE TABLE #target_tables (
			[table_name] sysname NOT NULL, 
			[object_id] int NULL
		);

		INSERT INTO [#target_tables] ([table_name])
		SELECT [result] FROM dbo.split_string(@TargetTables, N',', 1);

		SET @sql = N'USE [' + @TargetDatabase + N'];
		UPDATE #target_tables 
		SET 
			[object_id] = OBJECT_ID([table_name])
		WHERE 
			[object_id] IS NULL; ';

		EXEC sp_executesql 
			@sql;
	
		IF EXISTS (SELECT NULL FROM [#target_tables] WHERE [object_id] IS NULL) BEGIN 
			SELECT [table_name] [target_table], [object_id] FROM [#target_tables] WHERE [object_id] IS NULL; 

			RAISERROR(N'One or more supplied @TargetTables could not be identified (i.e., does not have a valid object_id). Please remove or correct.', 16, 1);
			RETURN -11;
		END;
	END;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Load Core Meta Data:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	SET @sql = N'	SELECT 
		[i].[object_id],
		[i].[index_id],
		[o].[type],
		[s].[name] [schema_name],
		[o].[name] [table_name],
		[i].[name] [index_name],
		[i].[type_desc],
		[i].[is_unique],
		[i].[ignore_dup_key],
		[i].[is_primary_key],
		[i].[is_unique_constraint],
		[i].[fill_factor],
		[i].[is_padded],
		[i].[is_disabled],
		[i].[is_hypothetical],
		[i].[allow_row_locks],
		[i].[allow_page_locks],
		[i].[filter_definition]
	FROM 
		[{0}].sys.indexes i
		INNER JOIN [{0}].sys.objects o ON [i].[object_id] = [o].[object_id]
		INNER JOIN [{0}].sys.[schemas] s ON [o].[schema_id] = [s].[schema_id]{where}; ';

	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);

	IF @TargetTables = N'{ALL}' BEGIN 
		SET @sql = REPLACE(@sql, N'{where}', N'');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{where}', NCHAR(13) + NCHAR(10) + NCHAR(9) + N' WHERE ' + NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + N'[i].[object_id] IN (SELECT [object_id] FROM [#target_tables])');
	END;

	CREATE TABLE #sys_indexes (
		[object_id] int NOT NULL,
		[index_id] int NOT NULL,
		[type] char(2) NULL,
		[schema_name] sysname NOT NULL,
		[table_name] sysname NOT NULL,
		[index_name] sysname NULL,
		[type_desc] nvarchar(60) NULL,
		[is_unique] bit NULL,
		[ignore_dup_key] bit NULL,
		[is_primary_key] bit NULL,
		[is_unique_constraint] bit NULL,
		[fill_factor] tinyint NOT NULL,
		[is_padded] bit NULL,
		[is_disabled] bit NULL,
		[is_hypothetical] bit NULL,
		[allow_row_locks] bit NULL,
		[allow_page_locks] bit NULL,
		[filter_definition] nvarchar(max) NULL
	);

	INSERT INTO [#sys_indexes] (
		[object_id],
		[index_id],
		[type],
		[schema_name],
		[table_name],
		[index_name],
		[type_desc],
		[is_unique],
		[ignore_dup_key],
		[is_primary_key],
		[is_unique_constraint],
		[fill_factor],
		[is_padded],
		[is_disabled],
		[is_hypothetical],
		[allow_row_locks],
		[allow_page_locks],
		[filter_definition]
	)
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@TargetDatabase sysname', 
		@TargetDatabase = @TargetDatabase;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Usage Stats:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	SET @sql = N'WITH usage_stats AS (
	SELECT
		obj.[object_id],
		ixs.[index_id],
		usage.[user_seeks], 
		usage.[user_scans], 
		usage.[user_lookups],
		usage.user_seeks + usage.user_scans + usage.user_lookups [reads],
		usage.[user_updates] [writes]
	FROM
		[{0}].sys.dm_db_index_usage_stats usage
		INNER JOIN [{0}].sys.indexes ixs ON usage.[object_id] = ixs.[object_id] AND ixs.[index_id] = usage.[index_id]
		INNER JOIN [{0}].sys.objects obj ON usage.[object_id] = obj.[object_id]
	WHERE
		usage.database_id = DB_ID(@TargetDatabase){targets}
	)

	SELECT
		[object_id],
		[index_id],
		[user_seeks], 
		[user_scans], 
		[user_lookups],
		[reads],
		[writes],
		CAST (
			CASE 
				WHEN writes = 0 THEN reads 
				WHEN reads = 0 AND writes > 0 THEN 0 - writes
				ELSE CAST(reads as decimal(24,2)) / CAST(writes as decimal(24,2))
			END 
		as decimal(24,2)) [read_write_ratio], 
		CAST( 
			CASE 
				WHEN user_seeks > user_scans THEN CAST(user_seeks AS decimal(24,2)) / (CAST(user_seeks AS decimal(24,2)) + CAST(user_scans AS decimal(24,2))) * 100.0 
				ELSE 0
			END
		AS decimal(5,2)) [seek_ratio]
	FROM
		usage_stats
	ORDER BY
		[read_write_ratio] DESC; ';

---------------------------------------------------------------------------------------------------------------------------------------
-- TODO: [ratio] calculations have 2x problems: a) short-circuiting of CASE operators (compare BOTH values); b) 'simple' ratio probably isn't the BEST approach here. 
-- vNEXT: address issue with simple-ratio not being the best option/outcome here... 
--			could be something as simple as: "likelihood of current use" ... HIGH,MED,LOW*,NONE* - where warnings would obviously go with low/none... 
--					and column name could be [usage] - and... could be based on the ratio > x ...and or situations where reads > xK or some PERCENTAGE of writes...
---------------------------------------------------------------------------------------------------------------------------------------

	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);
	IF @TargetTables = N'{ALL}' BEGIN 
		SET @sql = REPLACE(@sql, N'{targets}', N'');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{targets}', NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + N' AND obj.[object_id] IN (SELECT [object_id] FROM [#target_tables])');
	END;

	CREATE TABLE #usage_stats (
		[object_id] int NOT NULL,
		[index_id] int NOT NULL,
		[user_seeks] bigint NOT NULL,
		[user_scans] bigint NOT NULL,
		[user_lookups] bigint NOT NULL,
		[reads] bigint NULL,
		[writes] bigint NOT NULL,
		[read_write_ratio] decimal(24,2) NULL,
		[seek_ratio] decimal(5,2) NULL
	);

	INSERT INTO [#usage_stats] (
		[object_id],
		[index_id],
		[user_seeks],
		[user_scans],
		[user_lookups],
		[reads],
		[writes],
		[read_write_ratio],
		[seek_ratio]
	)
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@TargetDatabase sysname', 
		@TargetDatabase = @TargetDatabase;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Operational Stats
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	SET @sql = N'WITH operational_stats AS ( 
		SELECT 
			object_id,
			index_id,
			SUM(row_lock_count) [row_lock_count],
			SUM(row_lock_wait_in_ms) [row_lock_waits],
			SUM(page_lock_count) [page_lock_count],
			SUM(page_lock_wait_in_ms) [page_lock_waits], 
			SUM(page_io_latch_wait_count) [page_io_latch_count],
			SUM(page_io_latch_wait_in_ms) [page_io_latch_waits]--, 
			-- TODO: output any of the following columns that make sense (into the operational_details xml):
			--SUM(leaf_insert_count) [leaf_insert_count],
			--SUM(leaf_delete_count) [leaf_delete_count],
			--SUM(leaf_update_count) [leaf_update_count],
			--SUM(leaf_ghost_count) [leaf_ghost_count],  -- does''t include retained rows via snapshot isolation
			--SUM(range_scan_count) [ranges_scan_count],
			--SUM(singleton_lookup_count) [seek_count],
			--SUM(forwarded_fetch_count) [forwarded_count]
		FROM 
			sys.dm_db_index_operational_stats(DB_ID(@TargetDatabase),NULL,NULL,NULL){where}
		GROUP BY 
			[object_id], index_id
	 )  

	 SELECT 
		[object_id], 
		index_id,
		[row_lock_waits] [row_lock_wait_MS],
		CASE 
			WHEN [row_lock_count] = 0 THEN 0
			ELSE CAST(CAST([row_lock_waits] AS decimal(24,2)) / CAST([row_lock_count] AS decimal(24,2)) AS decimal(24,2))
		END [avg_row_lock_wait], 
		[page_lock_waits] [page_lock_wait_MS],
		CASE 
			WHEN [page_lock_count] = 0 THEN 0
			ELSE CAST(CAST([page_lock_waits] AS decimal(24,2)) / CAST([page_lock_count] AS decimal(24,2)) AS decimal(24,2)) 
		END [avg_page_lock_wait], 
		[page_io_latch_waits] [page_io_latch_wait_MS],
		CASE
			WHEN [page_io_latch_count] = 0 THEN 0 
			ELSE CAST(CAST([page_io_latch_waits] AS decimal(24,2)) / CAST([page_io_latch_count] AS decimal(24,2)) AS decimal(24,2)) 
		END [avg_page_io_latch_wait] 
	FROM 
		operational_stats; ';

	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);
	IF @TargetTables = N'{ALL}' BEGIN 
		SET @sql = REPLACE(@sql, N'{where}', N'');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{where}', NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + N'WHERE' + NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + NCHAR(9) + N' [object_id] IN (SELECT [object_id] FROM [#target_tables])');
	END;

	CREATE TABLE #operational_stats (
		[object_id] int NOT NULL,
		[index_id] int NOT NULL,
		[row_lock_wait_MS] bigint NULL,
		[avg_row_lock_wait] decimal(24,2) NULL,
		[page_lock_wait_MS] bigint NULL,
		[avg_page_lock_wait] decimal(24,2) NULL,
		[page_io_latch_wait_MS] bigint NULL,
		[avg_page_io_latch_wait] decimal(24,2) NULL
	);

	INSERT INTO [#operational_stats] (
		[object_id],
		[index_id],
		[row_lock_wait_MS],
		[avg_row_lock_wait],
		[page_lock_wait_MS],
		[avg_page_lock_wait],
		[page_io_latch_wait_MS],
		[avg_page_io_latch_wait]
	)
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@TargetDatabase sysname', 
		@TargetDatabase = @TargetDatabase;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Physical Stats:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	CREATE TABLE #physical_stats (
		[object_id] int NULL,
		[index_id] int NULL,
		[alloc_unit_type_desc] nvarchar(60) NULL,
		[index_depth] tinyint NULL,
		[index_level] tinyint NULL,
		[avg_fragmentation_percent] decimal(5,2) NULL,
		[fragment_count] bigint NULL
	);

	IF @IncludeFragmentationMetrics = 1 BEGIN

		SET @sql = N'SELECT
			[object_id],
			index_id,
			alloc_unit_type_desc, 
			index_depth, 
			index_level, 
			CAST(avg_fragmentation_in_percent AS decimal(5,2)) avg_fragmentation_percent,
			fragment_count
		FROM 
			sys.dm_db_index_physical_stats(DB_ID(@TargetDatabase), NULL, -1, 0, ''LIMITED''); ';

		INSERT INTO [#physical_stats] (
			[object_id],
			[index_id],
			[alloc_unit_type_desc],
			[index_depth],
			[index_level],
			[avg_fragmentation_percent],
			[fragment_count]
		)
		EXEC [sys].[sp_executesql]
			@sql, 
			N'@TargetDatabase sysname', 
			@TargetDatabase = @TargetDatabase;

	END;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Sizing Stats
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	SET @sql = N'SELECT
			[t].[object_id],
			[i].[index_id],
			[p].[rows] AS [row_count],
			CAST(((SUM([a].[total_pages]) * 8) / 1024.0) AS decimal(24, 2)) AS [allocated_mb],
			CAST(((SUM([a].[used_pages]) * 8) / 1024.0) AS decimal(24, 2)) AS [used_mb],
			CAST((((SUM([a].[total_pages]) - SUM([a].[used_pages])) * 8) / 1024.0) AS decimal(24, 2)) AS [unused_mb]
		FROM
			[{0}].[sys].[tables] [t]
			INNER JOIN [{0}].[sys].[indexes] [i] ON [t].[object_id] = [i].[object_id]
			INNER JOIN [{0}].[sys].[partitions] [p] ON [i].[object_id] = [p].[object_id] AND [i].[index_id] = [p].[index_id]
			INNER JOIN [{0}].[sys].[allocation_units] [a] ON [p].[partition_id] = [a].[container_id]{where}
		GROUP BY
			[t].[object_id],
			[i].[index_id],
			[p].[rows]; ';

	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);
	IF @TargetTables = N'{ALL}' BEGIN 
		SET @sql = REPLACE(@sql, N'{where}', N'');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{where}', NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + N'WHERE' + NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + NCHAR(9) + N' [t].[object_id] IN (SELECT [object_id] FROM [#target_tables])');
	END;

	CREATE TABLE #sizing_stats (
		[object_id] int NOT NULL,
		[index_id] int NOT NULL,
		[row_count] bigint NULL,
		[allocated_mb] decimal(24,2) NULL,
		[used_mb] decimal(24,2) NULL,
		[unused_mb] decimal(24,2) NULL
	);

	INSERT INTO [#sizing_stats] (
		[object_id],
		[index_id],
		[row_count],
		[allocated_mb],
		[used_mb],
		[unused_mb]
	)
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@TargetDatabase sysname', 
		@TargetDatabase = @TargetDatabase;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Buffering Stats
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	SET @sql = N'SELECT
		allocation_unit_id,
		COUNT(*) cached_page_count
	INTO 
		#buffers	
	FROM 
		sys.dm_os_buffer_descriptors WITH(NOLOCK)
	WHERE 
		[database_id] = DB_ID(@TargetDatabase)
	GROUP BY 
		[allocation_unit_id];
	
	WITH buffered AS ( 
		SELECT
			p.[object_id],
			p.[index_id],
			CAST((buffers.[cached_page_count]) * 8.0 / 1024.0 AS decimal(24,2)) AS [buffered_size_mb]
		FROM
			[#buffers] buffers
			INNER JOIN [{0}].sys.allocation_units AS au ON au.[allocation_unit_id] = buffers.[allocation_unit_id]
			INNER JOIN [{0}].sys.partitions AS p ON au.[container_id] = p.[partition_id]
			INNER JOIN [{0}].sys.indexes AS i ON i.[index_id] = p.[index_id] AND p.[object_id] = i.[object_id]{objects}
	)

	SELECT
		b.[object_id], 
		b.index_id, 
		b.buffered_size_mb
	FROM 
		buffered b ; ';

-- TODO: may need to remap allocation_unit_ids to containers/targets as per example listed here: https://docs.microsoft.com/en-us/sql/relational-databases/system-dynamic-management-views/sys-dm-os-buffer-descriptors-transact-sql?view=sql-server-ver15#examples

	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);
	IF @TargetTables = N'{ALL}' BEGIN 
		SET @sql = REPLACE(@sql, N'{objects}', N'');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{objects}', NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + NCHAR(9) + N'INNER JOIN #target_tables [t] ON [p].[object_id] = [t].[object_id]');
	END;


	CREATE TABLE #buffer_stats (
		[object_id] int NOT NULL,
		[index_id] int NOT NULL,
		[buffered_size_mb] decimal(24,2) NULL
	);

	INSERT INTO [#buffer_stats] (
		[object_id],
		[index_id],
		[buffered_size_mb]
	)
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@TargetDatabase sysname', 
		@TargetDatabase = @TargetDatabase;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Index Definition:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	DECLARE @ixDefinitions xml; 
	EXEC dbo.[script_indexes]
		@TargetDatabase = @TargetDatabase,
		@ExcludeHeaps = 1,
		@IncludeSystemTables = 0,
		@IncludeViews = 0,
		@SerializedOutput = @ixDefinitions OUTPUT; 

	CREATE TABLE #definitions (
		[object_id] int NOT NULL, 
		[index_id] int NOT NULL,
		[key_columns] nvarchar(MAX) NOT NULL, 
		[included_columns] nvarchar(MAX) NULL, 
		[definition] nvarchar(MAX) NOT NULL,
		PRIMARY KEY CLUSTERED ([object_id], [index_id])
	);

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'(object_id)[1]', N'int') [object_id],
			[data].[row].value(N'(index_id)[1]', N'int') [index_id],
			[data].[row].value(N'(key_columns)[1]', N'nvarchar(MAX)') [key_columns],
			[data].[row].value(N'(included_columns)[1]', N'nvarchar(MAX)') [included_columns],
			[data].[row].value(N'(definition)[1]', N'nvarchar(MAX)') [definition]
		FROM 
			@ixDefinitions.nodes(N'//object') [data]([row])
	)	

	INSERT INTO [#definitions] (
		[object_id],
		[index_id],
		[key_columns],
		[included_columns],
		[definition]
	)
	SELECT 
		[object_id],
		[index_id],
		[key_columns],
		[included_columns],
		[definition] 
	FROM 
		[shredded];

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Final Projection:
	----------------------------------------------------------------------------------------------------------------------------------------------------------
	SET @sql = N'WITH collapsed_physical_stats AS (
		SELECT 
			[object_id], 
			index_id,
			SUM([avg_fragmentation_percent]) [avg_fragmentation_percent], 
			SUM([fragment_count]) [fragment_count]
		FROM 
			[#physical_stats]	
		GROUP BY	
			[object_id], 
			index_id
	), 
	collapsed_buffer_stats AS ( 
		SELECT 
			[object_id], 
			index_id,
			SUM([buffered_size_mb]) [buffered_size_mb]
		FROM 
			[#buffer_stats]
		GROUP BY 
			[object_id], 
			index_id
	)

	{projectOrReturn}SELECT 
		--i.[object_id],
		i.[table_name],
		i.[index_id],
		ISNULL(i.[index_name], N'''') [index_name],
		--cd.[definition],
		[d].[key_columns], 
		[d].[included_columns],
		ss.[row_count],
		ISNULL(us.reads, 0) reads, 
		ISNULL(us.writes, 0) writes, 
		us.[read_write_ratio] [ratio], 
		{fragmentation_details}
		ss.allocated_mb, 
		ss.used_mb, 
		--ss.unused_mb,
		ISNULL(bs.buffered_size_mb, 0) cached_mb, 
		--br.buffered_percentage,
		ISNULL(us.user_seeks, 0) seeks, 
		ISNULL(us.user_scans, 0) scans, 
		ISNULL(us.user_lookups, 0) lookups,
		us.seek_ratio, 
		(SELECT 
			[name] ''@name'', [metric] ''@value''  FROM ( 
				VALUES
					(ISNULL(os.avg_row_lock_wait, 0), N''avg_row_lock_ms''),
					(ISNULL(os.avg_page_lock_wait, 0), N''avg_page_lock_ms''), 
					(ISNULL(os.avg_page_io_latch_wait, 0), N''avg_page_io_latch_ms'')
			) AS x([metric], [name])
		FOR XML PATH(''metric''), ROOT(''operational_metrics''), type) [operational_metrics]{definitions}
	FROM 
		#sys_indexes i
		--{IncludedTables}
		--{ExcludedTables}
		LEFT OUTER JOIN #usage_stats us ON i.[object_id] = us.[object_id] AND i.[index_id] = us.index_id
		LEFT OUTER JOIN #operational_stats os ON i.[object_id] = os.[object_id] AND i.index_id = os.index_id
		{physical_stats}
		LEFT OUTER JOIN #sizing_stats ss ON i.[object_id] = ss.[object_id] AND i.index_id = ss.index_id
		LEFT OUTER JOIN [collapsed_buffer_stats] bs ON i.[object_id] = bs.[object_id] AND i.index_id = bs.index_id
		--LEFT OUTER JOIN #column_definitions cd ON i.[object_id] = cd.[object_id] AND i.index_id = cd.index_id
		LEFT OUTER JOIN #definitions [d] ON [i].[object_id] = [d].[object_id] AND [i].[index_id] = [d].[index_id]
	WHERE
		1 = 1
		{IncludeSystemTables}
		{MinRequiredTableRowCount}
	ORDER BY 
		{ORDERBY} DESC{forxml}; ';

	-- predicates:
	IF @ExcludeSystemTables = 1 
		SET @sql = REPLACE(@sql, N'{IncludeSystemTables}', N'AND i.[type] = ''U'' '); -- exclude 'S'
	ELSE 
		SET @sql = REPLACE(@sql, N'{IncludeSystemTables}', N'');

	IF @MinRequiredTableRowCount <> 0 
		SET @sql = REPLACE(@sql, N'{MinRequiredTableRowCount}', N'AND ss.[row_count] > ' + CAST(@MinRequiredTableRowCount AS sysname));
	ELSE 
		SET @sql = REPLACE(@sql, N'{MinRequiredTableRowCount}', N'');

	IF @IncludeFragmentationMetrics = 1 BEGIN
		SET @sql = REPLACE(@sql, N'{fragmentation_details}', N'ps.avg_fragmentation_percent [fragmentation_%], ISNULL(ps.fragment_count, 0) [fragments],');
		SET @sql = REPLACE(@sql, N'{physical_stats}', N'LEFT OUTER JOIN [collapsed_physical_stats] ps ON i.[object_id] = ps.[object_id] AND i.index_id = ps.index_id');
	  END;
	ELSE BEGIN
		SET @sql = REPLACE(@sql, N'{fragmentation_details}', N'');
		SET @sql = REPLACE(@sql, N'{physical_stats}', N'');
	END;

	IF @TargetTables <> N'{ALL}' BEGIN 
		SET @sql = REPLACE(@sql, N'{IncludedTables}', N'INNER JOIN #target_tables targets ON i.table_name LIKE targets.table_name ');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{IncludedTables}', N'');
	END;

	-- etc... 
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	IF @IncludeDefinition = 1 BEGIN 
		SET @sql = REPLACE(@sql, N'{definitions}', N',' + @crlf + @tab + N'[d].[definition] [index_definition]');
	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{definitions}', N'');
	END;

	--IF @ExcludedTables IS NOT NULL BEGIN 
		
	--	SELECT [result] [table_name] 
	--	INTO #excluded_tables
	--	FROM dbo.[split_string](@ExcludedTables, N',', 1);		

	--	SET @sql = REPLACE(@sql, N'{ExcludedTables}', N'INNER JOIN #excluded_tables excluded ON i.table_name NOT LIKE excluded.table_name');
	--  END; 
	--ELSE BEGIN 
	--	SET @sql = REPLACE(@sql, N'{ExcludedTables}', N'');
	--END;

	-- sort order:
	DECLARE @sort sysname; 
	SELECT @sort = CASE NULLIF(@OrderBy, N'')
		WHEN NULL THEN N'ss.[row_count]'
		WHEN N'FRAGMENTATION' THEN N'ps.avg_fragmentation_percent'
		WHEN N'SIZE' THEN N'ss.allocated_mb'
		WHEN N'BUFFER_SIZE' THEN N'bs.buffered_size_mb'
		WHEN N'READS' THEN N'us.reads'
		WHEN N'WRITES' THEN N'us.writes' 
		ELSE N'ss.[row_count]'
	END;

	SET @sql = REPLACE(@sql, N'{ORDERBY}', @sort);

	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- RETURN instead of project.. 
		DECLARE @crlftab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);

		-- NOTE: the following line INCLUDES the ) for nesting the select @output = (nested_goes_here):
		SET @sql = REPLACE(@sql, N'{forxml}', @crlftab + N'FOR XML PATH(N''index''), ROOT (N''indexes''))');
		SET @sql = REPLACE(@sql, N'{projectOrReturn}', N'SELECT @output = (');

		--PRINT @sql;
		DECLARE @output xml;
		EXEC [sys].[sp_executesql]
			@sql, 
			N'@output xml OUTPUT', 
			@output = @output OUTPUT;

		SET @SerializedOutput = @output;

		RETURN 0;
	END;

	SET @sql = REPLACE(@sql, N'{forxml}', N'');
	SET @sql = REPLACE(@sql, N'{projectOrReturn}', N'');
	EXEC sp_executesql 
		@sql;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.script_indexes','P') IS NOT NULL
	DROP PROC dbo.[script_indexes];
GO

CREATE PROC dbo.[script_indexes]
	@TargetDatabase				sysname				= NULL, 
	@TargetTables				nvarchar(MAX)		= N'{ALL}', 
	@ExcludedTables				nvarchar(MAX)		= NULL,
	@TargetIndexes				sysname				= N'{ALL}', 
	@ExcludedIndexes			nvarchar(MAX)		= NULL,
	@ExcludeHeaps				bit					= 1,
	@IncludeSystemTables		bit					= 0, 
	@IncludeViews				bit					= 0, 
	@SerializedOutput			xml					= N'<default/>'	    OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @TargetTables = ISNULL(NULLIF(@TargetTables, N''), N'{ALL}'); 
	SET @TargetIndexes = ISNULL(NULLIF(@TargetIndexes, N''), N'{ALL}'); 

	SET @ExcludedTables = NULLIF(@ExcludedTables, N'');
	SET @ExcludedIndexes = NULLIF(@ExcludedIndexes, N'');

	SET @ExcludeHeaps = ISNULL(@ExcludeHeaps, 1);

	IF @TargetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @TargetDatabase OUTPUT;
		
		IF @TargetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for @TargetDatabase and/or S4 was unable to determine calling-db-context. Please specify a valid database name for @TargetDatabase and retry. ', 16, 1);
			RETURN -5;
		END;
	END;

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
    DECLARE @newAtrributeLine sysname = @crlf + NCHAR(9) + N' ';
	DECLARE @sql nvarchar(MAX);
	DECLARE @types sysname = N'''U'''; 
	IF @IncludeSystemTables = 1 SET @types = @types + N', ''S''';
	IF @IncludeViews = 1 SET @types = @types + N', ''V''';

	IF @ExcludedTables IS NOT NULL BEGIN 
		CREATE TABLE #excluded_tables (
			[table_name] sysname NOT NULL
		);

		INSERT INTO [#excluded_tables] ([table_name])
		SELECT [result] FROM dbo.split_string(@ExcludedTables, N',', 1);
	END;

	CREATE TABLE #target_tables (
		[table_name] sysname NOT NULL, 
		[object_id] int NULL
	);

	IF @TargetTables <> N'{ALL}' BEGIN 
		INSERT INTO [#target_tables] ([table_name])
		SELECT [result] FROM dbo.split_string(@TargetTables, N',', 1);

		IF EXISTS (SELECT NULL FROM [#target_tables] WHERE [table_name] LIKE N'%`%%' ESCAPE N'`') BEGIN 
			SET @sql = N'SELECT 
				[t].[name]
			FROM 
				[{0}].sys.[objects] [t]
				LEFT OUTER JOIN [#target_tables] [x] ON [t].[name] LIKE [x].[table_name]
			WHERE 
				[t].[type] IN ({types})
				AND [x].[table_name] LIKE N''%`%'' ESCAPE N''`''; '; 

			SET @sql = REPLACE(@sql, N'{types}', @types);
			SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);

			INSERT INTO [#target_tables] ([table_name]) 
			EXEC sys.sp_executesql 
				@sql; 

			DELETE FROM [#target_tables] WHERE [table_name] LIKE N'%`%%' ESCAPE N'`';
		END;

		SET @sql = N'USE [' + @TargetDatabase + N'];
		UPDATE #target_tables 
		SET 
			[object_id] = OBJECT_ID([table_name])
		WHERE 
			[object_id] IS NULL; ';

		EXEC sp_executesql 
			@sql;

		-- MKC: need to 'pre-exclude' here to avoid error about NOT finding an explicitly defined table. (AND need to exclude below as well).
		IF @ExcludedTables IS NOT NULL BEGIN 
			DELETE [t] 
			FROM 
				[#target_tables] [t] 
				INNER JOIN [#excluded_tables] [x] ON [t].[table_name] LIKE [x].[table_name];
		END;
		
		IF EXISTS (SELECT NULL FROM [#target_tables] WHERE [object_id] IS NULL) BEGIN 
			SELECT [table_name] [target_table], [object_id] FROM [#target_tables] WHERE [object_id] IS NULL; 

			RAISERROR(N'One or more supplied @TargetTables could not be identified (i.e., does not have a valid object_id). Please remove or correct.', 16, 1);
			RETURN -11;
		END;
	END;

	CREATE TABLE #target_indexes (
		[object_name] sysname NOT NULL, 
		[object_id] sysname NOT NULL, 
		[schema_id] int NOT NULL,
		[object_type] char(1) NOT NULL,
		[index_id] int NOT NULL, 
		[index_name] sysname NULL 
		-- other cols here as needed
	);

	SET @sql = N'	SELECT 
		[o].[name], 
		[o].[object_id], 
		[o].[schema_id], 
		[o].[type],
		[i].[index_id], 
		[i].[name]
	FROM 
		[{0}].sys.objects [o] 
		INNER JOIN [{0}].sys.indexes [i] ON [o].[object_id] = [i].[object_id] 
	WHERE 
		[o].[type] IN ({types}){filter}; ';

	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);
	SET @sql = REPLACE(@sql, N'{types}', @types);
	
	IF UPPER(@TargetTables) = N'{ALL}' BEGIN 
		SET @sql = REPLACE(@sql, N'{filter}', N'');
	  END; 
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{filter}', @newAtrributeLine + NCHAR(9) + N'AND [o].[name] IN (SELECT [table_name] FROM [#target_tables])');
	END;

	INSERT INTO [#target_indexes] ([object_name], [object_id], [schema_id], [object_type], [index_id], [index_name])
	EXEC sys.sp_executesql 
		@sql;

	IF @ExcludedTables IS NOT NULL BEGIN 
		DELETE [t] 
		FROM 
			[#target_indexes] [t] 
			INNER JOIN [#excluded_tables] [x] ON [t].[object_name] LIKE [x].[table_name];
	END; 

	IF @ExcludedIndexes IS NOT NULL BEGIN 
		DELETE [t] 
		FROM 
			[#target_indexes] [t] 
			INNER JOIN (SELECT [result] FROM dbo.[split_string](@ExcludedIndexes, N',', 1)) [x] ON [t].[index_name] LIKE [x].[result];
	END;
	
	IF NOT EXISTS (SELECT NULL FROM [#target_indexes]) BEGIN 
		PRINT N'No matches found for provided inputs.';
		RETURN 0;  
	END;
	
	CREATE TABLE #indexes_to_script (
		[schema_name] sysname NOT NULL,
		[object_type] char(1) NOT NULL,
		[object_id] int NOT NULL,
		[object_name] sysname NOT NULL,
		[index_id] int NOT NULL,
		[index_name] sysname NULL,
		[type_desc] nvarchar(60) NULL,
		[key_columns] nvarchar(4000) NULL,
		[included_columns] nvarchar(4000) NULL,
		[is_unique] bit NULL,
		[data_space_id] int NULL,
		[dataspace_name] sysname NULL,
		[partition_scheme_name] sysname NULL,
		[ignore_dup_key] bit NULL,
		[is_primary_key] bit NULL,
		[is_unique_constraint] bit NULL,
		[fill_factor] tinyint NOT NULL,
		[is_padded] bit NULL,
		[is_disabled] bit NULL,
		--[is_ignored_in_optimization] bit NULL,
		[allow_row_locks] bit NULL,
		[allow_page_locks] bit NULL,
		[filter_definition] nvarchar(max) NULL,
		[compression_delay] int NULL,
		--[suppress_dup_key_messages] bit NULL,  -- 2017+
		--[optimize_for_sequential_key] bit NULL  -- 2019+ 
	);

	-- TODO: figure out a) IF [is_ignored_in_optimization] is something that needs to be part of IX definitions/scripts and b) when it was added 
	IF (SELECT dbo.[get_engine_version]()) >= 14.00 BEGIN 
		ALTER TABLE [#indexes_to_script] ADD [suppress_dup_key_messages] bit NULL;
	END;

	IF (SELECT dbo.[get_engine_version]()) >= 15.00 BEGIN 
		ALTER TABLE [#indexes_to_script] ADD [optimize_for_sequential_key] bit NULL;
	END;

	SET @sql = N'	SELECT 
		[s].[name] [schema_name],
		[x].[object_type],
		[x].[object_id],
		[x].[object_name],
		[x].[index_id],
		[x].[index_name],
		[i].[type_desc],
		--(SELECT STRING_AGG((QUOTENAME([c].[name]) + CASE WHEN [ic].[is_descending_key] = 1 THEN N'' DESC'' ELSE N'''' END), N'', '') WITHIN GROUP(ORDER BY [ic].[key_ordinal]) FROM [{0}].sys.[index_columns] [ic] INNER JOIN [{0}].sys.columns [c] ON [ic].[object_id] = [c].[object_id] AND [ic].[column_id] = [c].[column_id] WHERE [ic].[key_ordinal] > 0 AND [ic].[object_id] = [i].[object_id] AND [ic].[index_id] = [i].[index_id]) [key_columns], 
		--(SELECT STRING_AGG(QUOTENAME([c].[name]), N'', '') WITHIN GROUP(ORDER BY [ic].[key_ordinal]) FROM [{0}].sys.[index_columns] [ic] INNER JOIN [{0}].sys.columns [c] ON [ic].[object_id] = [c].[object_id] AND [ic].[column_id] = [c].[column_id] WHERE [ic].[is_included_column] = 1 AND [ic].[object_id] = [i].[object_id] AND [ic].[index_id] = [i].[index_id]) [included_columns],
		(SELECT STUFF((SELECT N'','' + QUOTENAME([c].[name]) + CASE WHEN [ic].[is_descending_key] = 1 THEN N'' DESC'' ELSE N'''' END FROM [{0}].sys.[index_columns] [ic] INNER JOIN [{0}].sys.columns [c] ON [ic].[object_id] = [c].[object_id] AND [ic].[column_id] = [c].[column_id] WHERE [ic].[key_ordinal] > 0 AND [ic].[object_id] = [i].[object_id] AND [ic].[index_id] = [i].[index_id] ORDER BY [ic].[key_ordinal] FOR XML PATH(N''''), TYPE).value(N''.'', N''nvarchar(MAX)''), 1, 1, N'''')) [key_columns],
		(SELECT STUFF((SELECT N'','' + QUOTENAME([c].[name]) FROM [{0}].sys.[index_columns] [ic] INNER JOIN [{0}].sys.columns [c] ON [ic].[object_id] = [c].[object_id] AND [ic].[column_id] = [c].[column_id] WHERE [ic].[is_included_column] = 1 AND [ic].[object_id] = [i].[object_id] AND [ic].[index_id] = [i].[index_id] ORDER BY [ic].[key_ordinal] FOR XML PATH(N''''), TYPE).value(N''.'', N''nvarchar(MAX)''), 1, 1, N'''')) [included_columns],
		[i].[is_unique],
		[i].[data_space_id], 
		[d].[name] [dataspace_name],
		[ps].[name] [partition_scheme_name], -- TODO: going to have to look up the columns? for this? 
		[i].[ignore_dup_key],
		[i].[is_primary_key],
		[i].[is_unique_constraint],
		[i].[fill_factor],
		[i].[is_padded],
		[i].[is_disabled],
		--[i].[is_ignored_in_optimization], -- no idea when this was added ... 
		[i].[allow_row_locks],
		[i].[allow_page_locks],
		--[i].[has_filter],
		[i].[filter_definition],
		[i].[compression_delay]
		--[i].[suppress_dup_key_messages],
		--[i].[optimize_for_sequential_key] 
	FROM 
		[{0}].sys.indexes [i]
		INNER JOIN [#target_indexes] [x] ON [i].[object_id] = [x].[object_id] AND [i].[index_id] = [x].[index_id]
		INNER JOIN [{0}].sys.[schemas] [s] ON [x].[schema_id] = [s].[schema_id]
		LEFT OUTER JOIN [{0}].sys.[data_spaces] [d] ON [i].[data_space_id] = [d].[data_space_id]
		LEFT OUTER JOIN [{0}].sys.[partition_schemes] [ps] ON [i].[data_space_id] = [ps].[data_space_id]
	ORDER BY 
		[x].[object_name], [i].[index_id]; ';

	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase);

	INSERT INTO [#indexes_to_script] (
		[schema_name],
		[object_type],
		[object_id],
		[object_name],
		[index_id],
		[index_name],
		[type_desc],
		[key_columns],
		[included_columns],
		[is_unique],
		[data_space_id],
		[dataspace_name],
		[partition_scheme_name],
		[ignore_dup_key],
		[is_primary_key],
		[is_unique_constraint],
		[fill_factor],
		[is_padded],
		[is_disabled],
		--[is_ignored_in_optimization],
		[allow_row_locks],
		[allow_page_locks],
		[filter_definition],
		[compression_delay]--,
		--[suppress_dup_key_messages],
		--[optimize_for_sequential_key]
	)
	EXEC sys.[sp_executesql]
		@sql;
	
	IF @ExcludeHeaps = 1 BEGIN 
		DELETE FROM [#indexes_to_script] WHERE [index_id] = 0;
	END;
	   
	WITH options AS ( 
		SELECT 
			[object_id], 
			[index_id],
			CASE WHEN [is_padded] = 1 THEN N'PAD_INDEX = ON, ' ELSE N'' END 
				-- + stats recompute (where do i even find this?)
				-- + compression (page/row/none (default))
				--		though... this can also be defined by partitions ... so... that's complex. 
				-- + sort_in_tempdb... (directive)
				-- + drop_existing... (directive)
				-- + ONLINE (directive)
			+ CASE WHEN [allow_row_locks] = 0 THEN N' ALLOW_ROW_LOCKS = OFF,' ELSE N'' END 
			+ CASE WHEN [allow_page_locks] = 0 THEN N' ALLOW_PAGE_LOCKS = OFF' ELSE N'' END
			+ CASE WHEN [fill_factor] <> 0 THEN N' FILLFACTOR = ' + CAST([fill_factor] AS sysname) + N', ' ELSE N'' END
			 [options]
		FROM 
			[#indexes_to_script] 
	)

	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		[i].[object_id],
		[i].[index_id],
		[i].[schema_name], 
		[i].[object_name], 
		[i].[index_name],
		[i].[key_columns], 
		[i].[included_columns],
		CASE 
			WHEN [i].[index_id] = 0 THEN N'-- HEAP: ' + QUOTENAME([i].[schema_name]) + N'.' + QUOTENAME([object_name]) + @crlf
			ELSE 
				CASE WHEN [i].[is_primary_key] = 1 THEN N'ALTER TABLE ' + QUOTENAME([i].[schema_name]) + N'.' + QUOTENAME([object_name]) + N' ADD CONSTRAINT ' + QUOTENAME([i].[index_name]) + @crlf + N'PRIMARY KEY ' + CASE WHEN [i].[index_id] = 1 THEN N'CLUSTERED' ELSE N'' END + N' '
				ELSE N'CREATE ' + CASE WHEN [i].[is_unique] = 1 THEN N'UNIQUE' ELSE N'' END + CASE WHEN [i].[index_id] = 1 THEN N'' ELSE N'NON' END + N'CLUSTERED INDEX' + ' ' + QUOTENAME([i].[index_name]) + N' ' + @crlf + N'ON ' + QUOTENAME([i].[schema_name]) + N'.' + QUOTENAME([i].[object_name])
			END
			+ N'(' + [i].[key_columns] + N')'
			+ CASE WHEN [i].[included_columns] IS NOT NULL THEN @crlf + N'INCLUDE(' + [i].[included_columns] + N')' ELSE N'' END
			+ CASE WHEN [i].[filter_definition] IS NOT NULL THEN @crlf + N'WHERE ' + [i].[filter_definition] + N' ' ELSE N'' END
			+ CASE WHEN NULLIF(ISNULL([o].[options], N''), N'') IS NULL THEN N'' ELSE @crlf + N'WITH (' + LTRIM(LEFT([o].[options], LEN([o].[options]) - 1)) + N')' END
			+ @crlf + CASE WHEN [i].[partition_scheme_name] IS NULL THEN N'ON ' + QUOTENAME([i].[dataspace_name]) + N'' ELSE N'<partition_scheme_column_here>' END
			+ N';' + @crlf 
			
		END + @crlf [definition]
	INTO 
		#projected_indexes
	FROM 
		[#indexes_to_script] [i]
		INNER JOIN [options] [o] ON [i].[object_id] = [o].[object_id] AND [i].[index_id] = [o].[index_id]
	ORDER BY 
		[i].[object_name], [i].[index_id];

	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- RETURN instead of project.. 
		SELECT @SerializedOutput = (
			SELECT 
				[object_id],
				[index_id],
				[schema_name],
				[object_name],
				[index_name],
				[key_columns], 
				[included_columns],
				[definition]
			FROM 
				[#projected_indexes] 
			ORDER BY 
				[row_id]
			FOR XML PATH(N'object'), ROOT(N'objects'), TYPE
		);

		RETURN 0;
	END;

	-- otherwise: 
	DECLARE @output nvarchar(MAX) = N'';
	SELECT 
		@output = @output + [definition] 
	FROM 
		[#projected_indexes] 
	ORDER BY 
		[row_id];

	EXEC [dbo].[print_long_string] @output;

	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.help_index','P') IS NOT NULL
	DROP PROC dbo.[help_index];
GO

CREATE PROC dbo.[help_index]
	@Target					sysname				= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @Target, 
		@ParameterNameForTarget = N'@Target', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 
	
	DECLARE @targetDatabase sysname, @targetSchema sysname, @targetTable sysname;
	SELECT 
		@targetDatabase = PARSENAME(@normalizedName, 3),
		@targetSchema = PARSENAME(@normalizedName, 2), 
		@targetTable = PARSENAME(@normalizedName, 1);

	-- See vNEXT about ... not supporting schema names currently.
	--	2024-03-29 (I added the following - and .. it seems to work?)
	DECLARE @targetTableName sysname = QUOTENAME(@targetSchema) + N'.' + QUOTENAME(@targetTable);

	DECLARE @indexData xml; 
	EXEC dbo.[list_index_metrics]
		@TargetDatabase = @targetDatabase,
		@TargetTables = @targetTableName,
		@ExcludeSystemTables = 1,
		@IncludeFragmentationMetrics = 0,
		@MinRequiredTableRowCount = 0,
		@SerializedOutput = @indexData OUTPUT; 

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'(table_name)[1]', N'sysname') [table_name], 
			[data].[row].value(N'(index_id)[1]', N'int') [index_id], 
			[data].[row].value(N'(index_name)[1]', N'sysname') [index_name], 
			[data].[row].value(N'(index_definition)[1]', N'nvarchar(MAX)') [index_definition], 
			[data].[row].value(N'(key_columns)[1]', N'nvarchar(MAX)') [key_columns], 
			[data].[row].value(N'(included)[1]', N'nvarchar(MAX)') [included_columns], 
			[data].[row].value(N'(row_count)[1]', N'bigint') [row_count], 
			[data].[row].value(N'(reads)[1]', N'bigint') [reads], 
			[data].[row].value(N'(writes)[1]', N'bigint') [writes], 
			[data].[row].value(N'(allocated_mb)[1]', N'decimal(24,2)') [allocated_mb], 
			[data].[row].value(N'(used_mb)[1]', N'decimal(24,2)') [used_mb], 
			[data].[row].value(N'(cached_mb)[1]', N'decimal(24,2)') [cached_mb], 
			[data].[row].value(N'(seeks)[1]', N'bigint') [seeks], 
			[data].[row].value(N'(scans)[1]', N'bigint') [scans], 
			[data].[row].value(N'(lookups)[1]', N'bigint') [lookups], 
			[data].[row].value(N'(seek_ratio)[1]', N'decimal(5,2)') [seek_ratio],
			[data].[row].query(N'(//operational_metrics/operational_metrics)[1]') [operational_metrics]
		FROM 
			@indexData.nodes(N'//index') [data]([row])
	) 

	SELECT 
		* 
	INTO 
		#hydrated 
	FROM 
		[shredded];

	SELECT
		[index_id],
		[index_name],
		[key_columns],
		[included_columns],
		N' ' [ ],
		[row_count],
		[reads],
		[writes],
		[allocated_mb],
		[used_mb],
		[cached_mb],
		[seeks],
		[scans],
		[lookups],
		[seek_ratio],
		[operational_metrics], 
		[index_definition]
	FROM 
		#hydrated
	ORDER BY 
		[index_id];
	
	SELECT 
		SUM(CASE WHEN [index_id] IN (0,1) THEN [allocated_mb] ELSE 0 END) [data], 
		SUM(CASE WHEN [index_id] NOT IN (0,1) THEN [allocated_mb] ELSE 0 END) [index]
	FROM 
		[#hydrated] 

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_heaps','P') IS NOT NULL
	DROP PROC dbo.[list_heaps];
GO

CREATE PROC dbo.[list_heaps]
	@TargetDatabase					sysname
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	CREATE TABLE #sizes (
		[object_id] int NOT NULL, 
		[heap_name] sysname NOT NULL, 
		[row_count] bigint NOT NULL, 
		[reserved_gb] decimal(10,1) NOT NULL,
		[data_gb] decimal(10,1) NOT NULL, 
		[indexes_gb] decimal(10,1) NOT NULL, 
		[unused_gb] decimal(10,1) NOT NULL
	);

	DECLARE @isMemOptimizedChecks nvarchar(MAX) = N'
			WHERE
				[ps].[object_id] NOT IN (SELECT [object_id] FROM [sys].[tables] WHERE [is_memory_optimized] = 1)'; 

	DECLARE @sql nvarchar(MAX) = N'WITH metrics AS ( 
			SELECT
				[ps].[object_id],
				SUM(CASE WHEN ([ps].[index_id] < 2) THEN [row_count] ELSE 0	END) AS [row_count],
				SUM([ps].[reserved_page_count]) AS [reserved],
				SUM(CASE WHEN ([ps].[index_id] < 2) THEN ([ps].[in_row_data_page_count] + [ps].[lob_used_page_count] + [ps].[row_overflow_used_page_count]) ELSE ([ps].[lob_used_page_count] + [ps].[row_overflow_used_page_count])	END) AS [data],
				SUM([ps].[used_page_count]) AS [used]
			FROM
				[{targetDatabase}].[sys].[dm_db_partition_stats] [ps]{MemoryOptimizedChecks}
			GROUP BY
				[ps].[object_id]	
	), 
	expanded AS ( 
		SELECT 
			[m].[object_id],
			[m].[row_count], 
			[m].[reserved] * 8 [reserved], 
			[m].[data] * 8 [data],
			CASE WHEN [m].[used] > [m].[data] THEN [m].[used] - [m].[data] ELSE 0 END * 8 [index_size], 
			CASE WHEN [m].[reserved] > [m].[used] THEN [m].[reserved] - [m].[used] ELSE 0 END * 8 [unused]
		FROM 
			[metrics] [m]
	)

	SELECT
		[e].[object_id],
		[s].[name] + N''.'' + [t].[name] [table_name],
		[e].[row_count] [row_count],
		[e].[reserved] / 1048576.00 [reserved_gb],
		[e].[data] / 1048576.00 [data_gb],
		[e].[index_size] / 1048576.00 [indexes_gb], 
		[e].[unused] / 1048576.00 [unused_gb]
	FROM 
		[expanded] [e]
		INNER JOIN [{targetDatabase}].sys.[tables] [t] ON [e].[object_id] = [t].[object_id]
		INNER JOIN [{targetDatabase}].sys.schemas [s] ON [t].[schema_id] = [s].[schema_id]; ';
		
	SET @sql = REPLACE(@sql, N'{targetDatabase}', @TargetDatabase);

	IF dbo.[get_engine_version]() >= 12.0 
		SET @sql = REPLACE(@sql, N'{MemoryOptimizedChecks}', @isMemOptimizedChecks);
	ELSE 
		SET @sql = REPLACE(@sql, N'{MemoryOptimizedChecks}', N'');
	
	INSERT INTO [#sizes] (
		[object_id],
		[heap_name],
		[row_count],
		[reserved_gb],
		[data_gb],
		[indexes_gb],
		[unused_gb]
	)
	EXEC sys.[sp_executesql]
		@sql;	


	CREATE TABLE #heaps (
		[object_id] int NOT NULL,
		[heap_name] sysname NOT NULL, 
		[avg_page_space_used_in_percent] decimal(5,2) NULL,
		[ghost_record_count] bigint NULL,
		[avg_record_size_in_bytes] float NULL,
		[forwarded_record_count] bigint NULL
	);

	SET @sql = N'WITH heaps AS (
		SELECT 
			[i].[object_id], 
			[t].[name] [table_name]
		FROM 
			[{targetDatabase}].sys.[indexes] [i]
			INNER JOIN [{targetDatabase}].sys.[tables] [t] ON [i].[object_id] = [t].[object_id]
		WHERE 
			[i].[type] = 0 
			AND [i].[is_hypothetical] = 0
	)

	SELECT 
		[h].[object_id],
		[h].[table_name] [heap_name],
		[s].[avg_page_space_used_in_percent],
		[s].[ghost_record_count],
		[s].[avg_record_size_in_bytes],
		[s].[forwarded_record_count]
	FROM 
		heaps h
		CROSS APPLY sys.[dm_db_index_physical_stats](DB_ID(''{targetDatabase}''), [h].[object_id], 0, NULL, N''SAMPLED'') s; ';

	SET @sql = REPLACE(@sql, N'{targetDatabase}', @TargetDatabase);

	INSERT INTO [#heaps] (
		[object_id],
		[heap_name],
		[avg_page_space_used_in_percent],
		[ghost_record_count],
		[avg_record_size_in_bytes],
		[forwarded_record_count]
	)
	EXEC sp_executesql 
		@sql;


	WITH heaps AS (
		SELECT 
			[object_id],
			[heap_name],
			SUM(ISNULL([avg_page_space_used_in_percent], 0.0)) [avg_page_space_used_in_percent],
			SUM(ISNULL([ghost_record_count],0)) [ghost_record_count],
			SUM(ISNULL([avg_record_size_in_bytes], 0.0)) [avg_record_size_in_bytes],
			SUM(ISNULL([forwarded_record_count], 0)) [forwarded_record_count]
		FROM 
			[#heaps] 
		GROUP BY 
			[object_id], [heap_name]
	)

	SELECT 
		[h].[heap_name],
		[s].[row_count],
		[s].[reserved_gb],
		[s].[data_gb],
		[s].[indexes_gb],
		[s].[unused_gb],
		N'' [ ],
		[h].[avg_page_space_used_in_percent],
		[h].[ghost_record_count],
		[h].[avg_record_size_in_bytes],
		[h].[forwarded_record_count]
	FROM 
		[heaps] [h]
		INNER JOIN [#sizes] [s] ON [h].[object_id] = [s].[object_id]
	ORDER BY 
		[s].[reserved_gb] DESC;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_problem_heaps','P') IS NOT NULL
	DROP PROC dbo.[list_problem_heaps];
GO

CREATE PROC dbo.[list_problem_heaps]
	@TargetDatabase							sysname, 
	@PageUsagePercentBelowThreshold			decimal(5,2)	= 20.0
AS
    SET NOCOUNT ON; 

	SET @PageUsagePercentBelowThreshold = ISNULL(@PageUsagePercentBelowThreshold, 20.0);

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	CREATE TABLE #sizes (
		[object_id] int NOT NULL, 
		[heap_name] sysname NOT NULL, 
		[row_count] bigint NOT NULL, 
		[reserved_gb] decimal(10,1) NOT NULL,
		[data_gb] decimal(10,1) NOT NULL, 
		[indexes_gb] decimal(10,1) NOT NULL, 
		[unused_gb] decimal(10,1) NOT NULL
	);

	DECLARE @sql nvarchar(MAX) = N'WITH metrics AS ( 
			SELECT
				[ps].[object_id],
				SUM(CASE WHEN ([ps].[index_id] < 2) THEN [row_count] ELSE 0	END) AS [row_count],
				SUM([ps].[reserved_page_count]) AS [reserved],
				SUM(CASE WHEN ([ps].[index_id] < 2) THEN ([ps].[in_row_data_page_count] + [ps].[lob_used_page_count] + [ps].[row_overflow_used_page_count]) ELSE ([ps].[lob_used_page_count] + [ps].[row_overflow_used_page_count])	END) AS [data],
				SUM([ps].[used_page_count]) AS [used]
			FROM
				[{targetDatabase}].[sys].[dm_db_partition_stats] [ps]
			WHERE
				[ps].[object_id] NOT IN (SELECT [object_id] FROM [sys].[tables] WHERE [is_memory_optimized] = 1)
			GROUP BY
				[ps].[object_id]	
	), 
	expanded AS ( 
		SELECT 
			[m].[object_id],
			[m].[row_count], 
			[m].[reserved] * 8 [reserved], 
			[m].[data] * 8 [data],
			CASE WHEN [m].[used] > [m].[data] THEN [m].[used] - [m].[data] ELSE 0 END * 8 [index_size], 
			CASE WHEN [m].[reserved] > [m].[used] THEN [m].[reserved] - [m].[used] ELSE 0 END * 8 [unused]
		FROM 
			[metrics] [m]
	)

	SELECT
		[e].[object_id],
		[s].[name] + N''.'' + [t].[name] [table_name],
		[e].[row_count] [row_count],
		[e].[reserved] / 1048576.00 [reserved_gb],
		[e].[data] / 1048576.00 [data_gb],
		[e].[index_size] / 1048576.00 [indexes_gb], 
		[e].[unused] / 1048576.00 [unused_gb]
	FROM 
		[expanded] [e]
		INNER JOIN [{targetDatabase}].sys.[tables] [t] ON [e].[object_id] = [t].[object_id]
		INNER JOIN [{targetDatabase}].sys.schemas [s] ON [t].[schema_id] = [s].[schema_id]; ';
		
	SET @sql = REPLACE(@sql, N'{targetDatabase}', @TargetDatabase);

	IF (SELECT dbo.[get_engine_version]()) <= 11.00 BEGIN 
		SET @sql = REPLACE(@sql, N'
			WHERE
				[ps].[object_id] NOT IN (SELECT [object_id] FROM [sys].[tables] WHERE [is_memory_optimized] = 1)', N'');
	END;

	INSERT INTO [#sizes] (
		[object_id],
		[heap_name],
		[row_count],
		[reserved_gb],
		[data_gb],
		[indexes_gb],
		[unused_gb]
	)
	EXEC sys.[sp_executesql]
		@sql;
	
	/* Identify HEAPS with avg_page_space_used_in_percent < @PageUsagePercent  */
	CREATE TABLE #potentialProblems (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[object_id] int NOT NULL,
		[heap_name] sysname NOT NULL, 
		[avg_page_space_used_in_percent] decimal(5,2) NOT NULL,
		[page_count] bigint NOT NULL,
		[record_count] bigint NOT NULL,
		[ghost_record_count] bigint NOT NULL,
		[avg_record_size_in_bytes] float NOT NULL,
		[forwarded_record_count] bigint NOT NULL
	);

	SET @sql = N'WITH heaps AS (
		SELECT 
			[i].[object_id], 
			[t].[name] [table_name]
		FROM 
			[{targetDatabase}].sys.[indexes] [i]
			INNER JOIN [{targetDatabase}].sys.[tables] [t] ON [i].[object_id] = [t].[object_id]
		WHERE 
			[i].[type] = 0 
			AND [i].[is_hypothetical] = 0
	)

	SELECT 
		[h].[object_id],
		[h].[table_name] [heap_name],
		[s].[avg_page_space_used_in_percent],
		[s].[page_count],
		[s].[record_count],
		[s].[ghost_record_count],
		[s].[avg_record_size_in_bytes],
		[s].[forwarded_record_count]
	FROM 
		heaps h
		CROSS APPLY sys.[dm_db_index_physical_stats](DB_ID(''{targetDatabase}''), [h].[object_id], 0, NULL, N''SAMPLED'') s
	WHERE
		[s].[record_count] > 0
		AND [s].[page_count] > 1300  -- don''t bother with tables < ~10MB in size... 
		AND [s].[avg_page_space_used_in_percent] < @PageUsagePercentBelowThreshold; ';

	SET @sql = REPLACE(@sql, N'{targetDatabase}', @TargetDatabase);

	INSERT INTO [#potentialProblems] (
		[object_id],
		[heap_name],
		[avg_page_space_used_in_percent],
		[page_count],
		[record_count],
		[ghost_record_count],
		[avg_record_size_in_bytes],
		[forwarded_record_count]
	)
	EXEC sp_executesql
		@sql, 
		N'@PageUsagePercentBelowThreshold decimal(5,2)', 
		@PageUsagePercentBelowThreshold = @PageUsagePercentBelowThreshold;	


	/* Now that we've identified POTENTIAL problems, grab more detailed metrics */
	CREATE TABLE #detailedFragmentation (
		[object_id] int NOT NULL, 
		[avg_fragmentation_in_percent] decimal(5,2) NOT NULL
	);

	SET @sql = N'SELECT 
		[p].[object_id],
		[s].[avg_fragmentation_in_percent]
	FROM 
		[#potentialProblems] p 
		CROSS APPLY sys.[dm_db_index_physical_stats](DB_ID(''{targetDatabase}''), [p].[object_id], 0, NULL, ''DETAILED'') s; ';

	SET @sql = REPLACE(@sql, N'{targetDatabase}', @TargetDatabase);

	INSERT INTO [#detailedFragmentation] (
		[object_id],
		[avg_fragmentation_in_percent]
	)
	EXEC sp_executesql
		@sql;

	--SELECT * FROM [#tableSizes];
	--SELECT * FROM [#potentialProblems];
	--SELECT * FROM [#detailedFragmentation];

	WITH core AS ( 
		SELECT 
			[p].[heap_name],
			[s].[row_count], 
			[s].[reserved_gb], 
			[s].[data_gb], 
			[s].[indexes_gb],
			[f].[avg_fragmentation_in_percent],
			[p].[avg_page_space_used_in_percent],
			[p].[ghost_record_count],
			[p].[forwarded_record_count],
			[p].[avg_record_size_in_bytes],
			([p].[avg_record_size_in_bytes] * [p].[record_count]) / 1073741824.000 [expected_size_gb]

		FROM 
			[#potentialProblems] [p]
			INNER JOIN [#detailedFragmentation] [f] ON [p].[object_id] = [f].[object_id]
			INNER JOIN [#sizes] [s] ON [p].[object_id] = [s].[object_id]
	) 

	SELECT 
		[heap_name],
		FORMAT([row_count], N'N0') [row_count],
		FORMAT([reserved_gb], N'N1') [reserved_gb],
		FORMAT([data_gb], N'N1') [data_gb],
		FORMAT([indexes_gb], N'N1') [indexes_gb],
		'' [ ],
		FORMAT([avg_fragmentation_in_percent], N'N1') [avg_frag_%],
		FORMAT([avg_page_space_used_in_percent], N'N1') [avg_page_use_%],
		FORMAT([ghost_record_count], N'N0') [ghost_records],
		FORMAT([forwarded_record_count], N'N0') [forwarded_records],
		FORMAT([avg_record_size_in_bytes], N'N1') [avg_record_size],
		'' [=>],
		FORMAT([expected_size_gb], N'N1') [expected_size_gb], 
		CASE WHEN [reserved_gb] > [expected_size_gb] THEN FORMAT((([reserved_gb] - [expected_size_gb])), N'N1') ELSE FORMAT((0 - [expected_size_gb] - [reserved_gb]), N'N1') END [size_diff_gb]
	FROM 
		core 
	ORDER BY 
		[core].[reserved_gb] DESC;

	RETURN 0;
GO	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.plancache_columns_by_index','P') IS NOT NULL
	DROP PROC dbo.[plancache_columns_by_index];
GO

CREATE PROC dbo.[plancache_columns_by_index]
	@TargetDatabase				sysname = NULL,
	@TargetIndex				sysname
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @TargetDatabase = NULLIF(@TargetDatabase, N'');
	SELECT @TargetIndex = REPLACE(REPLACE(@TargetIndex, N']', N''), N'[', N''); 

	IF @TargetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @TargetDatabase OUTPUT;

		IF @TargetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for %s and/or S4 was unable to determine calling-db-context. ', 16, 1);
			RETURN -5;
		END;
	END;

	DECLARE @targetTable sysname; 
	DECLARE @sql nvarchar(MAX) = N'SELECT 
		@targetTable = [o].[name]
	FROM 
		[{targetDb}].sys.indexes i 
		INNER JOIN [{targetDb}].sys.objects o ON [i].[object_id] = [o].[object_id]
	WHERE 
		[i].[name] = @TargetIndex; ';

	SET @sql = REPLACE(@sql, N'{targetDb}', @TargetDatabase);

	EXEC sp_executesql 
		@sql, 
		N'@targetTable sysname OUTPUT, @TargetIndex sysname', 
		@targetTable = @targetTable OUTPUT, 
		@TargetIndex = @TargetIndex;

	CREATE TABLE #columnNames (
		[column_id] int NOT NULL, 
		[name] sysname NOT NULL 
	);
	
	SET @sql = N'SELECT 
		[c].[column_id],
		[c].[name]
	FROM 
		[{targetDb}].sys.[all_columns] c
		INNER JOIN [{targetDb}].sys.objects [o] ON [c].[object_id] = [o].[object_id]
	WHERE 
		[o].[name] = @targetTable; ';

	SET @sql = REPLACE(@sql, N'{targetDb}', @TargetDatabase);

	INSERT INTO [#columnNames] ([column_id],[name])
	EXEC sys.sp_executesql 
		@sql, 
		N'@targetTable sysname', 
		@targetTable = @targetTable;

	IF NOT EXISTS (SELECT NULL FROM [#columnNames]) BEGIN 
		RAISERROR('Invalid @TargetIndex specified - or @TargetIndex NOT found in CURRENT database. Either specify @TargetDatabase or EXECUTE this sproc from within database with @TargetIndex.', 16, 1);
		RETURN -10;		
	END;

	SET @TargetIndex = QUOTENAME(@TargetIndex);
	
	/* 
		DRY VIOLATION: The code below is 98% duplicated between plancache_columns_by_index and plancache_columns_by_table. 
				The ONLY differences are the WHERE clauses (2x in the core CTE + projection) for .exist()... 
			TODO: https://overachieverllc.atlassian.net/browse/S4-516
	*/

	/* Find all plans with REFERENCES to the table in question: */
	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan'),
	core AS (
		SELECT 
			ROW_NUMBER() OVER(ORDER BY [cp].[plan_handle]) [plan_number],
			[cp].[usecounts],
			[cp].[cacheobjtype],
			[qp].[query_plan]
		FROM 
			sys.[dm_exec_cached_plans] cp 
			CROSS APPLY sys.[dm_exec_query_plan](cp.[plan_handle]) qp
		WHERE 
			[qp].[dbid] = DB_ID(@TargetDatabase)
			AND [qp].[query_plan].exist('//Object[@Index=sql:variable("@TargetIndex")]') = 1
	)

	SELECT 
		[c].[plan_number],
		[c].[usecounts],
		[c].[cacheobjtype],
		[c].[query_plan], 
		[n].[node].value(N'(@NodeId)[1]', N'int') [node_id], 
		[n].[node].value(N'(@PhysicalOp)[1]', N'sysname') [physical_op],
		STUFF((
			SELECT DISTINCT 
				', ' + [r].[ref].value(N'(@Column)[1]', N'sysname')
			FROM 
				[n].[node].nodes(N'OutputList') [o]([outputs])
				CROSS APPLY [o].[outputs].nodes(N'ColumnReference') [r]([ref])
			WHERE 
				[r].[ref].value(N'(@Column)[1]', N'sysname') IN (SELECT [name] FROM [#columnNames])
			FOR XML PATH('')
		), 1, 2, '') [output_cols]
		
		,[n].[node].query(N'.') [rel_op]
	INTO 
		#planRelOps
	FROM 
		core [c]
		CROSS APPLY [c].[query_plan].nodes(N'//RelOp') [n]([node]) 
	WHERE 
		[n].[node].exist(N'IndexScan/Object[@Index=sql:variable("@TargetIndex")]') = 1;

	/* Extract ColumnReference details */
	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
	SELECT 
		[p].[plan_number],
		[p].[node_id],
		[n].[node].value(N'local-name(./..)', N'sysname') [great_grandparent_name],
		[n].[node].query(N'./..') [great_grandparent_node],
		[n].[node].value(N'local-name(.)', N'sysname') [grandparent_name],
		[n].[node].query(N'.') [grandparent_node], 
		[n].[node].value(N'local-name(*[1])', N'sysname') [parent_name],
		[n].[node].query(N'./*[1]') [parent_node],
		[n].[node].query(N'./*[1]/*[1]') [node]				-- child/child of [node]
	INTO 
		#explodedColRefs
	FROM 
		[#planRelOps] [p] 
		CROSS APPLY [p].rel_op.nodes(N'//*[ColumnReference]/..') [n]([node]) -- MKC: //*[ColumnReference] grabs ALL elements with name of 'ColumnReference]. And /.. then grabs the PARENT of said node. 
	WHERE 
		[n].[node].value(N'local-name(*[1])', N'sysname') NOT IN (N'OutputList', N'DefinedValue') --, N'Identifier')
	ORDER BY 
		[p].[plan_number], [p].[node_id], [parent_name];

	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
	SELECT 
		[r].[plan_number],
		[r].[node_id],
		[r].[grandparent_name],
		CASE
			WHEN [r].[great_grandparent_name] = N'Intrinsic' THEN [r].[great_grandparent_node].value(N'(/Intrinsic/@FunctionName)[1]', N'sysname')
			WHEN [r].[great_grandparent_name] = N'Compare' THEN [r].[great_grandparent_node].value(N'(/Compare/@CompareOp)[1]', N'sysname')
			WHEN [r].[grandparent_name] = N'Prefix' THEN [r].[grandparent_node].value(N'(/Prefix/@ScanType)[1]', N'sysname') 
			WHEN [r].[grandparent_name] = N'EndRange' THEN [r].[grandparent_node].value(N'(/EndRange/@ScanType)[1]', N'sysname') 
			WHEN [r].[grandparent_name] = N'StartRange' THEN [r].[grandparent_node].value(N'(/StartRange/@ScanType)[1]', N'sysname')
			ELSE N'' 
		END [scan_type],
		[r].[grandparent_node],
		[r].[parent_name],
		[r].[parent_node],
		[r].[node],
		[r].[node].value(N'(ColumnReference/@Column)[1]', N'sysname') [column_name]
	INTO 
		#expandedColumns
	FROM 
		#explodedColRefs [r]
	WHERE 
		[r].[node].value(N'(ColumnReference/@Column)[1]', N'sysname') IN (SELECT [name] FROM [#columnNames])
	ORDER BY 
		[r].[plan_number], [r].[node_id];

	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
	SELECT 
		[p].[plan_number],
		[p].[node_id] [operation_id],
		[p].[cacheobjtype],
		[p].[usecounts],
		[p].[physical_op] [operation],
		N' ' [ ], 
		[p].[rel_op].value(N'(//Object/@Index)[1]', N'sysname') [index],
		STUFF((
			SELECT DISTINCT
				N', ' + [e].[column_name]
			FROM 
				[#expandedColumns] [e]
			WHERE 
				[e].[scan_type] = N'EQ' 
				AND [e].[plan_number] = [p].[plan_number] AND [e].[node_id] = [p].[node_id]
			FOR XML PATH('')
			), 1, 2, N'') [equality_columns],
		STUFF((
			SELECT DISTINCT
				N', ' + [e].[column_name] + N' (' + UPPER([e].[scan_type]) + N')'
			FROM 
				[#expandedColumns] [e]
			WHERE 
				NULLIF([e].[scan_type], N'') IS NOT NULL AND [e].[scan_type] <> N'EQ' 
				AND [e].[plan_number] = [p].[plan_number] AND [e].[node_id] = [p].[node_id]
			FOR XML PATH('')
			), 1, 2, N'') [inequality_columns],		

		[p].[output_cols] [output_columns],
		N' ' [_], 
		[p].[query_plan]
		--[p].[rel_op] [operation_xml]
	FROM 
		[#planRelOps] [p]
	ORDER BY 
		[p].[plan_number], [p].[node_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.plancache_columns_by_table','P') IS NOT NULL
	DROP PROC dbo.[plancache_columns_by_table];
GO

CREATE PROC dbo.[plancache_columns_by_table]
	@TargetDatabase				sysname = NULL,
	@TargetTable				sysname
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @TargetDatabase = REPLACE(REPLACE(@TargetDatabase, N'[', N''), N']', N']');
	SET @TargetTable = REPLACE(REPLACE(@TargetTable, N'[', N''), N']', N']');

	IF @TargetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @TargetDatabase OUTPUT;

		IF @TargetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for %s and/or S4 was unable to determine calling-db-context. ', 16, 1);
			RETURN -5;
		END;
	END;

	CREATE TABLE #columnNames (
		[column_id] int NOT NULL, 
		[name] sysname NOT NULL 
	);
	
	DECLARE @sql nvarchar(MAX) = N'SELECT 
		[c].[column_id],
		[c].[name]
	FROM 
		[{targetDb}].sys.[all_columns] c
		INNER JOIN [{targetDb}].sys.objects [o] ON [c].[object_id] = [o].[object_id]
	WHERE 
		[o].[name] = @TargetTable; ';

	SET @sql = REPLACE(@sql, N'{targetDb}', @TargetDatabase);

	INSERT INTO [#columnNames] ([column_id],[name])
	EXEC sys.sp_executesql 
		@sql, 
		N'@TargetTable sysname', 
		@TargetTable = @TargetTable;

	IF NOT EXISTS (SELECT NULL FROM [#columnNames]) BEGIN 
		RAISERROR('Invalid @TargetTable specified - or @TargetTable NOT found in CURRENT database. Either specify @TargetDatabase or EXECUTE this sproc from within database with @TargetTable.', 16, 1);
		RETURN -10;	
	END;

	SET @TargetTable = QUOTENAME(@TargetTable);

	/* 
		DRY VIOLATION: The code below is 98% duplicated between plancache_columns_by_index and plancache_columns_by_table. 
				The ONLY differences are the WHERE clauses (2x in the core CTE + projection) for .exist()... 
			TODO: https://overachieverllc.atlassian.net/browse/S4-516
	*/

	/* Find all plans with REFERENCES to the table in question: */
	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan'),
	core AS (
		SELECT 
			ROW_NUMBER() OVER(ORDER BY [cp].[plan_handle]) [plan_number],
			[cp].[usecounts],
			[cp].[cacheobjtype],
			[qp].[query_plan]
		FROM 
			sys.[dm_exec_cached_plans] cp 
			CROSS APPLY sys.[dm_exec_query_plan](cp.[plan_handle]) qp
		WHERE 
			[qp].[dbid] = DB_ID(@TargetDatabase)
			AND [qp].[query_plan].exist('//Object[@Table=sql:variable("@TargetTable")]') = 1
	)

	SELECT 
		[c].[plan_number],
		[c].[usecounts],
		[c].[cacheobjtype],
		[c].[query_plan], 
		[n].[node].value(N'(@NodeId)[1]', N'int') [node_id], 
		[n].[node].value(N'(@PhysicalOp)[1]', N'sysname') [physical_op],
		STUFF((
			SELECT DISTINCT 
				', ' + [r].[ref].value(N'(@Column)[1]', N'sysname')
			FROM 
				[n].[node].nodes(N'OutputList') [o]([outputs])
				CROSS APPLY [o].[outputs].nodes(N'ColumnReference') [r]([ref])
			WHERE 
				[r].[ref].value(N'(@Column)[1]', N'sysname') IN (SELECT [name] FROM [#columnNames])
			FOR XML PATH('')
		), 1, 2, '') [output_cols]
		
		,[n].[node].query(N'.') [rel_op]
	INTO 
		#planRelOps
	FROM 
		core [c]
		CROSS APPLY [c].[query_plan].nodes(N'//RelOp') [n]([node]) 
	WHERE 
		[n].[node].exist(N'IndexScan/Object[@Table=sql:variable("@TargetTable")]') = 1;

	/* Extract ColumnReference details */
	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
	SELECT 
		[p].[plan_number],
		[p].[node_id],
		[n].[node].value(N'local-name(./..)', N'sysname') [great_grandparent_name],
		[n].[node].query(N'./..') [great_grandparent_node],
		[n].[node].value(N'local-name(.)', N'sysname') [grandparent_name],
		[n].[node].query(N'.') [grandparent_node], 
		[n].[node].value(N'local-name(*[1])', N'sysname') [parent_name],
		[n].[node].query(N'./*[1]') [parent_node],
		[n].[node].query(N'./*[1]/*[1]') [node]				-- child/child of [node]
	INTO 
		#explodedColRefs
	FROM 
		[#planRelOps] [p] 
		CROSS APPLY [p].rel_op.nodes(N'//*[ColumnReference]/..') [n]([node]) -- MKC: //*[ColumnReference] grabs ALL elements with name of 'ColumnReference]. And /.. then grabs the PARENT of said node. 
	WHERE 
		[n].[node].value(N'local-name(*[1])', N'sysname') NOT IN (N'OutputList', N'DefinedValue') --, N'Identifier')
	ORDER BY 
		[p].[plan_number], [p].[node_id], [parent_name];

	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
	SELECT 
		[r].[plan_number],
		[r].[node_id],
		[r].[grandparent_name],
		CASE
			WHEN [r].[great_grandparent_name] = N'Intrinsic' THEN [r].[great_grandparent_node].value(N'(/Intrinsic/@FunctionName)[1]', N'sysname')
			WHEN [r].[great_grandparent_name] = N'Compare' THEN [r].[great_grandparent_node].value(N'(/Compare/@CompareOp)[1]', N'sysname')
			WHEN [r].[grandparent_name] = N'Prefix' THEN [r].[grandparent_node].value(N'(/Prefix/@ScanType)[1]', N'sysname') 
			WHEN [r].[grandparent_name] = N'EndRange' THEN [r].[grandparent_node].value(N'(/EndRange/@ScanType)[1]', N'sysname') 
			WHEN [r].[grandparent_name] = N'StartRange' THEN [r].[grandparent_node].value(N'(/StartRange/@ScanType)[1]', N'sysname')
			ELSE N'' 
		END [scan_type],
		[r].[grandparent_node],
		[r].[parent_name],
		[r].[parent_node],
		[r].[node],
		[r].[node].value(N'(ColumnReference/@Column)[1]', N'sysname') [column_name]
	INTO 
		#expandedColumns
	FROM 
		#explodedColRefs [r]
	WHERE 
		[r].[node].value(N'(ColumnReference/@Column)[1]', N'sysname') IN (SELECT [name] FROM [#columnNames])
	ORDER BY 
		[r].[plan_number], [r].[node_id];

	WITH XMLNAMESPACES (DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan')
	SELECT 
		[p].[plan_number],
		[p].[node_id] [operation_id],
		[p].[cacheobjtype],
		[p].[usecounts],
		[p].[physical_op] [operation],
		N' ' [ ], 
		[p].[rel_op].value(N'(//Object/@Index)[1]', N'sysname') [index],
		STUFF((
			SELECT DISTINCT
				N', ' + [e].[column_name]
			FROM 
				[#expandedColumns] [e]
			WHERE 
				[e].[scan_type] = N'EQ' 
				AND [e].[plan_number] = [p].[plan_number] AND [e].[node_id] = [p].[node_id]
			FOR XML PATH('')
			), 1, 2, N'') [equality_columns],
		STUFF((
			SELECT DISTINCT
				N', ' + [e].[column_name] + N' (' + UPPER([e].[scan_type]) + N')'
			FROM 
				[#expandedColumns] [e]
			WHERE 
				NULLIF([e].[scan_type], N'') IS NOT NULL AND [e].[scan_type] <> N'EQ' 
				AND [e].[plan_number] = [p].[plan_number] AND [e].[node_id] = [p].[node_id]
			FOR XML PATH('')
			), 1, 2, N'') [inequality_columns],		

		[p].[output_cols] [output_columns],
		N' ' [_], 
		[p].[query_plan]
		--[p].[rel_op] [operation_xml]
	FROM 
		[#planRelOps] [p]
	ORDER BY 
		[p].[plan_number], [p].[node_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.plancache_metrics_for_index','P') IS NOT NULL
	DROP PROC dbo.[plancache_metrics_for_index];
GO

CREATE PROC dbo.[plancache_metrics_for_index]
	@TargetDatabase				sysname = NULL,
	@TargetIndex				sysname
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @TargetDatabase = NULLIF(@TargetDatabase, N'');
	SELECT @TargetIndex = REPLACE(REPLACE(@TargetIndex, N']', N''), N'[', N''); 

	IF @TargetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @TargetDatabase OUTPUT;

		IF @TargetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for %s and/or S4 was unable to determine calling-db-context. ', 16, 1);
			RETURN -5;
		END;
	END;

	DECLARE @ixId int; 
	DECLARE @sql nvarchar(MAX) = N'SELECT @ixID = [index_id] FROM [{0}].[sys].[indexes] WHERE [name] = @TargetIndex; ';
	SET @sql = REPLACE(@sql, N'{0}', @TargetDatabase); 

	EXEC sys.sp_executesql 
		@sql, 
		N'@TargetIndex sysname, @ixID int OUTPUT', 
		@TargetIndex = @TargetIndex, 
		@ixId = @ixId OUTPUT; 

	IF @ixId IS NULL BEGIN 
		RAISERROR('Invalid @TargetIndex specified - or @TargetIndex NOT found in CURRENT database. Either specify @TargetDatabase or EXECUTE this sproc from within database with @TargetIndex.', 16, 1);
		RETURN -10;
	END;
	
	SELECT @TargetIndex = QUOTENAME(@TargetIndex); 

	WITH XMLNAMESPACES (
		DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan'
	), 
	matches AS ( 
		SELECT 
			[cp].[usecounts],
			[cp].[size_in_bytes],
			[cp].[cacheobjtype],
			[cp].[objtype],
			[cp].[plan_handle],
			[cp].[parent_plan_handle],
			[qp].[dbid],
			[qp].[query_plan]
		FROM 
			sys.[dm_exec_cached_plans] cp 
			CROSS APPLY sys.[dm_exec_query_plan](cp.[plan_handle]) qp
		WHERE 
			[qp].[dbid] = DB_ID(@TargetDatabase)
			AND [qp].[query_plan].exist('//Object[@Index=sql:variable("@TargetIndex")]') = 1
	)

	SELECT
		ROW_NUMBER() OVER(ORDER BY plan_handle) [plan_id],
		[usecounts],
		[size_in_bytes],
		[cacheobjtype],
		[objtype],
		[query_plan] 
	INTO 
		#metrics
	FROM 
		[matches];


	WITH XMLNAMESPACES (
		DEFAULT N'http://schemas.microsoft.com/sqlserver/2004/07/showplan'
	),
	nodes AS ( 
		SELECT 
			[plan_id],
			[operation].value(N'(@NodeId)[1]', N'int') [node_id],
			[operation].value(N'(@PhysicalOp)[1]', N'sysname') [op_type],
			[operation].query(N'.') [operation]
		FROM 
			[#metrics]
			CROSS APPLY [query_plan].nodes(N'.//RelOp') [nodes]([operation])
		WHERE 
			[operation].value(N'(./IndexScan/Object/@Index)[1]', N'sysname') = @TargetIndex
	), 
	node_aggs AS ( 
		SELECT 
			[plan_id], 
			--STRING_AGG([node_id], N', ') WITHIN GROUP (ORDER BY [node_id]) [nodes]
			COUNT([node_id]) [node_count]
		FROM 
			nodes 
		GROUP BY 
			[plan_id]
	)

	SELECT 
		[m].[plan_id],
		FORMAT(CAST([m].[size_in_bytes] AS decimal(24,2)) / 1024.0, N'N0') [plan_size_kb],
		FORMAT([m].[usecounts], N'N0') [use_counts],
		[m].[cacheobjtype] [cacheobject_type],
		[m].[objtype] [obj_type],
		[n].[node_count],
		[m].[query_plan]
	FROM 
		[#metrics] m
		INNER JOIN node_aggs n ON [m].[plan_id] = [n].[plan_id] 
	ORDER BY 
		[m].[plan_id];

	RETURN 0 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_sysadmins_and_owners','P') IS NOT NULL
	DROP PROC dbo.[list_sysadmins_and_owners];
GO

CREATE PROC dbo.[list_sysadmins_and_owners]
	@ListType				sysname						= N'SYSADMINS_AND_OWNERS',			-- { SYSADMINS | OWNERS | SYSADMINS_AND_OWNERS }
	@TargetDatabases		nvarchar(MAX)				= N'{ALL}', 
	@Exclusions				nvarchar(MAX)				= NULL, 
	@Priorities				nvarchar(MAX)				= NULL
AS
    SET NOCOUNT ON; 

    -- {copyright}

	CREATE TABLE #principals (
		[row_id] int IDENTITY(1, 1),
		[scope] sysname NOT NULL,
		[database] sysname NOT NULL,
		[role] sysname NOT NULL,
		[login_or_user_name] sysname NOT NULL
	);

	IF UPPER(@ListType) LIKE '%SYSADMINS%' BEGIN

		INSERT INTO #principals (
			[scope],
			[database],
			[role],
			[login_or_user_name]
		)
		SELECT
			N'SERVER' [scope],
			N'' [database],
			[r].[name] [role],
			[sp].[name] [login_name]
		FROM
			[sys].[server_principals] [sp],
			[sys].[server_role_members] [rm],
			[sys].[server_principals] [r]
		WHERE
			[sp].[principal_id] = [rm].[member_principal_id] AND [r].[principal_id] = [rm].[role_principal_id] AND LOWER([r].[name]) IN (N'sysadmin', N'securityadmin')
		ORDER BY
			[r].[name],
			[sp].[name];

	END;

	IF UPPER(@ListType) LIKE '%OWNER%' BEGIN
		DECLARE @targetDBs table ( 
			row_id int IDENTITY(1,1) NOT NULL,
			[database_name] sysname NOT NULL
		);

		INSERT INTO @targetDBs (
			[database_name]
		)
		EXEC dbo.[list_databases]
			@Targets = @TargetDatabases,
			@Exclusions = @Exclusions,
			@Priorities = @Priorities,
			@ExcludeClones = 1,
			@ExcludeSecondaries = 1,
			@ExcludeSimpleRecovery = 0,
			@ExcludeReadOnly = 0,
			@ExcludeRestoring = 1,
			@ExcludeRecovering = 1,
			@ExcludeOffline = 1;
		
		DECLARE @databaseName sysname;
		DECLARE @template nvarchar(MAX) = N'
			INSERT INTO #principals ([scope], [database], [role], [login_or_user_name]) 
			SELECT ''DATABASE'' [scope], ''{dbname}'', ''db_owner'' [role], p.[name] [login_or_user_name]
			FROM 
				[{dbname}].sys.database_role_members m
				INNER JOIN [{dbname}].sys.database_principals r ON m.role_principal_id = r.principal_id
				INNER JOIN [{dbname}].sys.database_principals p ON m.member_principal_id = p.principal_id
			WHERE 
				r.[name] = ''db_owner''
				AND p.[name] <> ''dbo''; ';

		DECLARE @command nvarchar(MAX);
		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[database_name]
		FROM 
			@targetDBs
		ORDER BY 
			[row_id];

		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @databaseName;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			SET @command = REPLACE(@template, N'{dbname}', @databaseName);

			EXEC sp_executesql @command;
		
			FETCH NEXT FROM [walker] INTO @databaseName;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

	END;

	SELECT
		*
	FROM
		#principals
	ORDER BY 
		row_id;

	RETURN 0;
GO




-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_orphaned_users','P') IS NOT NULL
	DROP PROC dbo.[list_orphaned_users];
GO

CREATE PROC dbo.[list_orphaned_users]
	@TargetDatabases						nvarchar(MAX)			= N'{ALL}',
	@ExcludedDatabases						nvarchar(MAX)			= NULL,
	@ExcludedLogins							nvarchar(MAX)			= NULL, 
	@ExcludedUsers							nvarchar(MAX)			= NULL, 
	@ExcludeMSAndServiceLogins				bit						= 1, 
	@ExcludeLocalPrincipalLogins			bit						= 1,
	@Output									xml						= N'<default/>'	    OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	IF NULLIF(@TargetDatabases,'') IS NULL SET @TargetDatabases = N'{ALL}';
	SET @ExcludedDatabases = NULLIF(@ExcludedDatabases, N'');
	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');
	SET @ExcludedUsers = NULLIF(@ExcludedUsers, N'');
	SET @ExcludeMSAndServiceLogins = ISNULL(@ExcludeMSAndServiceLogins, 1);

	DECLARE @ignoredDatabases table (
		[database_name] sysname NOT NULL
	);

	DECLARE @ingnoredLogins table (
		[login_name] sysname NOT NULL 
	);

	DECLARE @ignoredUsers table (
		[user_name] sysname NOT NULL
	);

	IF @ExcludedDatabases IS NOT NULL BEGIN
		INSERT INTO @ignoredDatabases ([database_name])
		SELECT [result] [database_name] FROM dbo.[split_string](@ExcludedDatabases, N',', 1) ORDER BY row_id;
	END;

	IF @ExcludedLogins IS NOT NULL BEGIN 
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [result] [login_name] FROM dbo.[split_string](@ExcludedLogins, N',', 1) ORDER BY row_id;
	END;

	IF @ExcludeMSAndServiceLogins = 1 BEGIN 
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [result] [login_name] FROM dbo.[split_string](N'##MS%, NT AUTHORITY\%, NT SERVICE\%', N',', 1) ORDER BY row_id;				
	END;

	IF @ExcludeLocalPrincipalLogins = 1 BEGIN
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [name] FROM sys.[server_principals] WHERE [type] = 'U' AND [name] LIKE @@SERVERNAME + N'\%';
	END;

	IF @ExcludedUsers IS NOT NULL BEGIN 
		INSERT INTO @ignoredUsers ([user_name]) 
		SELECT [result] [user_name] FROM dbo.[split_string](@ExcludedUsers, N',', 1) ORDER BY row_id;
	END;

	CREATE TABLE #Users (
		[name] sysname NOT NULL, 
		[sid] varbinary(85) NOT NULL, 
		[type] char(1) NOT NULL
	);

	CREATE TABLE #Orphans (
		[name] sysname NOT NULL, 
		[sid] varbinary(85) NOT NULL
	);	

	SELECT 
        sp.[is_disabled][enabled],
		sp.[name], 
		sp.[sid],
		sp.[type], 
		sp.[is_disabled], 
		sp.[default_database_name],
		sl.[password_hash], 
		sl.[is_expiration_checked], 
		sl.[is_policy_checked], 
		sp.[default_language_name]
	INTO 
		#Logins
	FROM 
		sys.[server_principals] sp
		LEFT OUTER JOIN sys.[sql_logins] sl ON sp.[sid] = sl.[sid]
	WHERE 
		sp.[type] NOT IN ('R');

	DECLARE @currentDatabase sysname;
	DECLARE @dbPrincipalsTemplate nvarchar(MAX) = N'SELECT [name], [sid], [type] 
FROM 
	[{0}].sys.database_principals 
WHERE 
	[type] IN (''S'', ''U'') 
	AND [name] NOT IN (''dbo'',''guest'',''INFORMATION_SCHEMA'',''sys'')
	AND [authentication_type] <> 0; ';
	DECLARE @sql nvarchar(MAX);
	DECLARE @text nvarchar(MAX);
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	DECLARE @dbsToProcess table ( 
		row_id int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL 
	);

	INSERT INTO @dbsToProcess ([database_name])
	EXEC dbo.[list_databases]
		@Targets = @TargetDatabases,
		@Exclusions = @ExcludedDatabases,
		@ExcludeClones = 1,
		@ExcludeSecondaries = 1,
		@ExcludeSimpleRecovery = 0,
		@ExcludeReadOnly = 0,
		@ExcludeRestoring = 1,
		@ExcludeRecovering = 1,
		@ExcludeOffline = 1;

	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name]
	FROM 
		@dbsToProcess 
	ORDER BY 
		[row_id];
	
	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @currentDatabase;
	
	DECLARE @projectInsteadOfSendXmlAsOutput bit = 1;
	IF (SELECT dbo.is_xml_empty(@Output)) = 1 SET @projectInsteadOfSendXmlAsOutput = 0;
	CREATE TABLE #xmlOutput ( 
		row_id int IDENTITY(1,1) NOT NULL, 
		[database] sysname NOT NULL, 
		[login_name] sysname NOT NULL, 
		[sid] varbinary(85) NOT NULL
	);

	WHILE @@FETCH_STATUS = 0 BEGIN
	
		DELETE FROM [#Users]; 
		DELETE FROM [#Orphans];

		SET @sql = REPLACE(@dbPrincipalsTemplate, N'{0}', @currentDatabase);

		INSERT INTO [#Users] ([name], [sid], [type])
		EXEC master.sys.sp_executesql @sql;

		/* Remove any explicitly ignored logins: */
		DELETE u 
		FROM 
			[#Users] u 
			INNER JOIN @ingnoredLogins x ON u.[name] LIKE x.[login_name];

		/* Remove any explicitly ignored/excluded users: */
		DELETE u 
		FROM [#Users] u 
		INNER JOIN @ignoredUsers x ON u.[name] LIKE x.[user_name];

		INSERT INTO [#Orphans] ([name],	[sid])
		SELECT 
			u.[name], 
			u.[sid]
		FROM 
			[#Users] u 
		WHERE 
			u.[sid] NOT IN (SELECT [sid] FROM [#Logins]);
		
		IF EXISTS (SELECT NULL FROM [#Orphans]) BEGIN
			IF @projectInsteadOfSendXmlAsOutput = 1 BEGIN 
				
				PRINT '----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'
				PRINT '-- DATABASE: ' + @currentDatabase 
				PRINT '----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------'

				SET @text = N'';
				SELECT 
					@text = @text +  N'-- ORPHAN: ' + [name] + N' (SID: ' + CONVERT(sysname, [sid], 1) + N') ' + @crlf
				FROM 
					[#Orphans] 
				ORDER BY 
					[name];

				SET @text = @text + @crlf;

				EXEC [dbo].[print_long_string] @text;

			  END; 
			ELSE BEGIN 
				INSERT INTO [#xmlOutput] (
					[database],
					[login_name],
					[sid]
				)
				SELECT 
					@currentDatabase [database],
					[name] [user_name],
					[sid]
				FROM 
					[#Orphans]
				ORDER BY 
					[name];
			END;
		END;
	
		FETCH NEXT FROM [walker] INTO @currentDatabase;
	END;

	IF @projectInsteadOfSendXmlAsOutput = 0 BEGIN 
		SELECT @Output = (SELECT 
			[database] [user/@database],
			CONVERT(sysname, [sid], 1) [user/@sid],
			[login_name] [user]
		FROM 
			[#xmlOutput] 
		ORDER BY 
			[row_id]
		FOR XML PATH(''), ROOT('orphans'), TYPE);
	END;

	CLOSE [walker];
	DEALLOCATE [walker];

	RETURN 0
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_login_permissions','P') IS NOT NULL
	DROP PROC dbo.[list_login_permissions];
GO

CREATE PROC dbo.[list_login_permissions]
	@Mode									sysname					= N'SUMMARY',  -- { SUMMARY | TABLE }
	@ExcludedLogins							nvarchar(MAX)			= NULL,
	@ExcludeMSAndServiceLogins				bit						= 1, 
	@ExcludedDatabases						sysname					= NULL

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @Mode = ISNULL(NULLIF(@Mode, N''), N'SUMMARY');

	DECLARE @ingnoredLogins table (
		[login_name] sysname NOT NULL 
	);	

	INSERT INTO @ingnoredLogins (
		[login_name]
	)
	VALUES	
		--(N'sa'), 
		(N'public');

	IF @ExcludedLogins IS NOT NULL BEGIN
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [result] [login_name] FROM dbo.[split_string](@ExcludedLogins, N',', 1) ORDER BY row_id;
	END;

	IF @ExcludeMSAndServiceLogins = 1 BEGIN
		INSERT INTO @ingnoredLogins ([login_name])
		SELECT [result] [login_name] FROM dbo.[split_string](N'##MS%, NT AUTHORITY\%, NT SERVICE\%', N',', 1) ORDER BY row_id;		
	END;

	SELECT 
		[p].[principal_id],
		[p].[sid],
		[p].[name],
		CASE WHEN [p].[is_disabled] = 1 THEN 0 ELSE 1 END [enabled],
		[p].[default_database_name] [default_database]
	INTO 
		#Logins
	FROM 
		sys.[server_principals] [p]
		LEFT OUTER JOIN sys.[sql_logins] sl ON [p].[sid] = sl.[sid]
	WHERE 
		[is_fixed_role] = 0;

	DELETE l 
	FROM 
		#Logins l
		INNER JOIN @ingnoredLogins x ON l.[name] LIKE x.[login_name];

	WITH [server_role_members] AS (
		SELECT 
			[members].[principal_id],
			[roles].[name] [role_name]
		FROM 
			sys.[server_role_members] [rm]
			INNER JOIN sys.[server_principals] [roles] ON [rm].[role_principal_id] = [roles].[principal_id] 
			INNER JOIN sys.[server_principals] [members] ON [rm].[member_principal_id] = [members].[principal_id]
		WHERE 
			[members].[principal_id] IN (SELECT [principal_id] FROM [#Logins])
	)

	SELECT 
		[m].[principal_id], 
		STUFF(
			(SELECT N', ' + [x].[role_name] FROM [server_role_members] [x] WHERE [x].[principal_id] = [m].[principal_id] FOR XML PATH('')),
		1, 1, N' ') [roles]
	INTO 
		#serverRoleMembership
	FROM 
		[server_role_members] [m]
	GROUP BY 
		[m].[principal_id];
	
	/* Extract per-database role_memberships */
	CREATE TABLE #dbRoleMembers (
		[row_id] int IDENTITY(1, 1),
		[database] sysname NOT NULL,
		[sid] varbinary(85) NOT NULL,
		[user_name] sysname NOT NULL, 
		[schema] sysname NOT NULL, 
		[roles] nvarchar(MAX) NOT NULL
	);

	DECLARE @targetDBs table ( 
		row_id int IDENTITY(1,1) NOT NULL,
		[database_name] sysname NOT NULL
	);

	INSERT INTO @targetDBs (
		[database_name]
	)
	EXEC dbo.[list_databases]
		@Targets = N'{ALL}',
		@Exclusions = @ExcludedDatabases,
		@Priorities = NULL,
		@ExcludeClones = 1,
		@ExcludeSecondaries = 1,
		@ExcludeSimpleRecovery = 0,
		@ExcludeReadOnly = 0,
		@ExcludeRestoring = 1,
		@ExcludeRecovering = 1,
		@ExcludeOffline = 1;

	DECLARE @databaseName sysname;
	DECLARE @template nvarchar(MAX) = N'WITH [users] AS ( 
		SELECT 
			[p].[sid],
			[x].[name] [user_name]
		FROM 
			[{dbname}].sys.[database_principals] p
			INNER JOIN [#Logins] x ON [p].[sid] = [x].[sid]
		WHERE 
			[p].[sid] <> 0x01
	), 
	[role_members] AS (
		SELECT
			[members].[sid],
			[members].[default_schema_name] [default_schema],
			[roles].[name] [role]
		FROM 
			[{dbname}].sys.[database_role_members] [rm]
			INNER JOIN [{dbname}].[sys].[database_principals] AS [roles] ON [rm].[role_principal_id] = [roles].[principal_id]
			INNER JOIN [{dbname}].[sys].[database_principals] AS [members] ON [rm].[member_principal_id] = [members].[principal_id]
		WHERE
			[roles].[type] = ''R''		
			AND [members].[sid] IN (SELECT [sid] FROM [#Logins])
			AND [members].[sid] <> 0x01
	), 
	[joined] AS (
		SELECT 
			[u].[sid],
			[u].[user_name],
			ISNULL([r].[default_schema], N'''') [schema],
			ISNULL([r].[role], N''public'') [role]
		FROM 
			[users] [u]
			LEFT OUTER JOIN [role_members] [r] ON [u].[sid] = [r].[sid]
	)

	SELECT 
		N''{dbname}'' [database],
		[j].[sid], 
		[j].[user_name], 
		[j].[schema], 
		LTRIM(STUFF(
			(SELECT N'', '' + [x].[role] FROM [joined] [x] WHERE [x].[sid] = [j].[sid] FOR XML PATH('''')),
		1, 1, N'' '')) [roles]
	FROM 
		[joined] [j]
	GROUP BY 
		[j].[sid], 
		[j].[user_name], 
		[j].[schema]; '

	DECLARE @command nvarchar(MAX);
	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name]
	FROM 
		@targetDBs
	ORDER BY 
		[row_id];

	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @databaseName;
		
	WHILE @@FETCH_STATUS = 0 BEGIN
		
		SET @command = REPLACE(@template, N'{dbname}', @databaseName);

		INSERT INTO [#dbRoleMembers] (
			[database],
			[sid],
			[user_name],
			[schema],
			[roles]
		)
		EXEC sp_executesql 
			@command;
		
		FETCH NEXT FROM [walker] INTO @databaseName;
	END;
		
	CLOSE [walker];
	DEALLOCATE [walker];

	WITH core AS ( 
		SELECT
			[l].[principal_id],
			[l].[name],
			[l].[enabled],
			[l].[default_database], 
			LTRIM(ISNULL([s].[roles], N'')) [roles], 
			[d].[database],
			[d].[user_name],
			[d].[schema],
			[d].[roles] [db_roles]
		FROM 
			[#Logins] [l]
			LEFT OUTER JOIN #serverRoleMembership [s] ON [l].[principal_id] = [s].[principal_id]
			LEFT OUTER JOIN [#dbRoleMembers] [d] ON [l].[sid] = [d].[sid]
	) 

	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		[c].[enabled],
		[c].[name] [login],
		[c].[default_database] [default_db], 
		[c].[roles] [server_roles], 
		ISNULL([c].[database], CASE WHEN [c].[roles] LIKE N'%sysadmin%' THEN N'ALL' ELSE N'' END) [database],
		ISNULL([c].[user_name], CASE WHEN [c].[roles] LIKE N'%sysadmin%' THEN N'db_owner' ELSE N'' END) [user_name],
		ISNULL([c].[schema], CASE WHEN [c].[roles] LIKE N'%sysadmin%' THEN N'dbo' ELSE N'' END) [schema],
		ISNULL([c].[db_roles], CASE WHEN [c].[roles] LIKE N'%sysadmin%' THEN N'db_owner' ELSE N'' END) [db_roles]
	INTO 
		#report
	FROM 
		core c
	ORDER BY 
		c.[principal_id];

	IF UPPER(@Mode) = N'SUMMARY' BEGIN 
		WITH core AS (
			SELECT 
				[enabled],
				[login],
				LAG([login], 1, NULL) OVER (ORDER BY [row_id]) [lagged],
				[default_db],
				[server_roles],
				[database],
				[user_name],
				[schema],
				[db_roles] 
			FROM 
				[#report] 
		) 

		SELECT 
			CASE WHEN [lagged] = [login] THEN N'' ELSE [login] END [login],
			CASE WHEN [lagged] = [login] THEN N'' ELSE CAST([enabled] AS sysname) END [enabled],
			CASE WHEN [lagged] = [login] THEN N'' ELSE [default_db] END [default_db],
			[server_roles],
			N' ' [ ],
			[database],
			[user_name],
			[schema],
			[db_roles] 
		FROM 
			[core];

		RETURN 0;
	END;

	SELECT 
		[enabled],
		[login],
		[default_db],
		[server_roles],
		[database],
		[user_name],
		[schema],
		[db_roles] 
	FROM 
		[#report];

	RETURN 0;
GO	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.view_querystore_consumers','P') IS NOT NULL
	DROP PROC dbo.[view_querystore_consumers];
GO

CREATE PROC dbo.[view_querystore_consumers]
	@TargetDatabase								sysname			= NULL, 
	@MostExpensiveBy							sysname			= N'DURATION',		-- { CPU | DURATION | EXECUTIONCOUNTS | READS | WRITES | ROWCOUNTS | TEMPDB | GRANTS | TLOG | PLANCOUNTS | COMPILECOUNTS | DOP }
	@TopResults									int				= 30,
	@OptionalStartTime							datetime		= NULL, 
	@OptionalEndTime							datetime		= NULL 
	--@ExcludeServiceBrokerQueues					bit				= 1, 
	--@ExcludeFailedAndAbortedQueries				bit				= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	SET @MostExpensiveBy = ISNULL(NULLIF(@MostExpensiveBy, N''), N'DURATION');

	IF UPPER(@MostExpensiveBy) NOT IN (N'CPU', N'DURATION', N'EXECUTIONCOUNTS', N'READS', N'WRITES', N'ROWCOUNTS', N'TEMPDB', N'GRANTS', N'TLOG', N'PLANCOUNTS', N'COMPILECOUNTS', N'DOP') BEGIN
		RAISERROR('Allowed values for @MostExpensiveBy are { CPU | DURATION | EXECUTIONCOUNTS | READS | WRITES | ROWCOUNTS | TEMPDB | GRANTS | TLOG | PLANCOUNTS | COMPILECOUNTS | DOP }.', 16, 1);
		RETURN -10;
	END;

	-- meh: 
	IF UPPER(@MostExpensiveBy) = N'COMPILECOUNTS' BEGIN 
		RAISERROR('Sorry, COMPILECOUNTS is not YET implemented.', 16, 1);
		RETURN -11;
	END;

	DECLARE @orderBy sysname;
	SET @orderBy = (SELECT 
		CASE @MostExpensiveBy 
			WHEN N'CPU' THEN N'[total_cpu_time]'
			WHEN N'DURATION' THEN N'[total_duration]'
			WHEN N'EXECUTIONCOUNTS' THEN N'[executions_count]'
			WHEN N'READS' THEN N'[total_logical_reads]'
			WHEN N'WRITES' THEN N'[total_logical_writes]'
			WHEN N'ROWCOUNTS' THEN N'[total_row_count]'
			WHEN N'TEMPDB' THEN N'[total_tempdb_space_used]'
			WHEN N'GRANTS' THEN N'[total_used_memory]'
			WHEN N'TLOG' THEN N'[total_log_bytes_used]'
			WHEN N'PLANCOUNTS' THEN N'[plans_count]'
			WHEN N'COMPILECOUNTS' THEN N'[compiles_count]'
			WHEN N'DOP' THEN N'[max_dop]'
			ELSE NULL
		END);
	
	IF @orderBy IS NULL BEGIN 
		RAISERROR('S4 Framework Error. %s has not had an ORDER BY clause defined.', 16, 1, @MostExpensiveBy);
		RETURN -20;
	END;

	DECLARE @sql nvarchar(MAX); 
	DECLARE @startTime datetime, @endTime datetime; 
	
	SET @sql = N'SELECT 
		@startTime = CAST(MIN(start_time) AS datetime), 
		@endTime = CAST(MAX(end_time) AS datetime) 
	FROM 
		[{targetDB}].sys.[query_store_runtime_stats_interval]; ';
	
	SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);
	EXEC sys.[sp_executesql]
		@sql, 
		N'@startTime datetime OUTPUT, @endTime datetime OUTPUT', 
		@startTime = @startTime OUTPUT,
		@endTime = @endTime OUTPUT;

	IF @OptionalStartTime IS NOT NULL BEGIN 
		IF @OptionalStartTime > @startTime 
			SET @startTime = @OptionalStartTime;
	END;

	IF @OptionalEndTime IS NOT NULL BEGIN 
		IF @OptionalEndTime < @endTime
			SET @endTime = @OptionalEndTime;
	END;

	CREATE TABLE #TopQueryStoreStats (
		[row_id] int IDENTITY(1, 1) NOT NULL,
		[query_id] bigint NOT NULL,
		[plans_count] int NOT NULL,
		[compiles_count] bigint NOT NULL,
		[executions_count] bigint NOT NULL,
		[avg_cpu_time] float NOT NULL,
		[total_cpu_time] float NOT NULL,
		[avg_duration] float NOT NULL,
		[total_duration] float NOT NULL,
		[avg_logical_reads] float NOT NULL,
		[total_logical_reads] float NOT NULL,
		[avg_logical_writes] float NOT NULL,
		[total_logical_writes] float NOT NULL,
		[avg_physical_reads] float NOT NULL,
		[total_physical_reads] float NOT NULL,
		[avg_used_memory] float NOT NULL,
		[total_used_memory] float NOT NULL,
		[avg_rowcount] float NOT NULL,
		[total_rowcount] float NOT NULL,
		[avg_log_bytes_used] float NULL,
		[total_log_bytes_used] float NULL,
		[avg_tempdb_space_used] float NULL,
		[total_tempdb_space_used] float NULL,
		[max_dop] bigint NOT NULL,
		[min_dop] bigint NOT NULL
	);

	SET @sql = N'WITH core AS ( 
	SELECT 
		p.[query_id],
		COUNT(DISTINCT s.[plan_id]) [plans_count],
		SUM(p.[count_compiles]) [compiles_count],
		SUM(s.[count_executions]) [executions_count],
		SUM(s.[avg_cpu_time]) [avg_cpu_time],
		SUM(s.[avg_cpu_time] * s.[count_executions]) [total_cpu_time],
		SUM(s.[avg_duration]) [avg_duration],
		SUM(s.[avg_duration] * s.[count_executions]) [total_duration],
		SUM(s.[avg_logical_io_reads]) [avg_logical_reads],
		SUM(s.[avg_logical_io_reads] * s.[count_executions]) [total_logical_reads],
		SUM(s.[avg_logical_io_writes]) [avg_logical_writes],
		SUM(s.[avg_logical_io_writes] * s.[count_executions]) [total_logical_writes],
		SUM(s.[avg_physical_io_reads]) [avg_physical_reads],
		SUM(s.[avg_physical_io_reads] * s.[count_executions]) [total_physical_reads],
		SUM(s.[avg_query_max_used_memory]) [avg_used_memory],
		SUM(s.[avg_query_max_used_memory] * s.[count_executions]) [total_used_memory],
		SUM(s.[avg_rowcount]) [avg_rowcount],
		SUM(s.[avg_rowcount] * s.[count_executions]) [total_rowcount],
		SUM(s.[avg_log_bytes_used]) [avg_log_bytes_used],
		SUM(s.[avg_log_bytes_used] * s.[count_executions]) [total_log_bytes_used],
		SUM(s.[avg_tempdb_space_used]) [avg_tempdb_space_used], 
		SUM(s.[avg_tempdb_space_used] * s.[count_executions]) [total_tempdb_space_used],
		MAX(s.[max_dop]) [max_dop], 
		MIN(s.[min_dop]) [min_dop]
	FROM 
		[{targetDB}].sys.[query_store_runtime_stats] s
		LEFT OUTER JOIN [{targetDB}].sys.[query_store_plan] p ON s.[plan_id] = p.[plan_id]
	WHERE 
		NOT (s.first_execution_time > @endTime OR s.last_execution_time < @startTime)
	GROUP BY 
		p.[query_id]
) 

SELECT TOP (@TopResults)
	[query_id],
	[plans_count],
	[compiles_count],
	[executions_count],
	[avg_cpu_time],
	[total_cpu_time],
	[avg_duration],
	[total_duration],
	[avg_logical_reads],
	[total_logical_reads],
	[avg_logical_writes],
	[total_logical_writes],
	[avg_physical_reads],
	[total_physical_reads],
	[avg_used_memory],
	[total_used_memory],
	[avg_rowcount],
	[total_rowcount],
	[avg_log_bytes_used],
	[total_log_bytes_used],
	[avg_tempdb_space_used],
	[total_tempdb_space_used],
	[max_dop],
	[min_dop] 
FROM 
	core 
ORDER BY 
	{orderBy} DESC; ';

	SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);
	SET @sql = REPLACE(@sql, N'{orderBy}', @orderBy);

	INSERT INTO [#TopQueryStoreStats] (
		[query_id],
		[plans_count],
		[compiles_count],
		[executions_count],
		[avg_cpu_time],
		[total_cpu_time],
		[avg_duration],
		[total_duration],
		[avg_logical_reads],
		[total_logical_reads],
		[avg_logical_writes],
		[total_logical_writes],
		[avg_physical_reads],
		[total_physical_reads],
		[avg_used_memory],
		[total_used_memory],
		[avg_rowcount],
		[total_rowcount],
		[avg_log_bytes_used],
		[total_log_bytes_used],
		[avg_tempdb_space_used],
		[total_tempdb_space_used],
		[max_dop],
		[min_dop]
	)
	EXEC sys.[sp_executesql] 
		@sql, 
		N'@TopResults int, @startTime datetime, @endTime datetime', 
		@TopResults = @TopResults,
		@startTime = @startTime, 
		@endTime = @endTime;

	CREATE TABLE #details ( 
		[row_id] int NOT NULL, 
		[query_id] bigint NOT NULL,
		[most_recent_plan] nvarchar(MAX) NULL, 
		[query_text] nvarchar(MAX) NULL 
	); 

	SET @sql = N'SELECT 
		[x].[row_id],
		[x].[query_id],
		(SELECT TOP (1) p.[query_plan] FROM [{targetDB}].sys.[query_store_plan] p WHERE p.[query_id] = x.[query_id] ORDER BY [plan_id] DESC) [most_recent_plan], 
		[t].[query_sql_text]
	FROM 
		[#TopQueryStoreStats] [x]
		LEFT OUTER JOIN [{targetDB}].sys.[query_store_query] q ON [x].[query_id] = [q].[query_id]
		LEFT OUTER JOIN [{targetDB}].sys.[query_store_query_text] t ON [q].[query_text_id] = [t].[query_text_id]; ';

	SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);

	INSERT INTO [#details] (
		[row_id],
		[query_id],
		[most_recent_plan],
		[query_text]
	)
	EXEC sys.[sp_executesql]
		@sql;


	WITH expanded AS ( 
		SELECT 
			[x].[row_id],
			[x].[query_id],
			[d].[query_text], 
			TRY_CAST([d].[most_recent_plan] AS xml) [query_plan],
			[x].[plans_count],
			[x].[compiles_count],
			[x].[executions_count],
			CAST(([x].[avg_duration] / 1000.0) AS decimal(24,2)) [avg_duration_ms],
			CAST(([x].[total_duration] / 1000.0) AS decimal(24,2)) [total_duration_ms],
			CAST(([x].[avg_cpu_time] / 1000.0) AS decimal(24,2)) [avg_cpu_time_ms],
			CAST(([x].[total_cpu_time] / 1000.0) AS decimal(24,2)) [total_cpu_time_ms],
			CAST(([x].[avg_logical_reads] * 8.0 / 1073741824) AS decimal(24,2)) [avg_logical_reads],
			CAST(([x].[total_logical_reads] * 8.0 / 1073741824) AS decimal(24,2)) [total_logical_reads],
			CAST(([x].[avg_logical_writes] * 8.0 / 1073741824) AS decimal(24,2)) [avg_logical_writes],
			CAST(([x].[total_logical_writes] * 8.0 / 1073741824) AS decimal(24,2)) [total_logical_writes],
			CAST(([x].[avg_physical_reads] * 8.0 / 1073741824) AS decimal(24,2)) [avg_physical_reads],
			CAST(([x].[total_physical_reads] * 8.0 / 1073741824) AS decimal(24,2)) [total_physical_reads],
			CAST(([x].[avg_used_memory] * 8.0 / 1073741824) AS decimal(24,2)) [avg_used_memory],
			CAST(([x].[total_used_memory] * 8.0 / 1073741824) AS decimal(24,2)) [total_used_memory],
			CAST(([x].[avg_rowcount]) AS decimal(24,2)) [avg_rowcount],
			CAST(([x].[total_rowcount]) AS decimal(24,2)) [total_rowcount],
			CAST(([x].[avg_log_bytes_used] / 1073741824.0) AS decimal(24,2)) [avg_log_bytes_used],
			CAST(([x].[total_log_bytes_used] / 1073741824.0) AS decimal(24,2)) [total_log_bytes_used],
			CAST(([x].[avg_tempdb_space_used] * 8.0 / 1073741824) AS decimal(24,2)) [avg_tempdb_space_used],
			CAST(([x].[total_tempdb_space_used] * 8.0 / 1073741824) AS decimal(24,2)) [total_tempdb_space_used],
			[x].[max_dop],
			[x].[min_dop]
		FROM 
			[#TopQueryStoreStats] [x] 
			INNER JOIN [#details] [d] ON [x].[row_id] = [d].[row_id]
	)

	SELECT 
		--[row_id],
		[query_id],
		[query_text],
		--CASE WHEN [query_plan] IS NULL THEN (SELECT [most_recent_plan] FROM [#details] x WHERE x.[row_id] = [expanded].[row_id]) ELSE [query_plan] END [query_plan],
		[query_plan],
		[plans_count],
		--[compiles_count],
		[executions_count] [execution_count],
		dbo.format_timespan([avg_duration_ms]) [avg_duration],
		dbo.format_timespan([avg_cpu_time_ms]) [avg_cpu_time],
		dbo.format_timespan([total_duration_ms]) [total_duration],
		dbo.format_timespan([total_cpu_time_ms]) [total_cpu_time],
		[avg_logical_reads] [avg_reads_GB],
		[total_logical_reads] [total_reads_GB],
		[avg_logical_writes] [avg_writes_GB],
		[total_logical_writes] [total_writes_GB],
		--[avg_physical_reads],
		--[total_physical_reads],
		[avg_used_memory] [avg_grant_GB],
		[total_used_memory] [total_grant_GB],
		[avg_rowcount],
		[total_rowcount],
		[avg_log_bytes_used] [avg_log_GB],
		[total_log_bytes_used] [total_log_GB],
		[avg_tempdb_space_used] [avg_spills_GB],
		[total_tempdb_space_used] [total_spills_GB],
		[max_dop],
		[min_dop]
	FROM 
		[expanded]
	ORDER BY 
		[row_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.view_querystore_counts','P') IS NOT NULL
	DROP PROC dbo.[view_querystore_counts];
GO

CREATE PROC dbo.[view_querystore_counts]
	@TargetDatabase								sysname			= NULL, 
	@Granularity								sysname			= N'HOUR',		-- { MINUTES | HOUR | DAY } 
	@OptionalStartTime							datetime		= NULL, 
	@OptionalEndTime							datetime		= NULL, 
	--@ExcludeServiceBrokerQueues					bit				= 1, 
	--@ExcludeFailedAndAbortedQueries				bit				= 1, 
	@OptionalCoreCount							int				= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	SET @Granularity = ISNULL(NULLIF(@Granularity, N''), N'HOUR');
	
	IF UPPER(@Granularity) NOT IN (N'MINUTE', N'MINUTES', N'HOUR', N'DAY') BEGIN 
		RAISERROR('@Granularity can only be set to { MINUTE(S) | HOUR | DAY }. ', 16, 1);
		RETURN -10;
	END;

	DECLARE @minutes int = 60; 
	DECLARE @sql nvarchar(MAX); 
	DECLARE @qsStart datetime, @qsEnd datetime; 

	IF UPPER(@Granularity) = N'DAY' BEGIN
		SET @minutes = 60 * 24;
	END;

	IF UPPER(@Granularity) = N'MINUTES' BEGIN 
		SET @sql = N'SELECT @minutes = interval_length_minutes FROM [{targetDB}].sys.[database_query_store_options]; ';
		SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);

		EXEC sys.sp_executesql
			@sql, 
			N'@minutes int OUTPUT', 
			@minutes = @minutes OUTPUT;
	END;
	
	SET @sql = N'SELECT 
		@qsStart = CAST(MIN(start_time) AS datetime), 
		@qsEnd = CAST(MAX(end_time) AS datetime) 
	FROM 
		[{targetDB}].sys.[query_store_runtime_stats_interval]; ';
	
	SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);
	EXEC sys.[sp_executesql]
		@sql, 
		N'@qsStart datetime OUTPUT, @qsEnd datetime OUTPUT', 
		@qsStart = @qsStart OUTPUT,
		@qsEnd = @qsEnd OUTPUT;


	IF @OptionalStartTime IS NOT NULL BEGIN 
		IF @OptionalStartTime > @qsStart 
			SET @qsStart = @OptionalStartTime;
	END;

	IF @OptionalEndTime IS NOT NULL BEGIN 
		IF @OptionalEndTime < @qsEnd
			SET @qsEnd = @OptionalEndTime;
	END;

	DECLARE @startTime datetime, @endTime datetime;
	SELECT 
		@startTime = DATEADD(MINUTE, DATEDIFF(MINUTE, 0, @qsStart) / @minutes * @minutes, 0), 
		@endTime = DATEADD(MINUTE, @minutes, DATEADD(MINUTE, DATEDIFF(MINUTE, 0, @qsEnd) / @minutes * @minutes, 0));

	DECLARE @coreCount int = @OptionalCoreCount;
	IF @coreCount IS NULL BEGIN 
		SELECT @coreCount = cpu_count FROM sys.dm_os_sys_info;  -- this provides LOGICAL core counts, but that's good/accurate enough.
	END;

	DECLARE @cpuMillisecondsPerInterval int = (1000 * @coreCount * 60) * @minutes;  -- milliseconds * cores * 60 seconds (1 minute) ... * # of minutes.
	
	
	DECLARE @startInterval int, @endInterval int;
	SET @sql = N'SET @startInterval = (SELECT TOP 1 [runtime_stats_interval_id] FROM [{targetDB}].sys.[query_store_runtime_stats_interval] WHERE [start_time] >= @startTime); ';
	SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);
	EXEC sys.[sp_executesql]
		@sql, 
		N'@startTime datetime, @startInterval int OUTPUT', 
		@startTime = @startTime,
		@startInterval = @startInterval OUTPUT;

	SET @sql = N'SET @endInterval = (SELECT TOP 1 [runtime_stats_interval_id] FROM [{targetDB}].sys.[query_store_runtime_stats_interval] WHERE [end_time] <= @endTime ORDER BY [end_time] DESC); ';
	SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);
	EXEC sys.[sp_executesql]
		@sql, 
		N'@endTime datetime, @endInterval int OUTPUT', 
		@endTime = @endTime,
		@endInterval = @endInterval OUTPUT;

	CREATE TABLE #QueryStoreStats (
		[runtime_stats_id] bigint NOT NULL,
		[start] datetime NOT NULL, 
		[end] datetime NOT NULL, 
		[execution_type] tinyint NOT NULL,
		[count_executions] bigint NOT NULL,
		[avg_duration] decimal(24,2) NOT NULL,
		[avg_cpu_time] decimal(24,2) NOT NULL,
		[avg_logical_io_reads] float NOT NULL,
		[avg_logical_io_writes] float NOT NULL,
		[avg_physical_io_reads] float NOT NULL,
		[avg_query_max_used_memory] float NOT NULL,
		[avg_rowcount] float NOT NULL,
		[avg_log_bytes_used] float NULL,
		[avg_tempdb_space_used]	 float NULL		
	);

	SET @sql = N'SELECT 
		s.[runtime_stats_id],
		CAST(i.[start_time] AS datetime) [start], 
		CAST(i.[end_time] AS datetime) [end],
		s.[execution_type],
		s.[count_executions],
		CAST(s.[avg_duration] / 1000.0 as decimal(24,2)) [avg_duration],
		CAST(s.[avg_cpu_time] / 1000.0 as decimal(24,2)) [avg_cpu_time],
		s.[avg_logical_io_reads],
		s.[avg_logical_io_writes],
		s.[avg_physical_io_reads],
		s.[avg_query_max_used_memory],
		s.[avg_rowcount],
		s.[avg_log_bytes_used],
		s.[avg_tempdb_space_used]
	FROM 
		[{targetDB}].sys.[query_store_runtime_stats] s
		INNER JOIN [{targetDB}].sys.[query_store_runtime_stats_interval] i ON s.[runtime_stats_interval_id] = i.[runtime_stats_interval_id]
	WHERE 
		s.[runtime_stats_interval_id] >= @startInterval
		AND s.[runtime_stats_interval_id] <= @endInterval; ';

	SET @sql = REPLACE(@sql, N'{targetDB}', @TargetDatabase);

	INSERT INTO #QueryStoreStats (
		[runtime_stats_id],
		[start],
		[end],
		[execution_type],
		[count_executions],
		[avg_duration],
		[avg_cpu_time],
		[avg_logical_io_reads],
		[avg_logical_io_writes],
		[avg_physical_io_reads],
		[avg_query_max_used_memory],
		[avg_rowcount],
		[avg_log_bytes_used],
		[avg_tempdb_space_used]
	)
	EXEC sys.[sp_executesql] 
		@sql, 
		N'@startInterval int, @endInterval int', 
		@startInterval = @startInterval, 
		@endInterval = @endInterval;

	CREATE TABLE #times (
		row_id int IDENTITY(1,1) NOT NULL, 
		time_block datetime NOT NULL
	);

	WITH times AS ( 
		SELECT @startTime [time_block] 

		UNION ALL 

		SELECT DATEADD(MINUTE, @minutes, [time_block]) [time_block]
		FROM [times]
		WHERE [time_block] < @endTime
	) 

	INSERT INTO [#times] (
		[time_block]
	)
	SELECT [time_block] 
	FROM times
	OPTION (MAXRECURSION 0);	

	WITH times AS ( 
		SELECT 
			row_id,
			t.[time_block] [end],
			LAG(t.[time_block], 1, DATEADD(MINUTE, (0 - @minutes), @startTime)) OVER (ORDER BY row_id) [start]
		FROM 
			[#times] t
	), 
	correlated AS ( 
		SELECT 
			t.[row_id], 
			t.[start] [time_period],
			[s].[runtime_stats_id],
			[s].[start],
			[s].[end],
			[s].[execution_type],
			[s].[count_executions],
			[s].[avg_duration],
			[s].[avg_cpu_time],
			[s].[avg_logical_io_reads],
			[s].[avg_logical_io_writes],
			[s].[avg_physical_io_reads],
			[s].[avg_query_max_used_memory],
			[s].[avg_rowcount],
			[s].[avg_log_bytes_used],
			[s].[avg_tempdb_space_used]
		FROM 
			[times] t 
			LEFT OUTER JOIN [#QueryStoreStats] s ON s.[end] < t.[end] AND s.[end] > t.[start]
	), 
	aggregated AS ( 
		SELECT 
			[time_period], 
			--COUNT([runtime_stats_id]) [total_collections], 
			SUM([count_executions]) [total_executions], 
			SUM([avg_cpu_time]) [avg_cpu], 
			CAST(((SUM([avg_cpu_time]) / @cpuMillisecondsPerInterval) * 100.0) AS decimal(4,2)) [%_cpu_ms],
			SUM([avg_duration]) [avg_duration],
			CAST(((SUM([avg_duration]) / @cpuMillisecondsPerInterval) * 100.0) AS decimal(4,2)) [%_duration_ms],
		-- this guy is usually a PIG compared to everything else: 
			CAST(((SUM([avg_logical_io_reads]) * 8.0) / 1073741824.0) AS decimal(24,2)) [logical_reads_TB], 
			CAST(((SUM([avg_logical_io_writes]) * 8.0) / 1048576.0) AS decimal(24,2)) [logical_writes_GB], 
			CAST(((SUM([avg_query_max_used_memory]) * 8.0) / 1048576.0) AS decimal(24,2)) [grant_GB],
			SUM([avg_rowcount]) [rowcounts], 
			CAST((SUM([avg_log_bytes_used]) / 1073741824.0) AS decimal(24,2)) [logged_GB], 
			CAST(((SUM([avg_tempdb_space_used]) * 8.0) / 1048576.0) AS decimal(24,2)) [tempdb_GB]
		FROM 
			[correlated] 
		WHERE 
			[correlated].[count_executions] IS NOT NULL
		GROUP BY 
			[time_period]
	), 
	formatted AS ( 
		SELECT 
			[time_period],
			FORMAT([total_executions], N'##,##0') [operations],
			FORMAT([rowcounts], N'##,##0') [rowcounts],
			dbo.[format_timespan](@cpuMillisecondsPerInterval) [available_ms],
			dbo.[format_timespan]([avg_cpu]) [consumed_cpu_ms],
			[%_cpu_ms],
			dbo.[format_timespan]([avg_duration]) [duration_ms],
			[%_duration_ms],
			[logical_reads_TB],
			[logical_writes_GB],
			[logged_GB],
			[grant_GB],
			[tempdb_GB] 
		FROM 
			[aggregated]
	) 

	SELECT 
		* 
	FROM 
		[formatted] 
	ORDER BY 
		[time_period];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.querystore_list_forced_plans','P') IS NOT NULL
	DROP PROC dbo.[querystore_list_forced_plans];
GO

CREATE PROC dbo.[querystore_list_forced_plans]
	@TargetDatabase						sysname		= NULL, 
	@ShowTimespanInsteadOfDates			bit			= 0, 
	@IncludeObjectDetails				bit			= 0, 
	@OrderResultsBy						sysname		= N'DURATION',			-- { DURATION_DEVIATION | CPU_DEVIATION | DURATION | CPU | ERRORS | PLAN_COUNT } 
	@IncludeScriptDirectives			bit			= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @ShowTimespanInsteadOfDates = ISNULL(@ShowTimespanInsteadOfDates, 0);
	SET @IncludeObjectDetails = ISNULL(@IncludeObjectDetails, 0);
	SET @IncludeScriptDirectives = ISNULL(@IncludeScriptDirectives, 1);
	SET @OrderResultsBy = ISNULL(NULLIF(@OrderResultsBy, N''), N'DURATION');

	IF UPPER(@OrderResultsBy) NOT IN (N'DURATION_DEVIATION', N'CPU_DEVIATION', N'DURATION', N'CPU', N'ERRORS', N'PLAN_COUNT') BEGIN 
		RAISERROR(N'Allowed values for @OrderResultsBy are { DURATION_DEVIATION | CPU_DEVIATION | DURATION | CPU | ERRORS | PLAN_COUNT }.', 16, 1);
		RETURN -10;
	END;

	IF @TargetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @TargetDatabase OUTPUT;
		
		IF @TargetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for @TargetDatabase and/or S4 was unable to determine calling-db-context. Please specify a valid database name for @TargetDatabase and retry. ', 16, 1);
			RETURN -5;
		END;
	END;

	IF NOT EXISTS (SELECT NULL FROM sys.databases WHERE [name] = @TargetDatabase AND [is_query_store_on] = 1) BEGIN 
		RAISERROR(N'The specified @TargetDatabase: [%s] does NOT exist OR Query Store is NOT enabled within %s.', 16, 1, @TargetDatabase, @TargetDatabase);
		RETURN -10;
	END;

	CREATE TABLE #forced_plans (
		[query_id] bigint NOT NULL,
		[plan_id] bigint NOT NULL,
		[query_text] nvarchar(max) NULL,
		[query_plan] xml NULL,
		[forcing_type] nvarchar(60) NULL,
		[plan_count] int NOT NULL, 
		[last_compile] datetime NULL,
		[last_execution] datetime NULL,
		[object_id] bigint NULL,
		[object_name] sysname NOT NULL,
		[failures] bigint NOT NULL,
		[last_failure] sysname NULL,
		[remove_script] nvarchar(331) NULL,
		[force_script] nvarchar(329) NULL
	);

	DECLARE @sql nvarchar(MAX) = N'SELECT
		[p].[query_id] [query_id],
		[p].[plan_id] [plan_id],
		[qt].[query_sql_text] [query_text],
		TRY_CAST([p].[query_plan] AS xml) [query_plan],
		[p].[plan_forcing_type_desc] [forcing_type],
		(SELECT COUNT(*) FROM [sys].[query_store_plan] [x] WHERE x.query_id = [p].query_id) [plan_count],
		CAST([p].[last_compile_start_time] AS datetime) [last_compile],
		CAST([p].[last_execution_time] AS datetime) [last_execution],
		[q].[object_id] [object_id],
		ISNULL(OBJECT_NAME([q].[object_id]), '''') [object_name],
		[p].[force_failure_count] [failures],
		[p].[last_force_failure_reason_desc] [last_failure],
		N''EXEC [{db_name}].sys.sp_query_store_unforce_plan @query_id = '' + CAST([p].[query_id] AS sysname) + N'', @plan_id = '' + CAST([p].[plan_id] AS sysname) + N'';'' [remove_script], 
		N''EXEC [{db_name}].sys.sp_query_store_force_plan @query_id = '' + CAST([p].[query_id] AS sysname) + N'', @plan_id = '' + CAST([p].[plan_id] AS sysname) + N'';'' [force_script]
	FROM
		[{db_name}].[sys].[query_store_plan] [p]
		INNER JOIN [{db_name}].[sys].[query_store_query] [q] ON [q].[query_id] = [p].[query_id]
		INNER JOIN [{db_name}].[sys].[query_store_query_text] [qt] ON [q].[query_text_id] = [qt].[query_text_id]
	WHERE
		[p].[is_forced_plan] = 1; ';

	SET @sql = REPLACE(@sql, N'{db_name}', @TargetDatabase);

	INSERT INTO [#forced_plans] (
		[query_id],
		[plan_id],
		[query_text],
		[query_plan],
		[forcing_type],
		[plan_count],
		[last_compile],
		[last_execution],
		[object_id],
		[object_name],
		[failures],
		[last_failure],
		[remove_script],
		[force_script]
	)
	EXEC sys.sp_executesql 
		@sql; 

	SET @sql = N'SELECT 
		[f].plan_id, 

		CAST(AVG([rs].[avg_duration]) as decimal(24,2)) [avg_duration], 
		CAST(MAX([rs].[avg_duration]) as decimal(24,2)) [max_duration],

		-- Deviation Logic 100% STOLEN from SSMS "Queries with High Variation" Report:
		ISNULL(ROUND(CONVERT(float, (SQRT(SUM([rs].[stdev_duration] * [rs].[stdev_duration] * [rs].[count_executions]) / NULLIF(SUM([rs].[count_executions]), 0)) * SUM([rs].[count_executions])) / NULLIF(SUM([rs].[avg_duration] * [rs].[count_executions]), 0)), 2), 0) [variation_duration],
		
		CAST(AVG([rs].[avg_cpu_time]) as decimal(24,2)) [avg_cpu_time], 
		CAST(MAX([rs].[avg_cpu_time]) as decimal(24,2)) [max_cpu_time],
		
		-- Ditto (except copy/paste/tweak to find variation based on cpu_usage): 
		ISNULL(ROUND(CONVERT(float, (SQRT(SUM([rs].[stdev_cpu_time] * [rs].[stdev_cpu_time] * [rs].[count_executions]) / NULLIF(SUM([rs].[count_executions]), 0)) * SUM([rs].[count_executions])) / NULLIF(SUM([rs].[avg_cpu_time] * [rs].[count_executions]), 0)), 2), 0) [variation_cpu_time]
	FROM 
		[#forced_plans] [f]
		INNER JOIN [{db_name}].[sys].[query_store_runtime_stats] [rs] ON [f].[plan_id] = [rs].[plan_id]
	GROUP BY 
		[f].[plan_id]; ';

	SET @sql = REPLACE(@sql, N'{db_name}', @TargetDatabase);

	CREATE TABLE #metrics (
		[plan_id] bigint NOT NULL,
		[avg_duration] float NOT NULL, 
		[max_duration] float NOT NULL, 
		[variation_duration] float NOT NULL, 
		[avg_cpu_time] float NOT NULL, 
		[max_cpu_time] float NOT NULL, 
		[variation_cpu_time] float NOT NULL
	);

	INSERT INTO [#metrics] (
		[plan_id],
		[avg_duration],
		[max_duration],
		[variation_duration],
		[avg_cpu_time],
		[max_cpu_time],
		[variation_cpu_time]
	)
	EXEC sp_executesql 
		@sql;

	SET @sql = N'SELECT 
	[f].[query_id],
	[f].[plan_id],
	[f].[query_text],
	[f].[query_plan],
	[f].[forcing_type],
	[f].[plan_count],
	{times}{options}
	[f].[failures],
	[f].[last_failure],
	[m].[avg_duration],
	[m].[max_duration],
	[m].[variation_duration],
	[m].[avg_cpu_time],
	[m].[max_cpu_time],
	[m].[variation_cpu_time], 
	N'''' [ ],
	[f].[remove_script],
	[f].[force_script]
FROM 
	[#forced_plans] [f]
	LEFT OUTER JOIN [#metrics] [m] ON [f].[plan_id] = [m].[plan_id]
ORDER BY 
	{order_by} DESC; '; 

	DECLARE @times nvarchar(MAX) = N'[f].[last_compile],
	[f].[last_execution], ';

	IF @ShowTimespanInsteadOfDates = 1 BEGIN 
		SET @times = N'admindb.dbo.format_timespan(DATEDIFF(MILLISECOND, [f].[last_compile], GETDATE())) [last_compile],
	admindb.dbo.format_timespan(DATEDIFF(MILLISECOND,[f].[last_execution], GETDATE())) [last_execution],';
	END;

	DECLARE @options nvarchar(MAX) = N''; 
	IF @IncludeObjectDetails = 1 BEGIN 
		SET @options = NCHAR(13) + NCHAR(10) + NCHAR(9) + N'[f].[object_id],
	[f].[object_name],'
	END;

	DECLARE @orderBy nvarchar(MAX);
	SET @orderBy = CASE UPPER(@OrderResultsBy)
		WHEN N'DURATION_DEVIATION' THEN N'[m].[variation_duration]'
		WHEN N'CPU_DEVIATION' THEN N'[m].[variation_cpu_time]'
		WHEN N'DURATION' THEN N'[m].[avg_duration]'
		WHEN N'CPU' THEN N'[m].[avg_cpu_time]'
		WHEN N'ERRORS' THEN N'[f].[failures]'
		WHEN N'PLAN_COUNT' THEN N'[f].[plan_count]'
		ELSE N'[m].[variation_duration]' 
	END;

	SET @sql = REPLACE(@sql, N'{times}', @times);
	SET @sql = REPLACE(@sql, N'{options}', @options);
	SET @sql = REPLACE(@sql, N'{order_by}', @orderBy);

	EXEC sys.sp_executesql 
		@sql;

	RETURN 0; 
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Extended Events
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_xe_sessions','P') IS NOT NULL
	DROP PROC dbo.[list_xe_sessions];
GO

CREATE PROC dbo.[list_xe_sessions]
	@TargetSessionName				sysname			= NULL,
	@IncludeDiagnostics				bit				= 0,
	@SerializedOutput				xml				= N'<default/>'	    OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @TargetSessionName = NULLIF(@TargetSessionName, N'');
	SET @IncludeDiagnostics = NULLIF(@IncludeDiagnostics, 0);

	DECLARE @xeSource sysname = N'server';
	IF LOWER(@@VERSION) LIKE '%azure%' SET @xeSource = N'database';

	DECLARE @sql nvarchar(MAX) = N'SELECT 
		[s].[event_session_id],
		[s].[name],
		[s].[event_retention_mode_desc],
		[s].[max_dispatch_latency],
		[s].[max_memory],
		[s].[max_event_size],
		[s].[memory_partition_mode],
		[s].[memory_partition_mode_desc],
		[s].[track_causality],
		[s].[startup_state], 
		-- azure only: [has_long_running_target] 
		[t].[name] [storage_type]
	FROM 
		sys.[{0}_event_sessions] [s]
		INNER JOIN [sys].[{0}_event_session_targets] [t] ON [s].[event_session_id] = [t].[event_session_id]; ';

	SET @sql = REPLACE(@sql, N'{0}', @xeSource);

	CREATE TABLE #definitions ( 
		[event_session_id] int NOT NULL,
		[name] sysname NULL,
		[event_retention_mode_desc] nvarchar(60) NULL,
		[max_dispatch_latency] int NULL,
		[max_memory] int NULL,
		[max_event_size] int NULL,
		[memory_partition_mode] char(1) NULL,
		[memory_partition_mode_desc] nvarchar(60) NULL,
		[track_causality] bit NULL,
		[startup_state] bit NULL,
		[storage_type] sysname NOT NULL
	); 

	INSERT INTO [#definitions] (
		[event_session_id],
		[name],
		[event_retention_mode_desc],
		[max_dispatch_latency],
		[max_memory],
		[max_event_size],
		[memory_partition_mode],
		[memory_partition_mode_desc],
		[track_causality],
		[startup_state], 
		[storage_type]
	)
	EXEC sp_executesql
		@sql;

	SET @sql = N'SELECT 
	[s].[name],
	[s].[buffer_policy_desc],
	[s].[dropped_event_count],
	[s].[dropped_buffer_count],
	[s].[blocked_event_fire_time],
	[s].[create_time] /* Pretty much pointless as per: https://dba.stackexchange.com/q/255387/6100 */,{version_specific}
	[t].[target_data],
	[t].[bytes_written]	
FROM 
	sys.[dm_xe_{0}sessions] [s]
	INNER JOIN [sys].[dm_xe_{0}session_targets] [t] ON [s].[address] = [t].[event_session_address]; ';

	CREATE TABLE #states (
		[name] sysname NOT NULL, 
		[buffer_policy_des] sysname NOT NULL,
		[dropped_event_count] int NOT NULL, 
		[dropped_buffer_count] int NOT NULL, 
		[blocked_event_fire_time] int NOT NULL,
		[create_time] datetime NOT NULL
	);
	
	DECLARE @versionCols nvarchar(MAX) = N'';
	DECLARE @crlftab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);
	IF (SELECT dbo.[get_engine_version]()) >= 14.00 BEGIN 
		ALTER TABLE [#states] ADD [buffer_processed_count] bigint NOT NULL;
		ALTER TABLE [#states] ADD [total_bytes_generated] bigint NOT NULL;

		SET @versionCols = @versionCols + @crlftab + N'[s].[buffer_processed_count], ' + @crlftab + N'[s].[buffer_processed_count],';
	END; 

	IF (SELECT dbo.[get_engine_version]()) >= 15.00 BEGIN 
		ALTER TABLE [#states] ADD [total_target_memory] bigint NOT NULL;

		SET @versionCols = @versionCols + @crlftab + N'[s].[total_target_memory],';
	END;
	
	ALTER TABLE [#states] ADD [target_data] nvarchar(MAX) NULL;
	ALTER TABLE [#states] ADD [bytes_written] bigint NOT NULL;

	SET @sql = REPLACE(@sql, N'{version_specific}', @versionCols);
	
	IF @xeSource = N'database'
		SET @sql = REPLACE(@sql, N'{0}', N'database_');
	ELSE 
		SET @sql = REPLACE(@sql, N'{0}', N'');

	INSERT INTO [#states] -- MKC: hmmm... being lazy and using shorthand syntax. usually comes to bite me later on. 
	EXEC sp_executesql 
		@sql

	SET @sql = N'SELECT 
	[event_session_id], 
	CAST([value] as sysname) [file_name] 
FROM 
	[sys].[{0}_event_session_fields] 
WHERE 
	LOWER([name]) = N''filename''; ';

	CREATE TABLE #files ( 
		[event_session_id] int NOT NULL, 
		[file_name] sysname NOT NULL 
	); 

	SET @sql = REPLACE(@sql, N'{0}', @xeSource);

	INSERT INTO [#files] ([event_session_id],[file_name])
	EXEC sp_executesql 
		@sql; 

	DECLARE @finalProjection nvarchar(MAX) = N'	SELECT 
		[d].[name] [session_name],
		CASE WHEN [s].[name] IS NULL THEN N''stopped'' ELSE N''RUNNING'' END [status],
		REPLACE(REPLACE([d].[event_retention_mode_desc], N''ALLOW_'', N''''), N''_EVENT_LOSS'', N'''') [loss_mode],
		[d].[max_dispatch_latency] / 1000 [latency],
		[d].[max_memory] / 1024 [buffer_mb],
		--[d].[max_event_size],
		REPLACE([d].[memory_partition_mode_desc], N''PER_'', N'''') [partition],
		[d].[track_causality] [causality],
		[d].[startup_state] [auto_start],
		[d].[storage_type],
		--[s].[buffer_policy_des],
		[f].[file_name]{diagnostics}
	FROM 
		[#definitions] [d]
		LEFT OUTER JOIN [#states] [s] ON [d].[name] = [s].[name]
		LEFT OUTER JOIN [#files] [f] ON [d].[event_session_id] = [f].[event_session_id]{WHERE} 
	ORDER BY 
		[d].[name]{FORXML} ;';

	DECLARE @diagnostics nvarchar(MAX) = N'		{padding}[s].[dropped_event_count] [dropped_events],
		[s].[dropped_buffer_count] [dropped_buffers],
		[s].[blocked_event_fire_time] [blocked_latency],
		[s].[create_time], 
		[s].[target_data],{version_specific} 
		[s].[bytes_written] ';

	IF @IncludeDiagnostics = 1 BEGIN 
	   	SET @finalProjection = REPLACE(@finalProjection, N'{diagnostics}', N',' + @crlftab + @diagnostics);
		SET @finalProjection = REPLACE(@finalProjection, N'{version_specific}', REPLACE(@versionCols, NCHAR(9), NCHAR(9) + NCHAR(9)));
	  END; 
	ELSE 
		SET @finalProjection = REPLACE(@finalProjection, N'{diagnostics}', N'');

	IF @TargetSessionName IS NOT NULL 
		SET @finalProjection = REPLACE(@finalProjection, N'{WHERE}', @crlftab + N'WHERE' + @crlftab + NCHAR(9) + N'LOWER([d].[name]) = LOWER(@TargetSessionName)'); 
	ELSE 
		SET @finalProjection = REPLACE(@finalProjection, N'{WHERE}', N''); 

	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- RETURN instead of project.. 
		SET @finalProjection = REPLACE(@finalProjection, N'{padding}', N'');	

		SET @finalProjection = REPLACE(@finalProjection, N'{FORXML}', @crlftab + N'FOR XML PATH(''session''), ROOT(''sessions'')');
		SET @finalProjection = REPLACE(@finalProjection, N'SELECT', N'SELECT @output = (SELECT');
		SET @finalProjection = REPLACE(@finalProjection, N';', N');');

		DECLARE @output xml;
		EXEC [sys].[sp_executesql]
			@finalProjection, 
			N'@TargetSessionName sysname, @output xml OUTPUT', 
			@TargetSessionName = @TargetSessionName,
			@output = @output OUTPUT

		SET @SerializedOutput = @output;

		RETURN 0;
	END;

	-- If we're still here: PROJECT:
	SET @finalProjection = REPLACE(@finalProjection, N'{FORXML}', N'');
	SET @finalProjection = REPLACE(@finalProjection, N'{padding}', N''''' [ ],');
	
	EXEC sys.[sp_executesql]
		@finalProjection, 
		N'@TargetSessionName sysname', 
		@TargetSessionName = @TargetSessionName;

	RETURN 0;
GO	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_initialize_extraction]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_initialize_extraction];
GO

CREATE PROC dbo.[eventstore_initialize_extraction]
	@SessionName					sysname, 
	@ExtractionID					int					OUTPUT, 
	@CET							datetime2			OUTPUT, 
	@LSET							datetime2			OUTPUT, 
	@Attributes						nvarchar(300)		OUTPUT, 
	@InitializationDaysBack			int =				10
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SELECT @CET = DATEADD(MILLISECOND, -2, GETUTCDATE());

	-- grab LSET and attributes: 
	DECLARE @intializationLSET datetime2 = DATEADD(DAY, 0 - @InitializationDaysBack, GETUTCDATE());
	DECLARE @maxID int; 

	SELECT 
		@maxID = MAX(extraction_id)
	FROM 
		[dbo].[eventstore_extractions] 
	WHERE 
		[session_name] = @SessionName 
		AND [lset] IS NOT NULL;

	SELECT 
		@Attributes = [attributes]
	FROM 
		dbo.[eventstore_extractions] 
	WHERE 
		[extraction_id] = @maxID;

	SELECT @LSET = ISNULL(@LSET, @intializationLSET);

	-- start CET:
	INSERT INTO dbo.[eventstore_extractions] ([session_name], [cet]) 
	VALUES (@SessionName, @CET);

	SELECT @ExtractionID = SCOPE_IDENTITY();

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_finalize_extraction]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_finalize_extraction];
GO

CREATE PROC dbo.[eventstore_finalize_extraction]
	@SessionName			sysname,
	@ExtractionId			int, 
	@RowCount				int,
	@Attributes				nvarchar(300)		= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @Attributes = NULLIF(@Attributes, N'');

	IF NOT EXISTS (SELECT NULL FROM dbo.[eventstore_extractions] WHERE [extraction_id] = @ExtractionId AND [session_name] = @SessionName AND [lset] IS NULL) BEGIN 
		RAISERROR(N'Invalid @ExtractionId or @SessionName - no match for specified @SessionName + @ExtractionId exists - or LSET has already been assigned.', 16, 1);
		RETURN -10;
	END;
	
	UPDATE [dbo].[eventstore_extractions] 
	SET 
		[lset] = [cet], 
		[attributes] = @Attributes, 
		[row_count] = @RowCount
	WHERE 
		[extraction_id] = @ExtractionId; 

	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_extract_session_xml]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_extract_session_xml];
GO

CREATE PROC dbo.[eventstore_extract_session_xml]
	@SessionName				sysname, 
	@Output						xml					OUTPUT, 
	@ExtractionID				int					OUTPUT, 
	@ExtractionAttributes		nvarchar(300)		OUTPUT, 
	@InitializationDaysBack		int					= 10
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	SET @SessionName = NULLIF(@SessionName, N'');

	IF @SessionName IS NULL BEGIN 
		RAISERROR(N'A valid @SessionName must be provided.', 16, 1);
		RETURN -1;
	END;

	DECLARE @SerializedOutput xml;
	EXEC dbo.[list_xe_sessions] 
		@TargetSessionName = @SessionName, 
		@IncludeDiagnostics = 1,
		@SerializedOutput = @SerializedOutput OUTPUT;

	IF dbo.[is_xml_empty](@SerializedOutput) = 1 BEGIN 
		RAISERROR(N'Target @SessionName: [%s] not found. Please verify @SessionName input.', 16, 1, @SessionName); 
		RETURN -10;
	END;

	DECLARE @storageType sysname, @fileName sysname;
	SELECT 
		@storageType = [nodes].[data].value(N'(storage_type)[1]',N'sysname'), 
		@fileName = [nodes].[data].value(N'(file_name)[1]',N'sysname')
	FROM 
		@SerializedOutput.nodes(N'//session') [nodes] ([data]);

	DECLARE @cet datetime2;
	DECLARE @lset datetime2;
	DECLARE @attributes nvarchar(300);

	EXEC dbo.[eventstore_initialize_extraction]
		@SessionName = @SessionName,
		@ExtractionID = @ExtractionID OUTPUT,
		@CET = @cet OUTPUT,
		@LSET = @lset OUTPUT,
		@Attributes = @attributes OUTPUT, 
        @InitializationDaysBack = @InitializationDaysBack;

	IF @storageType = N'ring_buffer' BEGIN 
		SELECT 
			nodes.[event].query(N'(.)[1]') [event] 
			--nodes.[event].value(N'(@timestamp)[1]', N'datetime2(7)') [timestamp_utc]
		FROM 
			(
			SELECT 
				CAST([t].[target_data] AS xml) [events]
			FROM 
				sys.[dm_xe_database_sessions] s 
				INNER JOIN sys.[dm_xe_database_session_targets] t ON t.[event_session_address] = s.[address] 
			WHERE 
				s.[name] = @SessionName
			) [xml]
			CROSS APPLY [xml].[events].nodes(N'//event') [nodes]([event])
		WHERE 
			nodes.[event].value(N'(@timestamp)[1]', N'datetime2(7)') >= @lset 
			AND nodes.[event].value(N'(@timestamp)[1]', N'datetime2(7)') < @cet;
	  END; 
	ELSE BEGIN -- event_file
		/* Normalize and tokenize .xel file name: */
		IF @fileName NOT LIKE N'%`.xel' ESCAPE N'`' SET @fileName = @fileName + N'.xel';
		SET @fileName = REPLACE(@fileName, N'.xel', N'*.xel');
		
		DECLARE @fileAttribute sysname = NULL, @offsetAttribute bigint = NULL;

		IF @attributes IS NOT NULL BEGIN 
			SELECT 
				@fileAttribute = LEFT(@attributes, PATINDEX(N'%::%', @attributes) - 1), 
				@offsetAttribute = CAST(SUBSTRING(@attributes, PATINDEX(N'%::%', @attributes) +2, LEN(@attributes)) AS bigint); 
		END;

		CREATE TABLE #raw_xe_data (
			[row_id] int IDENTITY(1,1) NOT NULL, 
			[event_data] xml NOT NULL, 
			[file_name] nvarchar(260) NOT NULL, 
			[file_offset] bigint NOT NULL
		);
		
		IF dbo.[get_engine_version]() < 14.00 BEGIN 
			INSERT INTO [#raw_xe_data] (
				[event_data],
				[file_name],
				[file_offset]
			)			
			SELECT 
				[x].[XMLData] [event_data], 
				[x].[file_name], 
				[x].[file_offset]
			FROM (
				SELECT 
					CAST([event_data] AS xml) [XMLData], 
					[file_name], 
					[file_offset] 
				FROM 
					sys.[fn_xe_file_target_read_file](@fileName, NULL, @fileAttribute, @offsetAttribute)
			) AS [x] 
			WHERE 
				[x].[XMLData].value(N'(/event/@timestamp)[1]', N'datetime2') >= @lset AND [x].[XMLData].value(N'(/event/@timestamp)[1]', N'datetime2') < @cet;
		  END; 
		ELSE BEGIN
			INSERT INTO [#raw_xe_data] (
				[event_data],
				[file_name],
				[file_offset]
			)
			SELECT 
				[event_data],
				[file_name],
				[file_offset]
			FROM 
				sys.[fn_xe_file_target_read_file](@fileName, NULL, @fileAttribute, @offsetAttribute)
			WHERE 
				/* BUG: https://dba.stackexchange.com/a/323151/6100 */
				CAST([timestamp_utc] AS datetime2) >= @lset AND CAST([timestamp_utc] AS datetime2) < @cet;
		END;

		IF EXISTS (SELECT NULL FROM [#raw_xe_data]) BEGIN 
			DECLARE @newAttribute nvarchar(300);
			SELECT
				@newAttribute = [file_name] + N'::' + CAST([file_offset] AS sysname)
			FROM 
				[#raw_xe_data] 
			WHERE 
				[row_id] = (SELECT MAX(row_id) FROM [#raw_xe_data]);

			SET @ExtractionAttributes = @newAttribute;
		  END;
		ELSE BEGIN 
			-- If there were no NEW rows extracted, PRESERVE the previous attributes:
			SELECT @ExtractionAttributes = @attributes;
		END;
	END; 

	SELECT @Output = (
		SELECT
			[event_data] [node()]  -- outputs WITHOUT creating new tags
		FROM 
			[#raw_xe_data]
		ORDER BY 
			[row_id] 
		FOR XML PATH(''), ROOT('events'), TYPE
	);

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_etl_session]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_etl_session];
GO

CREATE PROC dbo.[eventstore_etl_session]
	@SessionName					sysname, 
	@EventStoreTarget				sysname,
	@TranslationDML					nvarchar(MAX),
	@InitializeDaysBack				int						= 10
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @InitializeDaysBack = ISNULL(@InitializeDaysBack, 10);	

	/* Verify that the XE Session (SessionName) exists: */
	DECLARE @SerializedOutput xml;
	EXEC dbo.[list_xe_sessions] 
		@TargetSessionName = @SessionName, 
		@IncludeDiagnostics = 1,
		@SerializedOutput = @SerializedOutput OUTPUT;

	IF dbo.[is_xml_empty](@SerializedOutput) = 1 BEGIN 
		RAISERROR(N'Target @SessionName: [%s] not found. Please verify @SessionName input.', 16, 1, @SessionName); 
		RETURN -10;
	END;

	/* Verify that the target table (XEStoreTarget) exists: */ 
	DECLARE @targetDatabase sysname, @targetSchema sysname, @targetObjectName sysname;
	SELECT 
		@targetDatabase = PARSENAME(@EventStoreTarget, 3), 
		@targetSchema = ISNULL(PARSENAME(@EventStoreTarget, 2), N'dbo'), 
		@targetObjectName = PARSENAME(@EventStoreTarget, 1);
	
	IF @targetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @targetDatabase OUTPUT;
		
		IF @targetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for @EventStoreTarget and/or S4 was unable to determine calling-db-context. Please use [db_name].[schema_name].[object_name] qualified names.', 16, 1);
			RETURN -5;
		END;
	END;

	DECLARE @fullyQualifiedTargetTableName nvarchar(MAX) = QUOTENAME(@targetDatabase) + N'.' + QUOTENAME(@targetSchema) + N'.' + QUOTENAME(@targetObjectName) + N'';
	DECLARE @check nvarchar(MAX) = N'SELECT @targetObjectID = OBJECT_ID(''' + @fullyQualifiedTargetTableName + N''');';

	DECLARE @targetObjectID int;
	EXEC [sys].[sp_executesql] 
		@check, 
		N'@targetObjectID int OUTPUT', 
		@targetObjectID = @targetObjectID OUTPUT; 

	IF @targetObjectID IS NULL BEGIN 
		RAISERROR('The target table-name specified by @EventStoreTarget: [%s] could not be located. Please create it using admindb.dbo.eventstore_init_%s or create a new table following admindb documentation.', 16, 1, @EventStoreTarget, @SessionName);
		RETURN -7;
	END;

	/* Otherwise, init extraction, grab rows, and ... if all passes, finalize extraction (i.e., LSET/CET management). */
	DECLARE @Output xml, @extractionID int,	@extractionAttributes nvarchar(300);
	EXEC dbo.[eventstore_extract_session_xml]
		@SessionName = @SessionName,
		@Output = @Output OUTPUT,
		@ExtractionID = @extractionID OUTPUT,
		@ExtractionAttributes = @extractionAttributes OUTPUT, 
		@InitializationDaysBack = @InitializeDaysBack;

	DECLARE @sql nvarchar(MAX) = @TranslationDML;

	SET @sql = REPLACE(@sql, N'{targetDatabase}', @targetDatabase);
	SET @sql = REPLACE(@sql, N'{targetSchema}', @targetSchema);
	SET @sql = REPLACE(@sql, N'{targetTable}', @targetObjectName);

-- TODO: use a helper func to get this - based on underlying OS (windows or linux). 
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @rowCount int;
	DECLARE @errorMessage nvarchar(MAX), @errorLine int;
	BEGIN TRY 
		BEGIN TRAN;

			EXEC sys.sp_executesql 
				@sql,
				N'@EventData xml', 
				@EventData = @Output;

			SELECT @rowCount = @@ROWCOUNT;

			EXEC dbo.[eventstore_finalize_extraction] 
				@SessionName = @SessionName, 
				@ExtractionId = @extractionID, 
				@RowCount = @rowCount,
				@Attributes = @extractionAttributes;
		
		COMMIT;
	END TRY
	BEGIN CATCH 
		SELECT 
			@errorLine = ERROR_LINE(), 
			@errorMessage = N'Exception processing ETL for Session: [%s].' + @crlf + N'Msg ' + CAST(ERROR_NUMBER() AS sysname) + N', Line ' + CAST(ERROR_LINE() AS sysname) + @crlf + ERROR_MESSAGE();

		IF @@TRANCOUNT > 0 
			ROLLBACK;

		RAISERROR(@errorMessage, 16, 1, @SessionName);
		EXEC dbo.[extract_dynamic_code_lines] @sql, @errorLine, 6;

		UPDATE dbo.[eventstore_extractions] 
		SET
			[error] = @errorMessage
		WHERE 
			[extraction_id] = @extractionID 
			AND [session_name] = @SessionName;

		RETURN -100;
	END CATCH;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_etl_processor]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_etl_processor];
GO

CREATE PROC dbo.[eventstore_etl_processor]

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Get Sessions to Process:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	WITH core AS ( 
		SELECT 
			[session_name],
			[etl_proc_name],
			[target_table],
			[etl_enabled],
			[etl_frequency_minutes],
			ISNULL((SELECT MAX([e].[lset]) FROM [dbo].[eventstore_extractions] [e] WHERE [e].[session_name] = [s].[session_name]), DATEADD(MINUTE, 0 - 12, GETUTCDATE())) [lset]
		FROM 
			dbo.[eventstore_settings] [s]
		WHERE 
			[etl_enabled] = 1 
	) 

	SELECT 
		[session_name],
		[etl_proc_name],
		[target_table],
		[etl_enabled],
		[etl_frequency_minutes],
		[lset]
	INTO 
		#sessions_to_process
	FROM 
		core 
	WHERE 
		DATEDIFF(MINUTE, [lset], GETUTCDATE()) > [etl_frequency_minutes]
	ORDER BY
		[etl_frequency_minutes];

	IF NOT EXISTS (SELECT NULL FROM [#sessions_to_process]) BEGIN 
		RETURN 0; -- nothing to process. 
	END;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- AND execute each etl that needs to be handled.
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @sprocToExecute sysname;
	
	DECLARE @sessionName sysname, @etlName sysname, @targetTableName sysname;
	DECLARE [cursorName] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[session_name],
		[etl_proc_name],
		[target_table]
	FROM 
		[#sessions_to_process] 
	ORDER BY 
		[etl_frequency_minutes];
	
	OPEN [cursorName];
	FETCH NEXT FROM [cursorName] INTO @sessionName, @etlName, @targetTableName;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
	
		SET @sprocToExecute = @etlName; 

		EXEC @sprocToExecute 
			@SessionName = @sessionName, 
			@EventStoreTarget = @targetTableName;
	
		-- vNEXT: check for LSET by session_name... as a form of error handling/reporting.

		FETCH NEXT FROM [cursorName] INTO @sessionName, @etlName, @targetTableName;
	END;
	
	CLOSE [cursorName];
	DEALLOCATE [cursorName];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_verify_jobs]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_verify_jobs];
GO

CREATE PROC dbo.[eventstore_verify_jobs]
	@ForceOverwrite			bit		= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @dateAsInt int = CAST(CONVERT(sysname, GETDATE(), 112) AS int);

	IF @ForceOverwrite = 1 OR (NOT EXISTS (SELECT NULL FROM msdb..[sysjobs] WHERE [name] = N'EventStore Processor')) BEGIN

		DECLARE @jobStep nvarchar(MAX) = N'EXEC admindb.dbo.[eventstore_etl_processor];';

		DECLARE @JobID uniqueidentifier;
		EXEC dbo.[create_agent_job]
			@TargetJobName = N'EventStore Processor',
			@JobCategoryName = N'EventStore',
			@JobEnabled = 1,
			@AddBlankInitialJobStep = 1,
			@OverWriteExistingJobDetails = 1,
			@JobID = @JobID OUTPUT; 

		EXEC msdb..[sp_update_job] 
			@job_id = @JobID,
			@description = N'Transforms EventStore XE Session Target Data to EventStore Reporting Data.';		

		EXEC msdb..[sp_add_jobschedule]
			@job_id = @JobID,
			@name = N'Regular EventStore ETL Processing Schedule',
			@enabled = 1,
			@freq_type = 4,		-- daily
			@freq_interval = 1,  -- every 1 day
			@freq_subday_type = 4,	-- every N minutes
			@freq_subday_interval = 1,  -- 1 minute (i.e., N from above).
			@freq_relative_interval = 0,
			@freq_recurrence_factor = 0,
			@active_start_date = @dateAsInt,
			@active_start_time = 140;  -- at 12:01:40

		EXEC msdb..[sp_add_jobstep]
			@job_id = @JobID,
			@step_id = 2,
			@step_name = N'Process EventStore Transformations',
			@subsystem = N'TSQL',
			@command = @jobStep,
			@on_success_action = 1,
			@on_fail_action = 2,
			@database_name = N'admindb',
			@retry_attempts = 0,
			@retry_interval = 0;
	END;

	IF @ForceOverwrite = 1 OR (NOT EXISTS (SELECT NULL FROM msdb..[sysjobs] WHERE [name] = N'EventStore Cleanup')) BEGIN 
		
		SET @jobStep = N'EXEC admindb.dbo.[eventstore_data_cleanup];';

		SET @JobID = NULL;
		EXEC dbo.[create_agent_job]
			@TargetJobName = N'EventStore Cleanup',
			@JobCategoryName = N'EventStore',
			@JobEnabled = 1,
			@AddBlankInitialJobStep = 1,
			@OverWriteExistingJobDetails = 1,
			@JobID = @JobID OUTPUT; 

		EXEC msdb..[sp_update_job] 
			@job_id = @JobID,
			@description = N'Regular cleanup of EventStore data.';		

		EXEC msdb..[sp_add_jobschedule]
			@job_id = @JobID,
			@name = N'Regular EventStore Cleanup Schedule',
			@enabled = 1,
			@freq_type = 4,		-- daily
			@freq_interval = 1,  -- every 1 day
			@freq_subday_type = 1,	
			@freq_subday_interval = 0,  
			@freq_relative_interval = 0,
			@freq_recurrence_factor = 0,
			@active_start_date = @dateAsInt,
			@active_start_time = 223000;  -- 10:30PM

		EXEC msdb..[sp_add_jobstep]
			@job_id = @JobID,
			@step_id = 2,
			@step_name = N'Cleanup Transformed EventStore Data.',
			@subsystem = N'TSQL',
			@command = @jobStep,
			@on_success_action = 1,
			@on_fail_action = 2,
			@database_name = N'admindb',
			@retry_attempts = 0,
			@retry_interval = 0;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_setup_session]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_setup_session];
GO

CREATE PROC dbo.[eventstore_setup_session]
	@EventStoreKey							sysname,
	@TargetSessionName						sysname,
	@TargetEventStoreTable					sysname,
	@TraceTarget							sysname = N'event_file',	-- { event_file | ring_buffer }. When 'ring_buffer', use/set @MaxBufferEvents; when event_file, use/set @MaxiFiles + @FileSizeMB + @TraceFilePath.
	@TraceFilePath							sysname = N'D:\Traces', 
	@MaxFiles								int = 10, 
	@FileSizeMB								int = 200, 
	@MaxBufferEvents						int = 1024,
	@StartupState							bit = 1, 
	@StartSessionOnCreation					bit = 1,
	@EtlEnabled								bit = 1,
	@EtlFrequencyMinutes					int = 10,
	@EtlProcedureName						sysname,
	@DataRetentionDays						int = 90,
	@OverwriteSessionIfExists				sysname = NULL,				-- { KEEP | REPLACE}
	@OverwriteTableIfExists					sysname = NULL,				-- { KEEP | REPLACE}
	@OverwriteSettingsIfExist				sysname = NULL,				-- { KEEP | REPLACE}
	@EventStoreTableDDL						nvarchar(MAX),				-- Expect exact/raw table DDL - with any IXes, compression, etc. defined as needed. ONLY 'templating' is {schema} and {table} vs hard-coded values.
	@EventStoreSessionDDL					nvarchar(MAX),				-- Expeect MOSTLY raw Session DDL. Tokens for: {session_name}, ON {server_or_database}, {xe_target}, and {starupt_state}
	@PrintOnly								bit = 0	
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @PrintOnly = ISNULL(@PrintOnly, 0);
	SET @MaxFiles = ISNULL(NULLIF(@MaxFiles, 0), 10);
	SET @FileSizeMB = ISNULL(NULLIF(@FileSizeMB, 0), 200);
	SET @MaxBufferEvents = ISNULL(NULLIF(@MaxBufferEvents, 0), 1024);

	SET @StartupState = ISNULL(@StartupState, 1);
	SET @StartSessionOnCreation = ISNULL(@StartSessionOnCreation, 1);	

	SET @OverwriteSessionIfExists = NULLIF(@OverwriteSessionIfExists, N'');
	SET @OverwriteTableIfExists = NULLIF(@OverwriteTableIfExists, N'');

	IF LOWER(@TraceTarget) NOT IN (N'event_file', N'ring_buffer') BEGIN 
		RAISERROR(N'Allowed values for @TraceTarget are ''event_file'' or ''ring_buffer''.', 16, 1);
		RETURN -110;
	END;

-- TODO: use a helper func to get this - based on underlying OS (windows or linux). 
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	/* Check for EventStore Table (@TargetEventStoreTable) exists + extract DB info/etc.: */
	DECLARE @dropTable nvarchar(MAX) = N'';
	DECLARE @targetDatabase sysname, @targetSchema sysname, @targetObjectName sysname;
	SELECT 
		@targetDatabase = PARSENAME(@TargetEventStoreTable, 3), 
		@targetSchema = ISNULL(PARSENAME(@TargetEventStoreTable, 2), N'dbo'), 
		@targetObjectName = PARSENAME(@TargetEventStoreTable, 1);
	
	IF @targetDatabase IS NULL BEGIN 
		IF @@VERSION NOT LIKE N'%Azure%' BEGIN
			EXEC dbo.[get_executing_dbname] @ExecutingDBName = @targetDatabase OUTPUT;
		  END; 
		ELSE BEGIN 
			SELECT @targetDatabase = DB_NAME();   -- TODO: need to verify that this works... 
		END;

		IF @targetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for %s and/or unable to determine calling-db-context. Please use dbname.schemaname.objectname qualified names.', 16, 1, @TargetEventStoreTable);
			RETURN -15;
		END;
	END;

	DECLARE @fullyQualifiedTargetTableName nvarchar(MAX) = QUOTENAME(@targetDatabase) + N'.' + QUOTENAME(@targetSchema) + N'.' + QUOTENAME(@targetObjectName) + N'';
	DECLARE @check nvarchar(MAX) = N'SELECT @targetObjectID = OBJECT_ID(''' + @fullyQualifiedTargetTableName + N''');'

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Check for Overwrite Options/Settings (and needs):
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @targetObjectID int;
	EXEC [sys].[sp_executesql] 
		@check, 
		N'@targetObjectID int OUTPUT', 
		@targetObjectID = @targetObjectID OUTPUT; 

	DECLARE @keepTable bit = 0;
	IF @targetObjectID IS NOT NULL BEGIN 
		IF @OverwriteTableIfExists IS NULL BEGIN 
			RAISERROR(N'The target table-name specified for @TargetEventStoreTable: [%s] already exists. Either a) manually drop it, b) set @OverwriteTableIfExists = N''KEEP'' to KEEP as-is, or c) set @OverwriteTableIfExists = N''REPLACE'' to DROP and re-CREATE.', 16, 1, @TargetEventStoreTable);
			RETURN -20;
		END;

		IF UPPER(@OverwriteTableIfExists) = N'REPLACE' BEGIN 
			SET @dropTable = N'DROP TABLE [{schema}].[{table}];' + @crlf;

			SET @dropTable = @dropTable + N'DELETE FROM dbo.eventstore_extractions WHERE [session_name] = N''' + @TargetSessionName + N'''' + @crlf;
		END;

		IF UPPER(@OverwriteTableIfExists) = N'KEEP' BEGIN 
			SET @keepTable = 1;
		END;
	END;

	/* Check for XE Session (@TargetSessionName) exists: */
	DECLARE @dropSession nvarchar(MAX) = N'';
	DECLARE @SerializedOutput xml;
	EXEC dbo.[list_xe_sessions] 
		@TargetSessionName = @TargetSessionName, 
		@IncludeDiagnostics = 1,
		@SerializedOutput = @SerializedOutput OUTPUT;

	DECLARE @keepSession bit = 0;
	IF dbo.[is_xml_empty](@SerializedOutput) <> 1 BEGIN 
		
		IF @OverwriteSessionIfExists IS NULL BEGIN 
			RAISERROR('Target XE Session (@TargetSessionName): [%s] already exists. Either a ) manually drop it, b) set @OverwriteSessionIfExists = N''KEEP'' to keep as-is, or c) set @OverwriteSessionIfExists = N''REPLACE'' to DROP and re-CREATE.', 16, 1, @TargetSessionName);
			RETURN -5;
		END; 

		IF UPPER(@OverwriteSessionIfExists) = N'REPLACE' BEGIN 
			SET @dropSession = N'DROP EVENT SESSION [{session_name}] ON {server_or_database};' + @crlf;
		END;

		IF UPPER(@OverwriteSessionIfExists) = N'KEEP' BEGIN 
			SET @keepSession =1;
		END;
	END;

	/* Check to see if dbo.eventstore_settings has row-data for this session already:	*/
	DECLARE @keepSetting bit = 0;
	DECLARE @deleteSettingRow nvarchar(MAX) = N'';
	IF EXISTS (SELECT NULL FROM dbo.[eventstore_settings] WHERE [event_store_key] = @EventStoreKey) BEGIN 
		IF @OverwriteSettingsIfExist IS NULL BEGIN 
			RAISERROR(N'Settings for event_key [%s] already exist in admindb.dbo.eventstore_settings. Either a) manually modify dbo.evenstore_settings, b) set @OverwriteSettingsIfExist = N''KEEP'' to keep as-is, or c) set @OverwriteSettingsIfExist = N''REPLACE''.', 16, 1, @EventStoreKey);
			RETURN -100;
		END;
		
		IF UPPER(@OverwriteSettingsIfExist) = N'REPLACE' BEGIN 
			SET @deleteSettingRow = N'DELETE FROM dbo.eventstore_settings WHERE [event_store_key] = N''' + @EventStoreKey + N'''; ';
		END;

		IF UPPER(@OverwriteSettingsIfExist) = N'KEEP' BEGIN 
			SET @keepSetting = 1;
		END;
	END;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Process Table DDL
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @tableDDLCommand nvarchar(MAX) = @EventStoreTableDDL;
	SET @tableDDLCommand = N'/*---------------------------------------------------------------------------------------------------------------------------------------------------
-- Create EventStore Table: [{database}].[{schema}].[{table}]
---------------------------------------------------------------------------------------------------------------------------------------------------*/
USE [{database}]; 
{drop}' + @tableDDLCommand;

	SET @tableDDLCommand = REPLACE(@tableDDLCommand, N'{drop}', @dropTable);
	SET @tableDDLCommand = REPLACE(@tableDDLCommand, N'{database}', @targetDatabase);
	SET @tableDDLCommand = REPLACE(@tableDDLCommand, N'{schema}', @targetSchema);
	SET @tableDDLCommand = REPLACE(@tableDDLCommand, N'{table}', @targetObjectName);	

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Process Session DDL
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @serverOrDatabase sysname = N'SERVER';
	IF @@VERSION LIKE N'%Azure%'
		SET @serverOrDatabase = N'DATABASE';

	DECLARE @startup sysname = N'OFF';
	IF @StartupState = 1 SET @startup = N'ON';

	DECLARE @eventFileTemplate nvarchar(MAX) = N'package0.event_file (
		SET FILENAME = N''{event_file_path}\{session_name}.xel'', 
		max_file_size = ({file_size}), 
		MAX_ROLLOVER_FILES = ({max_files})
	)';

	DECLARE @ringBufferTemplate nvarchar(MAX) = N'package0.ring_buffer (
		SET 
			MAX_MEMORY = 2048,  -- recommended by MS: https://docs.microsoft.com/en-us/sql/t-sql/statements/create-event-session-transact-sql?view=sql-server-ver15
			MAX_EVENTS_LIMIT = ' + CAST(@MaxBufferEvents AS sysname) + N'
	)';

	DECLARE @sessionDDLCommand nvarchar(MAX) = @EventStoreSessionDDL;
	SET @sessionDDLCommand = N'/*---------------------------------------------------------------------------------------------------------------------------------------------------
-- Create EventStore Session: [{session_name}]
---------------------------------------------------------------------------------------------------------------------------------------------------*/
USE [{database}]; 
{drop}' + @sessionDDLCommand;

	IF @StartSessionOnCreation = 1 BEGIN 
		SET @sessionDDLCommand = @sessionDDLCommand + @crlf + @crlf + N'ALTER EVENT SESSION [{session_name}] ON {server_or_database} STATE = START;'
	END;

	IF LOWER(@TraceTarget) = N'ring_buffer' 
		SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{xe_target}', @ringBufferTemplate);
	ELSE 
		SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{xe_target}', @eventFileTemplate);

	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{drop}', @dropSession);
	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{database}', @targetDatabase);

	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{session_name}', @TargetSessionName);
	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{server_or_database}', @serverOrDatabase);
	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{event_file_path}', dbo.[normalize_file_path](@TraceFilePath));
	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{file_size}', @FileSizeMB);
	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{max_files}', @MaxFiles);
	SET @sessionDDLCommand = REPLACE(@sessionDDLCommand, N'{startup_state}', @startup);

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Setup Jobs/Processing details within eventstore_settings:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @settingDMLCommand nvarchar(MAX) = N'/*---------------------------------------------------------------------------------------------------------------------------------------------------
-- Settings: 
---------------------------------------------------------------------------------------------------------------------------------------------------*/
USE [{database}];
';

	IF @keepSetting = 0 
		SET @settingDMLCommand = @settingDMLCommand + @deleteSettingRow + @crlf;

	DECLARE @collectionEnabled bit = COALESCE(NULLIF(@StartupState, 0), NULLIF(@StartSessionOnCreation, 0), 0);

	SET @settingDMLCommand = @settingDMLCommand + N'INSERT INTO [dbo].[eventstore_settings] (
	[event_store_key],
	[session_name],
	[etl_proc_name],
	[target_table],
	[collection_enabled],
	[etl_enabled],
	[etl_frequency_minutes],
	[retention_days]
)
VALUES (
	N''' + @EventStoreKey + N''',
	N''' + @TargetSessionName + N''',
	N''' + @EtlProcedureName + N''',
	N''' + @TargetEventStoreTable + N''',
	' + CAST(@collectionEnabled AS sysname) + N',
	' + CAST(@EtlEnabled AS sysname) + N',
	' + CAST(@EtlFrequencyMinutes AS sysname) + N',
	' + CAST(@DataRetentionDays AS sysname) + N'
); ';

	SET @settingDMLCommand = REPLACE(@settingDMLCommand, N'{database}', @targetDatabase);

	-- create a job if/as needed... 

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Processing / Output
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @finalSQL nvarchar(MAX) = N'';

	/* Always create the table first ... (just in case there's a job out there trying to push data from an EXISTING XE Session into a table... */
	IF @keepTable = 1 
		SET @finalSQL = @finalSQL + N'-- @OverwriteTableIfExists set to ''KEEP'' - Keeping Table ' + @TargetEventStoreTable + N' as-is.';
	ELSE 
		SET @finalSQL = @finalSQL + @tableDDLCommand; 

	IF @PrintOnly = 1 
		SET @finalSQL = @finalSQL + @crlf + N'GO'

	SET @finalSQL = @finalSQL + @crlf + @crlf;

	IF @keepSession = 1 
		SET @finalSQL = @finalSQL + N'-- @OverwriteSessionIfExists set to ''KEEP'' - Keeping XE Session [' + @TargetSessionName + N'] as-is.' ; 
	ELSE 
		SET @finalSQL = @finalSQL + @sessionDDLCommand; 

	IF @PrintOnly = 1 
		SET @finalSQL = @finalSQL + @crlf + N'GO';

	SET @finalSQL = @finalSQL + @crlf + @crlf;

	IF @keepSetting = 1  
		SET @finalSQL = @finalSQL + N'-- @OverwriteSettingsIfExist set to ''KEEP'' - Keeping dbo.evenstore_settings for [' + @EventStoreKey + N'] as-is.';
	ELSE 
		SET @finalSQL = @finalSQL + @settingDMLCommand;

	IF @PrintOnly = 1 
		SET @finalSQL = @finalSQL + @crlf + N'GO';

	SET @finalSQL = @finalSQL + @crlf;

	DECLARE @errorMessage nvarchar(MAX), @errorLine int;

	IF @PrintOnly = 1 BEGIN 
		EXEC dbo.[print_long_string] @finalSQL;
	  END;
	ELSE BEGIN 
		BEGIN TRY 

			EXEC sys.[sp_executesql]
				@finalSQL; 

		END TRY 
		BEGIN CATCH
			SELECT @errorLine = ERROR_LINE(), @errorMessage = N'Msg ' + CAST(ERROR_NUMBER() AS sysname) + N', Line ' + CAST(ERROR_LINE() AS sysname) + @crlf + ERROR_MESSAGE();

			RAISERROR(@errorMessage, 16, 1);
			EXEC dbo.[extract_dynamic_code_lines] @finalSQL, @errorLine, 6;
			RETURN -100;

		END CATCH;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_data_cleanup]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_data_cleanup];
GO

CREATE PROC dbo.[eventstore_data_cleanup]

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Get Sessions to Process:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	SELECT 
		[setting_id],
		[event_store_key],
		[target_table],
		[retention_days]
	FROM 
		dbo.[eventstore_settings];

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Batch Process Each Table as Needed:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/

	-- TODO: either ... pass these commands into batcher or ... set up some 'batcher-light' logic in here... 
	--	WHERE the challenge is that I'm going to POTENTIALLY need to execute DELETE operations in a database OTHER than the admindb. 
	--		which ... isn't that much of a problem ... other than that I need to create some code that effectively matches the 'batcher' interface
	--			and which can/will both run in other databases (if/as needed) AND return results to this (the caller) ... for handling/processing, etc. 

		DECLARE @statement nvarchar(MAX) = N'USE [{db}];
	DELETE FROM [{x}].[{table_name}] WHERE [timestamp] < @cutoff';


	RAISERROR(N'Not done yet.', 16, 1);
	RETURN -100; -- NOT DONE YET. 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_timebounded_counts]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_timebounded_counts];
GO

CREATE PROC dbo.[eventstore_timebounded_counts]
	@Granularity				sysname			= N'HOUR', 
	@Start						datetime		= NULL, 
	@End						datetime		= NULL, 
	@TimeZone					sysname			= NULL,			-- Defaults to UTC (as that's what ALL XE sessions record in/against). Can be changed to a TimeZone on NEWER versions of SQL Server - including {SERVER_LOCAL}. 
	@SerializedOutput			xml				= NULL			OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @Granularity = ISNULL(NULLIF(@Granularity, N''), N'HOUR');
	IF UPPER(@Granularity) LIKE N'%S' SET @Granularity = LEFT(@Granularity, LEN(@Granularity) - 1);

	SET @TimeZone = NULLIF(@TimeZone, N'');

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Time-Bounding Predicates and Translations:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	IF @TimeZone IS NOT NULL BEGIN 

		IF [dbo].[get_engine_version]() < 130 BEGIN 
			RAISERROR(N'@TimeZone is only supported on SQL Server 2016+.', 16, 1);
			RETURN -110;
		END;
	
		IF UPPER(@TimeZone) = N'{SERVER_LOCAL}'
			SET @TimeZone = dbo.[get_local_timezone]();

		DECLARE @offsetMinutes int = 0;
		IF @TimeZone IS NOT NULL
			SELECT @offsetMinutes = dbo.[get_timezone_offset_minutes](@TimeZone);
	END;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Time Bounding (Blocks) - and Start/End Defaults.
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	DECLARE @minutes int = 0;
	IF UPPER(@Granularity) LIKE N'%INUTE%' BEGIN -- 5 minute blocks... 
		SET @minutes = 5;
		SET @Start = ISNULL(@Start, DATEADD(HOUR, -2, GETUTCDATE()));
		SET @End = ISNULL(@End, GETUTCDATE());
	END; 

	IF UPPER(@Granularity) = N'HOUR' BEGIN 
		SET @minutes = 60;
		SET @Start = ISNULL(@Start, DATEADD(HOUR, -24, GETUTCDATE()));
		SET @End = ISNULL(@End, GETUTCDATE());
	END;

	IF UPPER(@Granularity) = N'DAY' BEGIN 
		SET @minutes = 60 * 24;
		SET @Start = ISNULL(@Start, DATEADD(DAY, -8, GETUTCDATE()));
		SET @End = ISNULL(@End, GETUTCDATE());
	END;	
	
	DECLARE @boundingTimes xml; 
	EXEC dbo.[generate_bounding_times] 
		@Start = @Start, 
		@End = @End	, 
		@Minutes = @minutes, 
		@SerializedOutput = @boundingTimes OUTPUT;

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'(block_id)[1]', N'int') [block_id], 
			[data].[row].value(N'(time_block)[1]', N'datetime') [time_block]
		FROM 
			@boundingTimes.nodes(N'//time') [data]([row])
	) 

	SELECT 
		[block_id],
		[time_block] 
	INTO 
		#times
	FROM 
		shredded 
	ORDER BY 
		[block_id];

	DECLARE @startTime datetime = (SELECT DATEADD(MINUTE, 0 - @minutes, MIN(time_block)) FROM [#times]);

	WITH times AS ( 
		SELECT 
			[t].[block_id], 
			LAG([t].[time_block], 1, @startTime) OVER (ORDER BY [t].[block_id]) [start_time],
			[t].[time_block] [end_time],
			@TimeZone [time_zone]
		FROM 
			[#times] [t]
	)

	SELECT @SerializedOutput = (
		SELECT 
			[block_id],
			[start_time],
			[end_time],
			[time_zone] 
		FROM 
			times
		FOR XML PATH(N'time'), ROOT(N'times'), TYPE
	); 

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_heatmap_frame]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_heatmap_frame];
GO

CREATE PROC dbo.[eventstore_heatmap_frame]
--	@Mode						sysname			= N'TIME_OF_DAY',		-- { TIME_OF_DAY | TIME_OF_WEEK } 
	@Granularity				sysname			= N'HOUR',				-- { HOUR | [20]MINUTE } (minute = 20 minute blocks)
	@TimeZone					sysname			= NULL,			-- Defaults to UTC (as that's what ALL XE sessions record in/against). Can be changed to a TimeZone on NEWER versions of SQL Server - including {SERVER_LOCAL}. 
	@SerializedOutput			xml				= NULL			OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	--SET @Mode = UPPER(ISNULL(NULLIF(@Mode, N''), N'TIME_OF_DAY'));
	SET @Granularity = UPPER(ISNULL(NULLIF(@Granularity, N''), N'HOUR'));
	IF @Granularity LIKE N'%S' SET @Granularity = LEFT(@Granularity, LEN(@Granularity) - 1);

	SET @TimeZone = NULLIF(@TimeZone, N'');	

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Time-Bounding Predicates and Translations:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	IF @TimeZone IS NOT NULL BEGIN 

		IF [dbo].[get_engine_version]() < 130 BEGIN 
			RAISERROR(N'@TimeZone is only supported on SQL Server 2016+.', 16, 1);
			RETURN -110;
		END;
	
		IF UPPER(@TimeZone) = N'{SERVER_LOCAL}'
			SET @TimeZone = dbo.[get_local_timezone]();

		DECLARE @offsetMinutes int = 0;
		IF @TimeZone IS NOT NULL
			SELECT @offsetMinutes = dbo.[get_timezone_offset_minutes](@TimeZone);
	END;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Time Bounding (Blocks) - and Start/End Defaults.
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @minutes int = 0;
	IF UPPER(@Granularity) LIKE N'%INUTE%' BEGIN -- 20 minute blocks... 
		SET @minutes = 20;
	END; 

	IF UPPER(@Granularity) = N'HOUR' BEGIN 
		SET @minutes = 60;
	END;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- HeatMap Creation:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @startTime datetime2 = '2017-01-01 00:00:00.000';
	DECLARE @endTime datetime2 = '2017-01-01 23:59:59.999';

	CREATE TABLE #times (
		[row_id] int IDENTITY(1, 1) NOT NULL, 
		[utc_start] time NOT NULL, 
		[utc_end] time NOT NULL
	);

	WITH times AS ( 
		SELECT @startTime [start], DATEADD(MICROSECOND, 0 - 1, (DATEADD(MINUTE, @minutes, @startTime))) [end]

		UNION ALL 
			
		SELECT 
			DATEADD(MINUTE, @minutes, [start]) [start] , 
			DATEADD(MICROSECOND, 0 - 1, (DATEADD(MINUTE, @minutes, [end]))) [end]
		FROM 
			[times]
		WHERE 
			[times].[start] < DATEADD(MINUTE, 0 - @minutes, @endTime)
	)

	INSERT INTO [#times] ([utc_start], [utc_end])
	SELECT 
		CAST([start] AS time) [utc_start], 
		CAST([end] AS time) [utc_end]
	FROM 
		[times]
	OPTION (MAXRECURSION 200);

	--IF @Mode = N'TIME_OF_DAY' BEGIN
		SELECT @SerializedOutput = (
			SELECT 
				[row_id] [block_id],
				CAST([utc_start] AS time) [utc_start],
				CAST([utc_end] AS time) [utc_end]
			FROM 
				[#times]
			ORDER BY 
				[row_id]
			FOR XML PATH(N'time'), ROOT(N'times'), TYPE
		);

		RETURN 0;
	--END;

	RETURN 0;
GO
--	/*---------------------------------------------------------------------------------------------------------------------------------------------------
--	-- TIME_OF_WEEK Logic Only (already short-circuited / returned if we were processing TIME_OF_DAY)
--	---------------------------------------------------------------------------------------------------------------------------------------------------*/
----	SET @endTime = '2017-01-07 23:59:59.999';

--	DECLARE @sql nvarchar(MAX);
--	CREATE TABLE #weekView (
--		[row_id] int IDENTITY(1,1) NOT NULL, 
--		[utc_start] time NOT NULL,
--		[utc_end] time NOT NULL,
--		[Sunday] sysname NULL, 
--		[Monday] sysname NULL, 
--		[Tuesday] sysname NULL,
--		[Wednesday] sysname NULL,
--		[Thursday] sysname NULL,
--		[Friday] sysname NULL,
--		[Saturday] sysname NULL,
--	);

--	INSERT INTO [#weekView] (
--		[utc_start],
--		[utc_end]
--	)
--	SELECT 
--		[utc_start], 
--		[utc_end]
--	FROM 
--		[#times]
--	ORDER BY 
--		[row_id];

--	SELECT @SerializedOutput = (
--		SELECT 
--			[row_id],
--			[utc_start],
--			[utc_end],
--			[Sunday],
--			[Monday],
--			[Tuesday],
--			[Wednesday],
--			[Thursday],
--			[Friday],
--			[Saturday]	
--		FROM 
--			[#weekView]
--		ORDER BY 
--			[row_id] 
--		FOR XML PATH(N'time'), ROOT(N'times'), TYPE, ELEMENTS XSINIL
--	);

--	RETURN 0;
--GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_enable_all_errors]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_enable_all_errors];
GO

CREATE PROC dbo.[eventstore_enable_all_errors]
	@TargetSessionName						sysname = N'eventstore_all_errors', 
	@TargetEventStoreTable					sysname = N'admindb.dbo.eventstore_all_errors', 
	@EtlProcedureName						sysname = N'admindb.dbo.eventstore_etl_all_errors',
	@TraceTarget							sysname = N'event_file',				
	@TraceFilePath							sysname = N'D:\Traces', 
	@MaxFiles								int = 8, 
	@FileSizeMB								int = 200,
	@MaxBufferEvents						int = 1024,
	@StartupState							bit = 1, 
	@StartSessionOnCreation					bit = 1,
	@EventStoreDataRetentionDays			int = 60,
	@OverwriteSessionIfExists				sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteTableIfExists					sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteSettingsIfExist				sysname = NULL,			-- { KEEP | REPLACE} 
	@PrintOnly								bit = 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @eventStoreKey sysname = N'ALL_ERRORS';

	SET @TargetSessionName = ISNULL(NULLIF(@TargetSessionName, N''), N'eventstore_all_errors');
	SET @TargetEventStoreTable = ISNULL(NULLIF(@TargetEventStoreTable, N''), N'admindb.dbo.eventstore_all_errors');	
	SET @EtlProcedureName = ISNULL(@EtlProcedureName, N'admindb.dbo.eventstore_etl_all_errors');

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Table Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreTableDDL nvarchar(MAX) = N'CREATE TABLE [{schema}].[{table}] (
	[timestamp] [datetime] NULL,
	[operation] [varchar](30) NULL,
	[error_number] [int] NULL,
	[severity] [int] NULL,
	[state] [int] NULL,
	[message] [varchar](max) NULL,
	[database] [sysname] NULL,
	[user_name] [sysname] NULL,
	[host_name] [varchar](max) NULL,
	[application_name] [varchar](max) NULL,
	[is_system] [sysname] NULL,
	[statement] [varchar](max) NULL, 
	[report] [xml] NULL
) 
WITH (DATA_COMPRESSION = PAGE); ';

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Session Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreSessionDDL nvarchar(MAX) = N'CREATE EVENT SESSION [{session_name}] ON {server_or_database} 
	ADD EVENT sqlserver.error_reported (  
		ACTION (
			sqlserver.client_app_name,
			sqlserver.client_hostname,
			sqlserver.database_name,
			sqlserver.is_system,
			sqlserver.nt_username,
			sqlserver.sql_text,
			sqlserver.tsql_frame,
			sqlserver.tsql_stack,
			sqlserver.username
		)
		WHERE (
			[error_number] <> (5701) AND			-- db changed
			[error_number] <> (5703) AND			-- language changed
			[error_number] <> (3262) AND			-- backup file is valid
			[error_number] <> (3014) AND			-- tlog backup success
			[error_number] <> (4035) AND			-- backup pages (count) processed
			[error_number] <> (2528) AND			-- dbcc completed.
			[error_number] <> (8153) AND			-- Null value eliminated in aggregate

			[error_number] <> (22803) AND			-- CDC has scanned the log from LSN ..... 

			--[error_number] <> (3609) AND			-- tx ended in trigger 
			[error_number] <> (17892) AND			-- login failed due to trigger
			[error_number] <> (18456) AND			-- login failed
			[error_number] <> (15653) AND			-- Status update NOT necessary... 
			[error_number] <> (14553) AND			-- Replication Distribution Subsystem (NOT an error).... 

			[error_number] <> (14205) AND			-- (Unknown) (literally)
			[error_number] <> (14570) AND			-- (Job Outcome) 
			

			[error_number] <> (15651) AND			-- # indexes/stats ... have been updated, # did not require update... 
			[error_number] <> (15650) AND			-- Updating [object] stats... 
			[error_number] <> (15652) AND			-- [object] has been updated (stats)

			[error_number] <> (17550) AND			-- DBCC TRACEON 3604...
			[error_number] <> (17551) AND			-- DBCC TRACEOFF 3604...

			[error_number] <> (22121) AND			-- repl cleanup message... 

			[message] NOT LIKE ''Command: UPDATE STATISTICS%'' -- commonly finding BAZILLIONS of these on most servers (obviously) - which muddies the waters... 
		)
	)
	ADD TARGET {xe_target}
    WITH (
		MAX_MEMORY = 16 MB,
		EVENT_RETENTION_MODE = ALLOW_SINGLE_EVENT_LOSS,
		MAX_DISPATCH_LATENCY = 30 SECONDS,
		MAX_EVENT_SIZE = 0 KB,
		MEMORY_PARTITION_MODE = PER_NODE,  
		TRACK_CAUSALITY = OFF, 
		STARTUP_STATE = {startup_state}
    ); ';

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Processing (via core/base functionality):
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @enableETL bit = COALESCE(NULLIF(@StartupState, 0), NULLIF(@StartSessionOnCreation, 0), 0);

	DECLARE @returnValue int;
	EXEC @returnValue = dbo.[eventstore_setup_session]
		@EventStoreKey = @eventStoreKey,
		@TargetSessionName = @TargetSessionName,
		@TargetEventStoreTable = @TargetEventStoreTable,
		@TraceTarget = @TraceTarget,
		@TraceFilePath = @TraceFilePath,
		@MaxFiles = @MaxFiles,
		@FileSizeMB = @FileSizeMB,
		@MaxBufferEvents = @MaxBufferEvents,
		@StartupState = @StartupState,
		@StartSessionOnCreation = @StartSessionOnCreation,
		@EtlEnabled = @enableETL,
		@EtlFrequencyMinutes = 5,
		@EtlProcedureName = @EtlProcedureName,
		@DataRetentionDays = @EventStoreDataRetentionDays,		
		@OverwriteSessionIfExists = @OverwriteSessionIfExists,
		@OverwriteTableIfExists = @OverwriteTableIfExists,
		@OverwriteSettingsIfExist = @OverwriteSettingsIfExist,
		@EventStoreTableDDL = @eventStoreTableDDL,
		@EventStoreSessionDDL = @eventStoreSessionDDL,
		@PrintOnly = @PrintOnly;

	RETURN @returnValue;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_enable_blocked_processes]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_enable_blocked_processes];
GO

CREATE PROC dbo.[eventstore_enable_blocked_processes]
	@TargetSessionName						sysname = N'eventstore_blocked_processes', 
	@TargetEventStoreTable					sysname = N'admindb.dbo.eventstore_blocked_processes', 
	@EtlProcedureName						sysname = N'admindb.dbo.eventstore_etl_blocked_processes',
	@TraceTarget							sysname = N'event_file', 
	@TraceFilePath							sysname = N'D:\Traces', 
	@MaxFiles								int = 10, 
	@FileSizeMB								int = 200, 
	@MaxBufferEvents						int = 1024,
	@StartupState							bit = 1, 
	@StartSessionOnCreation					bit = 1,
	@BlockedProcessThreshold				int = 2, 
	@EventStoreDataRetentionDays			int = 60,
	@OverwriteSessionIfExists				sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteTableIfExists					sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteSettingsIfExist				sysname = NULL,			-- { KEEP | REPLACE} 
	@PrintOnly								bit = 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @eventStoreKey sysname = N'BLOCKED_PROCESSES';

	SET @TargetSessionName = ISNULL(NULLIF(@TargetSessionName, N''), N'eventstore_blocked_processes');
	SET @TargetEventStoreTable = ISNULL(NULLIF(@TargetEventStoreTable, N''), N'admindb.dbo.eventstore_blocked_processes');
	SET @EtlProcedureName = ISNULL(@EtlProcedureName, N'admindb.dbo.eventstore_etl_blocked_processes');
	SET @BlockedProcessThreshold = ISNULL(NULLIF(@BlockedProcessThreshold, 0), 2);

	DECLARE @command nvarchar(MAX);
	DECLARE @errorMessage nvarchar(MAX);
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Blocked Processes Threshold:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @currentThreshold int = (SELECT CAST(value_in_use AS int) FROM sys.[configurations] WHERE [name] = N'blocked process threshold (s)');

	IF @currentThreshold <> @BlockedProcessThreshold BEGIN 

-- TODO: verify that we can execute a RECONFIGURE (i.e., no pending ugliness or potential problems);
/* Verify that we can RECONFIGURE */

-- TODO: I think i should probably 'wrap' sp_configure calls in a sproc - so that 'my' code doesn't echo things like "COnfiguration option 'x' changed from x to y. Run Reconfigure...
		SET @command = N'/*---------------------------------------------------------------------------------------------------------------------------------------------------
-- Set Blocked Process Threshold on Server:
---------------------------------------------------------------------------------------------------------------------------------------------------*/
EXEC sp_configure ''blocked process threshold'', ' + CAST(@BlockedProcessThreshold AS sysname) + N'; ';

		IF @PrintOnly = 1 BEGIN 
			PRINT @command;
			PRINT N'GO';
			PRINT N'';
			PRINT N'RECONFIGURE;';
			PRINT N'GO';
			PRINT N'';
		  END; 
		ELSE BEGIN 
			BEGIN TRY
				EXEC sys.[sp_executesql] 
					@command; 

				EXEC(N'RECONFIGURE');
			END TRY 
			BEGIN CATCH 
				SET @errorMessage = N'Failed to Set Blocked Process Threshold on Server. ERROR ' + CAST(ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE() + N'.';
				PRINT 'would be handling errors here and ... not going through with rest of operation... ';
			END CATCH;
		END;
	END;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Table Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreTableDDL nvarchar(MAX) = N'CREATE TABLE [{schema}].[{table}](
	[row_id] [int] IDENTITY(1,1) NOT NULL,
	[timestamp] [datetime2](7) NOT NULL,
	[database_name] [nvarchar](128) NOT NULL,
	[seconds_blocked] [decimal](24, 2) NOT NULL,
	[report_id] [int] NOT NULL,
	[blocking_id] sysname NULL,  -- ''self blockers'' can/will be NULL
	[blocked_id] sysname NOT NULL,
	[blocking_xactid] [bigint] NULL,  -- ''self blockers'' can/will be NULL
	[blocking_request] [nvarchar](MAX) NOT NULL,
	[blocking_sproc_statement] [nvarchar](MAX) NOT NULL,
	[blocking_resource_id] [nvarchar](80) NULL,
	[blocking_resource] [varchar](2000) NOT NULL,
	[blocking_wait_time] [int] NULL,
	[blocking_tran_count] [int] NULL,  -- ''self blockers'' can/will be NULL
	[blocking_isolation_level] [nvarchar](128) NULL,   -- ''self blockers'' can/will be NULL
	[blocking_status] sysname NULL,
	[blocking_start_offset] [int] NULL,
	[blocking_end_offset] [int] NULL,
	[blocking_host_name] sysname NULL,
	[blocking_login_name] sysname NULL,
	[blocking_client_app] sysname NULL,
	[blocked_spid] [int] NOT NULL,
	[blocked_ecid] [int] NOT NULL,
	[blocked_xactid] [bigint] NULL,  -- can be NULL
	[blocked_request] [nvarchar](max) NOT NULL,
	[blocked_sproc_statement] [nvarchar](max) NOT NULL,
	[blocked_resource_id] [nvarchar](80) NOT NULL,
	[blocked_resource] [varchar](2000) NULL,  -- can be NULL if/when there isn''t an existing translation
	[blocked_wait_time] [int] NOT NULL,
	[blocked_tran_count] [int] NOT NULL,
	[blocked_log_used] [int] NOT NULL,
	[blocked_lock_mode] sysname NULL, -- CAN be NULL
	[blocked_isolation_level] [nvarchar](128) NULL,
	[blocked_status] sysname NOT NULL,
	[blocked_start_offset] [int] NOT NULL,
	[blocked_end_offset] [int] NOT NULL,
	[blocked_host_name] sysname NULL,
	[blocked_login_name] sysname NULL,
	[blocked_client_app] sysname NULL,
	[report] [xml] NOT NULL
) ON [PRIMARY]; 

CREATE CLUSTERED INDEX [CLIX_{table}_ByRowID] ON [{table}] ([row_id]);
CREATE NONCLUSTERED INDEX [COVIX_{table}_details_ByTxIds] ON [{table}] ([blocking_xactid],[blocked_xactid]) INCLUDE ([timestamp],[seconds_blocked]); ';

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Session Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreSessionDDL nvarchar(MAX) = N'CREATE EVENT SESSION [{session_name}] ON {server_or_database} 
	ADD EVENT sqlserver.blocked_process_report()
	ADD TARGET {xe_target}
	WITH (
		MAX_MEMORY = 16MB,
		EVENT_RETENTION_MODE = ALLOW_SINGLE_EVENT_LOSS,
		MAX_DISPATCH_LATENCY = 30 SECONDS,
		MAX_EVENT_SIZE = 0KB,
		MEMORY_PARTITION_MODE = PER_NODE,
		TRACK_CAUSALITY = OFF,
		STARTUP_STATE = {startup_state}
	);	';

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Processing (via core/base functionality):
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @enableETL bit = COALESCE(NULLIF(@StartupState, 0), NULLIF(@StartSessionOnCreation, 0), 0);

	DECLARE @returnValue int;
	EXEC @returnValue = dbo.[eventstore_setup_session]
		@EventStoreKey = @eventStoreKey,
		@TargetSessionName = @TargetSessionName,
		@TargetEventStoreTable = @TargetEventStoreTable,
		@TraceTarget = @TraceTarget,
		@TraceFilePath = @TraceFilePath,
		@MaxFiles = @MaxFiles,
		@FileSizeMB = @FileSizeMB,
		@MaxBufferEvents = @MaxBufferEvents,
		@StartupState = @StartupState,
		@StartSessionOnCreation = @StartSessionOnCreation,
		@EtlEnabled = @enableETL,
		@EtlFrequencyMinutes = 10,
		@EtlProcedureName = @EtlProcedureName,
		@DataRetentionDays = @EventStoreDataRetentionDays,
		@OverwriteSessionIfExists = @OverwriteSessionIfExists,
		@OverwriteTableIfExists = @OverwriteTableIfExists,
		@OverwriteSettingsIfExist = @OverwriteSettingsIfExist,
		@EventStoreTableDDL = @eventStoreTableDDL,
		@EventStoreSessionDDL =@eventStoreSessionDDL,
		@PrintOnly = @PrintOnly;

	RETURN @returnValue;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_enable_deadlocks]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_enable_deadlocks];
GO

CREATE PROC dbo.[eventstore_enable_deadlocks]
	@TargetSessionName						sysname = N'eventstore_deadlocks', 
	@TargetEventStoreTable					sysname = N'admindb.dbo.eventstore_deadlocks', 
	@EtlProcedureName						sysname = N'admindb.dbo.eventstore_etl_deadlocks',
	@TraceTarget							sysname = N'event_file', 
	@TraceFilePath							sysname = N'D:\Traces', 
	@MaxFiles								int = 4, 
	@FileSizeMB								int = 100, 
	@MaxBufferEvents						int = 1024,
	@StartupState							bit = 1, 
	@StartSessionOnCreation					bit = 1,
	@EventStoreDataRetentionDays			int = 60,
	@OverwriteSessionIfExists				sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteTableIfExists					sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteSettingsIfExist				sysname = NULL,			-- { KEEP | REPLACE} 
	@PrintOnly								bit = 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @eventStoreKey sysname = N'DEADLOCKS';

	SET @TargetSessionName = ISNULL(NULLIF(@TargetSessionName, N''), N'eventstore_deadlocks');
	SET @TargetEventStoreTable = ISNULL(NULLIF(@TargetEventStoreTable, N''), N'admindb.dbo.eventstore_deadlocks');	
	SET @EtlProcedureName = ISNULL(@EtlProcedureName, N'admindb.dbo.eventstore_etl_deadlocks');

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Table Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreTableDDL nvarchar(MAX) = N'CREATE TABLE [{schema}].[{table}] (
	[timestamp] [datetime] NULL,
	[deadlock_id] [int] NOT NULL,
	[process_count] [int] NOT NULL,
	[session_id] [varchar](30) NOT NULL,
	--[process_id] [varchar](30) NOT NULL,
	[application_name] [sysname] NULL,
	[host_name] [sysname] NULL,
	[transaction_count] [int] NULL,
	[lock_mode] [varchar](20) NULL,
	[wait_time_ms] bigint NULL,
	[log_used] [bigint] NULL,
	[wait_resource_id] [varchar](200) NULL,
	[wait_resource] [varchar](2000) NULL,
	[proc] [nvarchar](MAX) NULL,
	[statement] [nvarchar](MAX) NULL,
	[input_buffer] [nvarchar](MAX) NULL,
	[deadlock_graph] [xml] NULL
);';

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Session Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreSessionDDL nvarchar(MAX) = N'CREATE EVENT SESSION [{session_name}] ON {server_or_database} 
	ADD EVENT sqlserver.xml_deadlock_report ()
	ADD TARGET {xe_target}
	WITH (
		MAX_MEMORY = 16MB,
		EVENT_RETENTION_MODE = ALLOW_SINGLE_EVENT_LOSS,
		MAX_DISPATCH_LATENCY = 30 SECONDS,
		MAX_EVENT_SIZE = 0KB,
		MEMORY_PARTITION_MODE = PER_NODE,
		TRACK_CAUSALITY = OFF,
		STARTUP_STATE = {startup_state}
	);	';

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Processing (via core/base functionality):
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @enableETL bit = COALESCE(NULLIF(@StartupState, 0), NULLIF(@StartSessionOnCreation, 0), 0);

	DECLARE @returnValue int;
	EXEC @returnValue = dbo.[eventstore_setup_session]
		@EventStoreKey = @eventStoreKey,
		@TargetSessionName = @TargetSessionName,
		@TargetEventStoreTable = @TargetEventStoreTable,
		@TraceTarget = @TraceTarget,
		@TraceFilePath = @TraceFilePath,
		@MaxFiles = @MaxFiles,
		@FileSizeMB = @FileSizeMB,
		@MaxBufferEvents = @MaxBufferEvents,
		@StartupState = @StartupState,
		@StartSessionOnCreation = @StartSessionOnCreation,
		@EtlEnabled = @enableETL,
		@EtlFrequencyMinutes = 2,  -- some deadlocks can/will be against tempdb objects - so... more frequent extraction/transform = better insight.
		@EtlProcedureName = @EtlProcedureName,
		@DataRetentionDays = @EventStoreDataRetentionDays,
		@OverwriteSessionIfExists = @OverwriteSessionIfExists,
		@OverwriteTableIfExists = @OverwriteTableIfExists,
		@OverwriteSettingsIfExist = @OverwriteSettingsIfExist,
		@EventStoreTableDDL = @eventStoreTableDDL,
		@EventStoreSessionDDL =@eventStoreSessionDDL,
		@PrintOnly = @PrintOnly;

	RETURN @returnValue;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_enable_large_sql]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_enable_large_sql];
GO

CREATE PROC dbo.[eventstore_enable_large_sql]
	@TargetSessionName						sysname = N'eventstore_large_sql',   
	@TargetEventStoreTable					sysname = N'admindb.dbo.eventstore_large_sql', 
	@EtlProcedureName						sysname = N'admindb.dbo.eventstore_etl_large_sql',
	@TraceTarget							sysname = N'event_file',				
	@TraceFilePath							sysname = N'D:\Traces', 
	@MaxFiles								int = 10, 
	@FileSizeMB								int = 200,
	@MaxBufferEvents						int = 1024,
	@StartupState							bit = 1, 
	@StartSessionOnCreation					bit = 1,
	@DurationMillisecondsThreshold			int = 20000,
	@CPUMillisecondsThreshold				int = 15000,
	@RowCountThreshold						int = 20000,
	@EventStoreDataRetentionDays			int = 90,
	@OverwriteSessionIfExists				sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteTableIfExists					sysname = NULL,			-- { KEEP | REPLACE} 
	@OverwriteSettingsIfExist				sysname = NULL,			-- { KEEP | REPLACE} 
	@PrintOnly								bit = 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @eventStoreKey sysname = N'LARGE_SQL';

	SET @TargetSessionName = ISNULL(NULLIF(@TargetSessionName, N''), N'eventstore_large_sql');
	SET @TargetEventStoreTable = ISNULL(NULLIF(@TargetEventStoreTable, N''), N'admindb.dbo.eventstore_large_sql');	
	SET @EtlProcedureName = ISNULL(@EtlProcedureName, N'admindb.dbo.eventstore_etl_large_sql');

	SET @DurationMillisecondsThreshold = ISNULL(NULLIF(@DurationMillisecondsThreshold, 0), 20000);
	SET @CPUMillisecondsThreshold = ISNULL(NULLIF(@CPUMillisecondsThreshold, 0), 15000);
	SET @RowCountThreshold = ISNULL(NULLIF(@RowCountThreshold, 0), 20000);

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Table Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreTableDDL nvarchar(MAX) = N'CREATE TABLE [{schema}].[{table}] (
	[timestamp] [datetime] NULL,
	[database_name] [sysname] NULL,
	[user_name] [sysname] NULL,
	[host_name] [sysname] NULL,
	[application_name] [sysname] NULL,
	[module] [sysname] NULL,
	[statement] [nvarchar](max) NULL,
	[offset] [nvarchar](259) NULL,
	[cpu_ms] [bigint] NULL,
	[duration_ms] [bigint] NULL,
	[physical_reads] [bigint] NULL,
	[writes] [bigint] NULL,
	[row_count] [bigint] NULL,
	[report] [xml] NULL
) 
WITH (DATA_COMPRESSION = PAGE); ';

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Session Definition:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @eventStoreSessionDDL nvarchar(MAX) = N'CREATE EVENT SESSION [{session_name}] ON {server_or_database} 
	ADD EVENT sqlserver.sql_statement_completed (
		SET 
			collect_statement = 1 
		ACTION (
			[sqlserver].[database_name],
			[sqlserver].[client_app_name],
			[sqlserver].[client_hostname], 
			[sqlserver].[session_id], 
			[sqlserver].[username]
		)
		WHERE (
			[duration] > {durationMS}000 
			OR 
			[cpu_time] > {cpuMS}000 
			OR 
			[row_count] > {rowCount}
		)
	), 
	ADD EVENT sqlserver.rpc_completed (
		ACTION ( 
			[sqlserver].[database_name],
			[sqlserver].[client_app_name],
			[sqlserver].[client_hostname], 
			[sqlserver].[session_id], 
			[sqlserver].[username]
		)
		WHERE  (
			[duration] > {durationMS}000 
			OR 
			[cpu_time] > {cpuMS}000 
			OR 
			[row_count] > {rowCount}
		)
	)
	ADD TARGET {xe_target}
	WITH (
		MAX_MEMORY = 16MB,
		EVENT_RETENTION_MODE = ALLOW_SINGLE_EVENT_LOSS,
		MAX_DISPATCH_LATENCY = 30 SECONDS,
		MAX_EVENT_SIZE = 0KB,
		MEMORY_PARTITION_MODE = PER_NODE,
		TRACK_CAUSALITY = OFF,
		STARTUP_STATE = {startup_state}
	);	';

	SET @eventStoreSessionDDL = REPLACE(@eventStoreSessionDDL, N'{durationMS}', @DurationMillisecondsThreshold);
	SET @eventStoreSessionDDL = REPLACE(@eventStoreSessionDDL, N'{cpuMS}', @CPUMillisecondsThreshold);
	SET @eventStoreSessionDDL = REPLACE(@eventStoreSessionDDL, N'{rowCount}', @RowCountThreshold);
	
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Processing (via core/base functionality):
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @enableETL bit = COALESCE(NULLIF(@StartupState, 0), NULLIF(@StartSessionOnCreation, 0), 0);

	DECLARE @returnValue int;
	EXEC @returnValue = dbo.[eventstore_setup_session]
		@EventStoreKey = @eventStoreKey,
		@TargetSessionName = @TargetSessionName,
		@TargetEventStoreTable = @TargetEventStoreTable,
		@TraceTarget = @TraceTarget,
		@TraceFilePath = @TraceFilePath,
		@MaxFiles = @MaxFiles,
		@FileSizeMB = @FileSizeMB,
		@MaxBufferEvents = @MaxBufferEvents,
		@StartupState = @StartupState,
		@StartSessionOnCreation = @StartSessionOnCreation,
		@EtlEnabled = @enableETL,
		@EtlFrequencyMinutes = 5,
		@EtlProcedureName = @EtlProcedureName,
		@DataRetentionDays = @EventStoreDataRetentionDays,		
		@OverwriteSessionIfExists = @OverwriteSessionIfExists,
		@OverwriteTableIfExists = @OverwriteTableIfExists,
		@OverwriteSettingsIfExist = @OverwriteSettingsIfExist,
		@EventStoreTableDDL = @eventStoreTableDDL,
		@EventStoreSessionDDL = @eventStoreSessionDDL,
		@PrintOnly = @PrintOnly;

	RETURN @returnValue;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_etl_all_errors]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_etl_all_errors];
GO

CREATE PROC dbo.[eventstore_etl_all_errors]
	@SessionName				sysname			= N'eventstore_all_errors', 
	@EventStoreTarget			sysname			= N'admindb.dbo.eventstore_all_errors',
	@InitializeDaysBack			int				= 5
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @SessionName = ISNULL(NULLIF(@SessionName, N''), N'eventstore_all_errors');
	SET @EventStoreTarget = ISNULL(NULLIF(@EventStoreTarget, N''), N'admindb.dbo.eventstore_all_errors');
	SET @InitializeDaysBack = ISNULL(@InitializeDaysBack, 5);	

	DECLARE @etlSQL nvarchar(MAX) = N'
	USE [{targetDatabase}];

	INSERT INTO [{targetSchema}].[{targetTable}] (
		[timestamp],
		[operation],
		[error_number],
		[severity],
		[state],
		[message],
		[database],
		[user_name],
		[host_name],
		[application_name],
		[is_system],
		[statement],
		[report]
	)
	SELECT 
		[nodes].[row].value(N''(@timestamp)[1]'', N''datetime'') [timestamp],
		[nodes].[row].value(N''(@name)[1]'', N''varchar(30)'') [operation],
		[nodes].[row].value(N''(data[@name="error_number"]/value)[1]'', N''int'') [error_number],
		[nodes].[row].value(N''(data[@name="severity"]/value)[1]'', N''int'') [severity],
		[nodes].[row].value(N''(data[@name="state"]/value)[1]'', N''int'') [state],
		[nodes].[row].value(N''(data[@name="message"]/value)[1]'', N''varchar(max)'') [message],
		[nodes].[row].value(N''(action[@name="database_name"]/value)[1]'', N''sysname'') [database],
		[nodes].[row].value(N''(action[@name="user_name"]/value)[1]'', N''sysname'')	[user_name],
		[nodes].[row].value(N''(action[@name="client_hostname"]/value)[1]'', N''varchar(max)'') [host_name],
		[nodes].[row].value(N''(action[@name="client_app_name"]/value)[1]'', N''varchar(max)'') [application_name],
		[nodes].[row].value(N''(action[@name="is_system"]/value)[1]'', N''sysname'') [is_system],
		[nodes].[row].value(N''(action[@name="sql_text"]/value)[1]'', N''varchar(max)'') [statement], 
		[nodes].[row].query(N''.'') [report]
	FROM 
		@EventData.nodes(N''//event'') [nodes]([row]);  ';

	DECLARE @return int;
	EXEC @return = dbo.[eventstore_etl_session] 
		@SessionName = @SessionName, 
		@EventStoreTarget = @EventStoreTarget, 
		@TranslationDML = @etlSQL, 
		@InitializeDaysBack = @InitializeDaysBack;
	
	RETURN @return;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_etl_blocked_processes]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_etl_blocked_processes];
GO

CREATE PROC dbo.[eventstore_etl_blocked_processes]
	@SessionName				sysname			= N'blocked_processes', 
	@EventStoreTarget			sysname			= N'admindb.dbo.eventstore_blocked_processes',
	@InitializeDaysBack			int				= 30
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @SessionName = ISNULL(NULLIF(@SessionName, N''), N'blocked_processes');
	SET @EventStoreTarget = ISNULL(NULLIF(@EventStoreTarget, N''), N'admindb.dbo.eventstore_blocked_processes');
	SET @InitializeDaysBack = ISNULL(@InitializeDaysBack, 30);

	DECLARE @etlSQL nvarchar(MAX) = N'
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- XEL Data Extraction:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	WITH shredded AS ( 
		SELECT 
			[nodes].[row].value(N''(@timestamp)[1]'', N''datetime2'') AS [timestamp],
			[nodes].[row].value(N''(data[@name="database_name"]/value)[1]'',N''nvarchar(128)'') AS [database_name],
			[nodes].[row].value(N''(data[@name="duration"]/value)[1]'', N''bigint'') AS [duration],
			[nodes].[row].value(N''(data/value/blocked-process-report/@monitorLoop)[1]'', N''int'') AS [report_id],

			-- blockER:
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@spid)[1]'', N''int'') [blocking_spid],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@ecid)[1]'', N''int'') [blocking_ecid],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@xactid)[1]'', N''bigint'') [blocking_xactid],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/inputbuf)[1]'', N''nvarchar(max)'') [blocking_request],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@waitresource)[1]'', N''nvarchar(80)'') [blocking_resource],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@waittime)[1]'', N''int'') [blocking_wait_time],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@trancount)[1]'', N''int'') [blocking_tran_count],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@clientapp)[1]'', N''nvarchar(128)'') [blocking_client_app],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@hostname)[1]'', N''nvarchar(128)'') [blocking_host_name],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@loginname)[1]'', N''nvarchar(128)'') [blocking_login_name],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@isolationlevel)[1]'', N''nvarchar(128)'') [blocking_isolation_level],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/executionStack/frame/@stmtstart)[1]'', N''int'') [blocking_start_offset],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/executionStack/frame/@stmtend)[1]'', N''int'') [blocking_end_offset],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocking-process/process/@status)[1]'', N''nvarchar(128)'') [blocking_status],

			-- blockED
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@spid)[1]'', N''int'') [blocked_spid],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@ecid)[1]'', N''int'') [blocked_ecid],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@xactid)[1]'', N''bigint'') [blocked_xactid],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/inputbuf)[1]'', N''nvarchar(max)'') [blocked_request],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@waitresource)[1]'', N''nvarchar(80)'') [blocked_resource],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@waittime)[1]'', N''int'') [blocked_wait_time],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@trancount)[1]'', N''int'') [blocked_tran_count],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@logused)[1]'', N''int'') [blocked_log_used],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@clientapp)[1]'', N''nvarchar(128)'') [blocked_client_app],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@hostname)[1]'', N''nvarchar(128)'') [blocked_host_name],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@loginname)[1]'', N''nvarchar(128)'') [blocked_login_name],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@isolationlevel)[1]'', N''nvarchar(128)'') [blocked_isolation_level],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@lockMode)[1]'', N''nvarchar(128)'') [blocked_lock_mode],
			[nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/@status)[1]'', N''nvarchar(128)'') [blocked_status], 

			-- NOTE: this EXPLICITLY pulls only the FIRST frame''s details (there can be MULTIPLE per ''batch'').
			ISNULL([nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/executionStack/frame/@stmtstart)[1]'', N''int''), 0) [blocked_start_offset],
			ISNULL([nodes].[row].value(N''(data/value/blocked-process-report/blocked-process/process/executionStack/frame/@stmtend)[1]'', N''int''), 0) [blocked_end_offset],
			[nodes].[row].query(N''.'') [raw_xml]
		FROM 
			@EventData.nodes(N''//event'') [nodes]([row])
		WHERE 
			[nodes].[row].value(N''(@name)[1]'', N''sysname'') = N''blocked_process_report''
	)

	SELECT
		IDENTITY(int, 1, 1) [row_id],
		[s].[timestamp],
		[s].[database_name],
		CAST(([s].[duration]/1000000.0) as decimal(24,2)) [seconds_blocked],
		[s].[report_id],
		CAST([s].[blocking_spid] as sysname) + CASE WHEN [s].[blocking_ecid] = 0 THEN N'' '' ELSE N'' '' + QUOTENAME([s].blocking_ecid, N''()'') END [blocking_id], 
		CAST([s].[blocked_spid] as sysname) + CASE WHEN [s].[blocked_ecid] = 0 THEN N'' '' ELSE N'' '' + QUOTENAME([s].blocked_ecid, N''()'') END [blocked_id],
		[s].[blocking_xactid],
		[s].[blocking_request],
		CAST(N'''' AS nvarchar(MAX)) [normalized_blocking_request],
		CAST(N'''' AS nvarchar(MAX)) [blocking_sproc_statement],
		[s].[blocking_resource] [blocking_resource_id], 
		CAST(N'''' AS varchar(2000)) [blocking_resource],
-- TODO: is //event/data/@lock_mode/value ... the lock_mode of the BLOCKER? seems like it is... i just need to confirm this with some ''real'' data... 
---			actually... guessing it''s the lock mode for the BLOCKED process... 
--		and, if it is, then i need to add a new [blocking_lock_mode] column into the mix. 
		[s].[blocking_wait_time],
		[s].[blocking_tran_count],
		[s].[blocking_isolation_level],
		[s].[blocking_status],
		ISNULL([s].[blocking_start_offset], 0) [blocking_start_offset],
		ISNULL([s].[blocking_end_offset], 0) [blocking_end_offset],

		[s].[blocking_host_name],
		[s].[blocking_login_name],
		[s].[blocking_client_app],
		

		[s].[blocked_spid],
		[s].[blocked_ecid],
		[s].[blocked_xactid],
		[s].[blocked_request],
		CAST(N'''' AS nvarchar(MAX)) [normalized_blocked_request],
		CAST(N'''' AS nvarchar(MAX)) [blocked_sproc_statement],
		CAST(N'''' AS sysname) [blocked_weight],
		[s].[blocked_resource] [blocked_resource_id],
		CAST(N'''' AS varchar(2000)) [blocked_resource],

		[s].[blocked_wait_time],
		[s].[blocked_tran_count],
		[s].[blocked_log_used],
		[s].[blocked_lock_mode],
		[s].[blocked_isolation_level],
		[s].[blocked_status],

		ISNULL([s].[blocked_start_offset], 0) [blocked_start_offset],
		ISNULL([s].[blocked_end_offset], 0) [blocked_end_offset],
		[s].[blocked_host_name],
		[s].[blocked_login_name],
		[s].[blocked_client_app],
		[s].[raw_xml] [report]
	INTO 
		#data
	FROM 
		[shredded] s
	ORDER BY 
		[s].[report_id]; 

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Statement Extraction: 
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @rowID int;
	DECLARE @statement nvarchar(MAX); 	
	
	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		[database_name],
		blocking_request [request], 
		blocking_start_offset, 
		blocking_end_offset, 
		CAST('''' AS nvarchar(MAX)) [definition] 
	INTO 
		#statement_blocking
	FROM 
		[#data] 
	WHERE 
		[blocking_request] LIKE N''%Object Id = [0-9]%''
	GROUP BY 
		[database_name], [blocking_request], [blocking_start_offset], [blocking_end_offset];

	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		[database_name],
		blocked_request [request], 
		blocked_start_offset, 
		blocked_end_offset, 
		CAST('''' AS nvarchar(MAX)) [definition]
	INTO 
		#statement_blocked
	FROM 
		[#data] 
	WHERE 
		[blocked_request] LIKE N''%Object Id = [0-9]%''
	GROUP BY 
		[database_name], [blocked_request], [blocked_start_offset], [blocked_end_offset];

	DECLARE @sproc sysname;
	DECLARE @sourceDatabase sysname;
	DECLARE @objectId int;
	DECLARE @start int;
	DECLARE @end int;

	DECLARE extracting CURSOR LOCAL FAST_FORWARD FOR 
	SELECT row_id, [database_name], request, blocking_start_offset, blocking_end_offset FROM [#statement_blocking];

	OPEN [extracting];
	FETCH NEXT FROM [extracting] INTO @rowID, @sourceDatabase, @sproc, @start, @end;

	WHILE @@FETCH_STATUS = 0 BEGIN

		SET @objectId = CAST(REPLACE(RIGHT(@sproc, CHARINDEX('' = '', REVERSE(@sproc))), '']'', '''') AS int);
		SET @statement = NULL; 

		EXEC dbo.[extract_statement]
			@TargetDatabase = @sourceDatabase,
			@ObjectID = @objectId, 
			@OffsetStart = @start, 
			@OffsetEnd = @end,
			@Statement = @statement OUTPUT;

		UPDATE [#statement_blocking]
		SET 
			[definition] = @statement 
		WHERE 
			[row_id] = @rowID;

		FETCH NEXT FROM [extracting] INTO @rowID, @sourceDatabase, @sproc, @start, @end;
	END;

	CLOSE [extracting];
	DEALLOCATE [extracting];

	--------------------------------------------------------------------------------------------------------------------------------------------
	DECLARE extracted CURSOR LOCAL FAST_FORWARD FOR 
	SELECT row_id, [database_name], request, blocked_start_offset, blocked_end_offset FROM [#statement_blocked];

	OPEN [extracted];
	FETCH NEXT FROM [extracted] INTO @rowID, @sourceDatabase, @sproc, @start, @end;

	WHILE @@FETCH_STATUS = 0 BEGIN

		SET @objectId = CAST(REPLACE(RIGHT(@sproc, CHARINDEX('' = '', REVERSE(@sproc))), '']'', '''') AS int);
		SET @statement = NULL; 

		EXEC dbo.[extract_statement]
			@TargetDatabase = @sourceDatabase,
			@ObjectID = @objectId,
			@OffsetStart = @start,
			@OffsetEnd = @end,
			@Statement = @statement OUTPUT;

		UPDATE [#statement_blocked]
		SET 
			[definition] = @statement 
		WHERE 
			[row_id] = @rowID;

		FETCH NEXT FROM [extracted] INTO @rowID, @sourceDatabase, @sproc, @start, @end;
	END;

	CLOSE [extracted];
	DEALLOCATE [extracted];

	UPDATE d 
	SET 
		d.[blocking_sproc_statement] = x.[definition]
	FROM 
		[#data] d 
		INNER JOIN [#statement_blocking] x ON ISNULL(d.[normalized_blocking_request], d.[blocking_request]) = x.[request]
			AND d.[blocking_start_offset] = x.[blocking_start_offset] AND d.[blocking_end_offset] = x.[blocking_end_offset];

	UPDATE d 
	SET 
		d.[blocked_sproc_statement] = x.[definition]
	FROM 
		[#data] d 
		INNER JOIN [#statement_blocked] x ON ISNULL(d.[normalized_blocked_request], d.[blocked_request]) = x.[request]
			AND d.[blocked_start_offset] = x.[blocked_start_offset] AND d.[blocked_end_offset] = x.[blocked_end_offset];

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Wait Resource Extraction: 
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		blocking_resource_id, 
		CAST('''' AS nvarchar(MAX)) [definition]
	INTO 
		#resourcing
	FROM 
		[#data] 
	GROUP BY 
		blocking_resource_id; 
		
	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		blocked_resource_id, 
		CAST('''' AS nvarchar(MAX)) [definition]
	INTO 
		#resourced
	FROM 
		[#data] 
	GROUP BY 
		blocked_resource_id; 
		
	DECLARE @resourceID nvarchar(80);
	DECLARE @resource nvarchar(2000);
	
	DECLARE resourcing CURSOR LOCAL FAST_FORWARD FOR 
	SELECT row_id, blocking_resource_id FROM [#resourcing];

	OPEN [resourcing];
	FETCH NEXT FROM [resourcing] INTO @rowID, @resourceID;

	WHILE @@FETCH_STATUS = 0 BEGIN

		EXEC dbo.[extract_waitresource]
			@WaitResource = @resourceID,
			@Output = @resource OUTPUT;

		UPDATE [#resourcing] 
		SET 
			[definition] = @resource
		WHERE 
			[row_id] = @rowID;

		FETCH NEXT FROM [resourcing] INTO @rowID, @resourceID;
	END;

	CLOSE [resourcing];
	DEALLOCATE [resourcing];

	DECLARE resourced CURSOR LOCAL FAST_FORWARD FOR 
	SELECT row_id, blocked_resource_id FROM [#resourced];

	OPEN [resourced];
	FETCH NEXT FROM [resourced] INTO @rowID, @resourceID;

	WHILE @@FETCH_STATUS = 0 BEGIN

		EXEC dbo.[extract_waitresource]
			@WaitResource = @resourceID,
			@Output = @resource OUTPUT;

		UPDATE [#resourced] 
		SET 
			[definition] = @resource
		WHERE 
			[row_id] = @rowID;

		FETCH NEXT FROM [resourced] INTO @rowID, @resourceID;
	END;

	CLOSE [resourced];
	DEALLOCATE [resourced];

	UPDATE d 
	SET 
		d.blocking_resource = x.[definition]
	FROM 
		[#data] d 
		INNER JOIN [#resourcing] x ON d.[blocking_resource_id] = x.[blocking_resource_id];

	UPDATE d 
	SET 
		d.blocked_resource = x.[definition]
	FROM 
		[#data] d 
		INNER JOIN [#resourced] x ON d.[blocked_resource_id] = x.[blocked_resource_id];		
		
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Output / Project + Store:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	USE [{targetDatabase}];
	
	INSERT INTO [{targetSchema}].[{targetTable}] (
		[timestamp],
		[database_name],
		[seconds_blocked],
		[report_id],
		[blocking_id],
		[blocked_id],
		[blocking_xactid],
		[blocking_request],
		[blocking_sproc_statement],
		[blocking_resource_id],
		[blocking_resource],
		[blocking_wait_time],
		[blocking_tran_count],
		[blocking_isolation_level],
		[blocking_status],
		[blocking_start_offset],
		[blocking_end_offset],
		[blocking_host_name],
		[blocking_login_name],
		[blocking_client_app],
		[blocked_spid],
		[blocked_ecid],
		[blocked_xactid],
		[blocked_request],
		[blocked_sproc_statement],
		[blocked_resource_id],
		[blocked_resource],
		[blocked_wait_time],
		[blocked_tran_count],
		[blocked_log_used],
		[blocked_lock_mode],
		[blocked_isolation_level],
		[blocked_status],
		[blocked_start_offset],
		[blocked_end_offset],
		[blocked_host_name],
		[blocked_login_name],
		[blocked_client_app],
		[report]
	)
	SELECT 
		[timestamp],
		[database_name],
		[seconds_blocked],
		[report_id],
		[blocking_id],
		[blocked_id],
		[blocking_xactid],
		[blocking_request],
		--[normalized_blocking_request],
		[blocking_sproc_statement],
		[blocking_resource_id],
		[blocking_resource],
		[blocking_wait_time],
		[blocking_tran_count],
		[blocking_isolation_level],
		[blocking_status],
		[blocking_start_offset],
		[blocking_end_offset],
		[blocking_host_name],
		[blocking_login_name],
		[blocking_client_app],
		[blocked_spid],
		[blocked_ecid],
		[blocked_xactid],
		[blocked_request],
		--[normalized_blocked_request],
		[blocked_sproc_statement],
		[blocked_resource_id],
		[blocked_resource],
		[blocked_wait_time],
		[blocked_tran_count],
		[blocked_log_used],
		[blocked_lock_mode],
		[blocked_isolation_level],
		[blocked_status],
		[blocked_start_offset],
		[blocked_end_offset],
		[blocked_host_name],
		[blocked_login_name],
		[blocked_client_app],
		[report]
	FROM 
		[#data]
	ORDER BY 
		row_id; ';

	DECLARE @return int;
	EXEC @return = dbo.[eventstore_etl_session] 
		@SessionName = @SessionName, 
		@EventStoreTarget = @EventStoreTarget, 
		@TranslationDML = @etlSQL, 
		@InitializeDaysBack = @InitializeDaysBack;
	
	RETURN @return; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_etl_deadlocks]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_etl_deadlocks];
GO

CREATE PROC dbo.[eventstore_etl_deadlocks]
	@SessionName				sysname			= N'eventstore_deadlocks', 
	@EventStoreTarget			sysname			= N'admindb.dbo.eventstore_deadlocks',
	@InitializeDaysBack			int				= 5
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @SessionName = ISNULL(NULLIF(@SessionName, N''), N'eventstore_deadlocks');
	SET @EventStoreTarget = ISNULL(NULLIF(@EventStoreTarget, N''), N'admindb.dbo.eventstore_deadlocks');
	SET @InitializeDaysBack = ISNULL(@InitializeDaysBack, 5);		

	DECLARE @etlSQL nvarchar(MAX) = N'
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- XEL Data Extraction:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	WITH core AS ( 
		SELECT 
			[nodes].[row].value(N''(@timestamp)[1]'', N''datetime2'') AS [timestamp], 
			ROW_NUMBER() OVER (ORDER BY [nodes].[row].value(N''(@timestamp)[1]'', N''datetime2'')) [deadlock_id], 
			[nodes].[row].query(N''.'') [data]
		FROM 
			@EventData.nodes(N''//event'') [nodes]([row])

	), 
	processes AS ( 
		SELECT 
			[c].[timestamp],
			[c].[deadlock_id],
			[nodes].[row].value(N''@id'', N''varchar(30)'') [process_id], 
			[nodes].[row].value(N''@lockMode'', N''varchar(10)'') [lock_mode], 
			[nodes].[row].value(N''@spid'', N''int'') [session_id], 
			[nodes].[row].value(N''@ecid'', N''int'') [ecid], 
			[nodes].[row].value(N''@clientapp'', N''varchar(100)'') [application_name], 
			[nodes].[row].value(N''@hostname'', N''varchar(100)'') [host_name], 
			[nodes].[row].value(N''@trancount'', N''int'') [transaction_count], 
			[nodes].[row].value(N''@waitresource'', N''varchar(200)'') [wait_resource], 
			[nodes].[row].value(N''@waittime'', N''int'') [wait_time], 
			[nodes].[row].value(N''@logused'', N''bigint'') [log_used], 
			[nodes].[row].value(N''(inputbuf)[1]'', N''nvarchar(max)'') [input_buffer],
			[nodes].[row].value(N''(executionStack/frame/@procname)[1]'', N''nvarchar(max)'') [proc],
			[nodes].[row].value(N''(executionStack/frame)[1]'', N''nvarchar(max)'') [statement],
			COUNT(*) OVER (PARTITION BY [c].[deadlock_id]) [process_count], 
			[c].[data]
		FROM 
			core c
			CROSS APPLY c.data.nodes(N''//deadlock/process-list/process'') [nodes]([row])
	), 
	victims AS ( 
		SELECT 
			[c].[deadlock_id], 
			[v].[values].value(N''@id'', N''varchar(20)'') [victim_id]
		FROM 
			core [c]
			CROSS APPLY [c].[data].nodes(N''//deadlock/victim-list/victimProcess'') v ([values])
	), 
	aggregated AS ( 
		SELECT 
			[c].[deadlock_id], 
			[p].[process_id],
			[p].[session_id],
			[p].[application_name],
			[p].[host_name], 
			[p].[input_buffer]
		FROM 
			[core] [c]
			INNER JOIN [processes] [p] ON [c].[deadlock_id] = [p].[deadlock_id]
			LEFT OUTER JOIN [victims] [v] ON [v].[deadlock_id] = [c].[deadlock_id] AND [p].[process_id] = [v].[victim_id]	
	) 

	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		[a].[deadlock_id],
		[p].[timestamp],  /* S4-536 - i.e., pre-projection here breaks ability to filter later on. */
		[p].[process_count],
		CASE WHEN [p].[ecid] = 0 THEN CAST(a.[session_id] AS sysname) ELSE CAST([a].[session_id] AS sysname) + N'' ('' + CAST([p].[ecid] AS sysname) + N'')'' END [session_id],
		[a].[application_name],
		[a].[host_name],
		[p].[transaction_count],
		[p].[lock_mode],
		([p].[wait_time]) [wait_time_ms],  
		[p].[log_used],
		[p].[wait_resource] [wait_resource_id],
		CAST('''' AS varchar(2000)) [wait_resource],
		[p].[proc],
		[p].[statement],
		[a].[input_buffer],
		[p].[data] [deadlock_graph]
	INTO 
		#shredded
	FROM 
		[aggregated] a 
		INNER JOIN [processes] p ON [a].[deadlock_id] = [p].[deadlock_id] AND [a].[process_id] = [p].[process_id]
	ORDER BY 
		--a.[deadlock_id], a.[line_id];
		[a].[deadlock_id];

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Wait Resource Extraction:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	SELECT 
		IDENTITY(int, 1, 1) [row_id],
		[wait_resource_id], 
		CAST('''' AS nvarchar(MAX)) [definition]
	INTO 
		#waits
	FROM 
		[#shredded] 
	GROUP BY 
		[wait_resource_id]; 		

	DECLARE @rowID int;
	DECLARE @resourceID nvarchar(80);
	DECLARE @resource nvarchar(2000);
	
	DECLARE waiter CURSOR LOCAL FAST_FORWARD FOR 
	SELECT row_id, [wait_resource_id] FROM [#waits];

	OPEN [waiter];
	FETCH NEXT FROM [waiter] INTO @rowID, @resourceID;

	WHILE @@FETCH_STATUS = 0 BEGIN
		EXEC dbo.[extract_waitresource]
			@WaitResource = @resourceID,
			@Output = @resource OUTPUT;

		UPDATE #waits 
		SET 
			[definition] = @resource
		WHERE 
			[row_id] = @rowID;

		FETCH NEXT FROM [waiter] INTO @rowID, @resourceID;
	END;

	CLOSE [waiter];
	DEALLOCATE [waiter];

	UPDATE s 
	SET 
		s.wait_resource = x.[definition]
	FROM 
		[#shredded] s 
		INNER JOIN [#waits] x ON s.[wait_resource_id] = x.[wait_resource_id];

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Final Projection / Storage: 
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	USE [{targetDatabase}];

	INSERT INTO [{targetSchema}].[{targetTable}] (
		[timestamp],
		[deadlock_id],
		[process_count],
		[session_id],
		[application_name],
		[host_name],
		[transaction_count],
		[lock_mode],
		[wait_time_ms],
		[log_used],
		[wait_resource_id],
		[wait_resource],
		[proc],
		[statement],
		[input_buffer],
		[deadlock_graph]
	)
	SELECT 
		[timestamp],
		[deadlock_id],
		[process_count],
		[session_id],
		[application_name],
		[host_name],
		[transaction_count],
		[lock_mode],
		[wait_time_ms],
		[log_used],
		[wait_resource_id],
		[wait_resource],
		[proc],
		[statement],
		[input_buffer],
		[deadlock_graph] 
	FROM 
		[#shredded]
	ORDER BY 
		[row_id]; ';	

	DECLARE @return int;
	EXEC @return = dbo.[eventstore_etl_session] 
		@SessionName = @SessionName, 
		@EventStoreTarget = @EventStoreTarget, 
		@TranslationDML = @etlSQL, 
		@InitializeDaysBack = @InitializeDaysBack;
	
	RETURN @return;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_etl_large_sql]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_etl_large_sql];
GO

CREATE PROC dbo.[eventstore_etl_large_sql]
	@SessionName				sysname			= N'capture_large_sql', 
	@EventStoreTarget			sysname			= N'admindb.dbo.eventstore_large_sql',
	@InitializeDaysBack			int				= 10
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @SessionName = ISNULL(NULLIF(@SessionName, N''), N'capture_large_sql');
	SET @EventStoreTarget = ISNULL(NULLIF(@EventStoreTarget, N''), N'admindb.dbo.eventstore_large_sql');
	SET @InitializeDaysBack = ISNULL(@InitializeDaysBack, 10);

	DECLARE @etlSQL nvarchar(MAX) = N'
	USE [{targetDatabase}];

	INSERT INTO [{targetSchema}].[{targetTable}] (
		[timestamp],
		[database_name],
		[user_name],
		[host_name],
		[application_name],
		[module],
		[statement],
		[offset],
		[cpu_ms],
		[duration_ms],
		[physical_reads],
		[writes],
		[row_count],
		[report]
	)
	SELECT 
		[nodes].[row].value(N''(@timestamp)[1]'', N''datetime'') [timestamp],
		[nodes].[row].value(N''(action[@name="database_name"]/value)[1]'', N''sysname'') [database_name],
		[nodes].[row].value(N''(action[@name="username"]/value)[1]'', N''sysname'') [user_name],
		[nodes].[row].value(N''(action[@name="client_hostname"]/value)[1]'', N''sysname'') [host_name],
		[nodes].[row].value(N''(action[@name="client_app_name"]/value)[1]'', N''sysname'') [application_name],
		[nodes].[row].value(N''(data[@name="object_name"]/value)[1]'', N''sysname'') [module],
		[nodes].[row].value(N''(data[@name="statement"]/value)[1]'', N''nvarchar(MAX)'') [statement],
		[nodes].[row].value(N''(data[@name="offset"]/value)[1]'', N''sysname'') + N'' - '' + [nodes].[row].value(N''(data[@name="offset_end"]/value)[1]'', N''sysname'')  [offset],
		[nodes].[row].value(N''(data[@name="cpu_time"]/value)[1]'', N''bigint'') / 1000 [cpu_ms],
		[nodes].[row].value(N''(data[@name="duration"]/value)[1]'', N''bigint'') / 1000 [duration_ms],
		[nodes].[row].value(N''(data[@name="physical_reads"]/value)[1]'', N''bigint'') [physical_reads],
		[nodes].[row].value(N''(data[@name="writes"]/value)[1]'', N''bigint'') [writes],
		[nodes].[row].value(N''(data[@name="row_count"]/value)[1]'', N''bigint'') [row_count], 
		[nodes].[row].query(N''.'') [report]
	FROM 
		@EventData.nodes(N''//event'') [nodes]([row]); ';

	DECLARE @return int;
	EXEC @return = dbo.[eventstore_etl_session] 
		@SessionName = @SessionName, 
		@EventStoreTarget = @EventStoreTarget, 
		@TranslationDML = @etlSQL, 
		@InitializeDaysBack = @InitializeDaysBack;
	
	RETURN @return; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_report_all_error_counts]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_report_all_error_counts];
GO

CREATE PROC dbo.[eventstore_report_all_error_counts]
	@Granularity				sysname			= N'HOUR', 
	@Start						datetime		= NULL, 
	@End						datetime		= NULL, 
	@TimeZone					sysname			= NULL, 
	@MinimumSeverity			int				= -1, 
	@ExcludedErrorIds			nvarchar(MAX)	= NULL, 
	@RequiredErrorIds			nvarchar(MAX)	= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @ExcludedErrorIds = NULLIF(@ExcludedErrorIds, N'');
	SET @RequiredErrorIds = NULLIF(@RequiredErrorIds, N'');
	SET @MinimumSeverity = ISNULL(@MinimumSeverity, -1);
	SET @MinimumSeverity = ISNULL(NULLIF(@MinimumSeverity, 0), -1);
	
	DECLARE @eventStoreKey sysname = N'ALL_ERRORS';
	DECLARE @eventStoreTarget sysname = (SELECT [target_table] FROM [dbo].[eventstore_settings] WHERE [event_store_key] = @eventStoreKey); 	

	IF @RequiredErrorIds IS NOT NULL AND @ExcludedErrorIds IS NOT NULL BEGIN 
		RAISERROR(N'@ExcludedErrorIds and @RequiredErrorIds are mutually Exclusive - use one or the other (not both).', 16, 1);
		RETURN -10;
	END;

	IF @MinimumSeverity <> -1 BEGIN 
		IF @MinimumSeverity < 1 OR @MinimumSeverity > 25 BEGIN 
			RAISERROR(N'@MinimumSeverity may only be set to a value between 1 and 25.', 16, 1);
			RETURN -11;
		END;
	END;
	
	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Time-Bounding
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @eventStoreTarget, 
		@ParameterNameForTarget = N'@eventStoreTarget', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised...

	SET @outcome = 0;
	DECLARE @times xml;
	EXEC @outcome = dbo.[eventstore_timebounded_counts]
		@Granularity = @Granularity,
		@Start = @Start,
		@End = @End,
		@TimeZone = @TimeZone,
		@SerializedOutput = @times OUTPUT;

	IF @outcome <> 0 
		RETURN @outcome;

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'(block_id)[1]', N'int') [block_id], 
			[data].[row].value(N'(start_time)[1]', N'datetime') [start_time],
			[data].[row].value(N'(end_time)[1]', N'datetime') [end_time], 
			[data].[row].value(N'(time_zone)[1]', N'sysname') [time_zone]
		FROM 
			@times.nodes(N'//time') [data]([row])
	) 

	SELECT 
		[block_id],
		[start_time],
		[end_time],
		[time_zone]
	INTO 
		#times
	FROM 
		shredded 
	ORDER BY 
		[block_id];
	
	IF @Start IS NULL BEGIN 
		SELECT 
			@Start = MIN([start_time]), 
			@End = MAX([end_time]) 
		FROM 
			[#times];
	END;

-- HACK: 
--		Need to figure this out - in terms of HOW it interacts with an explicitly specified @TimeZone... 
--	BUT, for now, I'm hacking this to keep basic functionality working/proceding - and will come back and re-evaluate this. 
--		where 'this' is: 
--			for WHATEVER reason, [timestamp] values for this XE session are all, 100%, in UTC time - not local-server-time. 
--			I REALLY don't get that. 

--SELECT @Start, @End;
	DECLARE @diff int = DATEDIFF(HOUR, GETDATE(), GETUTCDATE());
	SET @Start = DATEADD(HOUR, @diff, @Start);
	SET @End = DATEADD(HOUR, @diff, @End);

	--SELECT @Start, @End;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Metrics Extraction:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	CREATE TABLE #metrics ( 
		[error_timestamp] datetime NOT NULL,  
		[error_id] int NOT NULL
	);
	CREATE NONCLUSTERED INDEX #metrics_error_id ON [#metrics] ([error_id]);
	
	DECLARE @crlftab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);
	DECLARE @filters nvarchar(MAX) = N'';
	DECLARE @joins nvarchar(MAX) = N'';

	IF @MinimumSeverity <> -1 BEGIN 
		SET @filters = @filters + @crlftab + N'AND Severity >= ' + CAST(@MinimumSeverity AS sysname); 
	END;

	IF @RequiredErrorIds IS NOT NULL BEGIN 
		CREATE TABLE #requiredIDs (
			[row_id] int IDENTITY(1,1) NOT NULL, 
			[error_id] int NOT NULL 
		);

		INSERT INTO [#requiredIDs] ([error_id])
		SELECT [result] FROM [dbo].[split_string](@RequiredErrorIds, N',', 1);

		SET @joins = @crlftab + N'INNER JOIN [#requiredIDs] [x] ON [e].[error_number] = [x].[error_id]';
	END;

	IF @ExcludedErrorIds IS NOT NULL BEGIN 
		CREATE TABLE #excludedIDs (
			[row_id] int IDENTITY(1,1) NOT NULL, 
			[error_id] int NOT NULL 
		);

		INSERT INTO [#excludedIDs] ([error_id])
		SELECT [result] FROM [dbo].[split_string](@ExcludedErrorIds, N',', 1);

		SET @joins = @crlftab + N'LEFT OUTER JOIN [#excludedIDs] [x] ON [e].[error_number] = [x].[error_id]';
		SET @filters = @filters + @crlftab + N'AND [x].[error_id] IS NOT NULL';
	END;

	DECLARE @sql nvarchar(MAX) = N'SELECT 
	[e].[timestamp] [error_timestamp], 
	[e].[error_number] [error_id]
FROM 
	{SourceTable} [e]{joins}
WHERE 
	[e].[timestamp]>= @Start 
	AND [e].[timestamp] <= @End{filters};'

	SET @sql = REPLACE(@sql, N'{SourceTable}', @normalizedName);
	SET @sql = REPLACE(@sql, N'{joins}', @joins);
	SET @sql = REPLACE(@sql, N'{filters}', @filters);

	INSERT INTO [#metrics] (
		[error_timestamp],
		[error_id]
	)
	EXEC sys.sp_executesql 
		@sql, 
		N'@Start datetime, @End datetime', 
		@Start = @Start, 
		@End = @End;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Correlate + Project:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	WITH times AS ( 
		SELECT 
			[t].[block_id], 
			[t].[start_time], 
			[t].[end_time]
		FROM 
			[#times] [t]
	),
	correlated AS ( 
		SELECT 
			[t].[block_id],
			[t].[start_time],
			[t].[end_time],
			[m].[error_timestamp], 
			[m].[error_id]
		FROM 
			[times] [t]
			LEFT OUTER JOIN [#metrics] [m] ON [m].[error_timestamp] < [t].[end_time] AND [m].[error_timestamp] > [t].[start_time] -- anchors 'up' - i.e., for an event that STARTS at 12:59:59.33 and ENDs 2 seconds later, the entry will 'show up' in hour 13:00... 
	), 
	aggregated AS ( 
		SELECT 
			[block_id], 
			COUNT(*) [errors], 
			COUNT(DISTINCT [error_id]) [distinct_errors]
		FROM 
			[correlated] 
		WHERE 
			[error_timestamp] IS NOT NULL 
		GROUP BY 
			[block_id]
	)

	SELECT 
		[t].[end_time],
		ISNULL([a].[errors], 0) [error_count],
		ISNULL([a].[distinct_errors], 0) [distinct_errors]
	FROM 
		[#times] [t] 
		LEFT OUTER JOIN [aggregated] [a] ON [t].[block_id] = [a].[block_id]
	ORDER BY 
		[t].[block_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_report_blocked_processes_chronology]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_report_blocked_processes_chronology];
GO

CREATE PROC dbo.[eventstore_report_blocked_processes_chronology]
	@Start						datetime		= NULL, 
	@End						datetime		= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @eventStoreKey sysname = N'BLOCKED_PROCESSES';
	DECLARE @eventStoreTarget sysname = (SELECT [target_table] FROM [dbo].[eventstore_settings] WHERE [event_store_key] = @eventStoreKey); 

	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @eventStoreTarget, 
		@ParameterNameForTarget = N'@eventStoreTarget', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised...

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Time-Bounding Predicates and Translations:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	IF @Start IS NULL AND @End IS NULL BEGIN 
		SET @Start = DATEADD(HOUR, -2, GETDATE());
		SET @End = GETDATE();
	  END; 
	ELSE BEGIN 
		IF @Start IS NOT NULL BEGIN 
			SET @End = DATEADD(HOUR, 2, @Start);
		END;

		IF @End IS NULL AND @Start IS NOT NULL BEGIN 
			RAISERROR(N'A value for @End can ONLY be specified if a value for @Start has been provided.', 16, 1);
			RETURN -2;
		END;

		IF @End < @Start BEGIN 
			RAISERROR(N'Specified value for @End can NOT be less than (earlier than) value provided for @Start.', 16, 1);
			RETURN -3;
		END;
	END;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Extraction / Work-Table:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	CREATE TABLE #work (
		[row_id] int NOT NULL,
		[timestamp] [datetime2](7) NOT NULL,
		[database_name] [nvarchar](128) NOT NULL,
		[seconds_blocked] [decimal](24, 2) NOT NULL,
		[report_id] [int] NOT NULL,
		[blocking_id] sysname NULL,  -- ''self blockers'' can/will be NULL
		[blocked_id] sysname NOT NULL,
		[blocking_xactid] [bigint] NULL,  -- ''self blockers'' can/will be NULL
		[blocking_request] [nvarchar](MAX) NOT NULL,
		[blocking_sproc_statement] [nvarchar](MAX) NOT NULL,
		[blocking_resource_id] [nvarchar](80) NULL,
		[blocking_resource] [varchar](2000) NOT NULL,
		[blocking_wait_time] [int] NULL,
		[blocking_tran_count] [int] NULL,  -- ''self blockers'' can/will be NULL
		[blocking_isolation_level] [nvarchar](128) NULL,   -- ''self blockers'' can/will be NULL
		[blocking_status] sysname NULL,
		[blocking_start_offset] [int] NULL,
		[blocking_end_offset] [int] NULL,
		[blocking_host_name] sysname NULL,
		[blocking_login_name] sysname NULL,
		[blocking_client_app] sysname NULL,
		[blocked_spid] [int] NOT NULL,
		[blocked_ecid] [int] NOT NULL,
		[blocked_xactid] [bigint] NULL,  -- can be NULL
		[blocked_request] [nvarchar](max) NOT NULL,
		[blocked_sproc_statement] [nvarchar](max) NOT NULL,
		[blocked_resource_id] [nvarchar](80) NOT NULL,
		[blocked_resource] [varchar](2000) NULL,  -- can be NULL if/when there isn''t an existing translation
		[blocked_wait_time] [int] NOT NULL,
		[blocked_tran_count] [int] NOT NULL,
		[blocked_log_used] [int] NOT NULL,
		[blocked_lock_mode] sysname NULL, -- CAN be NULL
		[blocked_isolation_level] [nvarchar](128) NULL,
		[blocked_status] sysname NOT NULL,
		[blocked_start_offset] [int] NOT NULL,
		[blocked_end_offset] [int] NOT NULL,
		[blocked_host_name] sysname NULL,
		[blocked_login_name] sysname NULL,
		[blocked_client_app] sysname NULL,
		[report] [xml] NOT NULL
	);

	CREATE CLUSTERED INDEX [____CLIX_#work_byReportId] ON [#work] (report_id);

	DECLARE @sql nvarchar(MAX) = N'	SELECT 
		*
	FROM 
		{SourceTable}
	WHERE
		[timestamp] >= @Start
		AND [timestamp] < @End
	ORDER BY 
		[row_id]; ';

	SET @sql = REPLACE(@sql, N'{SourceTable}', @normalizedName);

	INSERT INTO [#work] (
		[row_id],
		[timestamp],
		[database_name],
		[seconds_blocked],
		[report_id],
		[blocking_id],
		[blocked_id],
		[blocking_xactid],
		[blocking_request],
		[blocking_sproc_statement],
		[blocking_resource_id],
		[blocking_resource],
		[blocking_wait_time],
		[blocking_tran_count],
		[blocking_isolation_level],
		[blocking_status],
		[blocking_start_offset],
		[blocking_end_offset],
		[blocking_host_name],
		[blocking_login_name],
		[blocking_client_app],
		[blocked_spid],
		[blocked_ecid],
		[blocked_xactid],
		[blocked_request],
		[blocked_sproc_statement],
		[blocked_resource_id],
		[blocked_resource],
		[blocked_wait_time],
		[blocked_tran_count],
		[blocked_log_used],
		[blocked_lock_mode],
		[blocked_isolation_level],
		[blocked_status],
		[blocked_start_offset],
		[blocked_end_offset],
		[blocked_host_name],
		[blocked_login_name],
		[blocked_client_app],
		[report] 
	)
	EXEC sys.sp_executesql
		@sql, 
		N'@Start datetime, @End datetime', 
		@Start = @Start, 
		@End = @End;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Correlation + Projection:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	WITH leads AS (		
	
		SELECT report_id, blocking_id
		FROM [#work] 

		EXCEPT 

		SELECT report_id, blocked_id
		FROM [#work] 

	), 
	chain AS ( 
	
		SELECT 
			report_id, 
			0 AS [level],
			blocking_id, 
			CAST(blocking_id AS sysname) [blocking_chain]
		FROM 
			leads 

		UNION ALL 

		SELECT 
			base.report_id, 
			c.[level] + 1 [level],
			base.blocked_id, 
			CAST(c.[blocking_chain] + N' -> ' + CAST(base.blocked_id AS nvarchar(10)) AS sysname)
		FROM 
			[#work] base 
			INNER JOIN chain c ON base.report_id = c.report_id AND base.blocking_id = c.blocking_id 
	)

	SELECT 
		[report_id],
		[level],
		[blocking_id],
		[blocking_chain]
	INTO 
		#chain
	FROM 
		chain
	WHERE 
		[level] <> 0;

	SELECT 
		report_id, 
		MIN([timestamp]) [timestamp], 
		COUNT(*) [process_count]
	INTO 
		#aggregated
	FROM 
		[#work]
	GROUP BY 
		[report_id];

--
	WITH normalized AS ( 

		SELECT 
			ISNULL([c].[level], -1) [level],
			[w].[blocking_id],
			[w].[blocked_id],
			LAG([w].[report_id], 1, 0) OVER (ORDER BY [w].[report_id], ISNULL([c].[level], -1)) [previous_report_id],

			[w].[report_id] [original_report_id],
			[w].[database_name],
			[w].[timestamp],
			[a].[process_count],

			ISNULL([c].[blocking_chain], N'    ' + CAST([w].[blocked_id] AS sysname) + N' -> (' + CAST([w].[blocked_id] AS sysname) + N')') [blocking_chain],
			
			dbo.[format_timespan]([w].[blocked_wait_time]) [time_blocked],
			
			CASE WHEN [w].[blocking_id] IS NULL THEN N'<blocking-self>' ELSE [w].[blocking_status] END [blocking_status],
			[w].[blocking_isolation_level],
			CASE WHEN [w].[blocking_id] IS NULL THEN N'(' + CAST([w].[blocked_xactid] AS sysname) + N')' ELSE CAST([w].[blocking_xactid] AS sysname) END [blocking_xactid],
			[w].[blocking_tran_count],
			CASE WHEN [w].blocking_request LIKE N'%Object Id = [0-9]%' THEN [w].[blocking_request] + N' --> ' + ISNULL([w].[blocking_sproc_statement], N'#sproc_statement_extraction_error#') ELSE ISNULL([w].[blocking_request], N'') END [blocking_request],
			[w].[blocking_resource],

			-- blocked... 
			[w].[blocked_status], -- always suspended or background - but background can be important to know... 
			[w].[blocked_isolation_level],
			[w].[blocked_xactid],
			[w].[blocked_tran_count],
			[w].[blocked_log_used],
			
			CASE WHEN [w].[blocked_request] LIKE N'%Object Id = [0-9]%' THEN [w].[blocked_request] + N' --> ' + ISNULL([w].[blocked_sproc_statement], N'#sproc_statement_extraction_error#') ELSE ISNULL([w].[blocked_request], N'') END [blocked_request],
			[w].[blocked_resource],
		
			--[w].[blocking_weight],
			--[w].[blocked_weight],

			[w].[blocking_host_name],
			[w].[blocking_login_name],
			[w].[blocking_client_app],
		
			[w].[blocked_host_name],
			[w].[blocked_login_name],
			[w].[blocked_client_app],
			[w].[report]
		FROM 
			[#work] w
			LEFT OUTER JOIN [#aggregated] a ON [w].[report_id] = [a].[report_id]
			LEFT OUTER JOIN [#chain] c ON [w].[report_id] = [c].[report_id] AND w.blocked_id = c.[blocking_id]
	)

	SELECT 
		--[level],
		--[blocking_id],
		--[blocked_id],
		--[previous_report_id],
		
		CASE WHEN [original_report_id] = [previous_report_id] THEN N'' ELSE CAST([original_report_id] AS sysname) END [report_id],
		CASE WHEN [original_report_id] = [previous_report_id] THEN N'' ELSE [database_name] END [database_name],
		CASE WHEN [original_report_id] = [previous_report_id] THEN N'' ELSE CONVERT(sysname, [timestamp], 121) END [timestamp],
		CASE WHEN [original_report_id] = [previous_report_id] THEN N'' ELSE CAST([process_count] AS sysname) END [process_count],
		[blocking_chain],
		[time_blocked],
		[blocking_status],
		[blocking_isolation_level],
		[blocking_xactid],
		[blocking_tran_count],
		[blocking_request],
		[blocking_resource],
		[blocked_status],
		[blocked_isolation_level],
		[blocked_xactid],
		[blocked_tran_count],
		[blocked_log_used],
		[blocked_request],
		[blocked_resource],
		[blocking_host_name],
		[blocking_login_name],
		[blocking_client_app],
		[blocked_host_name],
		[blocked_login_name],
		[blocked_client_app],
		[report] 
	FROM 
		[normalized] 
	ORDER BY 
		[original_report_id], [level];

	RETURN 0;
GO




-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_report_blocked_processes_counts]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_report_blocked_processes_counts];
GO

CREATE PROC dbo.[eventstore_report_blocked_processes_counts]
	@Granularity				sysname			= N'HOUR', 
	@Start						datetime		= NULL, 
	@End						datetime		= NULL, 
	@TimeZone					sysname			= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @eventStoreKey sysname = N'BLOCKED_PROCESSES';
	DECLARE @eventStoreTarget sysname = (SELECT [target_table] FROM [dbo].[eventstore_settings] WHERE [event_store_key] = @eventStoreKey); 

	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @eventStoreTarget, 
		@ParameterNameForTarget = N'@eventStoreTarget', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised...

	SET @outcome = 0;
	DECLARE @times xml;
	EXEC @outcome = dbo.[eventstore_timebounded_counts]
		@Granularity = @Granularity,
		@Start = @Start,
		@End = @End,
		@TimeZone = @TimeZone,
		@SerializedOutput = @times OUTPUT;

	IF @outcome <> 0 
		RETURN @outcome;

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'(block_id)[1]', N'int') [block_id], 
			[data].[row].value(N'(start_time)[1]', N'datetime') [start_time],
			[data].[row].value(N'(end_time)[1]', N'datetime') [end_time], 
			[data].[row].value(N'(time_zone)[1]', N'sysname') [time_zone]
		FROM 
			@times.nodes(N'//time') [data]([row])
	) 

	SELECT 
		[block_id],
		[start_time],
		[end_time],
		[time_zone]
	INTO 
		#times
	FROM 
		shredded 
	ORDER BY 
		[block_id];

	IF @Start IS NULL BEGIN 
		SELECT 
			@Start = MIN([start_time]), 
			@End = MAX([end_time]) 
		FROM 
			[#times];
	END;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Normal Blocking:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	CREATE TABLE #blockers (
		[transaction_id] bigint NOT NULL, 
		[blocked_id] int NOT NULL,
		[event_time] datetime NOT NULL, 
		[seconds_blocked] decimal(24,2) NOT NULL 
	);

	DECLARE @sql nvarchar(MAX) = N'	WITH core AS ( 
		SELECT 
			blocking_xactid [transaction_id], 
			[blocked_id],
			[blocked_wait_time],
			[timestamp] [event_time], 
			[seconds_blocked]

		FROM 
			{SourceTable} 
		WHERE 
			[blocked_xactid] IS NOT NULL  -- don''t include ''phantom'' blocking
			AND [blocking_xactid] IS NOT NULL 
			AND [timestamp] >= @Start
			AND [timestamp] <= @End	
	)

	SELECT 
		[transaction_id], 
		[blocked_id],
		[event_time], 
		[seconds_blocked]
	FROM 
		core; ';

	SET @sql = REPLACE(@sql, N'{SourceTable}', @normalizedName);

	INSERT INTO [#blockers] (
		[transaction_id],
		[blocked_id],
		[event_time],
		[seconds_blocked]
	)
	EXEC sys.sp_executesql 
		@sql, 
		N'@Start datetime, @End datetime', 
		@Start = @Start, 
		@End = @End;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Self-Blocking:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	CREATE TABLE #self_blockers (
		[transaction_id] bigint NULL, 
		[blocked_id] int NOT NULL,
		[event_time] datetime NOT NULL, 
		[seconds_blocked] decimal(24,2) NOT NULL 
	);

	SET @sql = N'	WITH core AS ( 
		SELECT 
			[blocking_xactid] [transaction_id], 
			[blocked_id],
			[blocked_wait_time],
			[timestamp] [event_time], 
			[seconds_blocked]

		FROM 
			{SourceTable} 
		WHERE 
			[blocked_xactid] IS NOT NULL -- ignore ''phantom'' blocking 
			AND [blocking_xactid] IS NULL 
			AND [timestamp] >= @Start
			AND [timestamp] <= @End	
	)

	SELECT 
		[transaction_id], 
		[blocked_id],
		[event_time], 
		[seconds_blocked]
	FROM 
		core; ';

	SET @sql = REPLACE(@sql, N'{SourceTable}', @normalizedName);

	INSERT INTO [#self_blockers] (
		[transaction_id],
		[blocked_id],
		[event_time],
		[seconds_blocked]
	)
	EXEC sys.sp_executesql 
		@sql, 
		N'@Start datetime, @End datetime', 
		@Start = @Start, 
		@End = @End;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Phantom Blocking:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- TODO: add these in ... 
	-- they'd be ... same as blocking/self-blocking - but WHERE [blocked_xactid] IS NULL ... 
	
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Blocking Report Granularity:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- TODO: there's a happy-path logic bug here. Assume that blocked process threshold IS SET at 2 seconds. 
	--		if we get a COUPLE of operations that block for say, 6+ seconds each time there's a problem, fine - we'll get a MODE of 2 seconds between each blocking process and be FINE. 
	--		but. say that something blocks for 2.2 seconds ... every 90 seconds. At that point, the MODE will be ... 90 seconds (cuz there'll be, say, 4x of those back to back, with a cadence of 90 seconds between each problem)... 
	--		
	--		I can think of 2x ways to work around this: 
	--		a) as part of either eventstore_init_blockedprocesses - or the sproc that etl's blocked_processes every N seconds (by means of SQL Server Agent Job)
	--				capture blocked_processes_threshold and dump it into a tracking table IF the value has changed since the last time it was captured i.e., it'd be a 2 if it never changes, but might go from 2 to 4 or whatever in a case where an org changes this periodically.. 
	--				then, just look for what the value was for the @Start/@End in question and ... be done with it. 
	--		b) use .. blocked_seconds - previous.blocked_seconds for the cadence instead of event_time - previous.event_time. 
	--			and... yeah... this'd be a better option than mere event_time.
	DECLARE @blockedProcessThresholdCadenceSeconds int;

	WITH differenced AS (
		SELECT 
			[event_time], 
			DATEDIFF(SECOND, LAG(event_time, 1, NULL) OVER (ORDER BY [event_time]), [event_time]) [interval_seconds]
		FROM 
			[#blockers]
	), 
	ranked AS ( 
		SELECT 
			[interval_seconds], 
			DENSE_RANK() OVER (ORDER BY COUNT(*) DESC) [rank]
		FROM 
			[differenced]
		WHERE 
			[interval_seconds] IS NOT NULL 
			AND [interval_seconds] <> 0
		GROUP BY 
			[interval_seconds]
	) 

	SELECT 
		@blockedProcessThresholdCadenceSeconds = [interval_seconds]
	FROM 
		[ranked]
	WHERE 
		[rank] = 1;

	--SELECT ISNULL(@blockedProcessThresholdCadenceSeconds, 2);

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Correlate Self-Blocking by Time-Block:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	WITH times AS ( 
		SELECT 
			[t].[block_id], 
			[t].[start_time], 
			[t].[end_time]
		FROM 
			[#times] [t]
	),
	coordinated AS (
		SELECT 
			[t].[block_id], 
			[t].[end_time], 
			[b].[transaction_id], 
			[b].[blocked_id],
			[b].[event_time], 
			[b].[seconds_blocked] [running_seconds], 
			CASE 
				WHEN [b].[seconds_blocked] IS NULL THEN 0 
				WHEN [b].[seconds_blocked] > ISNULL(@blockedProcessThresholdCadenceSeconds, 2) AND [b].[seconds_blocked] < (2 * ISNULL(@blockedProcessThresholdCadenceSeconds, 2)) THEN [b].[seconds_blocked] 
				ELSE ISNULL(@blockedProcessThresholdCadenceSeconds, 2) 
			END [accrued_seconds]
		FROM 
			[times] [t]
			LEFT OUTER JOIN [#self_blockers] [b] ON [b].[event_time] < [t].[end_time] AND b.[event_time] > [t].[start_time] -- anchors 'up' - i.e., for an event that STARTS at 12:59:59.33 and ENDs 2 seconds later, the entry will 'show up' in hour 13:00... 
	), 
	maxed AS ( 
		SELECT 
			[block_id], 
			[transaction_id], 
			COUNT([blocked_id]) [total_events],  
			COUNT(DISTINCT [blocked_id]) [total_blocked_spids],
			MAX([running_seconds]) [running_seconds_blocked], 
			SUM([accrued_seconds]) [accrued_seconds_blocked]
		FROM 
			[coordinated]
		GROUP BY 
			[block_id], [transaction_id]
	), 
	summed AS ( 
		SELECT 
			[block_id], 
			SUM([maxed].[total_blocked_spids]) [total_blocked_spids],
			SUM([total_events]) [total_events], 
			SUM([running_seconds_blocked]) [running_seconds_blocked],
			SUM([accrued_seconds_blocked]) [accrued_seconds_blocked]
		FROM 
			maxed 
		GROUP BY 
			[block_id]
	)

	SELECT 
		[t].[block_id],
		[t].[end_time], 
		[s].[total_events] [blocking_events],
		[s].[total_blocked_spids] [blocked_spids],
		ISNULL([s].[accrued_seconds_blocked], 0) [blocking_seconds],
		ISNULL([s].[running_seconds_blocked], 0) [running_seconds] 
	INTO 
		#summedSelfBlockers
	FROM 
		[#times] [t]
		LEFT OUTER JOIN [summed] [s] ON [t].[block_id] = [s].[block_id]
	ORDER BY 
		[t].[block_id];

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Correlate by Time-Block + Project:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	WITH times AS ( 
		SELECT 
			[t].[block_id], 
			[t].[start_time], 
			[t].[end_time]
		FROM 
			[#times] [t]
	),
	coordinated AS (
		SELECT 
			[t].[block_id], 
			[t].[end_time], 
			[b].[transaction_id], 
			[b].[blocked_id],
			[b].[event_time], 
			[b].[seconds_blocked] [running_seconds], 
			CASE 
				WHEN [b].[seconds_blocked] IS NULL THEN 0 
				WHEN [b].[seconds_blocked] > ISNULL(@blockedProcessThresholdCadenceSeconds, 2) AND [b].[seconds_blocked] < (2 * ISNULL(@blockedProcessThresholdCadenceSeconds, 2)) THEN [b].[seconds_blocked] 
				ELSE ISNULL(@blockedProcessThresholdCadenceSeconds, 2) 
			END [accrued_seconds]
		FROM 
			[times] [t]
			LEFT OUTER JOIN [#blockers] [b] ON [b].[event_time] < [t].[end_time] AND b.[event_time] > [t].[start_time] -- anchors 'up' - i.e., for an event that STARTS at 12:59:59.33 and ENDs 2 seconds later, the entry will 'show up' in hour 13:00... 
	), 
	maxed AS ( 
		SELECT 
			[block_id], 
			[transaction_id], 
			COUNT([blocked_id]) [total_events],
			COUNT(DISTINCT [blocked_id]) [total_blocked_spids],
			MAX([running_seconds]) [running_seconds_blocked], 
			SUM([accrued_seconds]) [accrued_seconds_blocked]
		FROM 
			[coordinated]
		GROUP BY 
			[block_id], [transaction_id]
	), 
	summed AS ( 
		SELECT 
			[block_id], 
			SUM([maxed].[total_blocked_spids]) [total_blocked_spids],
			SUM([total_events]) [total_events], 
			SUM([running_seconds_blocked]) [running_seconds_blocked],
			SUM([accrued_seconds_blocked]) [accrued_seconds_blocked]
		FROM 
			maxed 
		GROUP BY 
			[block_id]
	)

	SELECT 
		--[t].[block_id], 
		--DATEADD(MILLISECOND, 3, DATEADD(MINUTE, 0 - @minutes, [t].[time_block])) [start_time],
		[t].[end_time] [event_time_end], 
		[s].[total_events] [blocking_events],
		[s].[total_blocked_spids] [blocked_spids],
		ISNULL([s].[accrued_seconds_blocked], 0) [blocking_seconds],
		ISNULL([s].[running_seconds_blocked], 0) [running_seconds], 
		N'' [ ], 
		sb.[blocking_events] [self_events], 
		sb.[blocked_spids] [self_spids],
		sb.[blocking_seconds] [self_seconds], 
		sb.[running_seconds] [self_running_seconds]
	FROM 
		[#times] [t]
		LEFT OUTER JOIN [summed] [s] ON [t].[block_id] = [s].[block_id]
		LEFT OUTER JOIN [#summedSelfBlockers] [sb] ON [s].[block_id] = [sb].[block_id]
	ORDER BY 
		[t].[block_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_report_deadlock_counts]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_report_deadlock_counts];
GO

CREATE PROC dbo.[eventstore_report_deadlock_counts]
	@Granularity				sysname			= N'HOUR', 
	@Start						datetime		= NULL, 
	@End						datetime		= NULL, 
	@TimeZone					sysname			= NULL, 
	@ExcludeSqlAgentJobs		bit				= 1, 
	@ExcludedStatements			nvarchar(MAX)	= NULL				
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ExcludeSqlAgentJobs = ISNULL(@ExcludeSqlAgentJobs, 1);
	SET @ExcludedStatements = NULLIF(@ExcludedStatements, N'');

	DECLARE @eventStoreKey sysname = N'DEADLOCKS';
	DECLARE @eventStoreTarget sysname = (SELECT [target_table] FROM [dbo].[eventstore_settings] WHERE [event_store_key] = @eventStoreKey); 
	
	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @eventStoreTarget, 
		@ParameterNameForTarget = N'@eventStoreTarget', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised...

	SET @outcome = 0;
	DECLARE @times xml;
	EXEC @outcome = dbo.[eventstore_timebounded_counts]
		@Granularity = @Granularity,
		@Start = @Start,
		@End = @End,
		@TimeZone = @TimeZone,
		@SerializedOutput = @times OUTPUT;

	IF @outcome <> 0 
		RETURN @outcome;

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'(block_id)[1]', N'int') [block_id], 
			[data].[row].value(N'(start_time)[1]', N'datetime') [start_time],
			[data].[row].value(N'(end_time)[1]', N'datetime') [end_time], 
			[data].[row].value(N'(time_zone)[1]', N'sysname') [time_zone]
		FROM 
			@times.nodes(N'//time') [data]([row])
	) 

	SELECT 
		[block_id],
		[start_time],
		[end_time],
		[time_zone]
	INTO 
		#times
	FROM 
		shredded 
	ORDER BY 
		[block_id];
	
	IF @Start IS NULL BEGIN 
		SELECT 
			@Start = MIN([start_time]), 
			@End = MAX([end_time]) 
		FROM 
			[#times];
	END;

	CREATE TABLE #metrics ( 
		[deadlock_time] datetime2 NOT NULL,
		[deadlock_id] int NOT NULL, 
		[process_count] int NOT NULL, 
		[transaction_count] int NOT NULL, 
		[wait_time_ms] bigint NOT NULL
	);

	DECLARE @crlftab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);
	DECLARE @exclusions nvarchar(MAX) = N'';
	IF @ExcludeSqlAgentJobs = 1 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [s].[application_name] NOT LIKE N''SQLAgent%''';
	END;

	DECLARE @excludedStatementsJoin nvarchar(MAX) = N'';
	IF @ExcludedStatements IS NOT NULL BEGIN 
		CREATE TABLE #excludedStatements (
			[row_id] int IDENTITY(1,1) NOT NULL, 
			[statement] nvarchar(MAX) NOT NULL
		);

		INSERT INTO [#excludedStatements] ([statement])
		SELECT [result] FROM [dbo].[split_string](@ExcludedStatements, N',', 1);
		
		SET @excludedStatementsJoin = @crlftab + N'LEFT OUTER JOIN #excludedStatements [x] ON ([s].[input_buffer] LIKE [x].[statement] OR [s].[statement] LIKE [x].[statement])';
		SET @exclusions = @exclusions + @crlftab + N'AND [x].[statement] IS NULL';
	END;
	
	DECLARE @sql nvarchar(MAX) = N'SELECT 
	[s].[timestamp] [deadlock_time], 
	[s].[deadlock_id], 
	[s].[process_count], 
	[s].[transaction_count], 
	[s].[wait_time_ms]
FROM 
	{SourceTable} [s]{excludedStatementsJoin}
WHERE 
	[s].[timestamp]>= @Start 
	AND [s].[timestamp] <= @End{exclusions};'; 

	SET @sql = REPLACE(@sql, N'{SourceTable}', @normalizedName);
	SET @sql = REPLACE(@sql, N'{excludedStatementsJoin}', @excludedStatementsJoin);
	SET @sql = REPLACE(@sql, N'{exclusions}', @exclusions);

	--EXEC [dbo].[print_long_string] @sql;
	
	INSERT INTO [#metrics] (
		[deadlock_time],
		[deadlock_id],
		[process_count],
		[transaction_count],
		[wait_time_ms]
	)
	EXEC sys.[sp_executesql]
		@sql, 
		N'@Start datetime, @End datetime', 
		@Start = @Start, 
		@End = @End;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Correlate + Project
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	WITH times AS ( 
		SELECT 
			[t].[block_id], 
			[t].[start_time], 
			[t].[end_time]
		FROM 
			[#times] [t]
	), 
	correlated AS ( 
		SELECT 
			[t].[block_id],
			[t].[start_time],
			[t].[end_time], 
			[m].[deadlock_time], 
			[m].[deadlock_id], 
			[m].[process_count], 
			[m].[transaction_count], 
			[m].[wait_time_ms]
		FROM 
			[times] [t]
			LEFT OUTER JOIN [#metrics] [m] ON [m].[deadlock_time] < [t].[end_time] AND [m].[deadlock_time] > [t].[start_time] -- anchors 'up' - i.e., for an event that STARTS at 12:59:59.33 and ENDs 2 seconds later, the entry will 'show up' in hour 13:00... 
	), 
	summed AS ( 
		SELECT 
			[block_id], 
			[deadlock_id], 
			MAX([process_count]) [processes_count], 
			MAX([transaction_count]) [transactions_count], 
			SUM([wait_time_ms]) [total_wait_ms]
		FROM 
			[correlated] 
		GROUP BY
			[block_id], [deadlock_id]
	),
	aggregated AS ( 
		SELECT 
			[block_id], 
			COUNT([deadlock_id]) [total_deadlocks],
			SUM([processes_count]) [total_processes], 
			SUM([transactions_count]) [total_transactions], 
			SUM([total_wait_ms]) [total_wait_ms]
		FROM 
			[summed] 
		GROUP BY
			[block_id]
	) 

	SELECT 
		[t].[end_time],
		ISNULL([a].[total_deadlocks], 0) [deadlock_reports],
		ISNULL([a].[total_processes], 0) [deadlocked_processes],
		ISNULL([a].[total_transactions], 0) [deadlocked_transactions],
		ISNULL([a].[total_wait_ms], 0) [total_wait_ms]
	FROM 
		[#times] [t]
		LEFT OUTER JOIN [aggregated] [a] ON [t].[block_id] = [a].[block_id] 
	ORDER BY 
		[t].[block_id];

	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_report_large_sql_chronology]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_report_large_sql_chronology];
GO

CREATE PROC dbo.[eventstore_report_large_sql_chronology]
	@Start						datetime		= NULL, 
	@End						datetime		= NULL,
	@ExcludeSqlAgentJobs		bit				= 1, 
	@ExcludeSqlCmd				bit				= 1,			-- bit of a hack ... to exclude jobs ... that are executed by admindb... 
	@ExcludedStatements			 nvarchar(MAX)	= NULL,
	@MinCpuMilliseconds			int				= -1, 
	@MinDurationMilliseconds	int				= -1, 
	@MinRowsModifiedCount		int				= -1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @ExcludeSqlAgentJobs = ISNULL(@ExcludeSqlAgentJobs, 1);
	SET @ExcludeSqlCmd = ISNULL(@ExcludeSqlCmd, 1);
	SET @ExcludedStatements = NULLIF(@ExcludedStatements, N'');
	
	DECLARE @eventStoreKey sysname = N'LARGE_SQL';
	DECLARE @eventStoreTarget sysname = (SELECT [target_table] FROM [dbo].[eventstore_settings] WHERE [event_store_key] = @eventStoreKey); 	

	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @eventStoreTarget, 
		@ParameterNameForTarget = N'@eventStoreTarget', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised...

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Time-Bounding Predicates and Translations:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	IF @Start IS NULL AND @End IS NULL BEGIN 
		SET @Start = DATEADD(HOUR, -2, GETDATE());
		SET @End = GETDATE();
	  END; 
	ELSE BEGIN 
		IF @Start IS NOT NULL BEGIN 
			SET @End = DATEADD(HOUR, 2, @Start);
		END;

		IF @End IS NULL AND @Start IS NOT NULL BEGIN 
			RAISERROR(N'A value for @End can ONLY be specified if a value for @Start has been provided.', 16, 1);
			RETURN -2;
		END;

		IF @End < @Start BEGIN 
			RAISERROR(N'Specified value for @End can NOT be less than (earlier than) value provided for @Start.', 16, 1);
			RETURN -3;
		END;
	END;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Extraction / Work-Table:
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	DECLARE @crlftab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);
	DECLARE @exclusions nvarchar(MAX) = N'';

	IF @ExcludeSqlAgentJobs = 1 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [application_name] NOT LIKE N''SQLAgent%''';
	END;

	IF @ExcludeSqlCmd = 1 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [application_name] <> N''SQLCMD''';
	END;

	IF @MinCpuMilliseconds > 0 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [cpu_ms] > ' + CAST(@MinCpuMilliseconds AS sysname);
	END;

	IF @MinDurationMilliseconds > 0 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [duration_ms] > ' + CAST(@MinDurationMilliseconds AS sysname);
	END; 

	IF @MinRowsModifiedCount > 0 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [row_count] > ' + CAST(@MinRowsModifiedCount AS sysname);
	END;

	DECLARE @excludedStatementsJoin nvarchar(MAX) = N'';
	IF @ExcludedStatements IS NOT NULL BEGIN 
		CREATE TABLE #excludedStatements (
			[row_id] int IDENTITY(1,1) NOT NULL, 
			[statement] nvarchar(MAX) NOT NULL
		);

		INSERT INTO [#excludedStatements] ([statement])
		SELECT [result] FROM [dbo].[split_string](@ExcludedStatements, N',', 1);
		
		SET @excludedStatementsJoin = @crlftab + N'LEFT OUTER JOIN #excludedStatements [x] ON [s].[statement] LIKE [x].[statement]';
		SET @exclusions = @exclusions + @crlftab + N'AND [x].[statement] IS NULL';

	END;

	CREATE TABLE #metrics (
		[row_id] int IDENTITY(1,1) NOT NULL,
		[timestamp] datetime NULL,
		[database_name] sysname NULL,
		[user_name] sysname NULL,
		[host_name] sysname NULL,
		[application_name] sysname NULL,
		[module] sysname NULL,
		[statement] nvarchar(max) NULL,
		[offset] nvarchar(259) NULL,
		[cpu_ms] bigint NULL,
		[duration_ms] bigint NULL,
		[physical_reads] bigint NULL,
		[writes] bigint NULL,
		[row_count] bigint NULL,
		[report] xml NULL
	);

	DECLARE @sql nvarchar(MAX) = N'SELECT 
	[s].[timestamp],
	[s].[database_name],
	[s].[user_name],
	[s].[host_name],
	[s].[application_name],
	[s].[module],
	[s].[statement],
	[s].[offset],
	[s].[cpu_ms],
	[s].[duration_ms],
	[s].[physical_reads],
	[s].[writes],
	[s].[row_count],
	[s].[report]
FROM 
	{SourceTable} [s]{excludedStatementsJoin}
WHERE
	[timestamp] >= @Start
	AND [timestamp] < @End{exclusions}
ORDER BY 
	[timestamp]; ';

	SET @sql = REPLACE(@sql, N'{SourceTable}', @normalizedName);
	SET @sql = REPLACE(@sql, N'{excludedStatementsJoin}', @excludedStatementsJoin);
	SET @sql = REPLACE(@sql, N'{exclusions}', @exclusions);

	INSERT INTO [#metrics] (
		[timestamp],
		[database_name],
		[user_name],
		[host_name],
		[application_name],
		[module],
		[statement],
		[offset],
		[cpu_ms],
		[duration_ms],
		[physical_reads],
		[writes],
		[row_count],
		[report]
	)
	EXEC sys.sp_executesql
		@sql, 
		N'@Start datetime, @End datetime', 
		@Start = @Start, 
		@End = @End;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Translate SQL Server Agent Job Names: 
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	IF @ExcludeSqlAgentJobs = 0 BEGIN 
		DECLARE @rowId int;
		DECLARE @currentAppName sysname; 
		DECLARE @jobName sysname;

		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[row_id],
			[application_name]
		FROM 
			[#metrics] 
		WHERE 
			[application_name] LIKE N'SQLAgent - TSQL JobStep (Job 0%';
		
		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @rowId, @currentAppName;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
			SET @jobName = NULL;  -- have to reset to NULL for project vs return semantics to work.

			EXEC dbo.[translate_program_name_to_agent_job] 
				@ProgramName = @currentAppName, 
				@IncludeJobStepInOutput = 1, 
				@JobName = @jobName OUTPUT;
			
			UPDATE [#metrics] 
			SET 
				[application_name] = N'SQL Agent Job: ' + @jobName 
			WHERE 
				[row_id] = @rowId;
		
			FETCH NEXT FROM [walker] INTO @rowId, @currentAppName;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

	END;

	SELECT 
		[timestamp],
		[database_name],
		[user_name],
		[host_name],
		[application_name],
		[module],
		[statement],
		[offset],
		[cpu_ms],
		dbo.[format_timespan]([duration_ms]) [duration],
		[physical_reads],
		[writes],
		[row_count],
		[report]
	FROM 
		[#metrics]
	ORDER BY 
		[timestamp];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[eventstore_report_large_sql_counts]','P') IS NOT NULL
	DROP PROC dbo.[eventstore_report_large_sql_counts];
GO

CREATE PROC dbo.[eventstore_report_large_sql_counts]
	@Granularity				sysname			= N'HOUR', 
	@Start						datetime		= NULL, 
	@End						datetime		= NULL, 
	@TimeZone					sysname			= NULL, 
	@ExcludeSqlAgentJobs		bit				= 1, 
	@ExcludeSqlCmd				bit				= 1,
	@ExcludedStatements			nvarchar(MAX)	= NULL,
	@MinCpuMilliseconds			int				= -1, 
	@MinDurationMilliseconds	int				= -1, 
	@MinRowsModifiedCount		int				= -1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @ExcludeSqlAgentJobs = ISNULL(@ExcludeSqlAgentJobs, 1);
	SET @ExcludeSqlCmd = ISNULL(@ExcludeSqlCmd, 1);
	SET @ExcludedStatements = NULLIF(@ExcludedStatements, N'');

	DECLARE @eventStoreKey sysname = N'LARGE_SQL';
	DECLARE @eventStoreTarget sysname = (SELECT [target_table] FROM [dbo].[eventstore_settings] WHERE [event_store_key] = @eventStoreKey); 

	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @eventStoreTarget, 
		@ParameterNameForTarget = N'@eventStoreTarget', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised...

	SET @outcome = 0;
	DECLARE @times xml;
	EXEC @outcome = dbo.[eventstore_timebounded_counts]
		@Granularity = @Granularity,
		@Start = @Start,
		@End = @End,
		@TimeZone = @TimeZone,
		@SerializedOutput = @times OUTPUT;

	IF @outcome <> 0 
		RETURN @outcome;

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'(block_id)[1]', N'int') [block_id], 
			[data].[row].value(N'(start_time)[1]', N'datetime') [start_time],
			[data].[row].value(N'(end_time)[1]', N'datetime') [end_time], 
			[data].[row].value(N'(time_zone)[1]', N'sysname') [time_zone]
		FROM 
			@times.nodes(N'//time') [data]([row])
	) 

	SELECT 
		[block_id],
		[start_time],
		[end_time],
		[time_zone]
	INTO 
		#times
	FROM 
		shredded 
	ORDER BY 
		[block_id];
	
	IF @Start IS NULL BEGIN 
		SELECT 
			@Start = MIN([start_time]), 
			@End = MAX([end_time]) 
		FROM 
			[#times];
	END;

	CREATE TABLE #metrics ( 
		[execution_end_time] datetime NOT NULL, 
		[cpu_milliseconds] bigint NOT NULL,
		[duration_milliseconds] bigint NOT NULL,
		[reads] bigint NOT NULL,
		[writes] bigint NOT NULL, 
		[row_count] bigint NOT NULL
	); 

	DECLARE @crlftab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);
	DECLARE @exclusions nvarchar(MAX) = N'';
	IF @ExcludeSqlAgentJobs = 1 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [s].[application_name] NOT LIKE N''SQLAgent%''';
	END;

	IF @ExcludeSqlCmd = 1 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [s].[application_name] <> N''SQLCMD''';
	END;

	IF @MinCpuMilliseconds > 0 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [s].[cpu_ms] > ' + CAST(@MinCpuMilliseconds AS sysname);
	END;

	IF @MinDurationMilliseconds > 0 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [s].[duration_ms] > ' + CAST(@MinDurationMilliseconds AS sysname);
	END; 

	IF @MinRowsModifiedCount > 0 BEGIN 
		SET @exclusions = @exclusions + @crlftab + N'AND [s].[row_count] > ' + CAST(@MinRowsModifiedCount AS sysname);
	END;

	DECLARE @excludedStatementsJoin nvarchar(MAX) = N'';
	IF @ExcludedStatements IS NOT NULL BEGIN 
		CREATE TABLE #excludedStatements (
			[row_id] int IDENTITY(1,1) NOT NULL, 
			[statement] nvarchar(MAX) NOT NULL
		);

		INSERT INTO [#excludedStatements] ([statement])
		SELECT [result] FROM [dbo].[split_string](@ExcludedStatements, N',', 1);
		
		SET @excludedStatementsJoin = @crlftab + N'LEFT OUTER JOIN #excludedStatements [x] ON [s].[statement] LIKE [x].[statement]';
		SET @exclusions = @exclusions + @crlftab + N'AND [x].[statement] IS NULL';

	END;

	DECLARE @sql nvarchar(MAX) = N'SELECT 
	[s].[timestamp] [execution_end_time], 
	[s].[cpu_ms] [cpu_milliseconds], 
	[s].[duration_ms] [duration_milliseconds], 
	[s].[physical_reads] [reads], 
	[s].[writes], 
	[s].[row_count]
FROM 
	{SourceTable} [s]{excludedStatementsJoin}
WHERE 
	[s].[timestamp]>= @Start 
	AND [s].[timestamp] <= @End{exclusions};'; 

	SET @sql = REPLACE(@sql, N'{SourceTable}', @normalizedName);
	SET @sql = REPLACE(@sql, N'{excludedStatementsJoin}', @excludedStatementsJoin);
	SET @sql = REPLACE(@sql, N'{exclusions}', @exclusions);

	--EXEC dbo.[print_long_string] @sql;	

	INSERT INTO [#metrics] (
		[execution_end_time],
		[cpu_milliseconds],
		[duration_milliseconds],
		[reads],
		[writes], 
		[row_count]
	)
	EXEC sys.[sp_executesql]
		@sql, 
		N'@Start datetime, @End datetime', 
		@Start = @Start, 
		@End = @End;

	/*---------------------------------------------------------------------------------------------------------------------------------------------------
	-- Correlate + Project:
	---------------------------------------------------------------------------------------------------------------------------------------------------*/
	WITH times AS ( 
		SELECT 
			[t].[block_id], 
			[t].[start_time], 
			[t].[end_time]
		FROM 
			[#times] [t]
	), 
	correlated AS ( 
		SELECT 
			[t].[block_id],
			[t].[start_time],
			[t].[end_time],
			[m].[execution_end_time],
			[m].[cpu_milliseconds],
			[m].[duration_milliseconds],
			[m].[reads],
			[m].[writes], 
			[m].[row_count]
		FROM 
			[times] [t]
			LEFT OUTER JOIN [#metrics] [m] ON [m].[execution_end_time] < [t].[end_time] AND [m].[execution_end_time] > [t].[start_time] -- anchors 'up' - i.e., for an event that STARTS at 12:59:59.33 and ENDs 2 seconds later, the entry will 'show up' in hour 13:00... 
	), 
	aggregated AS ( 
		SELECT 
			[block_id], 
			COUNT(*) [events],
			SUM([cpu_milliseconds]) [total_cpu],
			SUM([duration_milliseconds]) [total_duration], 
			SUM(CAST(([reads] * 8.0 / 1024.0) AS decimal(24,2))) [total_reads], 
			SUM(CAST(([writes] * 8.0 / 1024.0) AS decimal(24,2))) [total_writes], 
			SUM([row_count]) [total_rows]
		FROM 
			[correlated]
		WHERE 
			[execution_end_time] IS NOT NULL  -- without this, then 'empty' time slots (block_ids) end up with COUNT(*) = 1 ... 
		GROUP BY 
			[block_id]
	)

	SELECT 
		[t].[end_time],
		ISNULL([a].[events], 0) [events],
		ISNULL([a].[total_cpu], 0) [total_cpu_ms],
		dbo.[format_timespan](ISNULL([a].[total_duration], 0)) [total_duration],
		ISNULL([a].[total_reads], 0) [total_reads_MB],
		ISNULL([a].[total_writes], 0) [total_writes_MB], 
		ISNULL([a].[total_rows], 0) [total_rows]
	FROM 
		[#times] [t]
		LEFT OUTER JOIN [aggregated] [a] ON [t].[block_id] = [a].[block_id]
	ORDER BY 
		[t].[block_id];

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Maintenance
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.check_database_consistency','P') IS NOT NULL
	DROP PROC dbo.[check_database_consistency];
GO

CREATE PROC dbo.[check_database_consistency]
	@Targets								nvarchar(MAX)	                        = N'{ALL}',		-- {ALL} | {SYSTEM} | {USER} | comma,delimited,list, of, databases, where, spaces, do,not,matter
	@Exclusions								nvarchar(MAX)	                        = NULL,			-- comma, delimited, list, of, db, names, %wildcards_allowed%
	@Priorities								nvarchar(MAX)	                        = NULL,			-- higher,priority,dbs,*,lower,priority, dbs  (where * is an ALPHABETIZED list of all dbs that don't match a priority (positive or negative)). If * is NOT specified, the following is assumed: high, priority, dbs, [*]
	@IncludeExtendedLogicalChecks           bit                                     = 0,
    @OperatorName						    sysname									= N'Alerts',
	@MailProfileName					    sysname									= N'General',
	@EmailSubjectPrefix					    nvarchar(50)							= N'[Database Corruption Checks] ',	
    @PrintOnly                              bit                                     = 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
    IF @PrintOnly = 0 BEGIN 
        DECLARE @check int;

	    EXEC @check = dbo.verify_advanced_capabilities;
        IF @check <> 0
            RETURN @check;

        EXEC @check = dbo.verify_alerting_configuration
            @OperatorName, 
            @MailProfileName;

        IF @check <> 0 
            RETURN @check;
    END;

    DECLARE @DatabasesToCheck table ( 
        row_id int IDENTITY(1,1) NOT NULL,
        [database_name] sysname NOT NULL
    ); 

    INSERT INTO @DatabasesToCheck (
        [database_name]
    )
    EXEC dbo.[list_databases]
        @Targets = @Targets,
        @Exclusions = @Exclusions,
        @Priorities = @Priorities,
        @ExcludeClones = 1,
        @ExcludeSecondaries = 1,
        @ExcludeSimpleRecovery = 0,
        @ExcludeReadOnly = 0,
        @ExcludeRestoring = 1,
        @ExcludeRecovering = 1,
        @ExcludeOffline = 1;
    
    DECLARE @errorMessage nvarchar(MAX); 
	DECLARE @errors table ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL, 
		[results] xml NOT NULL, 
		[error_message] nvarchar(MAX) NULL
	);
	
	DECLARE @currentDbName sysname; 
    DECLARE @sql nvarchar(MAX);
    DECLARE @template nvarchar(MAX) = N'DBCC CHECKDB([{DbName}]) WITH NO_INFOMSGS, ALL_ERRORMSGS{ExtendedChecks};';
	DECLARE @succeeded int;

    IF @IncludeExtendedLogicalChecks = 1 
        SET @template = REPLACE(@template, N'{ExtendedChecks}', N', EXTENDED_LOGICAL_CHECKS');
    ELSE 
        SET @template = REPLACE(@template, N'{ExtendedChecks}', N'');


	DECLARE @outcome xml;
    DECLARE walker CURSOR LOCAL FAST_FORWARD FOR 
    SELECT 
        [database_name]
    FROM 
        @DatabasesToCheck
    ORDER BY 
        [row_id];

    OPEN [walker]; 
    FETCH NEXT FROM [walker] INTO @currentDbName;

    WHILE @@FETCH_STATUS = 0 BEGIN 

		SET @sql = REPLACE(@template, N'{DbName}', @currentDbName);

		EXEC @succeeded = dbo.[execute_command]
			@Command = @sql,
			@ExecutionType = N'SQLCMD',
			@ExecutionAttemptsCount = 1,
			@DelayBetweenAttempts = NULL,
			@IgnoredResults = N'{COMMAND_SUCCESS}',
			@PrintOnly = @PrintOnly,
			@Outcome = @outcome OUTPUT, 
			@ErrorMessage = @errorMessage OUTPUT;

		IF @succeeded <> 0 BEGIN 
			INSERT INTO @errors (
				[database_name],
				[results], 
				[error_message]
			)
			VALUES (
				@currentDbName, 
				@outcome,
				@errorMessage
			);
		END;

        FETCH NEXT FROM [walker] INTO @currentDbName;    
    END;

    CLOSE [walker];
    DEALLOCATE [walker];

	DECLARE @emailBody nvarchar(MAX);
	DECLARE @emailSubject nvarchar(300);

	IF EXISTS (SELECT NULL FROM @errors) BEGIN 
		DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
		DECLARE @tab nchar(1) = NCHAR(9);


		SET @emailSubject = ISNULL(@EmailSubjectPrefix, N'') + ' DATABASE CONSISTENCY CHECK ERRORS';
		SET @emailBody = N'The following problems were encountered: ' + @crlf; 

		SELECT 
			@emailBody = @emailBody + N'------------------------------------------------' + @crlf + N'DATABASE:' + @crlf + @tab + UPPER([database_name]) + @crlf + N'ERRORS: ' + @crlf + @tab + [error_message] + @crlf + N'XML EXECUTION DETAILS: ' + @crlf + @tab + CAST([results] AS nvarchar(MAX)) + @crlf + @crlf
		FROM 
			@errors 
		ORDER BY 
			[row_id];
	END;

	IF @emailBody IS NOT NULL BEGIN 

        EXEC msdb..sp_notify_operator
            @profile_name = @MailProfileName,
            @name = @OperatorName,
            @subject = @emailSubject, 
            @body = @emailBody;
	END; 
	
	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.clear_stale_jobsactivity','P') IS NOT NULL
	DROP PROC dbo.[clear_stale_jobsactivity];
GO

CREATE PROC dbo.[clear_stale_jobsactivity]
	@ThresholdVectorForStaleJobActivities		nvarchar(MAX)		= N'1 month',
	@MinimumSessionsToKeep						int					= 5
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	SET @ThresholdVectorForStaleJobActivities = ISNULL(NULLIF(@ThresholdVectorForStaleJobActivities, N''), N'1 month');
	
	DECLARE @retentionCutoff datetime;
	DECLARE @retentionError nvarchar(MAX);

	EXEC dbo.[translate_vector_datetime]
		@Vector = @ThresholdVectorForStaleJobActivities, 
		@Operation = N'SUBTRACT', 
		@ValidationParameterName = N'@ThresholdVectorForStaleJobActivities', 
		@ProhibitedIntervals = N'BACKUP', 
		@Output = @retentionCutoff OUTPUT, 
		@Error = @retentionError OUTPUT;

	IF @retentionError IS NOT NULL BEGIN 
		RAISERROR(@retentionError, 16, 1);
		RETURN -2;
	END;

	IF @MinimumSessionsToKeep > 0 BEGIN 
		
		DECLARE @minimumDate datetime; 
		
		WITH lastN AS ( 
			SELECT TOP (@MinimumSessionsToKeep) agent_start_date 
			FROM msdb.dbo.[syssessions] 
			ORDER BY [agent_start_date] DESC
		) 
		SELECT @minimumDate = (
			SELECT TOP (1) agent_start_date FROM [lastN] ORDER BY [lastN].[agent_start_date]
		);

		IF @minimumDate	< @retentionCutoff
			SET @retentionCutoff = @minimumDate;

	END;

	DECLARE @sessionId int; 
	SELECT @sessionId = MAX([session_id]) FROM [msdb].dbo.[syssessions] WHERE [agent_start_date] <= @retentionCutoff;

	DELETE FROM [msdb].dbo.[sysjobactivity] WHERE [session_id] < @sessionId;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_logfile_sizes','P') IS NOT NULL
	DROP PROC dbo.list_logfile_sizes;
GO

CREATE PROC dbo.list_logfile_sizes
	@TargetDatabases					nvarchar(MAX),															-- { {ALL} | {SYSTEM} | {USER} | name1,name2,etc }
	@DatabasesToExclude					nvarchar(MAX)							= NULL,							-- { NULL | name1,name2 }  
	@Priorities							nvarchar(MAX)							= NULL,
	@ExcludeSimpleRecoveryDatabases		bit										= 1,
	@SerializedOutput					xml										= N'<default/>'			OUTPUT
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Inputs:




	-----------------------------------------------------------------------------
	
	CREATE TABLE #targetDatabases ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL, 
		[vlf_count] int NULL, 
		[mimimum_allowable_log_size_gb] decimal(20,2) NULL
	);

	INSERT INTO [#targetDatabases] ([database_name])
	EXEC dbo.list_databases
		@Targets = @TargetDatabases, 
		@Exclusions = @DatabasesToExclude, 
		@Priorities = @Priorities, 
		@ExcludeSimpleRecovery = @ExcludeSimpleRecoveryDatabases;

	CREATE TABLE #logs (
		[row_id] int IDENTITY(1,1) NOT NULL,
		[database_name] sysname NOT NULL, 
		[recovery_model] sysname NOT NULL,
		[database_size_gb] decimal(20,2) NOT NULL, 
		[log_size_gb] decimal(20,2) NOT NULL, 
		[log_percent_used] decimal(20,2) NOT NULL,
		[vlf_count] int NOT NULL,
		[log_as_percent_of_db_size] decimal(20,2) NULL, 
		[mimimum_allowable_log_size_gb] decimal(20,2) NOT NULL 
	);
	
	IF NOT EXISTS (SELECT NULL FROM [#targetDatabases]) BEGIN 
		PRINT 'No databases matched @TargetDatbases (and @DatabasesToExclude) Inputs.'; 
		SELECT * FROM [#logs];
		RETURN 0; -- success (ish).
	END;

	DECLARE walker CURSOR LOCAL READ_ONLY FAST_FORWARD FOR 
	SELECT [database_name] FROM [#targetDatabases];

	DECLARE @currentDBName sysname; 
	DECLARE @vlfCount int; 
	DECLARE @startOffset bigint;
	DECLARE @fileSize bigint;
	DECLARE @MinAllowableSize decimal(20,2);

	DECLARE @template nvarchar(1000) = N'INSERT INTO #logInfo EXECUTE (''DBCC LOGINFO([{0}]) WITH NO_INFOMSGS''); ';
	DECLARE @command nvarchar(2000);

	CREATE TABLE #logInfo (
		RecoveryUnitId bigint,
		FileID bigint,
		FileSize bigint,
		StartOffset bigint,
		FSeqNo bigint,
		[Status] bigint,
		Parity bigint,
		CreateLSN varchar(50)
	);

	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @currentDBName;

	WHILE @@FETCH_STATUS = 0 BEGIN 
		
		DELETE FROM [#logInfo];
		SET @command = REPLACE(@template, N'{0}', @currentDBName); 

		EXEC master.sys.[sp_executesql] @command;
		SELECT @vlfCount = COUNT(*) FROM [#logInfo];

		SELECT @startOffset = MAX(StartOffset) FROM #LogInfo WHERE [Status] = 2;
		SELECT @fileSize = FileSize FROM #LogInfo WHERE StartOffset = @startOffset;
		SET @MinAllowableSize = CAST(((@startOffset + @fileSize) / (1024.0 * 1024.0 * 1024.0)) AS decimal(20,2))

		UPDATE [#targetDatabases] 
		SET 
			[vlf_count] = @vlfCount, 
			[mimimum_allowable_log_size_gb] = @MinAllowableSize 
		WHERE 
			[database_name] = @currentDBName;

		FETCH NEXT FROM [walker] INTO @currentDBName;
	END;
	
	CLOSE [walker];
	DEALLOCATE [walker];

	WITH core AS ( 
		SELECT
			x.[row_id],
			db.[name] [database_name], 
			db.recovery_model_desc [recovery_model],	
			CAST((CONVERT(decimal(20,2), sizes.size * 8.0 / (1024.0) / (1024.0))) AS decimal(20,2)) database_size_gb,
			CAST((logsize.log_size / (1024.0)) AS decimal(20,2)) [log_size_gb],
			CASE 
				WHEN logsize.log_size = 0 THEN 0.0
				WHEN logused.log_used = 0 THEN 0.0
				ELSE CAST(((logused.log_used / logsize.log_size) * 100.0) AS decimal(12,2))
			END log_percent_used, 
			x.[vlf_count], 
			x.[mimimum_allowable_log_size_gb]
		FROM 
			sys.databases db
			INNER JOIN #targetDatabases x ON db.[name] = x.[database_name]
			LEFT OUTER JOIN (SELECT instance_name [db_name], CAST((cntr_value / (1024.0)) AS decimal(20,2)) [log_size] FROM sys.dm_os_performance_counters WHERE counter_name LIKE 'Log File(s) Size %') logsize ON db.[name] = logsize.[db_name]
			LEFT OUTER JOIN (SELECT instance_name [db_name], CAST((cntr_value / (1024.0)) AS decimal(20,2)) [log_used] FROM sys.dm_os_performance_counters WHERE counter_name LIKE 'Log File(s) Used %') logused ON db.[name] = logused.[db_name]
			LEFT OUTER JOIN (
				SELECT	database_id, SUM(size) size, COUNT(database_id) [Files] FROM sys.master_files WHERE [type] = 0 GROUP BY database_id
			) sizes ON db.database_id = sizes.database_id		
	) 

	INSERT INTO [#logs] (
        [database_name], 
        [recovery_model], 
        [database_size_gb], 
        [log_size_gb], 
        [log_percent_used], 
		[vlf_count],
		[log_as_percent_of_db_size], 
		[mimimum_allowable_log_size_gb] 
    )
	SELECT 
        [database_name],
        [recovery_model],
        [database_size_gb],
        [log_size_gb],
        [log_percent_used], 
		[vlf_count],
		CAST(((([log_size_gb] / (CASE WHEN [database_size_gb] = 0 THEN CAST(0.01 AS decimal(20,2)) ELSE CAST([core].[database_size_gb] AS decimal(20,2)) END)) * 100.0)) AS decimal(20,2)) [log_as_percent_of_db_size],		-- goofy issue with divide by zero is reason for CASE... 
		[mimimum_allowable_log_size_gb]
	FROM 
		[core]
	ORDER BY 
		[row_id];
	
	-----------------------------------------------------------------------------
    -- Send output as XML if requested:
	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- if @SerializedOutput has been EXPLICITLY initialized as NULL/empty... then REPLY...
		SELECT @SerializedOutput = (SELECT 
			[database_name],
			[recovery_model],
			[database_size_gb],
			[log_size_gb],
			[log_percent_used],
			[vlf_count],  -- 160x
			[log_as_percent_of_db_size], 
			[mimimum_allowable_log_size_gb] 
		FROM 
			[#logs]
		ORDER BY 
			[row_id] 
		FOR XML PATH('database'), ROOT('databases'));

		RETURN 0;
	END; 

	-----------------------------------------------------------------------------
	-- otherwise, project:
	SELECT 
        [database_name],
        [recovery_model],
        [database_size_gb],
        [log_size_gb],
        [log_percent_used],
		[vlf_count],  -- 180x
		[log_as_percent_of_db_size], 
		[mimimum_allowable_log_size_gb] 
	FROM 
		[#logs]
	ORDER BY 
		[row_id];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.shrink_logfiles','P') IS NOT NULL
	DROP PROC dbo.shrink_logfiles;
GO

CREATE PROC dbo.shrink_logfiles
	@TargetDatabases							nvarchar(MAX),																		-- { {ALL} | {SYSTEM} | {USER} | name1,name2,etc }
	@DatabasesToExclude							nvarchar(MAX)							= NULL,										-- { NULL | name1,name2 }  
	@Priorities									nvarchar(MAX)							= NULL,										
	@TargetLogPercentageSize					int										= 20,										-- can be > 100? i.e., 200? would be 200% - which ... i guess is legit, right? 
	@ExcludeSimpleRecoveryDatabases				bit										= 1,										
	@IgnoreLogFilesSmallerThanGBs				decimal(5,2)							= 0.25,										-- e.g., don't bother shrinking anything > 200MB in size... 								
	@LogFileSizingBufferInGBs					decimal(5,2)							= 0.25,										-- a) when targetting a log for DBCC SHRINKFILE() add this into the target and b) when checking on dbs POST shrink, if they're under target + this Buffer, they're FINE/done/shrunk/ignored.
	@MaxTimeToWaitForLogBackups					sysname									= N'20m',		
	@LogBackupCheckPollingInterval				sysname									= N'40s',									-- Interval that defines how long to wait between 'polling' attempts to look for new T-LOG backups... 
	@OperatorName								sysname									= N'Alerts',
	@MailProfileName							sysname									= N'General',
	@EmailSubjectPrefix							nvarchar(50)							= N'[Log Shrink Operations ] ',
	@PrintOnly									bit										= 0
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	-- Validate Dependencies:
	EXEC dbo.verify_advanced_capabilities;	

	-----------------------------------------------------------------------------
	-- Validate Inputs:

	DECLARE @maxSecondsToWaitForLogFileBackups int; 
	DECLARE @error nvarchar(MAX);
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	EXEC dbo.[translate_vector]
	    @Vector = @MaxTimeToWaitForLogBackups,
	    @ValidationParameterName = N'@MaxTimeToWaitForLogBackups',
		@ProhibitedIntervals = N'MILLISECOND, DAY, WEEK, MONTH, QUARTER, YEAR',
	    @TranslationDatePart = N'SECOND',
	    @Output = @maxSecondsToWaitForLogFileBackups OUTPUT,
	    @Error = @error OUTPUT;
	
	IF @error IS NOT NULL BEGIN 
		RAISERROR(@error, 16, 1); 
		RETURN -10;
	END; 

	DECLARE @waitDuration sysname;
	EXEC dbo.[translate_vector_delay]
	    @Vector = @LogBackupCheckPollingInterval,
	    @ParameterName = N'@LogBackupCheckPollingInterval',
	    @Output = @waitDuration OUTPUT,
	    @Error = @error OUTPUT;
	
	IF @error IS NOT NULL BEGIN 
		RAISERROR(@error, 16, 1); 
		RETURN -11;
	END; 

	-----------------------------------------------------------------------------
	-- Processing: 
	DECLARE @targetRatio decimal(6,2) = @TargetLogPercentageSize / 100.0;
	DECLARE @BufferMBs int = CAST((@LogFileSizingBufferInGBs * 1024.0) AS int);  

	-- get a list of dbs to target/review: 
	CREATE TABLE #logSizes (
		[row_id] int IDENTITY(1,1) NOT NULL,
		[database_name] sysname NOT NULL, 
		[recovery_model] sysname NOT NULL,
		[database_size_gb] decimal(20,2) NOT NULL, 
		[log_size_gb] decimal(20,2) NOT NULL, 
		[log_percent_used] decimal(5,2) NOT NULL,
		[initial_min_allowed_gbs] decimal(20,2) NOT NULL, 
		[target_log_size] decimal(20,2) NOT NULL, 
		[operation] sysname NULL, 
		[last_log_backup] datetime NULL, 
		[processing_complete] bit NOT NULL DEFAULT (0)
	);

	CREATE TABLE #operations (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL, 
		[timestamp] datetime NOT NULL DEFAULT(GETDATE()), 
		[operation] nvarchar(2000) NOT NULL, 
		[outcome] nvarchar(MAX) NOT NULL, 
	);

	DECLARE @SerializedOutput xml = NULL;
	EXEC dbo.[list_logfile_sizes]
	    @TargetDatabases = @TargetDatabases,
	    @DatabasesToExclude = @DatabasesToExclude,
	    @Priorities = @Priorities,
	    @ExcludeSimpleRecoveryDatabases = @ExcludeSimpleRecoveryDatabases,
	    @SerializedOutput = @SerializedOutput OUTPUT;
	
	WITH shredded AS ( 
		SELECT 
			[data].[row].value('database_name[1]', 'sysname') [database_name], 
			[data].[row].value('recovery_model[1]', 'sysname') recovery_model, 
			[data].[row].value('database_size_gb[1]', 'decimal(20,1)') database_size_gb, 
			[data].[row].value('log_size_gb[1]', 'decimal(20,1)') log_size_gb,
			[data].[row].value('log_percent_used[1]', 'decimal(5,2)') log_percent_used, 
			[data].[row].value('vlf_count[1]', 'int') vlf_count,
			[data].[row].value('log_as_percent_of_db_size[1]', 'decimal(5,2)') log_as_percent_of_db_size,
			[data].[row].value('mimimum_allowable_log_size_gb[1]', 'decimal(20,1)') [initial_min_allowed_gbs]
		FROM 
			@SerializedOutput.nodes('//database') [data]([row])
	), 
	targets AS ( 
		SELECT
			[database_name],
			CAST(([shredded].[database_size_gb] * @targetRatio) AS decimal(20,2)) [target_log_size] 
		FROM 
			[shredded]
	) 
	
	INSERT INTO [#logSizes] (
        [database_name], 
        [recovery_model], 
        [database_size_gb], 
        [log_size_gb], 
        [log_percent_used], 
        [initial_min_allowed_gbs], 
        [target_log_size]
    )
	SELECT 
		[s].[database_name],
        [s].[recovery_model],
        [s].[database_size_gb],
        [s].[log_size_gb],
        [s].[log_percent_used],
        [s].[initial_min_allowed_gbs], 
		CAST((CASE WHEN t.[target_log_size] < @IgnoreLogFilesSmallerThanGBs THEN @IgnoreLogFilesSmallerThanGBs ELSE t.[target_log_size] END) AS decimal(20,2)) [target_log_size]
	FROM 
		[shredded] s 
		INNER JOIN [targets] t ON [s].[database_name] = [t].[database_name];

	WITH operations AS ( 
		SELECT 
			[database_name], 
			CASE 
				WHEN [log_size_gb] <= [target_log_size] THEN 'NOTHING' -- N'N/A - Log file is already at target size or smaller. (Current Size: ' + CAST([log_size_gb] AS sysname) + N' GB - Target Size: ' + CAST([target_log_size] AS sysname) + N' GB)'
				ELSE CASE 
					WHEN ([initial_min_allowed_gbs] > ([target_log_size] + @LogFileSizingBufferInGBs)) OR ([recovery_model] = N'SIMPLE') THEN 'SHRINK'
					ELSE N'CHECKPOINT + BACKUP + SHRINK'
				END
			END [operation]
		FROM 
			[#logSizes]
	) 

	UPDATE x 
	SET 
		x.[operation] = o.[operation]
	FROM 
		[#logSizes] x 
		INNER JOIN [operations] o ON [x].[database_name] = [o].[database_name];

	IF EXISTS (SELECT NULL FROM [#logSizes] WHERE [operation] = N'NOTHING') BEGIN 
		INSERT INTO [#operations] ([database_name], [operation], [outcome])
		SELECT 
			[database_name],
			N'NOTHING. Log file is already at target size or smaller. (Current Size: ' + CAST([log_size_gb] AS sysname) + N' GB - Target Size: ' + CAST([target_log_size] AS sysname) + N' GB)' [operation],
			N'' [outcome]
		FROM 
			[#logSizes] 
		WHERE 
			[operation] = N'NOTHING'
		ORDER BY 
			[row_id];

		UPDATE [#logSizes] 
		SET 
			[processing_complete] = 1
		WHERE 
			[operation] = N'NOTHING';
	END;


	DECLARE @returnValue int;
	DECLARE @outcome nvarchar(MAX);
	DECLARE @currentDatabase sysname;
	DECLARE @targetSize int;
	DECLARE @command nvarchar(2000); 
	DECLARE @executionResults xml;
	DECLARE @commandResultsErrorMessage nvarchar(MAX) = NULL;

	DECLARE @checkpointComplete datetime; 
	DECLARE @waitStarted datetime;
	IF EXISTS (SELECT NULL FROM [#logSizes] WHERE [operation] = N'CHECKPOINT + BACKUP + SHRINK') BEGIN 
		
		-- start by grabbing the latest backups: 
		UPDATE [ls]
		SET 
			ls.[last_log_backup] = x.[backup_finish_date]
		FROM 
			[#logSizes] ls
			INNER JOIN ( 
				SELECT
					[database_name],
					MAX([backup_finish_date]) [backup_finish_date]
				FROM 
					msdb.dbo.[backupset]
				WHERE 
					[type] = 'L'
				GROUP BY 
					[database_name]
			) x ON [ls].[database_name] = [x].[database_name]
		WHERE 
			ls.[processing_complete] = 0 AND ls.[operation] = N'CHECKPOINT + BACKUP + SHRINK';

		DECLARE @checkpointTemplate nvarchar(200) = N'USE [{0}]; ' + @crlf + N'CHECKPOINT; ' + @crlf + N'CHECKPOINT;' + @crlf + N'CHECKPOINT;';
		DECLARE walker CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[database_name]
		FROM 
			[#logSizes] 
		WHERE 
			[processing_complete] = 0 AND [operation] = N'CHECKPOINT + BACKUP + SHRINK';

		OPEN walker; 
		FETCH NEXT FROM walker INTO @currentDatabase;

		WHILE @@FETCH_STATUS = 0 BEGIN

			SET @command = REPLACE(@checkpointTemplate, N'{0}', @currentDatabase);

			IF @PrintOnly = 1 
				PRINT @command;
			ELSE BEGIN 
			
				EXEC @returnValue = dbo.[execute_command]
					@Command = @command,
					@ExecutionType = N'SQLCMD',
					@ExecutionAttemptsCount = 1, 
					@DelayBetweenAttempts = N'5s',
					@Outcome = @executionResults OUTPUT, 
					@ErrorMessage = @commandResultsErrorMessage OUTPUT;
			
				IF @returnValue = 0	BEGIN
					SET @outcome = N'SUCCESS';
				  END;
				ELSE BEGIN
					SET @outcome = N'ERROR: ' + @commandResultsErrorMessage;
				END;

				SET @checkpointComplete = GETDATE();

				INSERT INTO [#operations] ([database_name], [timestamp], [operation], [outcome])
				VALUES (@currentDatabase, @checkpointComplete, @command, @outcome);

				IF @returnValue <> 0 BEGIN
					-- we needed a checkpoint before we could go any further... it didn't work (somhow... not even sure that's a possibility)... so, we're 'done'. we need to terminate early.
					PRINT 'run an update where operation = checkpoint/backup/shrink and set those pigs to done with an ''early termination'' summary as the operation... we can keep trying other dbs... ';
				END;

			END;

			FETCH NEXT FROM walker INTO @currentDatabase;
		END;

		CLOSE walker;
		DEALLOCATE walker;

		SET @waitStarted = GETDATE();
WaitAndCheck:
		
		IF @PrintOnly = 1 BEGIN 
			SET @command = N'';
			SELECT @command = @command + [database_name] + N', ' FROM [#logSizes] WHERE [operation] = N'CHECKPOINT + BACKUP + SHRINK';
			
			PRINT N'-- NOTE: LogFileBackups of the following databases are required before processing can continue: '
			PRINT N'--		' + LEFT(@command, LEN(@command) - 1);

			GOTO ShrinkLogFile;
		END;

		WAITFOR DELAY @waitDuration;  -- Wait, then poll for new T-LOG backups:
-- TODO: arguably... i could keep track of the # of dbs we're waiting on ... and, each time we detect that a new DB has been T-log backed up... i could 'GOTO ShrinkDBs;' and then... if there are any dbs to process (at the end of that block of logic (i.e., @dbsWaitingOn > 0) then... GOTO WaitAndStuff;.. and, then, just tweak the way we do the final error/check - as in, if we've waited too long and stil have dbs to process, then.. we log the error message and 'goto' some other location (the end).
--			that way, say we've got t-logs cycling at roughly 2-3 minute intervals over the next N minutes... ... currently, if we're going to wait up to 20 minutes, we'll wait until ALL of them have been be backed up (or as many as we could get to before we timed out) and then PROCESS ALL of them. 
--				the logic above would, effectively, process each db _AS_ its t-log backup was completed... making it a bit more 'robust' and better ... 
		-- keep looping/waiting while a) we have time left, and b) there are dbs that have NOT been backed up.... 
		IF DATEDIFF(SECOND, @waitStarted, GETDATE()) < @maxSecondsToWaitForLogFileBackups BEGIN 
			IF EXISTS (SELECT NULL FROM [#logSizes] ls 
				INNER JOIN (SELECT [database_name], MAX([backup_finish_date]) latest FROM msdb.dbo.[backupset] WHERE type = 'L' GROUP BY [database_name]) x ON ls.[database_name] = [x].[database_name] 
				WHERE ls.[last_log_backup] IS NOT NULL AND x.[latest] < @checkpointComplete
			) BEGIN
					GOTO WaitAndCheck;
			END;
		END;

		-- done waiting - either we've now got T-LOG backups for all DBs, or we hit our max wait time: 
		INSERT INTO [#operations] ([database_name], [operation], [outcome])
		SELECT 
			ls.[database_name], 
			N'TIMEOUT' [operation], 
			N'Max Wait Time of (N) reached - last t-log backup of x was found (vs t-log backup > checkpoint date that was needed. SHRINKFILE won''t work.. ' [outcome]
		FROM 
			[#logSizes] ls 
			INNER JOIN ( 
				SELECT
					[database_name],
					MAX([backup_finish_date]) [backup_finish_date]
				FROM 
					msdb.dbo.[backupset]
				WHERE 
					[type] = 'L'
				GROUP BY 
					[database_name]
			) x ON [ls].[database_name] = [x].[database_name] 
		WHERE 
			ls.[operation] = N'CHECKPOINT + BACKUP + SHRINK'
			AND x.[backup_finish_date] < @checkpointComplete;
		
	END;


ShrinkLogFile:
	IF EXISTS (SELECT NULL FROM [#logSizes] WHERE ([operation] = N'SHRINK') OR ([operation] = N'CHECKPOINT + BACKUP + SHRINK')) BEGIN 
		
		DECLARE @minLogFileSize int = CAST((@IgnoreLogFilesSmallerThanGBs * 1024.0) as int);
		DECLARE shrinker CURSOR LOCAL READ_ONLY FAST_FORWARD FOR 
		SELECT [database_name], (CAST(([target_log_size] * 1024.0) AS int) - @BufferMBs) [target_log_size] FROM [#logSizes] WHERE [processing_complete] = 0 AND ([operation] = N'SHRINK') OR ([operation] = N'CHECKPOINT + BACKUP + SHRINK');

		OPEN [shrinker]; 
		FETCH NEXT FROM [shrinker] INTO @currentDatabase, @targetSize;

		WHILE @@FETCH_STATUS = 0 BEGIN

			BEGIN TRY 

				IF @targetSize < @minLogFileSize
					SET @targetSize = @minLogFileSize;

				SET @command = N'USE [{database}];' + @crlf + N'DBCC SHRINKFILE(2, {size}) WITH NO_INFOMSGS;';
				SET @command = REPLACE(@command, N'{database}', @currentDatabase);
				SET @command = REPLACE(@command, N'{size}', @targetSize);

				IF @PrintOnly = 1 BEGIN
					PRINT @command; 
					SET @outcome = N'';
				  END;
				ELSE BEGIN
					
					SET @commandResultsErrorMessage = NULL;
					EXEC @returnValue = dbo.[execute_command]
					    @Command = @command, 
					    @ExecutionType = N'SQLCMD', 
					    @IgnoredResults = N'[COMMAND_SUCCESS],[USE_DB_SUCCESS]', 
					    @Outcome = @executionResults OUTPUT, 
						@ErrorMessage = @commandResultsErrorMessage OUTPUT;
					
					IF @returnValue = 0
						SET @outcome = N'SUCCESS';	
					ELSE 
						SET @outcome = N'ERROR: ' + @commandResultsErrorMessage;
				END;
				
			END TRY 
			BEGIN CATCH 
				SET @outcome = N'EXCEPTION: ' + CAST(ERROR_LINE() AS sysname ) + N' - ' + ERROR_MESSAGE();
			END	CATCH

			INSERT INTO [#operations] ([database_name], [operation], [outcome])
			VALUES (@currentDatabase, @command, @outcome);

			FETCH NEXT FROM [shrinker] INTO @currentDatabase, @targetSize;
		END;

		CLOSE shrinker;
		DEALLOCATE [shrinker];

	END; 



	-- TODO: final operation... 
	--   a) go get a new 'logFileSizes' report... 
	--	b) report on any t-logs that are still > target... 

	-- otherwise... spit out whatever form of output/report would make sense at this point... where... we can bind #operations up as XML ... as a set of details about what happened here... 

	SET @SerializedOutput = NULL;
	EXEC dbo.[list_logfile_sizes]
	    @TargetDatabases = @TargetDatabases,
	    @DatabasesToExclude = @DatabasesToExclude,
	    @Priorities = @Priorities,
	    @ExcludeSimpleRecoveryDatabases = @ExcludeSimpleRecoveryDatabases,
	    @SerializedOutput = @SerializedOutput OUTPUT;

	WITH shredded AS ( 
		SELECT 
			[data].[row].value('database_name[1]', 'sysname') [database_name], 
			[data].[row].value('recovery_model[1]', 'sysname') recovery_model, 
			[data].[row].value('database_size_gb[1]', 'decimal(20,2)') database_size_gb, 
			[data].[row].value('log_size_gb[1]', 'decimal(20,2)') log_size_gb,
			[data].[row].value('log_percent_used[1]', 'decimal(5,2)') log_percent_used, 
			--[data].[row].value('vlf_count[1]', 'int') vlf_count,
			--[data].[row].value('log_as_percent_of_db_size[1]', 'decimal(5,2)') log_as_percent_of_db_size,
			[data].[row].value('mimimum_allowable_log_size_gb[1]', 'decimal(20,1)') [initial_min_allowed_gbs]
		FROM 
			@SerializedOutput.nodes('//database') [data]([row])
	)

	SELECT 
		[origin].[database_name], 
		[origin].[database_size_gb], 
		[origin].[log_size_gb] [original_log_size_gb], 
		[origin].[target_log_size], 
		x.[log_size_gb] [current_log_size_gb], 
		CASE WHEN (x.[log_size_gb] - @LogFileSizingBufferInGBs) <= [origin].[target_log_size] THEN 'SUCCESS' ELSE 'FAILURE' END [shrink_outcome], 
		CAST((
			SELECT  
				[row_id] [operation/@id],
				[timestamp] [operation/@timestamp],
				[operation],
				[outcome]		
			FROM 
				[#operations] o 
			WHERE 
				o.[database_name] = x.[database_name]
			ORDER BY 
				[o].[row_id]
			FOR XML PATH('operation'), ROOT('operations')) AS xml) [xml_operations]		
	FROM 
		[shredded] x 
		INNER JOIN [#logSizes] origin ON [x].[database_name] = [origin].[database_name]
	ORDER BY 
		[origin].[row_id];

	-- TODO: send email alerts based on outcomes above (specifically, pass/fail and such).

	-- in terms of output: 
	--		want to see those that PASSED and those that FAILED> 
	--			also? I'd like to see a summary of how much disk was reclaimed ... and how much stands to be reclaimed if/when we fix the 'FAILURE' outcomes. 
	--				so, in other words, some sort of header... 
	--		and... need the output sorted by a) failures first, then successes, b) row_id... (that way... it's clear which ones passed/failed). 
	--		

	--	also... MIGHT want to look at removing the WITH NO_INFOMSGS switch from the DBCC SHRINKFILE operations... 
	--			cuz.. i'd like to collect/gather the friggin errors - they seem to consistently keep coming back wiht 'end of file' crap - which is odd, given that I'm running checkpoint up the wazoo. 

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Additional Utilities
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[normalize_text]', 'P') IS NOT NULL 
	DROP PROC dbo.[normalize_text];
GO

CREATE PROC dbo.[normalize_text]
	@InputStatement			nvarchar(MAX)		= NULL, 
	@NormalizedOutput		nvarchar(MAX)		OUTPUT, 
	@ParametersOutput		nvarchar(MAX)		OUTPUT, 
	@ErrorInfo				nvarchar(MAX)		OUTPUT
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-- effectively, just putting a wrapper around sp_get_query_template - to account for the scenarios/situations where it throws an error or has problems.

	/*
		Problem Scenarios: 
			a. multi-statement batches... 
					b. requires current/accurate schema  - meaning that it HAS to be run (effectively) in the same db as where the statement was defined... (or a close enough proxy). 
						ACTUALLY, i think this might have been a limitation of the SQL Server 2005 version - pretty sure it doesn't cause problems (at all) on 2016 (and... likely 2008+)... 

					YEAH, this is NO longer valid... 
					specifically, note the 2x remarks/limitations listed in the docs (for what throws an error): 
						https://docs.microsoft.com/en-us/sql/relational-databases/system-stored-procedures/sp-get-query-template-transact-sql?view=sql-server-2017


			c. statements without any parameters - i.e., those without a WHERE clause... 

			d. implied: sprocs or other EXEC operations (or so I'd 100% expect). 
				CORRECT - as per this 'example': 

						DECLARE @normalized nvarchar(max), @params nvarchar(max); 
						EXEC sp_get_query_template    
							N'EXEC Billing.dbo.AddDayOff N''2018-11-13'', ''te3st day'';', 
							@normalized OUTPUT, 
							@params OUTPUT; 

						SELECT @normalized, @params;

				totally throws an excption - as expected... 



		So, just account for those concerns and provide fixes/work-arounds/hacks for all of those... 
			
	
	*/

	SET @InputStatement = ISNULL(LTRIM(RTRIM(@InputStatement)), '');
	DECLARE @multiStatement bit = 0;
	DECLARE @noParams bit = 0; 
	DECLARE @isExec bit = 0; 

	-- check for multi-statement batches (using SIMPLE/BASIC batch scheme checks - i.e., NOT worth getting carried away on all POTENTIAL permutations of how this could work). 
	IF (@InputStatement LIKE N'% GO %') OR (@InputStatement LIKE N';' AND @InputStatement NOT LIKE N'%sp_executesql%;%') 
		SET @multiStatement = 1; 

	-- TODO: if it's multi-statement, then 'split' on the terminator, parameterize the first statement, then the next, and so on... then 'chain' those together... as the output. 
	--		well, make this an option/switch... (i.e., an input parameter).

	-- again, looking for BASIC (non edge-case) confirmations here: 
	IF @InputStatement NOT LIKE N'%WHERE%' 
		SET @noParams = 1; 
	
	IF (@InputStatement LIKE N'Proc [Database%') OR (@InputStatement LIKE 'EXEC%') 
		SET @isExec = 1; 

	-- damn... this (exclusion logic) might be one of the smartest things i've done in a while... (here's hoping that it WORKS)... 
	IF COALESCE(@multiStatement, @noParams, @isExec, 0) = 0 BEGIN 
		
		DECLARE @errorMessage nvarchar(MAX);

		BEGIN TRY 
			SET @NormalizedOutput = NULL; 
			SET @ParametersOutput = NULL;
			SET @ErrorInfo = NULL;

			EXEC sp_get_query_template
				@InputStatement, 
				@NormalizedOutput OUTPUT, 
				@ParametersOutput OUTPUT;

		END TRY 
		BEGIN CATCH 
			
			SELECT @errorMessage = N'Error Number: ' + CAST(ERROR_NUMBER() AS nvarchar(30)) + N'. Message: ' + ERROR_MESSAGE();
			SELECT @NormalizedOutput = @InputStatement, @ErrorInfo = @errorMessage;
		END CATCH

	END; 

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.extract_statement','P') IS NOT NULL
	DROP PROC dbo.extract_statement;
GO

CREATE PROC dbo.extract_statement
	@TargetDatabase					sysname, 
	@ObjectID						int, 
	@OffsetStart					int, 
	@OffsetEnd						int, 
	@Statement						nvarchar(MAX)		OUTPUT
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @sql nvarchar(2000) = N'
SELECT 
	@Statement = SUBSTRING([definition], (@offsetStart / 2) + 1, (CASE WHEN @offsetEnd < 1 THEN DATALENGTH([definition]) ELSE (@offsetEnd - @offsetStart)/2 END) + 1) 
FROM 
	[{TargetDatabase}].sys.[sql_modules] 
WHERE 
	[object_id] = @ObjectID; ';

	SET @sql = REPLACE(@sql, N'{TargetDatabase}', @TargetDatabase);

	EXEC sys.[sp_executesql] 
		@sql, 
		N'@ObjectID int, @OffsetStart int, @OffsetEnd int, @Statement nvarchar(MAX) OUTPUT', 
		@ObjectID = @ObjectID, 
		@OffsetStart = @OffsetStart, 
		@OffsetEnd = @OffsetEnd, 
		@Statement = @Statement OUTPUT; 

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.extract_code_lines','P') IS NOT NULL
	DROP PROC dbo.[extract_code_lines];
GO

CREATE PROC dbo.[extract_code_lines]
	@TargetModule					sysname, 
	@TargetLine						int, 
	@BeforeAndAfterLines			int		= 10
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @TargetModule = NULLIF(@TargetModule, N'');
	SET @TargetLine = ISNULL(@TargetLine, -1);
	SET @BeforeAndAfterLines = ISNULL(@BeforeAndAfterLines, 8);	

	IF @TargetModule IS  NULL BEGIN 
		RAISERROR('Please specify the name of the module (sproc, trigger, udf) to extract code from as @TargetModule.', 16, 1);
		RETURN -1;
	END;

	IF @TargetLine < 1 BEGIN 
		RAISERROR('Please specify a value for @TargetLine.', 16, 1);
		RETURN -2;
	END;

	DECLARE @targetDatabase sysname, @targetSchema sysname, @targetObjectName sysname;
	SELECT 
		@targetDatabase = PARSENAME(@TargetModule, 3), 
		@targetSchema = ISNULL(PARSENAME(@TargetModule, 2), N'dbo'), 
		@targetObjectName = PARSENAME(@TargetModule, 1);
	
	IF @targetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @targetDatabase OUTPUT;
		
		IF @targetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified for %s and/or S4 was unable to determine calling-db-context. Please use dbname.schemaname.objectname qualified names.', 16, 1, N'@TargetTable');
			RETURN -5;
		END;
	END;

	DECLARE @fullName sysname = QUOTENAME(@targetDatabase) + N'.' + QUOTENAME(@targetSchema) + N'.' + QUOTENAME(@targetObjectName);

	DECLARE @body nvarchar(MAX); 
	DECLARE @sql nvarchar(MAX); 

	SET @sql = N'SELECT @body = [definition] FROM [{database}].sys.[sql_modules] WHERE [object_id] = OBJECT_ID(N''{fqn}''); ';

	SET @sql = REPLACE(@sql, N'{database}', @targetDatabase);
	SET @sql = REPLACE(@sql, N'{fqn}', @fullName);

	EXEC sys.[sp_executesql]
		@sql, 
		N'@body nvarchar(MAX) OUTPUT', 
		@body = @body OUTPUT;

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	SELECT 
		[row_id],
		[result]
	INTO 
		#lines
	FROM 
		dbo.[split_string](@body, @crlf, 0)
	ORDER BY 
		row_id;

	DECLARE @lineCount int; 
	SELECT @lineCount = (SELECT COUNT(*) FROM [#lines]);

	DECLARE @startLine int = @TargetLine - @BeforeAndAfterLines;
	DECLARE @endLine int = @TargetLine + @BeforeAndAfterLines;

	IF @startLine < 0 SET @startLine = 0;
	IF @endLine > @lineCount SET @endLine = @lineCount;

	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @output nvarchar(MAX) = N'';
	DECLARE @padding varchar(4) = REPLICATE(N' ', LEN(@TargetLine + @BeforeAndAfterLines));

	SELECT 
		@output = @output + CASE WHEN [row_id] = @TargetLine THEN N'--> ' ELSE @tab END + + RIGHT(@padding + CAST(row_id AS sysname), LEN(@TargetLine + @BeforeAndAfterLines)) + @tab + [result] + @crlf
	FROM 
		[#lines]
	WHERE 
		row_id >= @startLine 
		AND 
		row_id <= @endLine
	ORDER BY 
		row_id;

	EXEC dbo.[print_long_string] @output;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[extract_dynamic_code_lines]','P') IS NOT NULL
	DROP PROC dbo.[extract_dynamic_code_lines];
GO

CREATE PROC dbo.[extract_dynamic_code_lines]
	@DynamicCode				nvarchar(MAX), 
	@TargetLine					int, 
	@BeforeAndAfterLines		int			= 6
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @DynamicCode = NULLIF(@DynamicCode, N'');

	IF @DynamicCode IS NULL BEGIN 
		PRINT 'empty';
	END;

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	SELECT 
		[row_id],
		[result]
	INTO 
		#lines
	FROM 
		dbo.[split_string](@DynamicCode, @crlf, 0)
	ORDER BY 
		row_id;

	DECLARE @lineCount int; 
	SELECT @lineCount = (SELECT COUNT(*) FROM [#lines]);

	DECLARE @startLine int = @TargetLine - @BeforeAndAfterLines;
	DECLARE @endLine int = @TargetLine + @BeforeAndAfterLines;

	IF @startLine < 0 SET @startLine = 0;
	IF @endLine > @lineCount SET @endLine = @lineCount;

	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @output nvarchar(MAX) = N'';

	SELECT 
		@output = @output + CASE WHEN [row_id] = @TargetLine THEN N'--> ' ELSE @tab + N'' END + + CAST(row_id AS sysname) + @tab + [result] + @crlf
	FROM 
		[#lines]
	WHERE 
		row_id >= @startLine 
		AND 
		row_id <= @endLine
	ORDER BY 
		row_id;

	PRINT N'/* ';
	PRINT N'';
	
	EXEC dbo.[print_long_string] @output;

	PRINT N'';
	PRINT N'*/';

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.is_xml_empty','FN') IS NOT NULL
	DROP FUNCTION dbo.[is_xml_empty];
GO

CREATE FUNCTION dbo.[is_xml_empty] (@input xml)
RETURNS bit
	--WITH RETURNS NULL ON NULL INPUT  -- note, this WORKS ... but... uh, busts functionality cuz we don't want NULL if empty, we want 1... 
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
    	DECLARE @output bit = 0;

        IF @input IS NULL   
            SET @output = 1;
    	
        IF DATALENGTH(@input) <= 5
    	    SET @output = 1;
    	
    	RETURN @output;
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.refresh_code','P') IS NOT NULL
	DROP PROC dbo.[refresh_code];
GO

CREATE PROC dbo.[refresh_code]
	@Mode						sysname			= N'VIEWS_AND_MODULES',				-- { VIEWS_AND_MODULES | VIEWS | MODULES }
	@TargetDatabase				sysname			= NULL, 
	@PrintOnly					bit				= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @Mode = ISNULL(NULLIF(@Mode, N''), N'VIEWS_AND_MODULES');

	IF UPPER(@Mode) NOT IN (N'VIEWS_AND_MODULES', N'VIEWS', N'MODULES') BEGIN 
		RAISERROR(N'Invalid value specified for @Mode. Acceptable values are { VIEWS_AND_MODULES | VIEWS | MODULES }.', 16, 1);
		RETURN -1;
	END;

	-- establish database (if null) and/or verify that @Target database exists. 
	IF @TargetDatabase IS NULL BEGIN 
		EXEC dbo.[get_executing_dbname] @ExecutingDBName = @TargetDatabase OUTPUT;
		
		IF @TargetDatabase IS NULL BEGIN 
			RAISERROR('Invalid Database-Name specified and/or S4 was unable to determine calling-db-context. ', 16, 1);
			RETURN -5;
		END;
	END;

	DECLARE @command nvarchar(MAX);
	DECLARE @schemaId int;
	DECLARE @objectName sysname;

	IF UPPER(@Mode) IN (N'VIEWS_AND_MODULES', N'VIEWS') BEGIN 

		DECLARE refresher CURSOR LOCAL FAST_FORWARD FOR 
		SELECT [schema_id], [name]
		FROM sys.objects WHERE [type] = 'V';

		DECLARE @ErrorNumber int, @ErrorLine int, @ErrorProcedure nvarchar(126), @ErrorMessage nvarchar(2048);

		OPEN refresher;
		FETCH NEXT FROM refresher INTO @schemaId, @objectName;
		WHILE @@FETCH_STATUS = 0 BEGIN

			SET @command = N'EXEC sp_refreshview ''' + SCHEMA_NAME(@schemaId) + '.' + @objectName + ''' ';
		
			BEGIN TRY
				
				IF @PrintOnly = 1 BEGIN 
					PRINT @command;
				  END;
				ELSE BEGIN
					BEGIN TRAN;    
					EXEC sp_executesql @command;
					COMMIT;
				END;
			END TRY
			BEGIN CATCH
			      
				SELECT @ErrorNumber = ERROR_NUMBER(), @ErrorLine = ERROR_LINE(), @ErrorProcedure = ERROR_PROCEDURE(), @ErrorMessage = ERROR_MESSAGE();    
				PRINT 'REFRESH OF VIEW: ' + DB_NAME() + '.' + SCHEMA_NAME(@schemaId) + '.' + @objectName + ' Failed. -> Error: ' + @ErrorMessage;
				ROLLBACK;
			END CATCH      

			FETCH NEXT FROM refresher INTO @schemaId, @objectName;
		END

		CLOSE refresher;
		DEALLOCATE refresher;

	END;

	IF UPPER(@Mode) IN (N'VIEWS_AND_MODULES', N'MODULES') BEGIN 

		DECLARE [refresher2] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT
			[o].[schema_id],
			[o].[name]
		FROM
			[sys].[sql_modules] [m]
			INNER JOIN [sys].[objects] [o] ON [m].[object_id] = [o].[object_id];

	
		OPEN [refresher2];
		FETCH NEXT FROM [refresher2] INTO @schemaId, @objectName;
	
		WHILE @@FETCH_STATUS = 0 BEGIN
	
			SET @command = N'EXEC sp_refreshsqlmodule ''' + SCHEMA_NAME(@schemaId) + '.' + @objectName + ''' ';
	
				BEGIN TRY
				
					IF @PrintOnly = 1 BEGIN 
						PRINT @command;
					  END;
					ELSE BEGIN
						BEGIN TRAN;    
						EXEC sp_executesql @command;
						COMMIT;
					END;
				END TRY
				BEGIN CATCH
			      
					SELECT @ErrorNumber = ERROR_NUMBER(), @ErrorLine = ERROR_LINE(), @ErrorProcedure = ERROR_PROCEDURE(), @ErrorMessage = ERROR_MESSAGE();    
					PRINT 'REFRESH OF MODULE: ' + DB_NAME() + '.' + SCHEMA_NAME(@schemaId) + '.' + @objectName + ' Failed. -> Error: ' + @ErrorMessage;
					ROLLBACK;
				END CATCH 

			FETCH NEXT FROM [refresher2] INTO @schemaId, @objectName;
		END;
	
		CLOSE [refresher2];
		DEALLOCATE [refresher2];

	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.extract_directory_from_fullpath','FN') IS NOT NULL
	DROP FUNCTION dbo.[extract_directory_from_fullpath];
GO

CREATE FUNCTION dbo.[extract_directory_from_fullpath] (@FullFileName nvarchar(2000))
RETURNS sysname
	WITH RETURNS NULL ON NULL INPUT
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
    	DECLARE @output sysname = N'';
		DECLARE @delimiter sysname = N'\'; -- hard-coded for now, but needs to be diff with linux... 

		DECLARE @isUncPath bit = 0; 
		IF @FullFileName LIKE N'\\%' SET @isUncPath = 1;

		WITH parts AS ( 
			SELECT 
				row_id, 
				[result]
			FROM 
				dbo.[split_string](@FullFileName, @delimiter, 1)
		)
		SELECT 
			@output = @output + [result] + @delimiter
		FROM 
			parts 
		WHERE 
			row_id <> (SELECT MAX(row_id) FROM [parts])
		ORDER BY 
			row_id;

		SELECT @output = dbo.normalize_file_path(@output);

		IF @isUncPath = 1 SET @output = @delimiter + @output;

    	RETURN @output;
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.extract_filename_from_fullpath','FN') IS NOT NULL
	DROP FUNCTION dbo.[extract_filename_from_fullpath];
GO

CREATE FUNCTION dbo.[extract_filename_from_fullpath] (@FullFileName nvarchar(2000))
RETURNS sysname
	WITH RETURNS NULL ON NULL INPUT
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
    	DECLARE @output sysname;
		DECLARE @delimiter sysname = N'\'; -- hard-coded for now, but needs to be diff with linux... 

		WITH parts AS ( 
			SELECT 
				row_id, 
				[result]
			FROM 
				dbo.[split_string](@FullFileName, @delimiter, 1)
		)
		SELECT 
			@output = [result]
		FROM 
			[parts] 
		WHERE 
			row_id = (SELECT MAX(row_id) FROM [parts]);
    	
    	RETURN @output;
    
    END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.count_rows','P') IS NOT NULL
	DROP PROC dbo.[count_rows];
GO

CREATE PROC dbo.[count_rows]
	@Target					sysname				= NULL, 
	@Output					int					= -1			OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @Target, 
		@ParameterNameForTarget = N'@Target', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	DECLARE @targetDatabase sysname, @targetSchema sysname, @targetTable sysname;
	SELECT 
		@targetDatabase = PARSENAME(@normalizedName, 3),
		@targetSchema = PARSENAME(@normalizedName, 2), 
		@targetTable = PARSENAME(@normalizedName, 1);

	DECLARE @count int; 
	DECLARE @sql nvarchar(MAX) = N'SELECT
		@count	= SUM([p].[rows])
	FROM
		' + QUOTENAME(@targetDatabase) + N'.[sys].[partitions] AS [p]
		INNER JOIN ' + QUOTENAME(@targetDatabase) + N'.[sys].[tables] AS [t] ON [p].[object_id] = [t].[object_id]
		INNER JOIN ' + QUOTENAME(@targetDatabase) + N'.[sys].[schemas] AS [s] ON [t].[schema_id] = [s].[schema_id]
	WHERE
		[p].[index_id] IN (0, 1) -- heap or clustered index
		AND [t].[name] = @targetTable AND [s].[name] = @targetSchema ; ';
		
	EXEC sp_executesql 
		@sql, 
		N'@targetTable sysname, @targetSchema sysname, @count int OUTPUT', 
		@targetTable = @targetTable, 
		@targetSchema = @targetSchema, 
		@count = @count OUTPUT;

	
	IF @Output = -1 BEGIN
		SELECT @count [row_count];
		RETURN 0;
	END;

	SET @Output = @count;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.dump_module_code','P') IS NOT NULL
	DROP PROC dbo.[dump_module_code];
GO

CREATE PROC dbo.[dump_module_code]
	@TargetDatabases			nvarchar(MAX) = N'{ALL}', 
	@ExcludedDatabases			nvarchar(MAX) = NULL, 
	@Priorities					nvarchar(MAX) = NULL,
	@TargetPattern				sysname
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	CREATE TABLE #matches (
		[row_id] int IDENTITY(1,1) NOT NULL,
		[database_name] sysname NOT NULL, 
		[schema_name] sysname NOT NULL, 
		[module_name] sysname NOT NULL, 
		[module_type] sysname NOT NULL, 
		[module_definition] nvarchar(MAX) NOT NULL 
	);

	DECLARE @sql nvarchar(MAX); 
	DECLARE @currentDB sysname; 

	DECLARE @databaseTargets table (
        [entry_id] int IDENTITY(1,1) NOT NULL, 
        [database_name] sysname NOT NULL
    ); 

	INSERT INTO @databaseTargets ([database_name])
	EXEC dbo.[list_databases]
		@Targets = @TargetDatabases,
		@Exclusions = @ExcludedDatabases,
		@Priorities = @Priorities,
		@ExcludeClones = 1,
		@ExcludeSecondaries = 1,
		@ExcludeSimpleRecovery = 0,
		@ExcludeReadOnly = 0,
		@ExcludeRestoring = 1,
		@ExcludeRecovering = 1,
		@ExcludeOffline = 1;

	DECLARE [cursorName] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name]
	FROM 
		@databaseTargets 
	ORDER BY 
		[entry_id];
	
	OPEN [cursorName];
	FETCH NEXT FROM [cursorName] INTO @currentDB;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
	
		SET @sql = N'SELECT 
		N''{dbName}'' [database_name],
		[s].[name] [schema_name],
		[o].[name] [module_name],
		[o].[type_desc] [module_type],
		[m].[definition] [module_definition]
	FROM 
		[{dbName}].sys.[sql_modules] m 
		INNER JOIN [{dbName}].sys.[objects] o ON [m].[object_id] = [o].[object_id]
		INNER JOIN [{dbName}].sys.[schemas] s ON [o].[schema_id] = [s].[schema_id]
	WHERE 
		[m].[definition] LIKE @TargetPattern; ';

		SET @sql = REPLACE(@sql, N'{dbName}', @currentDB);

		INSERT INTO [#matches] (
			[database_name],
			[schema_name],
			[module_name],
			[module_type],
			[module_definition]
		)
		EXEC sys.sp_executesql
			@sql, 
			N'@TargetPattern sysname', 
			@TargetPattern = @TargetPattern;

		FETCH NEXT FROM [cursorName] INTO @currentDB;
	END;
	
	CLOSE [cursorName];
	DEALLOCATE [cursorName];

	DECLARE @previousDB sysname = N'';
	DECLARE @schemaName sysname, @moduleName sysname, @definition nvarchar(MAX); 
	DECLARE @testDefinition nvarchar(MAX);

	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name], 
		[schema_name],
		[module_name], 
		[module_definition]
	FROM 
		[#matches]
	ORDER BY 
		[row_id];
	
	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @currentDB, @schemaName, @moduleName, @definition;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
	
		IF @previousDB <> @currentDB BEGIN 
			PRINT N'--==================================================================================================================================--';
			PRINT N' -- ' + @currentDB
			PRINT N'--==================================================================================================================================--';
			PRINT N'USE [' + @currentDB + N'];'
			PRINT N'GO';
			SET @previousDB = @currentDB;
		END;

		SET @testDefinition = REPLACE(REPLACE(@definition, N'[', N''), N']', '');

		PRINT N'------------------------------+-+-~-+-+------------------------------';  -- goofy little pattern makes searching easier... 
		PRINT N'-- ' + QUOTENAME(@currentDB) + N'.' + QUOTENAME(@schemaName) + N'.' + QUOTENAME(@moduleName); 
		IF @testDefinition NOT LIKE '%' + @moduleName + N'%' BEGIN 
			PRINT N'-- WARNING: Object Definition does NOT contain LITERAL name of ' + @moduleName + N' - i.e., potential rename';
		END;
		PRINT N'---------------------------------------------------------------------';
		PRINT N'GO '; -- prevents the comments above from becoming part of the module definition... 

		EXEC dbo.[print_long_string] @definition;

		PRINT N'GO';
		PRINT N'';
	
		FETCH NEXT FROM [walker] INTO @currentDB, @schemaName, @moduleName, @definition;
	END;
	
	CLOSE [walker];
	DEALLOCATE [walker];

	RETURN 0; 
GO


	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.extract_matches','TF') IS NOT NULL
	DROP FUNCTION dbo.extract_matches;
GO

CREATE FUNCTION dbo.extract_matches(@Input nvarchar(MAX), @Match nvarchar(MAX), @PaddingCharsCount int, @MatchWrapper nvarchar(MAX))
RETURNS @Matches table (match_id int IDENTITY NOT NULL, match_position int NOT NULL, [match] nvarchar(MAX) NOT NULL)
AS 
	BEGIN 
		
		SET @PaddingCharsCount = ISNULL(@PaddingCharsCount, 10);
		SET @MatchWrapper = ISNULL(@MatchWrapper, N'');

		DECLARE @start int; 
		DECLARE @end int; 
		DECLARE @matchLen int = LEN(@Match);
		DECLARE @currentMatch nvarchar(MAX);

		DECLARE @matchPosition int = 0;

		WHILE 1 = 1 BEGIN

			SELECT @matchPosition = CHARINDEX(@Match, @Input, @matchPosition);

			IF @matchPosition < 1 
				BREAK;
	
			SET @start = @matchPosition - @PaddingCharsCount;
			IF @start < 0 
				SET @start = 0;

			SET @end = @matchPosition + @matchLen + @PaddingCharsCount;
			IF @end > LEN(@Input) 
				SET @end = LEN(@Input);

			SELECT @currentMatch = SUBSTRING(@Input, @start, @end);

			INSERT INTO @Matches (
				[match_position],
				[match]
			)
			VALUES	(
				@matchPosition,
				@currentMatch
			)

			SET @matchPosition = @matchPosition + 1;

		END;

		IF NULLIF(@MatchWrapper, N'') IS NOT NULL BEGIN
			SET @MatchWrapper = REPLACE(@MatchWrapper, N'{0}', @Match); 

			UPDATE @Matches
			SET 
				[match] = REPLACE([match], @Match, @MatchWrapper)
			WHERE 
				[match] IS NOT NULL;

		END;

		RETURN;
	END; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.kill_blocking_processes','P') IS NOT NULL
	DROP PROC dbo.[kill_blocking_processes];
GO

CREATE PROC dbo.[kill_blocking_processes]
	@BlockingThresholdSeconds				int					= 60,
	@ExcludeBackupsAndRestores				bit					= 1,					-- ALL exclude/allow directives apply to ROOT blocker only.
	@ExcludeSqlServerAgentJobs				bit					= 1,					
	@KillableApplicationNames				nvarchar(MAX)		= NULL,					-- All @Allows** params will limit to ONLY lead-blockers via OR on @Allowed values
	@KillableHostNames						nvarchar(MAX)		= NULL,					--			 and will, further, be EXCLUDED by @Excluded*** 
	@KillableLogins							nvarchar(MAX)		= NULL,
	@KillableDatabases						nvarchar(MAX)		= NULL, 
	@ExcludedApplicationNames				nvarchar(MAX)		= NULL,			
	@ExcludedDatabases						nvarchar(MAX)		= NULL,
	@ExcludedHostNames						nvarchar(MAX)		= NULL, 
	@ExcludedLogins							nvarchar(MAX)		= NULL, 
	@OperatorName							sysname				= N'Alerts',
	@MailProfileName						sysname				= N'General',
	@EmailSubjectPrefix						nvarchar(50)		= N'[Blocked Processes]',
	@PrintOnly								bit					= 0								-- Instead of EXECUTING commands, they're printed to the console only. 	
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @BlockingThresholdSeconds = ISNULL(@BlockingThresholdSeconds, 30);
	SET @ExcludeSqlServerAgentJobs = ISNULL(@ExcludeSqlServerAgentJobs, 1);
	SET @ExcludedApplicationNames = NULLIF(@ExcludedApplicationNames, N'');
	SET @ExcludedDatabases = NULLIF(@ExcludedDatabases, N'');
	SET @ExcludedHostNames = NULLIF(@ExcludedHostNames, N'');
	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');

	SET @KillableApplicationNames = NULLIF(@KillableApplicationNames, N'');
	SET @KillableHostNames = NULLIF(@KillableHostNames, N'');
	SET @KillableLogins = NULLIF(@KillableLogins, N'');
	SET @KillableDatabases = NULLIF(@KillableDatabases, N'');

	DECLARE @message nvarchar(MAX);

	CREATE TABLE #results (
		[database] sysname NULL,
		[blocking_chain] nvarchar(400) NULL,
		[blocking_session_id] nvarchar(4000) NULL,
		[session_id] nvarchar(4000) NULL,
		[command] sysname NULL,
		[status] sysname NOT NULL,
		[statement] nvarchar(MAX) NULL,
		[wait_time] int NULL,
		[wait_type] sysname NULL,
		[wait_resource] nvarchar(256) NOT NULL,
		[is_system] bit NOT NULL,
		[duration] nvarchar(128) NULL,
		[transaction_state] varchar(11) NOT NULL,
		[isolation_level] varchar(14) NULL,
		[transaction_type] varchar(8) NOT NULL,
		[context] xml NULL
	);

	INSERT INTO [#results] (
		[database],
		[blocking_chain],
		[blocking_session_id],
		[session_id],
		[command],
		[status],
		[statement],
		[wait_time],
		[wait_type],
		[wait_resource],
		[duration],
		[is_system],
		[transaction_state],
		[isolation_level],
		[transaction_type],
		[context]
	)
	EXEC dbo.[list_collisions] 
		@TargetDatabases = N'{ALL}', 
		@IncludePlans = 0, 
		@IncludeContext = 1, 
		@UseInputBuffer = 1, 
		@ExcludeFullTextCollisions = 0;

	IF EXISTS (SELECT NULL FROM [#results]) BEGIN 

		DELETE FROM [#results] WHERE [session_id] IS NULL; -- no idea why/how this one happens... but it occasionally does. 

		IF @ExcludedDatabases IS NOT NULL BEGIN 
			DELETE r
			FROM 
				[#results] r
				INNER JOIN (SELECT [result] FROM dbo.[split_string](@ExcludedDatabases, N', ', 1)) x ON r.[database] LIKE x.[result];
		END;

		IF NOT EXISTS (SELECT NULL FROM [#results]) BEGIN
			RETURN 0; -- short-circuit (i.e., nothing to do or report).
		END;

		-- Blocked processes happen all the time - at a transient level. Don't bother processing if nothing has been blocked for > @BlockingThresholdSeconds
		DECLARE @maxWait int = (SELECT MAX(wait_time) FROM [#results] WHERE [wait_time] IS NOT NULL);
		IF @maxWait < (@BlockingThresholdSeconds * 1000) BEGIN 
			RETURN 0;
		END;
	END;

	IF NOT EXISTS (SELECT NULL FROM [#results]) BEGIN
		RETURN 0; -- short-circuit (i.e., nothing to do or report).
	END;
	
	BEGIN TRY 
		WITH shredded AS ( 
			SELECT 
				[database]	,
				CAST([session_id] AS int) [session_id], 
				CAST((REPLACE(LEFT([blocking_chain], PATINDEX(N'% >%', [blocking_chain])), N' ' + CHAR(187) + N' ', N'')) AS int) [blocker],
				[command],
				[status],
				[statement],
				[wait_time],
				[wait_type],
				[wait_resource],
				[duration],
				[is_system],
				[transaction_state],
				[isolation_level],
				[transaction_type],
				[context].value(N'(/context/program_name)[1]', N'sysname') [program_name],
				[context].value(N'(/context/host_name)[1]', N'sysname') [host_name], 
				[context].value(N'(/context/login_name)[1]', N'sysname') [login_name]
			FROM 
				[#results]
		) 

		SELECT 
			[x].[database],
			[x].[session_id],
			(SELECT COUNT(*) FROM [shredded] x2 WHERE [x2].[blocker] = x.[session_id]) [blocked_count],
			dbo.[format_timespan]((SELECT MAX(wait_time) FROM [shredded] x2 WHERE [x2].[blocker] = x.[session_id])) [max_blocked_time],
			ISNULL([x].[command], N'<orphaned>') [command],
			[x].[status],
			[x].[statement],
			(SELECT TOP (1) x2.[wait_type] FROM [shredded] x2 WHERE [x2].[blocker] = x.[session_id] ORDER BY x2.[wait_time] DESC) [wait_type],
			(SELECT TOP (1) x2.[wait_resource] FROM [shredded] x2 WHERE [x2].[blocker] = x.[session_id] ORDER BY [x2].[wait_time] DESC) [blocked_resource],
			[x].[duration],
			[x].[is_system],
			CASE
				WHEN [x].[transaction_state] = N'#Unknown#' THEN N'<orphaned>' 
				ELSE [x].[transaction_state]
			END [transaction_state],
			[x].[isolation_level],
			[x].[transaction_type],
			[x].[program_name], 
			[x].[host_name], 
			[x].[login_name]
		INTO 
			#leadBlockers
		FROM 
			[shredded] x
		WHERE 
			[x].[blocker] = 0
			AND (SELECT MAX(wait_time) FROM [shredded] x2 WHERE [x2].[blocker] = x.[session_id]) > (@BlockingThresholdSeconds * 1000);
	
	END TRY 
	BEGIN CATCH 
		SELECT @message = N'Exception Identifying Blockers: [' + ERROR_MESSAGE() + N'] on line [' + CAST(ERROR_LINE() AS sysname) + N'].';
		GOTO SendMessage;
	END CATCH
	
	/* Additional short-circuit (no sense allowing/excluding if there are NO blocked processes */
	IF NOT EXISTS (SELECT NULL FROM [#leadBlockers]) BEGIN
		RETURN 0; -- short-circuit (i.e., nothing to do or report).
	END;
	
	/* Now that we know who the lead-blockers are, check for @Allowed/Inclusions - and then EXCLUDE by any @ExludeXXXX params. */
	DECLARE @killableApps table (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[app_name] sysname NOT NULL
	); 

	IF @KillableApplicationNames IS NOT NULL BEGIN 
		INSERT INTO @killableApps ([app_name])
		SELECT [result] FROM dbo.[split_string](@KillableApplicationNames, N', ', 1);
		
		DELETE x 
		FROM 
			[#leadBlockers] x  
			INNER JOIN @killableApps t ON x.[program_name] NOT LIKE t.[app_name];
	END;

	DECLARE @killableHosts table (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[host_name] sysname NOT NULL
	); 

	IF @KillableHostNames IS NOT NULL BEGIN 
		INSERT INTO @killableHosts ([host_name])
		SELECT [result] FROM dbo.[split_string](@KillableHostNames, N', ', 1);

		DELETE x 
		FROM 
			[#leadBlockers] x 
			INNER JOIN @killableHosts t ON [x].[host_name] NOT LIKE [t].[host_name];
	END;

	DECLARE @killable_logins table (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[login_name] sysname NOT NULL
	); 

	IF @KillableLogins IS NOT NULL BEGIN 
		INSERT INTO @killable_logins ([login_name])
		SELECT [result] FROM dbo.[split_string](@KillableLogins, N', ', 1);

		DELETE x 
		FROM 
			[#leadBlockers] x 
			INNER JOIN @killable_logins t ON [x].[login_name] NOT LIKE [t].[login_name];
	END;

	DECLARE @killable_databases table ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[database_name] sysname NOT NULL
	); 

	IF @KillableDatabases IS NOT NULL BEGIN 
		INSERT INTO @killable_databases ([database_name])
		SELECT [result] FROM dbo.[split_string](@KillableDatabases, N', ', 1);

		DELETE x 
		FROM 
			[#leadBlockers] x 
			INNER JOIN @killable_databases d ON x.[database] NOT LIKE d.[database_name];
	END;

	DECLARE @leadBlockers int;
	SELECT @leadBlockers = COUNT(*) FROM [#leadBlockers]; -- used down below... 

	-- Now that we know who the root blockers are... check for exclusions:
	DECLARE @excludedApps table (
		row_id int IDENTITY(1,1) NOT NULL, 
		[app_name] sysname NOT NULL 
	);

	IF @ExcludeSqlServerAgentJobs = 1 BEGIN 
		INSERT INTO @excludedApps ([app_name])
		VALUES	(N'SQLAgent - TSQL JobStep%');
	END;

	IF @ExcludedApplicationNames IS NOT NULL BEGIN 
		INSERT INTO @excludedApps ([app_name])
		SELECT [result] FROM dbo.[split_string](@ExcludedApplicationNames, N', ', 1);
	END;

	IF EXISTS (SELECT NULL FROM @excludedApps) BEGIN 
		DELETE b
		FROM 
			[#leadBlockers] b 
			INNER JOIN @excludedApps x ON b.[program_name] LIKE x.[app_name];
	END;

	IF @ExcludeBackupsAndRestores = 1 BEGIN 
		DELETE FROM [#leadBlockers]
		WHERE 
			[command] LIKE N'%BACKUP%'
			OR 
			[command] LIKE N'%RESTORE%'
	END;

	IF @ExcludedDatabases IS NOT NULL BEGIN 
		DELETE b 
		FROM 
			[#leadBlockers] b 
			INNER JOIN dbo.[split_string](@ExcludedDatabases, N', ', 1) x ON b.[database] LIKE x.[result];
	END;

	IF @ExcludedHostNames IS NOT NULL BEGIN 
		DELETE b 
		FROM 
			[#leadBlockers] b 
			INNER JOIN dbo.[split_string](@ExcludedHostNames, N', ', 1) x ON b.[host_name] LIKE x.[result];
	END;

	IF @ExcludedLogins IS NOT NULL BEGIN 
		DELETE b 
		FROM 
			[#leadBlockers] b 
			INNER JOIN dbo.[split_string](@ExcludedLogins, N', ', 1) x ON b.[login_name] LIKE x.[result];
	END;
	
	-- Remove any processes ALREADY KILL'd (i.e., zombies - don't want to tell them to 'die!!' again): 
	DELETE FROM [#leadBlockers] 
	WHERE 
		[command] = N'KILLED/ROLLBACK';

	IF NOT EXISTS (SELECT NULL FROM [#leadBlockers]) BEGIN 
		RETURN 0; -- nothing tripped expected thresholds... 
	END;

	/*	IF we're still here, there are spids to kill (though they might be system) 
		So, serialize a snapshot of the issues we're seeing.
	*/
	DECLARE @collisionSnapshot xml = (
		SELECT 
			[r].[database],
			CASE WHEN [x].[session_id] IS NULL THEN 0 ELSE 1 END [should_kill],
			[r].[blocking_chain],
			[r].[session_id],
			[r].[command],
			[r].[status],
			[r].[statement],
			[r].[wait_time],
			[r].[wait_type],
			[r].[wait_resource],
			[r].[is_system],
			[r].[duration],
			[r].[transaction_state],
			[r].[isolation_level],
			[r].[transaction_type],
			[r].[context]
		FROM 
			[#results] [r]
			LEFT OUTER JOIN [#leadBlockers] [x] ON [r].[session_id] = [x].[session_id]
		FOR XML PATH('row'), ROOT('blockers'), TYPE
	);

	DECLARE @blockedProcesses int, @blockersToKill int;
	SELECT @blockedProcesses = COUNT(*) FROM [#results];
	SELECT @blockersToKill = COUNT(*) FROM [#leadBlockers];  -- we gathered ALL before, now we're left with just those to kill.
	DECLARE @snapshotId int;

	INSERT INTO dbo.[kill_blocking_process_snapshots] (
		[timestamp],
		[print_only],
		[blocked_processes],
		[lead_blockers],
		[blockers_to_kill],
		[snapshot]
	)
	VALUES	(
		GETDATE(),
		@PrintOnly,
		@blockedProcesses, 
		@leadBlockers,
		@blockersToKill, 
		@collisionSnapshot
	);

	SELECT @snapshotId = SCOPE_IDENTITY();  -- vNEXT ... use this to do updates (against new columns to add) for ... POST kill metrics (count etc.)

	DECLARE @sessionId int, @isSystem bit;
	DECLARE @command sysname;
	DECLARE [killer] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[session_id], [is_system]
	FROM 
		[#leadBlockers];
	
	OPEN [killer];
	FETCH NEXT FROM [killer]INTO @sessionId, @isSystem;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
		
		IF @isSystem = 0 BEGIN 
			SET @command = N'KILL ' + CAST(@sessionId AS sysname) + N';';
		
			IF @PrintOnly = 1
				PRINT @command;
			ELSE BEGIN
				BEGIN TRY
					EXEC(@command);
				END TRY 
				BEGIN CATCH 

				END CATCH;
			END;
		END;

		FETCH NEXT FROM [killer]INTO @sessionId, @isSystem;
	END;
	
	CLOSE [killer];
	DEALLOCATE [killer];

	DECLARE @body nvarchar(MAX) = N'';
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);

	SELECT 
		@body = @body + CASE WHEN [is_system] = 1 THEN N'!COULD_NOT_KILL! (SYSTEM PROCESS) -> ' ELSE N'KILLED -> ' END + 
			@crlf + @tab + N'SESSION ID             : ' + CAST(ISNULL([session_id], -1) AS sysname) +
			@crlf + @tab + N'Blocked Operations     : ' + CAST(ISNULL([blocked_count], -1) AS sysname) + 
			@crlf + @tab + N'Max Blocked Duration   : ' + ISNULL([max_blocked_time], N'#ERROR#') + 
			@crlf + @tab + N'Status                 : ' + [status] +
			@crlf + @tab + N'Command                : ' + ISNULL([command], N'') +
			@crlf + @tab + N'Wait Type              : ' + ISNULL([wait_type], N'') +
			@crlf + @tab + N'Blocked Resource       : ' + ISNULL([blocked_resource], N'') +
			@crlf + @tab + N'Run Time               : ' + ISNULL([duration], N'') + 
			@crlf + @tab + N'Transaction State      : ' + ISNULL([transaction_state], N'') +
			@crlf + @tab + N'Isolation Level        : ' + ISNULL([isolation_level], N'#UNKNOWN#') +
			@crlf + @tab + N'Program Name           : ' + ISNULL([program_name], N'') +
			@crlf + @tab + N'Host                   : ' + ISNULL([host_name], N'') +
			@crlf + @tab + N'Login                  : ' + ISNULL([login_name], N'') +
			@crlf + @tab + N'Statement: [' + 
			@crlf + @tab + @tab + REPLACE(RTRIM(ISNULL([statement], N'')), @crlf, @crlf + @tab + @tab) +
			@crlf + @crlf + @tab + N']' +
			@crlf + @crlf
	FROM 
		[#leadBlockers] 
	ORDER BY 
		[blocked_count] DESC, [max_blocked_time] DESC;

	DECLARE @subject sysname; 

	SET @subject = ISNULL(@EmailSubjectPrefix, N'') + N' - Blocking Processes were KILLED';
	SET @message = N'The following blocking processes were detected and _KILLED_ on ' + @@SERVERNAME + N' because they exceeded blocking thresholds of ' + CAST(@BlockingThresholdSeconds AS sysname) + N' seconds: ' + @crlf + @crlf;
	SET @message = @message + @body; 

SendMessage:
	IF @PrintOnly = 1 BEGIN 
		PRINT N'SUBJECT: ' + @subject; 
		PRINT N'BODY: ' + @message;
	  END; 
	ELSE BEGIN 
		EXEC [msdb]..[sp_notify_operator] 
			@profile_name = @MailProfileName,
			@name = @OperatorName, -- operator name
			@subject = @subject, 
			@body = @message;	
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.kill_connections_by_statement','P') IS NOT NULL
	DROP PROC dbo.[kill_connections_by_statement];
GO

CREATE PROC dbo.[kill_connections_by_statement]
	@StatementPattern						nvarchar(MAX), 
	@CpuMillisecondsThreshold				int					= 2200,
	@KillableApplicationNames				nvarchar(MAX)		= NULL,			
	@KillableHostNames						nvarchar(MAX)		= NULL,			
	@KillableLogins							nvarchar(MAX)		= NULL,
	@KillableDatabases						nvarchar(MAX)		= NULL,
	@ExcludeBackupsAndRestores				bit					= 1,			
	@ExcludeSqlServerAgentJobs				bit					= 1,			
	@ExcludedApplicationNames				nvarchar(MAX)		= NULL,		
	@ExcludedHostNames						nvarchar(MAX)		= NULL, 
	@ExcludedLogins							nvarchar(MAX)		= NULL,
	@ExcludedDatabases						nvarchar(MAX)		= NULL,
	@PrintOnly								bit					= 0	
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @CpuMillisecondsThreshold = ISNULL(@CpuMillisecondsThreshold, 2200);

	SET @ExcludeBackupsAndRestores = ISNULL(@ExcludeBackupsAndRestores, 1);
	SET @ExcludeSqlServerAgentJobs = ISNULL(@ExcludeSqlServerAgentJobs, 1);
	SET @ExcludedApplicationNames = NULLIF(@ExcludedApplicationNames, N'');
	SET @ExcludedDatabases = NULLIF(@ExcludedDatabases, N'');
	SET @ExcludedHostNames = NULLIF(@ExcludedHostNames, N'');
	SET @ExcludedLogins = NULLIF(@ExcludedLogins, N'');

	SET @KillableApplicationNames = NULLIF(@KillableApplicationNames, N'');
	SET @KillableHostNames = NULLIF(@KillableHostNames, N'');
	SET @KillableLogins = NULLIF(@KillableLogins, N'');
	SET @KillableDatabases = NULLIF(@KillableDatabases, N'');

	CREATE TABLE [#results] ( 
		[session_id] smallint NOT NULL,
		[database] sysname NOT NULL,
		[elapsed_milliseconds] int NOT NULL,
		[status] nvarchar(30) NOT NULL,
		[command] nvarchar(32) NOT NULL,
		[program_name] sysname NULL,
		[login_name] sysname NOT NULL,
		[host_name] sysname NULL,
		[statement] nvarchar(max) NULL
	) 

	INSERT INTO [#results] (
		[session_id],
		[database],
		[elapsed_milliseconds],
		[status],
		[command],
		[program_name],
		[login_name],
		[host_name],
		[statement]
	)
	SELECT 
		r.[session_id], 
		DB_NAME(r.[database_id]) [database], 
		r.[total_elapsed_time] [elapsed_milliseconds], 
		r.[status], 
		r.[command], 
		s.[program_name], 
		s.[login_name], 
		s.[host_name], 
		t.[text] [statement]
	FROM 
		sys.dm_exec_requests r
		INNER JOIN sys.[dm_exec_sessions] s ON r.[session_id] = s.[session_id]
		OUTER APPLY sys.[dm_exec_sql_text](r.[sql_handle]) t
	WHERE 
		[r].[session_id] > 50
		AND s.[is_user_process] = 1
		AND r.[session_id] <> @@SPID
		AND r.[total_elapsed_time] >= @CpuMillisecondsThreshold;

	-----------------------------------------------------------------------------------------------------------------------------------------------------
	-- Normalize % within @StatementPattern - i.e., LEAVE any inside... but strip start/end ... then ADD % and % to start and end... 
	-----------------------------------------------------------------------------------------------------------------------------------------------------
	DECLARE @normalizedStatementPattern nvarchar(MAX) = @StatementPattern;
	IF LEFT(@normalizedStatementPattern, 1) = N'%'
		SET @normalizedStatementPattern = RIGHT(@normalizedStatementPattern, LEN(@normalizedStatementPattern) -1);

	IF RIGHT(@normalizedStatementPattern, 1) = N'%'
		SET @normalizedStatementPattern = LEFT(@normalizedStatementPattern, LEN(@normalizedStatementPattern) -1);

	SET @normalizedStatementPattern = N'%' + @normalizedStatementPattern + N'%';
	
	PRINT N'Normalized @StatementPattern used for matching target statements to kill: [' + @normalizedStatementPattern + N']';

	DELETE FROM [#results] WHERE [statement] NOT LIKE @normalizedStatementPattern;


	IF EXISTS (SELECT NULL FROM [#results]) BEGIN 

		DELETE FROM [#results] WHERE [session_id] IS NULL; -- no idea why/how this one happens... but it occasionally does. 

		-----------------------------------------------------------------------------------------------------------------------------------------------------
		-- Process Explicit Exclusions (i.e., white-listed - or un-KILL-able) operations:
		-----------------------------------------------------------------------------------------------------------------------------------------------------
		IF @ExcludeBackupsAndRestores = 1 BEGIN 
			DELETE FROM [#results]
			WHERE 
				[command] LIKE N'%BACKUP%'
				OR 
				[command] LIKE N'%RESTORE%'
		END;



		IF NOT EXISTS (SELECT NULL FROM [#results]) BEGIN
			RETURN 0; -- short-circuit (i.e., nothing to do or report).
		END;

		DECLARE @excludedApps table (
			row_id int IDENTITY(1,1) NOT NULL, 
			[app_name] sysname NOT NULL 
		);

		IF @ExcludeSqlServerAgentJobs = 1 BEGIN 
			INSERT INTO @excludedApps ([app_name])
			VALUES	(N'SQLAgent - TSQL JobStep%');
		END;

		IF @ExcludedApplicationNames IS NOT NULL BEGIN 
			INSERT INTO @excludedApps ([app_name])
			SELECT [result] FROM dbo.[split_string](@ExcludedApplicationNames, N', ', 1);
		END;

		IF EXISTS (SELECT NULL FROM @excludedApps) BEGIN 
			DELETE b
			FROM 
				[#results] b 
				INNER JOIN @excludedApps x ON b.[program_name] LIKE x.[app_name];
		END;

		IF @ExcludedHostNames IS NOT NULL BEGIN 
			DELETE r 
			FROM 
				[#results] r 
				INNER JOIN (SELECT [result] FROM dbo.[split_string](@ExcludedHostNames, N', ', 1)) x ON r.[host_name] LIKE x.[result];
		END;

		IF @ExcludedLogins IS NOT NULL BEGIN 
			DELETE r 
			FROM 
				[#results] r 
				INNER JOIN (SELECT [result] FROM dbo.[split_string](@ExcludedLogins, N', ', 1)) x ON r.[login_name] LIKE x.[result];
		END;

		IF @ExcludedDatabases IS NOT NULL BEGIN 
			DELETE r
			FROM 
				[#results] r
				INNER JOIN (SELECT [result] FROM dbo.[split_string](@ExcludedDatabases, N', ', 1)) x ON r.[database] LIKE x.[result];
		END;


		-- Don't attempt to KILL anything already in a kill state:
		DELETE FROM [#results] 
		WHERE 
			[command] = N'KILLED/ROLLBACK';

		-----------------------------------------------------------------------------------------------------------------------------------------------------
		-- Remove Operations that DON'T match applicable INCLUSIONS:
		-----------------------------------------------------------------------------------------------------------------------------------------------------
		IF @KillableApplicationNames IS NOT NULL BEGIN 
			DECLARE @killableApps table (
				[row_id] int IDENTITY(1,1) NOT NULL, 
				[app_name] sysname NOT NULL
			); 

			INSERT INTO @killableApps ([app_name])
			SELECT [result] FROM dbo.[split_string](@KillableApplicationNames, N', ', 1);
		
			DELETE x 
			FROM 
				[#results] x  
				INNER JOIN @killableApps t ON x.[program_name] NOT LIKE t.[app_name];
		END;

		IF @KillableHostNames IS NOT NULL BEGIN 
			DECLARE @killableHosts table (
				[row_id] int IDENTITY(1,1) NOT NULL, 
				[host_name] sysname NOT NULL
			); 

			INSERT INTO @killableHosts ([host_name])
			SELECT [result] FROM dbo.[split_string](@KillableHostNames, N', ', 1);

			DELETE x 
			FROM 
				[#results] x 
				INNER JOIN @killableHosts t ON [x].[host_name] NOT LIKE [t].[host_name];
		END;

		IF @KillableLogins IS NOT NULL BEGIN 
			DECLARE @killable_Logins table (
				[row_id] int IDENTITY(1,1) NOT NULL, 
				[login_name] sysname NOT NULL
			); 

			INSERT INTO @killable_Logins ([login_name])
			SELECT [result] FROM dbo.[split_string](@KillableLogins, N', ', 1);

			DELETE x 
			FROM 
				[#results] x 
				INNER JOIN @killable_Logins t ON [x].[login_name] NOT LIKE [t].[login_name];
		END;

		IF @KillableDatabases IS NOT NULL BEGIN 
			DECLARE @killable_databases table (
				[row_id] int IDENTITY(1,1) NOT NULL, 
				[database] sysname NOT NULL
			); 

			INSERT INTO @killable_databases ([database])
			SELECT [result] FROM dbo.[split_string](@KillableDatabases, N', ', 1);

			DELETE x 
			FROM 
				[#results] x 
				INNER JOIN @killable_databases d ON x.[database] NOT LIKE d.[database];
		END;

		-----------------------------------------------------------------------------------------------------------------------------------------------------
		-- KILL whatever is left:
		-----------------------------------------------------------------------------------------------------------------------------------------------------
		IF EXISTS (SELECT NULL FROM [#results]) BEGIN 
			DECLARE @sessionId int, @elapsed int;
			DECLARE @command sysname;
			DECLARE @statement nvarchar(MAX);
			DECLARE @errorId int, @errorMessage nvarchar(MAX);

			DECLARE @template nvarchar(MAX) = N'-- Elapsed (ms): {ms}. Command: {command}. 
--		Statement: {statement}
KILL {id};
' ;
			DECLARE @sql nvarchar(MAX);

			PRINT N'';
			PRINT N'';

			DECLARE [cursorName] CURSOR LOCAL FAST_FORWARD FOR 
			SELECT 
				session_id, 
				[command], 
				[statement], 
				[elapsed_milliseconds]
			FROM 
				[#results]
			ORDER BY 
				[elapsed_milliseconds] DESC;			
			
			OPEN [cursorName];
			FETCH NEXT FROM [cursorName] INTO @sessionId, @command, @statement, @elapsed;
			
			WHILE @@FETCH_STATUS = 0 BEGIN
	
				IF LEN(@statement) > 140
					SET @statement = LEFT(@statement, 140) + N' ... ';
				
				SET @statement = REPLACE(@statement, NCHAR(13) + NCHAR(10), N' ');

				SET @sql = REPLACE(@template, N'{id}', @sessionId);
				SET @sql = REPLACE(@sql, N'{command}', @command);
				SET @sql = REPLACE(@sql, N'{statement}', @statement);
				SET @sql = REPLACE(@sql, N'{ms}', FORMAT(@elapsed, N'N0'));
				
				IF @PrintOnly = 1 BEGIN 
					PRINT @sql;
				  END; 
				ELSE BEGIN 
					BEGIN TRY 
						EXEC sys.[sp_executesql] 
							@sql;

						PRINT N'KILL executed against session_id: ' + CAST(@sessionId AS sysname);
					END TRY 
					BEGIN CATCH 
						SELECT @errorId = ERROR_NUMBER(), @errorMessage = ERROR_MESSAGE();

						PRINT N'Error Attempting KILL against session_id: ' + CAST(@sessionId AS sysname) + N'. Error ' + CAST(@errorId AS sysname) + N' - ' + @errorMessage;
					END CATCH;
				END;
			
				FETCH NEXT FROM [cursorName] INTO @sessionId, @command, @statement, @elapsed;
			END;
			
			CLOSE [cursorName];
			DEALLOCATE [cursorName];




		  END;
		ELSE BEGIN
			PRINT 'Matches excluded or white-listed.';
		END;

	  END; 
	ELSE BEGIN 
		PRINT 'No Matches.';
	END
	
	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.aws3_install_modules','P') IS NOT NULL
	DROP PROC dbo.[aws3_install_modules];
GO

CREATE PROC dbo.[aws3_install_modules]

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @returnValue int;
	DECLARE @commandResults xml;
	DECLARE @errorText nvarchar(MAX);
	DECLARE @tls12Directive nvarchar(MAX) = N'[Net.ServicePointManager]::SecurityProtocol = [Net.ServicePointManager]::SecurityProtocol -bor [Net.SecurityProtocolType]::Tls12; ';
	DECLARE @currentCommand nvarchar(MAX) = N'';

	DECLARE @validationsCount int = 0;
Validation:
	SET @validationsCount = @validationsCount + 1; 
	IF @validationsCount > 2 BEGIN 
		RAISERROR(N'Potential infinite loop detected - Validation Logic run > 2 times. Aborting.', 16, 1);
		RETURN -100;
	END;
	
	DECLARE @validationResults xml = NULL;
	EXEC dbo.[aws3_verify_configuration]
		@VerifyNuget = 1,
		@VerifyGalleryAccess = 1,
		@VerifyS3Modules = 1,
		@VerifyProfile = 0,
		@VerifyBuckets = 0,
		@Results = @validationResults OUTPUT;
	
	DECLARE @validations table (test sysname NOT NULL, passed bit NOT NULL, details nvarchar(MAX) NOT NULL);
	INSERT INTO @validations ([test],[passed],[details])
	SELECT 
		r.d.value(N'(test/text())[1]', N'sysname') [test], 
		r.d.value(N'(passed/text())[1]', N'bit') [passed],
		r.d.value(N'(details/text())[1]', N'nvarchar(MAX)') [details]
	FROM 
		@validationResults.nodes(N'results/result') r(d);

	IF EXISTS (SELECT NULL FROM @validations WHERE test = N'ModuleInstalled' AND [passed] = 1) BEGIN 
		-- TODO: might make sense to a) report on the VERSION - which I can get from the 'GalleryAccess' row... - and output that. 
		PRINT N'AWS.Tools.S3 Module is already installed. Exiting Setup.';
		RETURN 0;
	END;

	DECLARE @nugetUpdateRequired bit = 0;
	IF EXISTS (SELECT NULL FROM @validations WHERE test = N'NugetVersion' AND [passed] = 0) 
		SET @nugetUpdateRequired = 1;


	SET @commandResults = NULL;
	EXEC @returnValue = dbo.[execute_powershell]
		@Command = N'Get-PackageProvider -Name NuGet | Select "Version" | ConvertTo-Xml -As Stream;',
		@SerializedXmlOutput = @commandResults OUTPUT, 
		@ErrorMessage = @errorText OUTPUT;

	IF @nugetUpdateRequired = 1 BEGIN 
		PRINT N'Nuget Update Required...';

		BEGIN TRY

			/* 

	
		
			*/
			SET @currentCommand = @tls12Directive + N'Install-PackageProvider -Name NuGet -MinimumVersion 2.8.5.208 -Force -Scope CurrentUser | ConvertTo-Xml -As Stream;';

			EXEC @returnValue = dbo.[execute_powershell]
				@Command = @currentCommand,
				@SerializedXmlOutput = @commandResults OUTPUT;

		END TRY 
		BEGIN CATCH 
			SET @errorText = N'Unhandled Exception Attempting Installation / Update of Nuget Package Management: ' + ERROR_MESSAGE();
			RAISERROR(@errorText, 16, 1);
			RETURN -25;
		END CATCH;
	END; 

	IF EXISTS (SELECT NULL FROM @validations WHERE [test] = N'GalleryAccess' AND [passed] = 0) BEGIN 
		GOTO Validation; -- yup, restart things. 
	END;

	-- If we're still here, time to try and install the module: 
-- TODO: might need to provide a switch that enables the -AllowClobber switch within the following powershell command... 
	SET @commandResults = NULL;
	EXEC @returnValue = dbo.[execute_powershell]
		@Command = N'Install-Module AWS.Tools.S3 -Force -Scope CurrentUser | ConvertTo-Xml -As Stream;',
		@SerializedXmlOutput = @commandResults OUTPUT, 
		@ErrorMessage = @errorText OUTPUT;

	IF @returnValue = 0 BEGIN 
		SET @commandResults = NULL;	
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Import-Module -Name AWS.Tools.S3;',
			@SerializedXmlOutput = @commandResults OUTPUT, 
			@ErrorMessage = @errorText OUTPUT;		

		IF @returnValue = 0 BEGIN 
			PRINT 'AWS.Tools.S3 Module Installed.';
		  END;
		ELSE BEGIN 
			RAISERROR(N'Install-Module Failure. Install-Module did NOT throw errors during installation, but AWS.Tools.S3 is NOT available.', 16, 1);
			RETURN -20;
		END;
	  END;
	ELSE BEGIN 
		RAISERROR(N'Unexpected Error Installing Module AWS.Tools.S3: %s', 16, 1, @errorText);
		RETURN -40;
	END;
			
	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.aws3_initialize_profile','P') IS NOT NULL
	DROP PROC dbo.[aws3_initialize_profile];
GO

CREATE PROC dbo.[aws3_initialize_profile]
	@AwsRegion					sysname, 
	@AwsAccessKey				sysname, 
	@AwsSecretKey				sysname
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	EXEC dbo.[verify_advanced_capabilities];

	-- Make sure we don't have an EC2-InstanceProfile already in place... 

	-- Also, since this is INITIALIZE... make sure we don't already have a default profile in place... 


	-- otherwise, if the above aren't an issue... 
	-- configure the creds... 


	-- TODO: 
	--		make sure that AWS.Tools.S3 is installed. 
	--		and... since I'm going to be doing this in aws3_initialize_profile, aws3_set_profile_stuff (i.e., update/edit/modify), remove_profile, and LIST_BUCKETS and so on... 
	--		weaponize this into dbo.aws3_verify_configuration or whatever... with switches to verify: 
	--						a. network/plumbing and nuget versions (not always - Nuget could be out of date and someone could manually install S3)
	--						b. S3 module installed/import-able. 
	--						c. profiles defined... 
	--						d. buckets? 
	--		with the idea that I can use the REUSABLE logic in the above for various bits of functionality INCLUDING setup/configuration and ... verifying stuff before backups/cleanup/etc. 


	DECLARE @returnValue int; 
	DECLARE @errorMessage nvarchar(MAX); 
	DECLARE @commandResults xml;

	DECLARE @currentCommand nvarchar(MAX) = N'Initialize-AWSDefaultConfiguration -Region ''{region}'' -AccessKey ''{key}'' -SecretKey ''{secret}'';'
	SET @currentCommand = REPLACE(@currentCommand, N'{region}', @AwsRegion);
	SET @currentCommand = REPLACE(@currentCommand, N'{key}', @AwsAccessKey);
	SET @currentCommand = REPLACE(@currentCommand, N'{secret}', @AwsSecretKey);

	BEGIN TRY 
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = @currentCommand,
			@SerializedXmlOutput = @commandResults OUTPUT, 
			@ErrorMessage = @errorMessage OUTPUT;		

-- TODO: 
	-- do i need to parse @commandResults and look for any kind of error? or... more importantly, some kind of success? 
	--	YES... i do... cuz imagine that someone called this sproc with this signature:  
		--				EXEC [admindb].dbo.[aws3_initialize_profile] 
		--					@AwsRegion = N'us-west-2', 
		--					@AwsAccessKey = N'', 
		--					@AwsSecretKey = N'';


		SELECT @commandResults [Initialize_AWSDefaultConfig_resutls];

	END TRY 
	BEGIN CATCH 
		SET @errorMessage = N'Unexpected Error Initializing AWS Default Profile. Error: ' + CAST(ERROR_NUMBER() AS sysname) + ERROR_MESSAGE();
		RAISERROR(@errorMessage, 16, 1);
		RETURN -10;
	END CATCH;

	IF @returnValue <> 0 OR @errorMessage IS NOT NULL BEGIN 
		SET @errorMessage = N'PowerShell Error: ' + @errorMessage;
		RAISERROR(@errorMessage, 16, 1);
		RETURN -12;
	END;

	-- get the creds and spit them out ... 
-- TODO: implement this to be more programatic:
	EXEC dbo.[execute_powershell]
		@Command = N'Get-AWSCredential -ListProfileDetail;'; 

	RETURN 0;
GO
	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.aws3_list_buckets','P') IS NOT NULL
	DROP PROC dbo.[aws3_list_buckets];
GO

CREATE PROC dbo.[aws3_list_buckets]
	@ExtractLocations				bit					= 1,			-- forces a lookup for each bucket to grab the location... 
	@ExcludedBuckets				nvarchar(MAX)		= NULL, 
	@OrderBy						sysname				= N'NAME'		-- { NAME | REGION | DATE }
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @ExcludedBuckets = NULLIF(@ExcludedBuckets, N'');
	SET @OrderBy = ISNULL(@OrderBy, N'NAME');

	IF UPPER(@OrderBy) NOT IN (N'NAME', N'REGION', N'DATE') BEGIN 
		RAISERROR(N'Allowed Options for @OrderBy are { NAME | REGION | DATE }.', 16, 1); 
		RETURN -1;
	END;

	EXEC dbo.[verify_advanced_capabilities];

	DECLARE @returnValue int; 
	DECLARE @errorMessage nvarchar(MAX); 
	DECLARE @commandResults xml;
	DECLARE @currentCommand nvarchar(MAX);

	BEGIN TRY 
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Import-Module -Name "AWS.Tools.S3"',
			@ErrorMessage = @errorMessage OUTPUT;	

	END TRY 
	BEGIN CATCH 
		SET @errorMessage = N'Unexpected Error Validating AWS.Tools.S3 Module Installed: Error ' + CAST(ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE();
		RAISERROR(@errorMessage, 16, 1);
		RETURN -10;
	END CATCH;

	IF @returnValue <> 0 OR @errorMessage IS NOT NULL BEGIN 
		SET @errorMessage = N'PowerShell Error: ' + @errorMessage;
		RAISERROR(@errorMessage, 16, 1);
		RETURN -12;
	END;

	-- Attempt to grab a list of buckets: 
	BEGIN TRY 
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Get-S3Bucket | ConvertTo-Xml -As Stream;',
			@SerializedXmlOutput = @commandResults OUTPUT, 
			@ErrorMessage = @errorMessage OUTPUT;	
		
-- TODO:
--			if Credentials haven't been specified (or there isn't an EC2-InstanceProfile bound/set...)
--			then, via native powershell ... we get something like: 
--				a) the attempt to Get-S3Bucket ... takes around 60 seconds (seriously). 
--				b) it throws this error: Get-S3Bucket: No credentials specified or obtained from persisted/shell defaults.
--		But, if I run this: 
--		I get this result: 
--					<?xml version="1.0" encoding="utf-8"?>
--					<Objects>
--					Get-S3Bucket: No credentials specified or obtained from persisted/shell defaults.

--		As in, PowerShell STOPS writing out XML ... and throws an error... 
--		meaning, I've got to look at 2-3 things here: 
--			a. I need to look at determining if XML passed out of powershell is even remotely well-formed or not. I'm getting '' as the result from the above... 
--				so... need better error handling here... 
--			b. I need a BETTER way to determine if creds have been loaded or not. 
--				I presume I can list profiles AND if those are empty, then ... try to find/see if there's an EC2 instanceProfile bound? 
--				something like this should be fairly... fast-ish? either there's nothing set at profile/creds level or there is... etc. 

	END TRY 
	BEGIN CATCH 
		SET @errorMessage = N'Unexpected Error Validating AWS.Tools.S3 Module Installed: Error ' + CAST(ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE();
		RAISERROR(@errorMessage, 16, 1);
		RETURN -20;
	END CATCH;

	IF @returnValue <> 0 OR @errorMessage IS NOT NULL BEGIN 
		SET @errorMessage = N'PowerShell Error: ' + @errorMessage;
		RAISERROR(@errorMessage, 16, 1);
		RETURN -22;
	END;

	CREATE TABLE #buckets ( 
		row_id int IDENTITY(1,1) NOT NULL, 
		bucket_name sysname NOT NULL, 
		created datetime NOT NULL, 
		region nvarchar(MAX) NULL
	);

	INSERT INTO [#buckets] (
		[bucket_name],
		[created]
	)
	SELECT 
		r.d.value(N'(./Property[@Name="BucketName"]/text())[1]', N'sysname') [bucket_name],
		r.d.value(N'(./Property[@Name="CreationDate"]/text())[1]', N'datetime') [created]
	FROM 
		@commandResults.nodes(N'Objects/Object') r(d);

	IF @ExcludedBuckets IS NOT NULL BEGIN 
		DECLARE @exclusions table ( 
			exclusion sysname NOT NULL 
		); 

		INSERT INTO @exclusions ([exclusion])
		SELECT 
			[result]
		FROM 
			dbo.[split_string](@ExcludedBuckets, N',', 1);

		DELETE x 
		FROM 
			[#buckets] x 
			INNER JOIN @exclusions e ON x.[bucket_name] LIKE e.[exclusion];
	END;

	IF @ExtractLocations = 1 BEGIN
		DECLARE @rowId int, @bucketName sysname, @regionName sysname; 

		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			row_id, 
			[bucket_name]
		FROM 
			[#buckets];
	
		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @rowId, @bucketName;
	
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			BEGIN TRY 
				SET @commandResults = NULL; 
				SET @currentCommand = N'Get-S3BucketLocation -BucketName "' + @bucketName +'" | ConvertTo-Xml -As Stream;'

				EXEC dbo.[execute_powershell]
					@Command = @currentCommand,
					@SerializedXmlOutput = @commandResults OUTPUT;

				SELECT @regionName = @commandResults.value(N'(/Objects/Object/Property/text())[1]', N'sysname');

	-- TODO: Looks like Get-S3BucketLocation is stupid/lame? if a bucket is NOT located in ... the current/default region ... we get
				--		the following as a result back from AWS: <Objects><Object Type="Amazon.S3.S3Region"><Property Name="Value" Type="System.String"/></Object></Objects>
				IF @regionName IS NULL 
					SET @regionName = CAST(@commandResults AS nvarchar(MAX));

			END TRY 
			BEGIN CATCH
				SET @regionName = N'# ERROR #';
			END CATCH;
		 
				UPDATE [#buckets] 
				SET 
					[region] = @regionName 
				WHERE 
					[row_id] = @rowId;
	
			FETCH NEXT FROM [walker] INTO @rowId, @bucketName;
		END;
	
		CLOSE [walker];
		DEALLOCATE [walker];
	END;

-- TODO: implement @ignored + join ... to exclude/remove any buckets not desired. 

	DECLARE @sql nvarchar(MAX) = N'SELECT 
		[bucket_name],
		[created]{region} 
	FROM 
		[#buckets]
	ORDER BY 
		{orderBy}; ';

	DECLARE @sort sysname = CASE @OrderBy 
		WHEN N'NAME' THEN N'bucket_name'
		WHEN N'REGION' THEN N'region'
		WHEN N'DATE' THEN N'created'
	END; 

	IF @ExtractLocations = 0 AND @sort = N'region' SET @sort = N'bucket_name';
	
	SET @sql = REPLACE(@sql, N'{orderBy}', @sort);

	IF @ExtractLocations = 0 
		SET @sql = REPLACE(@sql, N'{region}', N'');
	ELSE
		SET @sql = REPLACE(@sql, N'{region}', N',' + NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9) + N'[region]');

	EXEC sp_executesql 
		@sql;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.[aws3_verify_bucket_write]','P') IS NOT NULL
	DROP PROC dbo.[aws3_verify_bucket_write];
GO

CREATE PROC dbo.[aws3_verify_bucket_write]
	@TargetBucketName		sysname, 
	@TestKey				sysname, 
	@SkipBucketReadTest		bit			= 0			-- in some (restricted) environments, current machine/profile might NOT have Get-S3Bucket perms OR READ perms - just write perms.
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	EXEC dbo.[verify_advanced_capabilities];

	DECLARE @returnValue int; 
	DECLARE @errorMessage nvarchar(MAX); 
	DECLARE @commandResults xml;
	DECLARE @currentCommand nvarchar(MAX);

	BEGIN TRY 
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Import-Module -Name "AWS.Tools.S3"',
			@ErrorMessage = @errorMessage OUTPUT;	

	END TRY 
	BEGIN CATCH 
		SET @errorMessage = N'Unexpected Error Validating AWS.Tools.S3 Module Installed: Error ' + CAST(ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE();
		RAISERROR(@errorMessage, 16, 1);
		RETURN -10;
	END CATCH;

	-- verify that target bucket exists:
	IF @SkipBucketReadTest = 0 BEGIN
		BEGIN TRY 
			SET @currentCommand = N'Get-S3Bucket -BucketName "' + RTRIM(LTRIM(@TargetBucketName)) + N'"';
			DECLARE @stringOutput nvarchar(MAX);
			EXEC @returnValue = dbo.[execute_powershell]
				@Command = @currentCommand,
				@StringOutput = @stringOutput OUTPUT,
				@ErrorMessage = @errorMessage OUTPUT;
		
			IF NULLIF(@stringOutput, N'') IS NULL BEGIN 
				RAISERROR(N'@TargetBucketName: [%s] does not exist.', 16, 1, @TargetBucketName);
				RETURN -20;
			END;

		END TRY
		BEGIN CATCH 
			SET @errorMessage = N'Unexpected Error Validating @TargetBucketName: [' + @TargetBucketName + N']. Error ' + CAST(ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE();
			RAISERROR(@errorMessage, 16, 1);
			RETURN -22;
		END CATCH;
	END;

	SET @currentCommand = N'Write-S3Object -BucketName ''' + RTRIM(LTRIM(@TargetBucketName)) + N''' -Key ''' + @TestKey + N''' -Content ''Test Data - for Write-Test by admindb.'' -ConcurrentServiceRequest 2;';
	PRINT @currentCommand;
	PRINT N'';

	BEGIN TRY 
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = @currentCommand,
			@ExecutionAttemptsCount = 0,
			@StringOutput = @stringOutput OUTPUT,
			@ErrorMessage = @errorMessage OUTPUT;

		-- NOTE: if the error contains the text: "The bucket you are attempting to access must be addressed using the specified endpoint. Please send all future requests to this endpoint." 
		--		then ... the bucket does exist - but it's in a DIFFERENT AWS REGION than the one specified as the default AWS Region in the PROFILE being used. 
		-- there MIGHT be a 'fix' for this where you specify the FULLY qualified name of the bucket - something like: <bucketname>.s3-<region-name>.amazonaws.com. 
		--		some indications of POTENTIAL for this via this link: https://github.com/thoughtbot/paperclip/issues/2151 
		--		only I can't get it to work. 
		--		that said, CloudBerry Explorer shows that this format apparently works: https://emergencytransfer.s3.us-east-2.amazonaws.com/ 
		--			though, i'm guessing i don't need the https:// ? 
		--		only, when I TRY that I get "specified bucket does not exist". 
		--			here's an example: Write-S3Object -BucketName "emergencytransfer.s3.us-east-2.amazonaws.com" -Key "ooink" -Content "Test Content - for Write-Test by admindb." -ConcurrentServiceRequest 2;
		--		and, if I put "https://" in the bucket name ... i get: "The specified bucket is not valid". 
	END TRY 
	BEGIN CATCH 
		SET @errorMessage = N'Unexpected Error Executing Write-S3Object: Error ' + CAST(ERROR_NUMBER() AS sysname) + N': ' + ERROR_MESSAGE();
		RAISERROR(@errorMessage, 16, 1);
		RETURN -32;
	END CATCH;

	IF @errorMessage IS NOT NULL BEGIN 
		RAISERROR(N'Error: %s', 16, 1, @errorMessage); 
		RETURN -40;
	END;

	EXEC dbo.[print_long_string] @stringOutput;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.aws3_verify_configuration','P') IS NOT NULL
	DROP PROC dbo.[aws3_verify_configuration];
GO

CREATE PROC dbo.[aws3_verify_configuration]
	@VerifyNuget				bit				= 0,
	@VerifyGalleryAccess		bit				= 0,					-- where "Gallery" = powershell gallery - or internet connection
	@VerifyS3Modules			bit				= 1, 
	@VerifyProfile				bit				= 1, 
	@VerifyBuckets				bit				= 0, 
	@Results					xml				= N'<default/>'		OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @VerifyNuget = ISNULL(@VerifyNuget, 0);
	SET @VerifyGalleryAccess = ISNULL(@VerifyGalleryAccess, 0);
	SET @VerifyS3Modules = ISNULL(@VerifyS3Modules, 1);
	SET @VerifyProfile = ISNULL(@VerifyProfile, 1);
	SET @VerifyBuckets = ISNULL(@VerifyBuckets, 0);

	DECLARE @returnValue int; 
	DECLARE @stringResults nvarchar(MAX) = NULL;
	DECLARE @xmlResults xml	= NULL;
	DECLARE @errorMessage nvarchar(MAX);

	CREATE TABLE #results (
		row_id int IDENTITY(1,1) NOT NULL, 
		test sysname NOT NULL, 
		passed bit NOT NULL,
		details nvarchar(MAX) NOT NULL 
	);

	IF @VerifyNuget = 1 BEGIN 
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Get-PackageProvider -Name Nuget | Select-Object "Version" | ConvertTo-Xml -As Stream;',
			@SerializedXmlOutput = @xmlResults OUTPUT,
			@ErrorMessage = @errorMessage OUTPUT;

		IF @returnValue = 0 BEGIN 
			DECLARE @versionExists bit;
			SELECT 
				@versionExists = r.d.exist(N'Object/Property')
			FROM 
				@xmlResults.nodes(N'/Objects') r(d);

			IF @versionExists = 1 BEGIN 
				DECLARE @nugetVersion sysname;
				SELECT 
					@nugetVersion = r.d.value(N'./text()[1]', N'sysname')
				FROM 
					@xmlResults.nodes(N'/Objects/Object/Property') r(d);

				IF CAST((REPLACE(@nugetVersion, N'.', N'')) AS int) > 285201
					INSERT INTO [#results] (
						[test],
						[passed],
						[details]
					)
					VALUES (
						N'NugetVersion', 
						1, 
						N'Version ' + @nugetVersion + N' detected. (Required: 2.8.5.201+)'
					);
					
				ELSE 
					INSERT INTO [#results] (
						[test],
						[passed],
						[details]
					)
					VALUES (
						N'NugetVersion', 
						0, 
						N'Version ' + @nugetVersion + N' detected. (Required: 2.8.5.201+)'
					);
			  END;
			ELSE BEGIN 
				IF (CAST(@xmlResults AS nvarchar(MAX)) LIKE N'%Unable to find package provider ''NuGet''%')
					INSERT INTO [#results] (
						[test],
						[passed],
						[details]
					)
					VALUES (
						N'NugetVersion', 
						0, 
						N'Nuget is NOT installed.'
					);
				ELSE BEGIN 
					INSERT INTO [#results] (
						[test],
						[passed],
						[details]
					)
					VALUES (
						N'NugetVersion', 
						0, 
						-- TODO: maybe shove an [error] column into #results... 
						N'Unexpected Results from Get-PackageProvider -Name "Nuget". Results: ' + CAST(@xmlResults AS nvarchar(MAX))
					);
				END;
			END;
		  END;
		ELSE BEGIN 
			INSERT INTO [#results] (
				[test],
				[passed],
				[details]
			)
			VALUES (
				N'NugetVersion', 
				0, 
				'PowerShell Exception: ' + @errorMessage
			);
		END;
	END;

	/* Can we access the PowerShell Gallery? (which is BOTH a question of whether there's an internet connection AND whether box might be locked down by policy/etc.) */
	IF @VerifyGalleryAccess = 1 BEGIN 
		SET @xmlResults = NULL;
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Find-Module -Name "AWS.Tools.S3" | Select-Object "Version", "Name" | ConvertTo-Xml -As Stream;',
			@SerializedXmlOutput = @xmlResults OUTPUT,
			@ErrorMessage = @errorMessage OUTPUT;

		IF @returnValue = 0 BEGIN 
			DECLARE @awsVersion sysname;
			DECLARE @awsModuleName sysname;

			SELECT 
				@awsModuleName = r.d.value(N'(Property[@Name="Name"]/text())[1]', N'sysname'),
				@awsVersion = r.d.value(N'(Property[@Name="Version"]/text())[1]', N'sysname')
			FROM 
				@xmlResults.nodes(N'Objects/Object') r(d);		
	
			IF NULLIF(@awsVersion, N'') IS NOT NULL BEGIN 
				INSERT INTO [#results] (
					[test],
					[passed],
					[details]
				)
				VALUES (
					N'GalleryAccess', 
					1, 
					N'Found Module ' + @awsModuleName + N' with version ' + @awsVersion + N'.'
				);
			  END;
			ELSE BEGIN 
				INSERT INTO [#results] (
					[test],
					[passed],
					[details]
				)
				VALUES (
					N'GalleryAccess', 
					0, 
					N'Unexpected Result from Find-Module "AWS.Tools.S3": ' + CAST(@xmlResults AS nvarchar(MAX))
				);
			END;
		  END; 
		ELSE BEGIN 
			INSERT INTO [#results] (
				[test],
				[passed],
				[details]
			)
			VALUES (
				N'GalleryAccess', 
				0, 
				N'PowerShell Exception: ' + @errorMessage
			);
		END;
	END;

	IF @VerifyS3Modules = 1 BEGIN 
		SET @stringResults = NULL
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Import-Module -Name AWS.Tools.S3;',
			@StringOutput = @stringResults OUTPUT,
			@ErrorMessage = @errorMessage OUTPUT;
			
		IF @stringResults = N'' BEGIN 
			INSERT INTO [#results] (
				[test],
				[passed],
				[details]
			)
			VALUES (
				N'ModuleInstalled', 
				1, 
				N'Import-Module succeeded.'
			);
		  END; 
		ELSE BEGIN 
			IF @stringResults LIKE N'%The specified module ''%'' was not loaded because no valid module file was found in any%' BEGIN 
					INSERT INTO [#results] (
						[test],
						[passed],
						[details]
					)
					VALUES (
						N'ModuleInstalled', 
						0, 
						N'AWS.Tools.S3 Module is NOT installed.'
					);
				  END;
			ELSE BEGIN
				INSERT INTO [#results] (
					[test],
					[passed],
					[details]
				)
				VALUES (
					N'ModuleInstalled', 
					0, 
					N'Unexpected Output from Install-Module -Name "AWS.Tools.S3": Output: ' + @stringResults
				);
			END;
		END;
	END;

	IF @VerifyProfile = 1 BEGIN 
		IF @VerifyS3Modules = 1 BEGIN 
			IF EXISTS (SELECT NULL FROM [#results] WHERE [test] = N'ModuleInstalled' AND [passed] = 0) BEGIN
				INSERT INTO [#results] (
					[test],
					[passed],
					[details]
				)
				VALUES (
					N'ProfileConfigured', 
					0, 
					N'Test Skipped - AWS.Tools.S3 Module not present.'
				);	
			
				GOTO EndProfiles;
			END;
		END;

-- TODO: need to determine if the box in question is an EC2 instance, and, if so, if it has an EC2-InstanceProfile assigned. 
		-- i THINK the process here will be: a) hit the AWS/EC2 meta-data repository on that one ... address, and put in a timeout on the request of something like 5 seconds. 
		--									 b) if we get a result from the above, then check for a profile... otherwise, not an EC2 instance. 
		-- this might also help: https://serverfault.com/questions/607223/how-do-i-know-if-i-run-on-amazon-ec2-windows-instance 

		SET @xmlResults = NULL;
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Get-AWSCredential -ListProfileDetail | ConvertTo-Xml -As Stream;', 
			@SerializedXmlOutput = @xmlResults OUTPUT, 
			@ErrorMessage = @errorMessage OUTPUT;

		DECLARE @profiles table (profile_name sysname NOT NULL);

		IF @returnValue = 0 BEGIN 

			DECLARE @profilesExist bit;
			SELECT 
				@profilesExist = [r].[d].exist(N'Object/Property')
			FROM 
				@xmlResults.nodes(N'/Objects') [r]([d]);

			IF @profilesExist = 1 BEGIN 			
				INSERT INTO @profiles ([profile_name])
				SELECT 
					r.d.value(N'(./Property[@Name="ProfileName"]/text())[1]', N'sysname')
				FROM 
					@xmlResults.nodes(N'Objects/Object') r(d);

				DECLARE @profilesCount int = (SELECT COUNT(*) FROM @profiles);
				IF EXISTS (SELECT NULL FROM @profiles WHERE [profile_name] = N'default') BEGIN 
					INSERT INTO [#results] (
						[test],
						[passed],
						[details]
					)
					VALUES (
						N'ProfileConfigured', 
						1, 
						N'Detected ' + CAST(@profilesCount AS sysname) + N' profile(s) - including ''default'' profile.'
					);					
					END; 
				ELSE BEGIN 
					INSERT INTO [#results] (
						[test],
						[passed],
						[details]
					)
					VALUES (
						N'ProfileConfigured', 
						0, 
						N'Detected ' + CAST(@profilesCount AS sysname) + N' profile(s) - but the ''default'' profile was NOT found.'
					);				
				END;
			  END; 
			ELSE BEGIN 
				GOTO NoProfilesFound;
			END;
		  END;
		ELSE BEGIN 
NoProfilesFound:
			INSERT INTO [#results] (
				[test],
				[passed],
				[details]
			)
			VALUES (
				N'ProfileConfigured', 
				0, 
				N'No AWS Profiles Defined/Detected.'
			);	
		END;
	END;
EndProfiles:

	IF @VerifyBuckets = 1 BEGIN 
		IF @VerifyProfile = 1 BEGIN 
			IF EXISTS (SELECT NULL FROM [#results] WHERE [test] = N'ProfileConfigured' AND [passed] = 0) BEGIN
				INSERT INTO [#results] (
					[test],
					[passed],
					[details]
				)
				VALUES (
					N'BucketsExist', 
					0, 
					N'Test Skipped - a valid profile was not detected or is not configured.'
				);	
			
				GOTO EndBuckets;
			END;
		END;
		
		SET @xmlResults = NULL;
		EXEC @returnValue = dbo.[execute_powershell]
			@Command = N'Get-S3Bucket | ConvertTo-Xml -As Stream;', 
			@SerializedXmlOutput = @xmlResults OUTPUT, 
			@ErrorMessage = @errorMessage OUTPUT;

		DECLARE @buckets table (bucket_name sysname NOT NULL);

		IF @returnValue = 0 BEGIN 
			INSERT INTO @buckets ([bucket_name])
			SELECT 
				r.d.value(N'(./Property[@Name="BucketName"]/text())[1]', N'sysname') [bucket_name]
			FROM 
				@xmlResults.nodes(N'Objects/Object') r(d);

			DECLARE @bucketsCount int = (SELECT COUNT(*) FROM @buckets);

			IF @bucketsCount > 0 BEGIN 
				INSERT INTO [#results] (
					[test],
					[passed],
					[details]
				)
				VALUES (
					N'BucketsExist', 
					1, 
					N'Detected ' + CAST(@bucketsCount AS sysname) + N' bucket(s).'
				);	
			  END; 
			ELSE BEGIN 
				INSERT INTO [#results] (
					[test],
					[passed],
					[details]
				)
				VALUES (
					N'BucketsExist', 
					0, 
					N'No AWS Buckets Defined/Detected.'
				);	
			END;
		  END;
		ELSE BEGIN 
			PRINT 'no buckets';
		END;
	END;
EndBuckets:

	IF (SELECT dbo.is_xml_empty(@Results)) = 1 BEGIN -- RETURN instead of project.. 
		SELECT @Results = (SELECT 
			[test],
			[passed],
			[details]
		FROM 
			[#results] 
		ORDER BY 
			[row_id]
		FOR XML PATH(N'result'), ROOT(N'results'), TYPE);

		RETURN 0;
	END;

	SELECT 
		[test],
		[passed],
		[details]
	FROM 
		[#results] 
	ORDER BY 
		[row_id];

	RETURN 0; 
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Idioms
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.idiom_for_batched_operation','P') IS NOT NULL
	DROP PROC dbo.[idiom_for_batched_operation];
GO
 
CREATE PROC dbo.[idiom_for_batched_operation]
	@BatchSize							int, 
	@WaitFor							sysname				= N'00:00:01.500',
	@BatchStatement						nvarchar(MAX)		= NULL,
	@BatchModeStatementType				sysname				= N'DELETE',	-- { DELETE | MOVE | NONE } 
	@StrictRowCountMode					sysname				= N'THROW',		-- { NONE | WARN | THROW }  -- where THROW = ROLLBACK & throw. @StrictRowCountMode = a safety mechanism. Assume we're working against some 'child' table, and expect to delete 1000 rows, but manage to DELET, say, 80,890 rows instead - because an FK/JOIN is muffed in our @BatchStatement? At that point, it'd be NICE to have a ROLLBACK and THROW ... vs just keeping on going.
	@LoggingTableName					sysname				= N'{DEFAULT}',
	@MaxExecutionSeconds				int					= NULL, 
	@AllowDynamicBatchSizing			bit					= 1, 
	@MaxAllowedBatchSizeMultiplier		int					= 5,			-- i.e., if @BatchSize = 2000, and @AllowDynamicBatchSizing = 1, this means we can/could get to a batch-size (max) of 5 * 2K or 10K.
	@TargetBatchMilliseconds			int					= 4000, 
	@MaxAllowedErrors					int					= 1, 
	@TreatDeadlocksAsErrors				bit					= 0,
	@StopIfTempTableExists				sysname				= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @WaitFor = NULLIF(@WaitFor, N'');
	SET @StopIfTempTableExists = NULLIF(@StopIfTempTableExists, N'');
	SET @BatchStatement = NULLIF(@BatchStatement, N'');
	SET @LoggingTableName = NULLIF(@LoggingTableName, N'');
	SET @BatchModeStatementType = NULLIF(@BatchModeStatementType, N'');
	
	SET @LoggingTableName = ISNULL(@LoggingTableName, N'{DEFAULT}');
	SET @BatchModeStatementType = ISNULL(@BatchModeStatementType, N'DELETE');
	SET @AllowDynamicBatchSizing = ISNULL(@AllowDynamicBatchSizing, 1);
	SET @TargetBatchMilliseconds = ISNULL(@TargetBatchMilliseconds, 4000);
	SET @MaxAllowedBatchSizeMultiplier = ISNULL(@MaxAllowedBatchSizeMultiplier, 5);
	SET @MaxAllowedErrors = ISNULL(@MaxAllowedErrors, 1);
	SET @TreatDeadlocksAsErrors = ISNULL(@TreatDeadlocksAsErrors, 0);

	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);

	---------------------------------------------------------------------------------------------------
	-- Input processing/logic:
	---------------------------------------------------------------------------------------------------
	IF UPPER(@LoggingTableName) = N'{DEFAULT}' SET @LoggingTableName = N'#batched_operation_' + LEFT(CAST(NEWID() AS sysname), 8);

	IF @BatchStatement IS NULL BEGIN 
		IF UPPER(@BatchModeStatementType) = N'NONE' BEGIN

			SET @BatchStatement = N'Specify your batched T-SQL operation here. Note, you''ll want to try to use PKs/CLIXes and avoid NON-SARGable operations as much as possible.';
		END;

		IF UPPER(@BatchModeStatementType) = N'MOVE' BEGIN 
			SET @BatchStatement = N'			-- NOTE: you''ll have to create this table up BEFORE the WHILE @currentRowsProcessed = @BatchSize BEGIN loop starts... 
			--  it holds details on the rows REMOVED from the old table and to be SHOVED into the new table ... 
			--CREATE TABLE #MigrationTable (
			--	migration_row_id int IDENTITY(1,1) NOT NULL, 
				
			--	-- now, ''duplicate'' the schema of the table/rows you''ll be moving - i.e., column-names, data-types, and NULL/NON-NULL (you can ignore constraints).

			--	[column_1_to_copy] datatype_here [NOT NULL, 
			--	[column_2_to_copy] datatype_here NOT NULL, 
			--	-- etc.
			--	[column_N_to_copy] datatype_here NOT NULL
			--);


			TRUNCATE TABLE #MigrationTable;
			UPDATE [x] WITH(ROWLOCK)
			SET
				[x].[CopiedToNewTable] = 1  -- i.e., some sort of column to ''mark'' rows as transactionally moved. ALTER <myTable> ADD CopiedToNewTable bit NULL; -- if you make this NON-NULL, it''ll be a size of data operation.
			OUTPUT
				[Deleted].[column_1_to_copy],
				[Deleted].[column_2_to_copy],
				[Deleted].[column_3_to_copy],
				[Deleted].[column_4_to_copy],
				-- etc... 
				[Deleted].[column_N_to_copy]
			INTO #MigrationTable
			FROM 
				( 
					SELECT TOP (@BatchSize) * FROM [<table_to_move_rows_from, sysname, MySourceTable>] WHERE ([CopiedToNewTable] IS NULL OR [CopiedToNewTable] = 0) ORDER BY [<optional_orderby_column, sysname, CanBeRemoved>]
				) [x];

			--SELECT * FROM #MigrationTable

			INSERT INTO [<table_to_move_rows_TO, sysname, MyTargetTable>] WITH(ROWLOCK) (
				[column_1_to_copy],
				[column_2_to_copy],
				[column_3_to_copy],
				[column_4_to_copy],
				-- etc
				[column_N_to_copy]
			)
			SELECT
				[column_1_to_copy],
				[column_2_to_copy],
				[column_3_to_copy],
				[column_4_to_copy], 
				-- etc
				[column_N_to_copy]
			FROM
				 #MigrationTable;

				 -- USUALLY makes sense to let the engine figure out the best way to sort/order-by
			-- Later - i.e., once all rows are moved or ... whenever you want, you can DELETE FROM <your_source_table> WHERE [CopiedToNewTable] = 1'

		END;

		IF UPPER(@BatchModeStatementType) = N'DELETE' BEGIN 
			SET @BatchStatement = N'			
			DELETE [t]
			FROM dbo.[<target_table, sysname, TableToDeleteFrom>] t WITH(ROWLOCK)
			INNER JOIN (
				SELECT TOP (@BatchSize) 
					[<id_column, sysname, NameOfPrimaryKeyOrClixID>]  -- this is the ID of the row to be deleted, e.g., TicketID, ActivityID, UserId, Cart_Session_ID, etc. 
				FROM 
					dbo.[<target_table, sysname, TableToDeleteFrom>] WITH(NOLOCK)  -- For NON-DIRTY reads, MOST systems/scenarios can use WITH(READCOMMITTED, ROWLOCK, READPAST) which SKIPS locked rows (idea is it gets them later).
				WHERE 
					[<timestamp_column, sysname, NameOfTimeStampColumn>] < DATEADD(DAY, 0 - @DaysWorthOfDataToKeep, GETUTCDATE()) -- name of the datetime column to use for deletes, e.g., timestamp, create_time, entry_time, last_updated, etc. Should have a solid IX defined.
				) x ON t.[<id_column, sysname, NameOfPrimaryKeyOrClixID>]= x.[<id_column, sysname, NameOfPrimaryKeyOrClixID>];';

		END;
	END;

	---------------------------------------------------------------------------------------------------
	-- Initialization:
	---------------------------------------------------------------------------------------------------
	DECLARE @initialization nvarchar(MAX) = N'---------------------------------------------------------------------------------------------------------------
-- Setup:
---------------------------------------------------------------------------------------------------------------
SET NOCOUNT ON; 

DROP TABLE IF EXISTS [{logging_table_name}];
CREATE TABLE [{logging_table_name}] (
	[detail_id] int IDENTITY(1,1) NOT NULL, 
	[timestamp] datetime NOT NULL DEFAULT GETDATE(), 
	[is_error] bit NOT NULL DEFAULT (0), 
	[rolled_back] bit NOT NULL DEFAULT (0),
	[batch_size] int NOT NULL, 
	[wait_for] sysname NOT NULL, 
	[current_rows_processed] int NOT NULL, 
	[total_rows_processed] int NOT NULL, 
	[current_batch_milliseconds] int NOT NULL, 
	[cummulative_milliseconds] int NOT NULL, 
	[warning] nvarchar(MAX) NULL, 
	[error] nvarchar(MAX) NULL
); 

DECLARE @WaitForDelay sysname = N''{wait_for}''; 
DECLARE @BatchSize int = {batch_size};{Max_Allowed_Errors}{Dynamic_Batching_Params}{Max_Execution_Seconds}{strict_rowcount_mode}

-- Processing (variables/etc.)
DECLARE @continue bit = 1;
DECLARE @currentRowsProcessed int = @BatchSize; 
DECLARE @totalRowsProcessed int = 0;
DECLARE @errorDetails nvarchar(MAX);
DECLARE @errorsOccured bit = 0;
DECLARE @rolledBack bit = 0;
DECLARE @currentErrorCount int = 0;{deadlock_declaration}
DECLARE @startTime datetime = GETDATE();
DECLARE @batchStart datetime;{dynamic_batching_declarations}
';
	
	SET @initialization = REPLACE(@initialization, N'{logging_table_name}', @LoggingTableName);
	SET @initialization = REPLACE(@initialization, N'{wait_for}', @WaitFor);
	SET @initialization = REPLACE(@initialization, N'{batch_size}', @BatchSize);
	SET @initialization = REPLACE(@initialization, N'{Batch_Statement}', @BatchStatement);

	DECLARE @dynamicBatches nvarchar(MAX) = N'DECLARE @milliseconds int;
DECLARE @initialBatchSize int = @BatchSize;
	';

	IF @MaxAllowedErrors > 1 BEGIN 
		SET @initialization = REPLACE(@initialization, N'{Max_Allowed_Errors}', @crlf + N'DECLARE @MaxAllowedErrors int = ' + CAST(@MaxAllowedErrors AS sysname) + N';');
	  END;
	ELSE BEGIN
		SET @initialization = REPLACE(@initialization, N'{Max_Allowed_Errors}', N'');
	END;

	IF @TreatDeadlocksAsErrors = 1 BEGIN 
		SET @initialization = REPLACE(@initialization, N'{deadlock_declaration}', @crlf + N'DECLARE @deadlockOccurred bit = 0;');
	  END; 
	ELSE BEGIN 
		SET @initialization = REPLACE(@initialization, N'{deadlock_declaration}', N'');
	END;

	IF @AllowDynamicBatchSizing = 1 BEGIN 
		SET @initialization = REPLACE(@initialization, N'{Dynamic_Batching_Params}', @crlf + N'DECLARE @MaxAllowedBatchSizeMultiplier int = ' + CAST(@MaxAllowedBatchSizeMultiplier AS sysname) + N';' + @crlf + N'DECLARE @TargetBatchMilliseconds int = ' + CAST(@TargetBatchMilliseconds AS sysname) + N';');
		SET @initialization = REPLACE(@initialization, N'{dynamic_batching_declarations}', @crlf + @dynamicBatches);
	  END; 
	ELSE BEGIN 
		SET @initialization = REPLACE(@initialization, N'{Dynamic_Batching_Params}', N'');
		SET @initialization = REPLACE(@initialization, N'{dynamic_batching_declarations}', N'{}');
	END;

	IF @MaxExecutionSeconds > 0 BEGIN 
		SET @initialization = REPLACE(@initialization, N'{Max_Execution_Seconds}', @crlf + N'DECLARE @MaxExecutionSeconds int = ' + CAST(@MaxExecutionSeconds AS sysname) + N';');
	  END; 
	ELSE BEGIN 
		SET @initialization = REPLACE(@initialization, N'{Max_Execution_Seconds}', N'');
	END;

	IF @StrictRowCountMode = N'NONE' BEGIN 
		SET @initialization = REPLACE(@initialization, N'{strict_rowcount_mode}', N'');
	  END;
	ELSE BEGIN 
		SET @initialization = REPLACE(@initialization, N'{strict_rowcount_mode}', @crlf + N'DECLARE @StrictRowCountMode sysname = ''' + @StrictRowCountMode + N''';');
	END;

	---------------------------------------------------------------------------------------------------
	-- Body:
	---------------------------------------------------------------------------------------------------
	DECLARE @body nvarchar(MAX) = N'---------------------------------------------------------------------------------------------------------------
-- Processing:
---------------------------------------------------------------------------------------------------------------
WHILE @continue = 1 BEGIN 
	
	SET @batchStart = GETDATE();
	SET @errorsOccured = 0, @rolledBack = 0;
	
	BEGIN TRY
		BEGIN TRAN; 
				
			-------------------------------------------------------------------------------------------------
			-- batched operation code:
			-------------------------------------------------------------------------------------------------
--!!!!!!!!-- Specify YOUR code here, i.e., this is just a TEMPLATE:
{Batch_Statement} 
--!!!!!!!! - end YOUR code... 

			-------------------------------------------

			SELECT 
				@currentRowsProcessed = @@ROWCOUNT, 
				@totalRowsProcessed = @totalRowsProcessed + @@ROWCOUNT;

		COMMIT; 

		IF @currentRowsProcessed <> @BatchSize SET @continue = 0;{StrictRowCountHandling}

		INSERT INTO [{logging_table_name}] (
			[timestamp],
			[batch_size], 
			[wait_for], 
			[current_rows_processed], 
			[total_rows_processed], 
			[current_batch_milliseconds], 
			[cummulative_milliseconds]
		)
		SELECT 
			GETDATE() [timestamp], 
			@BatchSize [batch_size], 
			@WaitForDelay [wait_for], 
			@currentRowsProcessed [current_rows_processed], 
			@totalRowsProcessed [total_rows_processed],
			DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [current_batch_milliseconds], 
			DATEDIFF(MILLISECOND, @startTime, GETDATE())[cummulative_milliseconds];{MaxSeconds}{TerminateIfTempObject}{DynamicTuning}
		
		WAITFOR DELAY @WaitForDelay;
	END TRY
	BEGIN CATCH 
			
		{TreatDeadlocksAsErrors}SELECT @errorDetails = N''Error Number: '' + CAST(ERROR_NUMBER() AS sysname) + N''. Message: '' + ERROR_MESSAGE();

		IF @@TRANCOUNT > 0 BEGIN
			ROLLBACK; 
			SET @rolledBack = 1;
		END;

		INSERT INTO [{logging_table_name}] (
			[timestamp],
			[is_error],
			[rolled_back], 
			[batch_size], 
			[wait_for], 
			[current_rows_processed], 
			[total_rows_processed], 
			[current_batch_milliseconds], 
			[cummulative_milliseconds],
			[error]
		)
		SELECT
			GETDATE() [timestamp], 
			1 [is_error], 
			@rolledBack [rolled_back], 
			@BatchSize [batch_size], 
			@WaitForDelay [wait_for], 
			@currentRowsProcessed [current_rows_processed], 
			@totalRowsProcessed [total_rows_processed],
			DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [current_batch_milliseconds], 
			DATEDIFF(MILLISECOND, @startTime, GETDATE())[cummulative_milliseconds],
			@errorDetails [error];{MaxSeconds}{TerminateIfTempObject}{DynamicTuning}
					   
		SET @errorsOccured = 1;
		
		{MaxErrors}
	END CATCH;
END;

';
	
	DECLARE @maxSeconds nvarchar(MAX) = N'IF DATEDIFF(SECOND, @startTime, GETDATE()) >= {Max_Allowed_Execution_Seconds} BEGIN 
			INSERT INTO [{logging_table_name}] (
				[timestamp],
				[is_error],
				[rolled_back], 
				[batch_size], 
				[wait_for], 
				[current_rows_processed], 
				[total_rows_processed], 
				[current_batch_milliseconds], 
				[cummulative_milliseconds],
				[error]
			)
			SELECT
				GETDATE() [timestamp], 
				1 [is_error], 
				@rolledBack [rolled_back], 
				@BatchSize [batch_size], 
				@WaitForDelay [wait_for], 
				@currentRowsProcessed [current_rows_processed], 
				@totalRowsProcessed [total_rows_processed],
				DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [current_batch_milliseconds], 
				DATEDIFF(MILLISECOND, @startTime, GETDATE())[cummulative_milliseconds],
				CONCAT(N''Maximum execution seconds allowed for execution met/exceeded. Max Allowed Seconds: '', {Max_Allowed_Execution_Seconds}, N''.'') [error];
			
			SET @errorsOccured = 1;

			GOTO Finalize;		
		END;';
	DECLARE @tempdbTerminate nvarchar(MAX) = N'IF OBJECT_ID(N''tempdb..{tempdb_safe_stop_name}'') IS NOT NULL BEGIN 
			INSERT INTO [{logging_table_name}] (
				[timestamp],
				[is_error],
				[rolled_back], 
				[batch_size], 
				[wait_for], 
				[current_rows_processed], 
				[total_rows_processed], 
				[current_batch_milliseconds], 
				[cummulative_milliseconds],
				[error]				
			)
			SELECT
				GETDATE() [timestamp], 
				1 [is_error], 
				@rolledBack [rolled_back], 
				@BatchSize [batch_size], 
				@WaitForDelay [wait_for], 
				@currentRowsProcessed [current_rows_processed], 
				@totalRowsProcessed [total_rows_processed],
				DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [current_batch_milliseconds], 
				DATEDIFF(MILLISECOND, @startTime, GETDATE())[cummulative_milliseconds],
				N''Graceful execution shutdown/bypass directive detected - object [{tempdb_safe_stop_name}] found in tempdb. Terminating Execution.'' [error];
			
			SET @errorsOccured = 1;

			GOTO Finalize;
		END;';
	DECLARE @dynamicTuning nvarchar(MAX) = N'-- Dynamic Tuning:
		SET @milliseconds = DATEDIFF(MILLISECOND, @batchStart, GETDATE());
		IF @milliseconds <= @TargetBatchMilliseconds BEGIN 
			IF @BatchSize < (@initialBatchSize * @MaxAllowedBatchSizeMultiplier) BEGIN

				SET @BatchSize = FLOOR((@BatchSize + (@BatchSize * .2)) / 100) * 100; 
				IF @BatchSize > (@initialBatchSize * @MaxAllowedBatchSizeMultiplier) 
					SET @BatchSize = (@initialBatchSize * @MaxAllowedBatchSizeMultiplier);
			END;
		  END;
		ELSE BEGIN 
			IF @BatchSize > (@initialBatchSize / @MaxAllowedBatchSizeMultiplier) BEGIN

				SET @BatchSize = FLOOR((@BatchSize - (@BatchSize * .2)) / 100) * 100;
				IF @BatchSize < (@initialBatchSize / @MaxAllowedBatchSizeMultiplier)
					SET @BatchSize = (@initialBatchSize / @MaxAllowedBatchSizeMultiplier);
			END;
		END; 
		IF @BatchSize <> @currentRowsProcessed SET @currentRowsProcessed = @BatchSize; -- preserve looping capabilities (i.e., AFTER we''ve logged details). ';
	DECLARE @deadlocksAsErrors nvarchar(MAX) = N'IF ERROR_NUMBER() = 1205 BEGIN
		
			INSERT INTO [{logging_table_name}] (
				[timestamp],
				[is_error],
				[rolled_back], 
				[batch_size], 
				[wait_for], 
				[current_rows_processed], 
				[total_rows_processed], 
				[current_batch_milliseconds], 
				[cummulative_milliseconds],
				[error]	
			)
			SELECT
				GETDATE() [timestamp], 
				1 [is_error], 
				@rolledBack [rolled_back], 
				@BatchSize [batch_size], 
				@WaitForDelay [wait_for], 
				@currentRowsProcessed [current_rows_processed], 
				@totalRowsProcessed [total_rows_processed],
				DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [current_batch_milliseconds], 
				DATEDIFF(MILLISECOND, @startTime, GETDATE())[cummulative_milliseconds],
				N''Deadlock Detected. Logging to history table - but not counting deadlock as normal error for purposes of error handling/termination.'' [error];
					   
			SET @deadlockOccurred = 1;		
		END; ';
	DECLARE @maxErrors nvarchar(MAX) = N'SET @currentErrorCount = @currentErrorCount + 1; 
		IF @currentErrorCount >= @MaxAllowedErrors BEGIN 
			INSERT INTO [{logging_table_name}] (
				[timestamp],
				[is_error],
				[rolled_back], 
				[batch_size], 
				[wait_for], 
				[current_rows_processed], 
				[total_rows_processed], 
				[current_batch_milliseconds], 
				[cummulative_milliseconds],
				[error]	
			)
			SELECT
				GETDATE() [timestamp], 
				1 [is_error], 
				@rolledBack [rolled_back], 
				@BatchSize [batch_size], 
				@WaitForDelay [wait_for], 
				@currentRowsProcessed [current_rows_processed], 
				@totalRowsProcessed [total_rows_processed],
				DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [current_batch_milliseconds], 
				DATEDIFF(MILLISECOND, @startTime, GETDATE())[cummulative_milliseconds],				
				CONCAT(N''Max allowed errors count reached/exceeded: '', @MaxAllowedErrors, N''. Terminating Execution.'') [error];

			GOTO Finalize;
		END;';
	DECLARE @strictRowCountHandling nvarchar(MAX) = N'IF @currentRowsProcessed > @BatchSize BEGIN 
			
			IF UPPER(@StrictRowCountMode) = N''WARN'' BEGIN 
				PRINT ''hmmm.. treat this as an error, print it? or ... what?''; -- can''t be an error, that''d cause a rollback... so, need a decent way to warn... MAYBE add a WARNING column to the #logging_table?
			  END; 
			ELSE BEGIN 
				-- NOTE: no need to EXPLICITLY execute a ROLLBACK, because a ROLLBACK will be tackled in the CATCH. 
				RAISERROR(N''Fatal Exception. @StrictRowCountMode is enabled and # of rows (%i) processed in current ''''loop'''' was greater than @BatchSize (%i)'', 16, 1, @currentRowsProcessed, @BatchSize);
			END; 
		END;';

	IF @MaxAllowedErrors > 1 BEGIN 
		SET @body = REPLACE(@body, N'{MaxErrors}', @maxErrors);
	  END; 
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{MaxErrors}', N'GOTO Finalize;');
	END;

	IF @MaxExecutionSeconds > 0 BEGIN 
		SET @maxSeconds = REPLACE(@maxSeconds, N'{Max_Allowed_Execution_Seconds}', N'@MaxExecutionSeconds');
		SET @body = REPLACE(@body, N'{MaxSeconds}', @crlf + @crlf + @tab + @tab + @maxSeconds);

	  END; 
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{MaxSeconds}', N'');
	END;
	
	IF @StopIfTempTableExists IS NOT NULL BEGIN 
		SET @tempdbTerminate = REPLACE(@tempdbTerminate, N'{tempdb_safe_stop_name}', @StopIfTempTableExists);
		SET @body = REPLACE(@body, N'{TerminateIfTempObject}',@crlf + @crlf + @tab + @tab + @tempdbTerminate);
	  END;
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{TerminateIfTempObject}', N'');
	END;

	IF @AllowDynamicBatchSizing = 1 BEGIN 
		SET @body = REPLACE(@body, N'{DynamicTuning}', @crlf + @crlf + @tab + @tab + @dynamicTuning);
	  END;
	ELSE BEGIN
		SET @body = REPLACE(@body, N'{DynamicTuning}', N'');
	END;

	IF @TreatDeadlocksAsErrors = 1 BEGIN 
		SET @body = REPLACE(@body, N'{TreatDeadlocksAsErrors}', @deadlocksAsErrors + @crlf + @crlf + @tab + @tab);
	  END;
	ELSE BEGIN
		SET @body = REPLACE(@body, N'{TreatDeadlocksAsErrors}', N'');
	END;

	IF UPPER(@StrictRowCountMode) = N'NONE' BEGIN 
		SET @body = REPLACE(@body, N'{StrictRowCountHandling}', N'');
	  END; 
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{StrictRowCountHandling}', @crlf + @crlf + @tab + @tab + @strictRowCountHandling);
	END;

	SET @body = REPLACE(@body, N'{Batch_Statement}', @tab + @tab + @tab + @BatchStatement);
	SET @body = REPLACE(@body, N'{logging_table_name}', @LoggingTableName);

	---------------------------------------------------------------------------------------------------
	-- Cleanup
	---------------------------------------------------------------------------------------------------
	DECLARE @cleanup nvarchar(MAX) = N'---------------------------------------------------------------------------------------------------------------
-- Cleanup/Reporting:
---------------------------------------------------------------------------------------------------------------

Finalize:

{deadlock_report}IF @errorsOccured = 1 BEGIN 
	SELECT * FROM [{logging_table_name}] WHERE [is_error] = 1;
END;

PRINT N''-- NOTE: To view Output from logging history, run: { SELECT * FROM [{logging_table_name}] ORDER BY [timestamp]; } '';
';

	DECLARE @deadlockBlock nvarchar(MAX) = N'IF @deadlockOccurred = 1 BEGIN 
	PRINT N''NOTE: One or more deadlocks occurred - and were logged to [{logging_table_name}] ''; 
END;'

	IF @TreatDeadlocksAsErrors = 1 BEGIN 
		SET @cleanup = REPLACE(@cleanup, N'{deadlock_report}', @deadlockBlock + @crlf + @crlf);
	  END; 
	ELSE BEGIN 
		SET @cleanup = REPLACE(@cleanup, N'{deadlock_report}', N'');
	END;

	SET @cleanup = REPLACE(@cleanup, N'{logging_table_name}', @LoggingTableName);

	---------------------------------------------------------------------------------------------------
	-- Output/Projection:
	---------------------------------------------------------------------------------------------------

	EXEC [admindb].dbo.[print_long_string] @initialization;
	EXEC [admindb].dbo.[print_long_string] @body;
	EXEC [admindb].dbo.[print_long_string] @cleanup;

	RETURN 0
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.blueprint_for_batched_operation','P') IS NOT NULL
	DROP PROC dbo.[blueprint_for_batched_operation];
GO

CREATE PROC dbo.[blueprint_for_batched_operation]
	@DefaultNumberOfDaysToKeep						int, 
	@DefaultBatchSize								int, 
	@DefaultWaitDuration							sysname			= N'00:00:01.55',

	@TargetDatabase									sysname			= N'<db_name_here>',
	@GeneratedSprocSchema							sysname			= N'dbo',
	@GeneratedSprocName								sysname			= N'<sproc_name_here>', 

	@PreProcessingStatement							nvarchar(MAX)	= NULL,
	@BatchStatement									nvarchar(MAX)	= NULL,		
	@BatchModeStatementType							sysname			= N'DELETE',   -- { DELETE | MOVE | NONE } 

	@AllowConfigTableOverride						bit				= 1,				-- if present, then config is possible.
	@ConfigurationTableName							sysname			= NULL, 

	@AllowDynamicBatchSizing						bit				= 1, 
	@AllowMaxErrors									bit				= 1, 
	@AllowDeadlocksAsErrors							bit				= 1, 
	@AllowMaxExecutionSeconds						bit				= 1, 
	@AllowStopOnTempTableExists						bit				= 1, 
	@LoggingHistoryTableName						sysname, 
	@DefaultHistoryLoggingLevel						sysname			= N'SIMPLE'		-- { SIMPLE | DETAIL }  -- errors are always included... 
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	------------------------------------------------------------------------------------------------------------------------------
	-- Validate Inputs:
	-- i.e., input params for THIS blueprint sproc... 

	SET @TargetDatabase = ISNULL(NULLIF(@TargetDatabase, N''), N'<db_name_here>');
	SET @GeneratedSprocName = ISNULL(NULLIF(@GeneratedSprocName, N''), N'<sproc_name_here>');
	SET @DefaultWaitDuration = ISNULL(NULLIF(@DefaultWaitDuration, N''), N'00:00:01.500');
	SET @BatchModeStatementType = ISNULL(NULLIF(@BatchModeStatementType, N''), N'DELETE');
	SET @DefaultHistoryLoggingLevel = ISNULL(NULLIF(@DefaultHistoryLoggingLevel, N''), N'SIMPLE');

	SET @ConfigurationTableName = NULLIF(@ConfigurationTableName, N'');
	SET @LoggingHistoryTableName = NULLIF(@LoggingHistoryTableName, N'');
	SET @BatchStatement = NULLIF(@BatchStatement, N'');
	SET @PreProcessingStatement = NULLIF(@PreProcessingStatement, N'');
	   
	--IF (@DefaultBatchSize IS NULL OR @DefaultBatchSize < 0) OR (@DefaultNumberOfDaysToKeep IS NULL OR @DefaultNumberOfDaysToKeep < 0) BEGIN 
	--	RAISERROR('@DefaultBatchSize and @DefaultNumberOfDaysToKeep must both be set to non-NULL values > 0 - even when @UseConfig = 1.', 16, 1);
	--	RETURN -6;
	--END;

	IF @AllowConfigTableOverride = 1 BEGIN 
		IF @ConfigurationTableName IS NULL BEGIN
			RAISERROR(N'A configuration table must be supplied via the @ConfigurationTableName parameter when @AllowConfigTableOverride is set to 1.', 16, 1);
			RETURN -10;
		END;
	END;

	------------------------------------------------------------------------------------------------------------------------------
	-- Header/Signature:
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);

	DECLARE @loggingTableName sysname = N'#batched_operation_' + LEFT(CAST(NEWID() AS sysname), 8);

	---------------------------------------------------------------------------------------------------
	-- Batch Statement Defaults/Templates:
	---------------------------------------------------------------------------------------------------
	IF @BatchStatement IS NULL BEGIN 
		IF UPPER(@BatchModeStatementType) = N'NONE' BEGIN

			SET @BatchStatement = N'Specify your batched T-SQL operation here. Note, you''ll want to try to use PKs/CLIXes and avoid NON-SARGable operations as much as possible.';
		END;

		IF UPPER(@BatchModeStatementType) = N'MOVE' BEGIN 
			SET @BatchStatement = N'			-- NOTE: you''ll have to create this table up BEFORE the WHILE @currentRowsProcessed = @BatchSize BEGIN loop starts... 
			--  it holds details on the rows REMOVED from the old table and to be SHOVED into the new table ... 
			--CREATE TABLE #MigrationTable (
			--	migration_row_id int IDENTITY(1,1) NOT NULL, 
				
			--	-- now, ''duplicate'' the schema of the table/rows you''ll be moving - i.e., column-names, data-types, and NULL/NON-NULL (you can ignore constraints).

			--	[column_1_to_copy] datatype_here [NOT NULL, 
			--	[column_2_to_copy] datatype_here NOT NULL, 
			--	-- etc.
			--	[column_N_to_copy] datatype_here NOT NULL
			--);


			TRUNCATE TABLE #MigrationTable;
			UPDATE [x] WITH(ROWLOCK)
			SET
				[x].[CopiedToNewTable] = 1  -- i.e., some sort of column to ''mark'' rows as transactionally moved. ALTER <myTable> ADD CopiedToNewTable bit NULL; -- if you make this NON-NULL, it''ll be a size of data operation.
			OUTPUT
				[Deleted].[column_1_to_copy],
				[Deleted].[column_2_to_copy],
				[Deleted].[column_3_to_copy],
				[Deleted].[column_4_to_copy],
				-- etc... 
				[Deleted].[column_N_to_copy]
			INTO #MigrationTable
			FROM 
				( 
					SELECT TOP (@BatchSize) * FROM [<table_to_move_rows_from, sysname, MySourceTable>] WHERE ([CopiedToNewTable] IS NULL OR [CopiedToNewTable] = 0) ORDER BY [<optional_orderby_column, sysname, CanBeRemoved>]
				) [x];

			--SELECT * FROM #MigrationTable

			INSERT INTO [<table_to_move_rows_TO, sysname, MyTargetTable>] WITH(ROWLOCK) (
				[column_1_to_copy],
				[column_2_to_copy],
				[column_3_to_copy],
				[column_4_to_copy],
				-- etc
				[column_N_to_copy]
			)
			SELECT
				[column_1_to_copy],
				[column_2_to_copy],
				[column_3_to_copy],
				[column_4_to_copy], 
				-- etc
				[column_N_to_copy]
			FROM
				 #MigrationTable;

				 -- USUALLY makes sense to let the engine figure out the best way to sort/order-by
			-- Later - i.e., once all rows are moved or ... whenever you want, you can DELETE FROM <your_source_table> WHERE [CopiedToNewTable] = 1'
		END;

		IF UPPER(@BatchModeStatementType) = N'DELETE' BEGIN 
			SET @BatchStatement = N'			
				DELETE [t]
				FROM dbo.[<target_table, sysname, TableToDeleteFrom>] t WITH(ROWLOCK)
				INNER JOIN (
					SELECT TOP (@BatchSize) 
						[<id_column, sysname, NameOfPrimaryKeyOrClixID>]  
					FROM 
						dbo.[<target_table, sysname, TableToDeleteFrom>] WITH(NOLOCK)  
					WHERE 
						[<timestamp_column, sysname, NameOfTimeStampColumn>] < DATEADD(DAY, 0 - @DaysWorthOfDataToKeep, @startTime) 
					) x ON t.[<id_column, sysname, NameOfPrimaryKeyOrClixID>]= x.[<id_column, sysname, NameOfPrimaryKeyOrClixID>];';
		END;

		SET @BatchStatement = N'!!!!!!!!-- Specify YOUR code here, i.e., this is just a TEMPLATE:
				' + @BatchStatement + N' 
!!!!!!!! / YOUR code... ';

	END;

	---------------------------------------------------------------------------------------------------
	-- Sproc Signature and Configuration Settings:
	---------------------------------------------------------------------------------------------------

	DECLARE @signature nvarchar(MAX) = N'USE [{target_database}];
GO

IF OBJECT_ID(''[{schema}].[{sproc_name}]'',''P'') IS NOT NULL
	DROP PROC [{schema}].[{sproc_name}];
GO

CREATE PROC [{schema}].[{sproc_name}]
{parameters}
AS
    SET NOCOUNT ON; 

	-- NOTE: this code was generated from admindb.dbo.blueprint_for_batched_operation.
	
	-- Parameter Scrubbing/Cleanup:
	{cleanup}{configuration}
	';

	DECLARE @parameters nvarchar(MAX) = N'	@DaysWorthOfDataToKeep					int			= {default_retention},
	@BatchSize								int			= {default_batch_size},
	@WaitForDelay							sysname		= N''{default_wait_for}'',{configuration}{allow_batch_tuning}{total_cleanup_seconds}{default_max_errors}{deadlocks_as_errors}{safe_stop_name}
	@HistoryLoggingLevel					sysname		= N''{default_save_history}''   -- { SIMPLE | DETAIL }  -- errors are always logged...  ';

	DECLARE @cleanup nvarchar(MAX) = N'SET @WaitForDelay = NULLIF(@WaitForDelay, N'''');{tempTableName}';
	DECLARE @configuration nvarchar(MAX) = @crlf + @crlf + @tab + N'---------------------------------------------------------------------------------------------------------------
	-- Optional Retrieval of Settings via Configuration Table:
	---------------------------------------------------------------------------------------------------------------
	IF @OverrideWithConfigParameters = 1 BEGIN 
		
		DECLARE @enabled bit;
		DECLARE @configurationKey sysname = OBJECT_NAME(@@PROCID);--{dynamic_batching_params2}{max_errors2}

		BEGIN TRY 
			-- Reset/Load Input Values from Config Table INSTEAD of via parameters passed in to sproc: 
			DECLARE @configError nvarchar(MAX) = N'''';
			DECLARE @configSQL nvarchar(MAX) = N''SELECT 
				@enabled = [enabled],
				@DaysWorthOfDataToKeep = [retention_days],
				@BatchSize = [batch_size],
				@WaitForDelay = [wait_for_delay],{max_exections_select}{deadlocks_select}{max_errors_select}{dynamic_batching_select}{temp_select}
				@HistoryLoggingLevel = [logging_level]		
			FROM 
				{configuration_table_name}
			WHERE	
				[procedure_name] = @configurationKey; '';

			EXEC sp_executesql 
				@configSQL, 
				N''@enabled bit OUTPUT, 
				@DaysWorthOfDataToKeep int OUTPUT, 
				@BatchSize int OUTPUT,
				@WaitForDelay sysname OUTPUT,{dynamic_batching_def}{max_exections_def}{deadlocks_def}{max_errors_def}{temp_def}
				@HistoryLoggingLevel sysname OUTPUT, 
				@configurationKey sysname'',
				@enabled = @enabled OUTPUT,
				@DaysWorthOfDataToKeep = @DaysWorthOfDataToKeep OUTPUT,
				@BatchSize = @BatchSize OUTPUT,
				@WaitForDelay = @WaitForDelay OUTPUT,{dynamic_batching_assignment}{max_exections_assignment}{deadlocks_assignment}{max_errors_assignment}{temp_assignment}
				@HistoryLoggingLevel = @HistoryLoggingLevel OUTPUT,
				@configurationKey = @configurationKey;

			IF @BatchSize IS NULL BEGIN
				RAISERROR(''Invalid Configuration Definiition Specified. Key: %s did NOT match any configured [procedure_name] in table: {configuration_table_name}. Unable to continue. Terminating.'', 16, 1, @configurationKey);
			END;

			IF @enabled <> 1 BEGIN 
				PRINT N''Procedure '' + @configurationKey + N'' has been marked as DISABLED in table {configuration_table_name}. Execution is terminating gracefully.;'';
				RETURN 0;
			END;

		END TRY 
		BEGIN CATCH 
			SELECT @configError = N''ERROR NUMBER: '' + CAST(ERROR_NUMBER() as sysname) + N''. ERROR MESSAGE: '' + ERROR_MESSAGE();
			RAISERROR(@configError, 16, 1);
			RAISERROR(''Unexecpted Error Attempting retrieval of Configuration Values from Configuration Table {configuration_table_name}. Unable to continue. Terminating.'', 16, 1);
			RETURN -100;
		END CATCH

	END; ';

	SET @parameters = REPLACE(@parameters, N'{default_retention}', @DefaultNumberOfDaysToKeep);
	SET @parameters = REPLACE(@parameters, N'{default_batch_size}', @DefaultBatchSize);
	SET @parameters = REPLACE(@parameters, N'{default_wait_for}', @DefaultWaitDuration);
	SET @parameters = REPLACE(@parameters, N'{default_save_history}', @DefaultHistoryLoggingLevel);	

	IF @AllowConfigTableOverride = 1 BEGIN
		SET @parameters = REPLACE(@parameters, N'{configuration}', @crlf + @tab + N'@OverrideWithConfigParameters			bit			= 0, ');	

		SET @configuration = REPLACE(@configuration, N'{configuration_table_name}', @ConfigurationTableName);

		IF @AllowDynamicBatchSizing = 1 BEGIN
			SET @configuration = REPLACE(@configuration, N'{dynamic_batching_params}', @crlf + @tab + @tab + N'DECLARE @AllowDynamicBatchSizing bit;
		DECLARE @MaxAllowedBatchSizeMultiplier int;
		DECLARE @TargetBatchMilliseconds int;');
		  END; 
		ELSE BEGIN 
			SET @configuration = REPLACE(@configuration, N'{dynamic_batching_params}', N'');
		END;
	  END;
	ELSE BEGIN
		SET @parameters = REPLACE(@parameters, N'{configuration}', N'');	
		SET @cleanup = REPLACE(@cleanup, N'{configKeys}', N'');
		SET @configuration = N'';
	END;

	IF @AllowDynamicBatchSizing = 1 BEGIN
		SET @parameters = REPLACE(@parameters, N'{allow_batch_tuning}', @crlf + @tab + N'@AllowDynamicBatchSizing				bit			= 0,' + @crlf + @tab + '@MaxAllowedBatchSizeMultiplier			int			= 5, ' + @crlf + @tab + N'@TargetBatchMilliseconds				int			= 2800,');	
		SET @configuration = REPLACE(@configuration, N'{dynamic_batching_select}', @crlf + @tab + @tab + @tab + @tab + N'@AllowDynamicBatchSizing = [enable_dynamic_batch_sizing],
				@MaxAllowedBatchSizeMultiplier = [max_batch_size_multiplier],
				@TargetBatchMilliseconds = [target_batch_milliseconds],');
		SET @configuration = REPLACE(@configuration, N'{dynamic_batching_def}', @crlf + @tab + @tab + @tab + @tab + N'@AllowDynamicBatchSizing bit OUTPUT,
				@MaxAllowedBatchSizeMultiplier int OUTPUT, 
				@TargetBatchMilliseconds int OUTPUT,');

		SET @configuration = REPLACE(@configuration, N'{dynamic_batching_assignment}', @crlf + @tab + @tab + @tab + @tab + N'@AllowDynamicBatchSizing = @AllowDynamicBatchSizing OUTPUT,
				@MaxAllowedBatchSizeMultiplier = @MaxAllowedBatchSizeMultiplier OUTPUT,
				@TargetBatchMilliseconds = @TargetBatchMilliseconds OUTPUT,');
	  END;
	ELSE BEGIN 
		SET @parameters = REPLACE(@parameters, N'{allow_batch_tuning}', N'');	
		SET @configuration = REPLACE(@configuration, N'{dynamic_batching_select}', N'');
		SET @configuration = REPLACE(@configuration, N'{dynamic_batching_def}', N'');
		SET @configuration = REPLACE(@configuration, N'{dynamic_batching_assignment}', N'');
	END;

	IF @AllowMaxExecutionSeconds = 1 BEGIN
		SET @parameters = REPLACE(@parameters, N'{total_cleanup_seconds}', @crlf + @tab + N'@MaxExecutionSeconds					int			= NULL,');
		SET @configuration = REPLACE(@configuration, N'{max_exections_select}', @crlf + N'				@MaxExecutionSeconds = [max_execution_seconds],');
		SET @configuration = REPLACE(@configuration, N'{max_exections_def}', @crlf + N'				@MaxExecutionSeconds int OUTPUT,');
		SET @configuration = REPLACE(@configuration, N'{max_exections_assignment}', @crlf + N'				@MaxExecutionSeconds = @MaxExecutionSeconds OUTPUT,');
	  END;
	ELSE BEGIN
		SET @parameters = REPLACE(@parameters, N'{total_cleanup_seconds}', N'');	
		SET @configuration = REPLACE(@configuration, N'{max_exections_select}', N'');
		SET @configuration = REPLACE(@configuration, N'{max_exections_def}', N'');
		SET @configuration = REPLACE(@configuration, N'{max_exections_assignment}', N'');
	END;

	IF @AllowMaxErrors = 1 BEGIN
		SET @parameters = REPLACE(@parameters, N'{default_max_errors}', @crlf + @tab + N'@MaxAllowedErrors						int			= 1,');
		SET @configuration = REPLACE(@configuration, N'{max_errors}', @crlf + @tab + @tab + N'DECLARE @MaxAllowedErrors int;');
		SET @configuration = REPLACE(@configuration, N'{max_errors_select}', @crlf + N'				@MaxAllowedErrors = [max_allowed_errors],');
		SET @configuration = REPLACE(@configuration, N'{max_errors_def}', @crlf + N'				@MaxAllowedErrors int OUTPUT,');
		SET @configuration = REPLACE(@configuration, N'{max_errors_assignment}', @crlf + N'				@MaxAllowedErrors = @MaxAllowedErrors OUTPUT,');
	  END;
	ELSE BEGIN 
		SET @parameters = REPLACE(@parameters, N'{default_max_errors}', N'');
		SET @configuration = REPLACE(@configuration, N'{max_errors}', N'');
		SET @configuration = REPLACE(@configuration, N'{max_errors_select}', N'');
		SET @configuration = REPLACE(@configuration, N'{max_errors_def}', N'');
		SET @configuration = REPLACE(@configuration, N'{max_errors_assignment}', N'');
	END;

	IF @AllowDeadlocksAsErrors = 1 BEGIN
		SET @parameters = REPLACE(@parameters, N'{deadlocks_as_errors}',  @crlf + @tab + N'@TreatDeadlocksAsErrors					bit			= 0,');
		SET @configuration = REPLACE(@configuration, N'{deadlocks_select}', @crlf + N'				@TreatDeadlocksAsErrors = [treat_deadlocks_as_errors],');
		SET @configuration = REPLACE(@configuration, N'{deadlocks_def}', @crlf + N'				@TreatDeadlocksAsErrors bit OUTPUT,');
		SET @configuration = REPLACE(@configuration, N'{deadlocks_assignment}', @crlf + N'				@TreatDeadlocksAsErrors = @TreatDeadlocksAsErrors OUTPUT,');
	  END;
	ELSE BEGIN
		SET @parameters = REPLACE(@parameters, N'{deadlocks_as_errors}', N'');
		SET @configuration = REPLACE(@configuration, N'{deadlocks_select}', N'');
		SET @configuration = REPLACE(@configuration, N'{deadlocks_def}', N'');
		SET @configuration = REPLACE(@configuration, N'{deadlocks_assignment}', N'');
	END;

	IF @AllowStopOnTempTableExists  = 1 BEGIN 
		SET @parameters = REPLACE(@parameters, N'{safe_stop_name}', @crlf + @tab + N'@StopIfTempTableExists					sysname		= NULL,');
		SET @cleanup = REPLACE(@cleanup, N'{tempTableName}', @crlf + @tab + N'SET @StopIfTempTableExists = ISNULL(@StopIfTempTableExists, N'''');');
		SET @configuration = REPLACE(@configuration, N'{temp_select}', @crlf + N'				@StopIfTempTableExists = [stop_if_tempdb_table_exists],');
		SET @configuration = REPLACE(@configuration, N'{temp_def}', @crlf + N'				@StopIfTempTableExists sysname OUTPUT,');
		SET @configuration = REPLACE(@configuration, N'{temp_assignment}', @crlf + N'				@StopIfTempTableExists = @StopIfTempTableExists OUTPUT,');
	  END;
	ELSE BEGIN
		SET @parameters = REPLACE(@parameters, N'{safe_stop_name}', N'');
		SET @cleanup = REPLACE(@cleanup, N'{tempTableName}', N'');

		SET @configuration = REPLACE(@configuration, N'{temp_select}', N'');
		SET @configuration = REPLACE(@configuration, N'{temp_def}', N'');
		SET @configuration = REPLACE(@configuration, N'{temp_assignment}', N'');
	END;
	
	SET @signature = REPLACE(@signature, N'{target_database}', @TargetDatabase);
	SET @signature = REPLACE(@signature, N'{schema}', @GeneratedSprocSchema);
	SET @signature = REPLACE(@signature, N'{sproc_name}', @GeneratedSprocName);
	SET @signature = REPLACE(@signature, N'{parameters}', @parameters);
	SET @signature = REPLACE(@signature, N'{cleanup}', @cleanup);
	SET @signature = REPLACE(@signature, N'{configuration}', @configuration);

	---------------------------------------------------------------------------------------------------
	-- Initialization:
	---------------------------------------------------------------------------------------------------
	DECLARE @initialization nvarchar(MAX) = N'	---------------------------------------------------------------------------------------------------------------
	-- Initialization:
	---------------------------------------------------------------------------------------------------------------
	SET NOCOUNT ON; 

	-- DROP TABLE IF EXISTS [{logging_table_name}];
	CREATE TABLE [{logging_table_name}] (
		[detail_id] int IDENTITY(1,1) NOT NULL, 
		[timestamp] datetime NOT NULL DEFAULT GETDATE(), 
		[is_error] bit NOT NULL DEFAULT (0), 
		[detail] nvarchar(MAX) NOT NULL
	); 

	-- Processing Declarations:
	DECLARE @continue bit = 1;
	DECLARE @currentRowsProcessed int = @BatchSize; 
	DECLARE @totalRowsProcessed int = 0;
	DECLARE @errorDetails nvarchar(MAX);
	DECLARE @currentErrorCount int = 0;{deadlock_declaration}
	DECLARE @startTime datetime = GETDATE();
	DECLARE @batchStart datetime;{dynamic_batching_declarations}{preProcessingDirectives}
';

	SET @initialization = REPLACE(@initialization, N'{logging_table_name}', @loggingTableName);

	DECLARE @dynamicBatches nvarchar(MAX) = N'DECLARE @milliseconds int;
	DECLARE @initialBatchSize int = @BatchSize;
	';

	IF @AllowDeadlocksAsErrors = 1 BEGIN 
		SET @initialization = REPLACE(@initialization, N'{deadlock_declaration}', @crlf + @tab + N'DECLARE @deadlockOccurred bit = 0;');
	  END; 
	ELSE BEGIN 
		SET @initialization = REPLACE(@initialization, N'{deadlock_declaration}', N'');
	END;

	IF @AllowDynamicBatchSizing = 1 BEGIN 
		SET @initialization = REPLACE(@initialization, N'{dynamic_batching_declarations}', @crlf + @tab + @dynamicBatches);
	  END; 
	ELSE BEGIN 
		SET @initialization = REPLACE(@initialization, N'{dynamic_batching_declarations}', N'');
	END;

	IF @PreProcessingStatement IS NOT NULL BEGIN 
		SET @initialization = REPLACE(@initialization, N'{preProcessingDirectives}', @crlf + @tab + @PreProcessingStatement + @crlf);
	  END;
	ELSE BEGIN 
		SET @initialization = REPLACE(@initialization, N'{preProcessingDirectives}', N'');
	END;

	---------------------------------------------------------------------------------------------------
	-- Body/Processing:
	---------------------------------------------------------------------------------------------------
	DECLARE @body nvarchar(MAX) = N'	---------------------------------------------------------------------------------------------------------------
	-- Processing:
	---------------------------------------------------------------------------------------------------------------
	WHILE @continue = 1 BEGIN 
	
		SET @batchStart = GETDATE();
	
		BEGIN TRY
			BEGIN TRAN; 
				
				-------------------------------------------------------------------------------------------------
				-- batched operation code:
				-------------------------------------------------------------------------------------------------
				{Batch_Statement} 

				-------------------------------------------
				SELECT 
					@currentRowsProcessed = @@ROWCOUNT, 
					@totalRowsProcessed = @totalRowsProcessed + @@ROWCOUNT;

			COMMIT; 

			IF @currentRowsProcessed <> @BatchSize SET @continue = 0;

			INSERT INTO [{logging_table_name}] (
				[timestamp],
				[detail]
			)
			SELECT 
				GETDATE() [timestamp], 
				(
					SELECT 
						@BatchSize [settings.batch_size], 
						@WaitForDelay [settings.wait_for], 
						@currentRowsProcessed [progress.current_batch_count], 
						@totalRowsProcessed [progress.total_rows_processed],
						DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [progress.batch_milliseconds], 
						DATEDIFF(MILLISECOND, @startTime, GETDATE())[progress.total_milliseconds]
					FOR JSON PATH, ROOT(''detail'')
				) [detail];{MaxSeconds}{TerminateIfTempObject}{DynamicTuning}
			
			{delay}
		END TRY
		BEGIN CATCH 
			
			{TreatDeadlocksAsErrors}SELECT @errorDetails = N''Error Number: '' + CAST(ERROR_NUMBER() AS sysname) + N''. Message: '' + ERROR_MESSAGE();

			IF @@TRANCOUNT > 0
				ROLLBACK; 

			INSERT INTO [{logging_table_name}] (
				[timestamp],
				[is_error],
				[detail]
			)
			SELECT
				GETDATE() [timestamp], 
				1 [is_error], 
				( 
					SELECT 
						@currentRowsProcessed [progress.current_batch_count], 
						@totalRowsProcessed [progress.total_rows_processed],
						N''Unexpected Error Occurred: '' + @errorDetails [errors.error]
					FOR JSON PATH, ROOT(''detail'')
				) [detail];
					   
			{MaxErrors}
		END CATCH;
	END;

	';

	DECLARE @maxSeconds nvarchar(MAX) = N'	IF @MaxExecutionSeconds > 0 AND (DATEDIFF(SECOND, @startTime, GETDATE()) >= @MaxExecutionSeconds) BEGIN 
				INSERT INTO [{logging_table_name}] (
					[timestamp],
					[is_error],
					[detail]
				)
				SELECT
					GETDATE() [timestamp], 
					1 [is_error], 
					( 
						SELECT 
							@currentRowsProcessed [progress.current_batch_count], 
							@totalRowsProcessed [progress.total_rows_processed],
							DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [progress.batch_milliseconds], 
							DATEDIFF(MILLISECOND, @startTime, GETDATE())[progress.total_milliseconds],
							CONCAT(N''Maximum execution seconds allowed for execution met/exceeded. Max Allowed Seconds: '', @MaxExecutionSeconds, N''.'') [errors.error]
						FOR JSON PATH, ROOT(''detail'')
					) [detail];
			
				GOTO Finalize;		
			END;';
	DECLARE @tempdbTerminate nvarchar(MAX) = N'	IF OBJECT_ID(N''tempdb..'' + @StopIfTempTableExists) IS NOT NULL BEGIN 
				INSERT INTO [{logging_table_name}] (
					[timestamp],
					[is_error],
					[detail]
				)
				SELECT
					GETDATE() [timestamp], 
					1 [is_error], 
					( 
						SELECT 
							@currentRowsProcessed [progress.current_batch_count], 
							@totalRowsProcessed [progress.total_rows_processed],
							DATEDIFF(MILLISECOND, @batchStart, GETDATE()) [progress.batch_milliseconds], 
							DATEDIFF(MILLISECOND, @startTime, GETDATE())[progress.total_milliseconds],
							N''Graceful execution shutdown/bypass directive detected - object ['' + @StopIfTempTableExists + N''] found in tempdb. Terminating Execution.'' [errors.error]
						FOR JSON PATH, ROOT(''detail'')
					) [detail];
			
				GOTO Finalize;
			END;';
	DECLARE @dynamicTuning nvarchar(MAX) = N'	-- Dynamic Tuning:
			SET @milliseconds = DATEDIFF(MILLISECOND, @batchStart, GETDATE());
			IF @milliseconds <= @TargetBatchMilliseconds BEGIN 
				IF @BatchSize < (@initialBatchSize * @MaxAllowedBatchSizeMultiplier) BEGIN

					SET @BatchSize = FLOOR((@BatchSize + (@BatchSize * .2)) / 100) * 100; 
					IF @BatchSize > (@initialBatchSize * @MaxAllowedBatchSizeMultiplier) 
						SET @BatchSize = (@initialBatchSize * @MaxAllowedBatchSizeMultiplier);
				END;
			  END;
			ELSE BEGIN 
				IF @BatchSize > (@initialBatchSize / @MaxAllowedBatchSizeMultiplier) BEGIN

					SET @BatchSize = FLOOR((@BatchSize - (@BatchSize * .2)) / 100) * 100;
					IF @BatchSize < (@initialBatchSize / @MaxAllowedBatchSizeMultiplier)
						SET @BatchSize = (@initialBatchSize / @MaxAllowedBatchSizeMultiplier);
				END;
			END; ';
	DECLARE @deadlocksAsErrors nvarchar(MAX) = N'IF ERROR_NUMBER() = 1205 BEGIN
		
				INSERT INTO [{logging_table_name}] (
					[timestamp],
					[is_error],
					[detail]
				)
				SELECT
					GETDATE() [timestamp], 
					1 [is_error], 
					( 
						SELECT 
							@currentRowsProcessed [progress.current_batch_count], 
							@totalRowsProcessed [progress.total_rows_processed],
							N''Deadlock Detected. Logging to history table - but not counting deadlock as normal error for purposes of error handling/termination.'' [errors.error]
						FOR JSON PATH, ROOT(''detail'')
					) [detail];
					   
				SET @deadlockOccurred = 1;		
			END; ';
	DECLARE @maxErrors nvarchar(MAX) = N'SET @currentErrorCount = @currentErrorCount + 1; 
			IF @currentErrorCount >= @MaxAllowedErrors BEGIN 
				INSERT INTO [{logging_table_name}] (
					[timestamp],
					[is_error],
					[detail]
				)
				SELECT
					GETDATE() [timestamp], 
					1 [is_error], 
					( 
						SELECT 
							@currentRowsProcessed [progress.current_batch_count], 
							@totalRowsProcessed [progress.total_rows_processed],
							CONCAT(N''Max allowed errors count reached/exceeded: '', @MaxAllowedErrors, N''. Terminating Execution.'') [errors.error]
						FOR JSON PATH, ROOT(''detail'')
					) [detail];

				GOTO Finalize;
			END;';

	IF @AllowMaxErrors = 1 BEGIN 
		SET @body = REPLACE(@body, N'{MaxErrors}', @maxErrors);
	  END; 
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{MaxErrors}', N'GOTO Finalize;');
	END;

	IF @AllowMaxExecutionSeconds = 1 BEGIN 
		SET @body = REPLACE(@body, N'{MaxSeconds}', @crlf + @crlf + @tab + @tab + @maxSeconds);
	  END; 
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{MaxSeconds}', N'');
	END;
	
	IF @AllowStopOnTempTableExists = 1 BEGIN 
		SET @body = REPLACE(@body, N'{TerminateIfTempObject}',@crlf + @crlf + @tab + @tab + @tempdbTerminate);
	  END;
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{TerminateIfTempObject}', N'');
	END;

	IF @AllowDynamicBatchSizing = 1 BEGIN 
		SET @body = REPLACE(@body, N'{DynamicTuning}', @crlf + @crlf + @tab + @tab + @dynamicTuning);
	  END;
	ELSE BEGIN
		SET @body = REPLACE(@body, N'{DynamicTuning}', N'');
	END;

	IF @AllowDeadlocksAsErrors = 1 BEGIN 
		SET @body = REPLACE(@body, N'{TreatDeadlocksAsErrors}', @deadlocksAsErrors + @crlf + @crlf + @tab + @tab + @tab);
	  END;
	ELSE BEGIN
		SET @body = REPLACE(@body, N'{TreatDeadlocksAsErrors}', N'');
	END;

	IF @DefaultWaitDuration = N'N/A' BEGIN
		SET @body = REPLACE(@body, N'{delay}', N'SET @continue = 0; -- no waiting/looping...');
	  END;
	ELSE BEGIN 
		SET @body = REPLACE(@body, N'{delay}', N'WAITFOR DELAY @WaitForDelay;');
	END;


	SET @body = REPLACE(@body, N'{Batch_Statement}', @BatchStatement);
	SET @body = REPLACE(@body, N'{logging_table_name}', @loggingTableName);
	

	---------------------------------------------------------------------------------------------------
	-- Finalization:
	---------------------------------------------------------------------------------------------------
	DECLARE @finalize nvarchar(MAX) = N'	---------------------------------------------------------------------------------------------------------------
	-- Finalization/Reporting:
	---------------------------------------------------------------------------------------------------------------

	Finalize:{deadlock_report}

	DECLARE @executionID uniqueidentifier = NEWID();

	IF EXISTS (SELECT NULL FROM sys.tables WHERE [object_id] = OBJECT_ID(N''{History_Table_Name}'')) BEGIN
			
		IF @HistoryLoggingLevel = N''SIMPLE'' BEGIN 
			DELETE FROM {logging_table_name} WHERE is_error = 0 AND [detail_id] <> (SELECT MAX([detail_id]) FROM {logging_table_name});
		END;

		INSERT INTO {History_Table_Name} (
			[execution_id],
			[procedure_name],
			[detail_id],
			[timestamp],
			[is_error],
			[detail]
		)
		SELECT 
			@executionID [execution_id],
			OBJECT_NAME(@@PROCID) [procedure_name],
			[detail_id],
			[timestamp],
			[is_error],
			[detail]
		FROM 
			[{logging_table_name}] 
		ORDER BY 
			[detail_id];

		END;
	ELSE BEGIN 
		SELECT * FROM [{logging_table_name}] ORDER BY [detail_id];

		RAISERROR(N''Unable to persist processing history data into long-term storage. Storage Table not found/specified.'', 16, 1);
	END;

	RETURN 0;
GO';

	DECLARE @deadlockBlock nvarchar(MAX) = N'IF @deadlockOccurred = 1 BEGIN 
		PRINT N''NOTE: One or more deadlocks occurred.''; 
	END;'

	IF @AllowDeadlocksAsErrors = 1 BEGIN 
		SET @finalize = REPLACE(@finalize, N'{deadlock_report}', @crlf + @crlf + @tab + @deadlockBlock);
	  END; 
	ELSE BEGIN 
		SET @finalize = REPLACE(@finalize, N'{deadlock_report}', N'');
	END;

	IF PARSENAME(@LoggingHistoryTableName, 2) IS NULL SET @LoggingHistoryTableName = N'dbo.' + @LoggingHistoryTableName;
	
	SET @finalize = REPLACE(@finalize, N'{logging_table_name}', @loggingTableName);
	SET @finalize = REPLACE(@finalize, N'{History_Table_Name}', ISNULL(QUOTENAME(PARSENAME(@LoggingHistoryTableName, 2)) + N'.' + QUOTENAME(PARSENAME(@LoggingHistoryTableName, 1)), N''));

	---------------------------------------------------------------------------------------------------
	-- Projection/Print-Out:
	---------------------------------------------------------------------------------------------------

	EXEC admindb.dbo.[print_long_string] @signature;
	EXEC admindb.dbo.[print_long_string] @initialization;
	EXEC [admindb].dbo.[print_long_string] @body;
	EXEC [admindb].dbo.[print_long_string] @finalize;
	
	RETURN 0;

GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- SQL Server Agent Jobs
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_running_jobs','P') IS NOT NULL
	DROP PROC dbo.[list_running_jobs];
GO


CREATE PROC dbo.[list_running_jobs]
	@StartTime							datetime				= NULL, 
	@EndTime							datetime				= NULL, 
	@ExcludedJobs						nvarchar(MAX)			= NULL, 
	@PreFilterPaddingWeeks				int						= 1,							-- if @StartTime/@EndTime are specified, msdb.dbo.sysjobhistory stores start_dates as ints - so this is used to help pre-filter those results by @StartTime - N weeks and @EndTime + N weeks ... 
    @SerializedOutput					xml						= N'<default/>'			OUTPUT			-- when set to any non-null value (i.e., '') this will be populated with output - rather than having the output projected through the 'bottom' of the sproc (so that we can consume these details from other sprocs/etc.)
AS
	
	RAISERROR('Sorry. The S4 stored procedure dbo.list_running_jobs is NOT supported on SQL Server 2008/2008R2 instances.', 16, 1);
	RETURN -100;
GO

DECLARE @list_running_jobs nvarchar(MAX) = N'ALTER PROC dbo.[list_running_jobs]
	@StartTime							datetime				= NULL, 
	@EndTime							datetime				= NULL, 
	@ExcludedJobs						nvarchar(MAX)			= NULL, 
	@PreFilterPaddingWeeks				int						= 1,							-- if @StartTime/@EndTime are specified, msdb.dbo.sysjobhistory stores start_dates as ints - so this is used to help pre-filter those results by @StartTime - N weeks and @EndTime + N weeks ... 
    @SerializedOutput					xml						= N''<default/>''			OUTPUT			-- when set to any non-null value (i.e., '''') this will be populated with output - rather than having the output projected through the ''bottom'' of the sproc (so that we can consume these details from other sprocs/etc.)
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -----------------------------------------------------------------------------
    -- Validate Inputs: 

	IF (@StartTime IS NOT NULL AND @EndTime IS NULL) OR (@EndTime IS NOT NULL AND @StartTime IS NULL) BEGIN
        RAISERROR(''@StartTime and @EndTime must both either be specified - or both must be NULL (indicating that you''''d like to see jobs running right now).'', 16, 1);
        RETURN -1;
    END;

	IF @StartTime IS NOT NULL AND @EndTime < @StartTime BEGIN
        RAISERROR(''@Endtime must be greater than (or equal to) @StartTime.'', 16, 1);
        RETURN -2;		
	END;

	-----------------------------------------------------------------------------
	CREATE TABLE #RunningJobs (
		row_id int IDENTITY(1,1) NOT NULL, 
		job_name sysname NOT NULL, 
		job_id uniqueidentifier NOT NULL, 
		step_id int NOT NULL,
		step_name sysname NOT NULL, 
		start_time datetime NOT NULL, 
		end_time datetime NULL, 
		completed bit NULL
	);

    -----------------------------------------------------------------------------
    -- If there''s no filter, then we want jobs that are currently running (i.e., those who have started, but their stop time is NULL: 
	IF (@StartTime IS NULL) OR (@EndTime >= GETDATE()) BEGIN
		INSERT INTO [#RunningJobs] ( [job_name], [job_id], [step_name], [step_id], [start_time], [end_time], [completed])
		SELECT 
			j.[name] [job_name], 
			ja.job_id,
			js.[step_name] [step_name],
			js.[step_id],
			ja.[start_execution_date] [start_time], 
			NULL [end_time], 
			0 [completed]
		FROM 
			msdb.dbo.[sysjobactivity] ja 
			LEFT OUTER JOIN msdb.dbo.[sysjobhistory] jh ON [ja].[job_history_id] = [jh].[instance_id]
			INNER JOIN msdb.dbo.[sysjobs] j ON [ja].[job_id] = [j].[job_id] 
			INNER JOIN msdb.dbo.[sysjobsteps] js ON [ja].[job_id] = [js].[job_id] AND ISNULL([ja].[last_executed_step_id], 0) + 1 = [js].[step_id]
		WHERE 
			[ja].[session_id] = (SELECT TOP (1) [session_id] FROM msdb.dbo.[syssessions] ORDER BY [agent_start_date] DESC) 
			AND [ja].[start_execution_date] IS NOT NULL 
			AND [ja].[stop_execution_date] IS NULL;
	END;
	
	IF @StartTime IS NOT NULL BEGIN
		WITH starts AS ( 
			SELECT 
				instance_id,
				job_id, 
				step_id,
				step_name, 
				CAST((LEFT(run_date, 4) + ''-'' + SUBSTRING(CAST(run_date AS char(8)),5,2) + ''-'' + RIGHT(run_date,2) + '' '' + LEFT(REPLICATE(''0'', 6 - LEN(run_time)) + CAST(run_time AS varchar(6)), 2) + '':'' + SUBSTRING(REPLICATE(''0'', 6 - LEN(run_time)) + CAST(run_time AS varchar(6)), 3, 2) + '':'' + RIGHT(REPLICATE(''0'', 6 - LEN(run_time)) + CAST(run_time AS varchar(6)), 2)) AS datetime) AS [start_time],
				RIGHT((REPLICATE(N''0'', 6) + CAST([run_duration] AS sysname)), 6) [duration]
			FROM 
				msdb.dbo.[sysjobhistory] 
			WHERE 
				-- rather than a scan of the entire table - restrict things to 1 week before the specified start date and 1 week after the specified end date... 
				[run_date] >= CAST(CONVERT(char(8), DATEADD(WEEK, 0 - @PreFilterPaddingWeeks, @StartTime), 112) AS int)
				AND 
				[run_date] <= CAST(CONVERT(char(8), DATEADD(WEEK, @PreFilterPaddingWeeks, @EndTime), 112) AS int)
		), 
		ends AS ( 
			SELECT 
				instance_id,
				job_id, 
				step_id,
				step_name, 
				[start_time], 
				CAST((LEFT([duration], 2)) AS int) * 3600 + CAST((SUBSTRING([duration], 3, 2)) AS int) * 60 + CAST((RIGHT([duration], 2)) AS int) [total_seconds]
			FROM 
				starts
		),
		normalized AS ( 
			SELECT 
				instance_id,
				job_id, 
				step_id,
				step_name, 
				start_time, 
				DATEADD(SECOND, CASE WHEN total_seconds = 0 THEN 1 ELSE [ends].[total_seconds] END, start_time) end_time, 
				LEAD(step_id) OVER (PARTITION BY job_id ORDER BY instance_id) [next_job_step_id]  -- note, this isn''t 2008 compat... (and ... i don''t think i care... )
			FROM 
				ends
		)

		INSERT INTO [#RunningJobs] ( [job_name], [job_id], [step_name], [step_id], [start_time], [end_time], [completed])
		SELECT 
			[j].[name] [job_name],
			[n].[job_id], 
			ISNULL([js].[step_name], [n].[step_name]) [step_name],
			[n].[step_id],
			[n].[start_time],
			[n].[end_time], 
			CASE WHEN [n].[next_job_step_id] = 0 THEN CAST(1 AS bit) ELSE CAST(0 AS bit) END [completed]
		FROM 
			normalized n
			LEFT OUTER JOIN msdb.dbo.[sysjobs] j ON [n].[job_id] = [j].[job_id] -- allow this to be NULL - i.e., if we''re looking for a job that ran this morning at 2AM, it''s better to see that SOMETHING ran other than that a Job that existed (and ran) - but has since been deleted - ''looks'' like it didn''t run.
			LEFT OUTER JOIN msdb.dbo.[sysjobsteps] js ON [n].[job_id] = [js].[job_id] AND n.[step_id] = js.[step_id]
		WHERE 
			n.[step_id] <> 0 AND (
				-- jobs that start/stop during specified time window... 
				(n.[start_time] >= @StartTime AND n.[end_time] <= @EndTime)

				-- jobs that were running when the specified window STARTS (and which may or may not end during out time window - but the jobs were ALREADY running). 
				OR (n.[start_time] < @StartTime AND n.[end_time] > @StartTime)

				-- jobs that get started during our time window (and which may/may-not stop during our window - because, either way, they were running...)
				OR (n.[start_time] > @StartTime AND n.[end_time] > @EndTime)
			)
	END;

	-- Exclude any jobs specified: 
	DELETE FROM [#RunningJobs] WHERE [job_name] IN (SELECT [result] FROM dbo.[split_string](@ExcludedJobs, N'','', 1));
    
	-- TODO: are there any expansions/details we want to join from the Jobs themselves at this point? (or any other history info?) 
	
	-----------------------------------------------------------------------------
    -- Send output as XML if requested:
	IF (SELECT dbo.is_xml_empty(@SerializedOutput)) = 1 BEGIN -- if @SerializedOutput has been EXPLICITLY initialized as NULL/empty... then REPLY...  

		SELECT @SerializedOutput = (
			SELECT 
				[job_name],
				[job_id],
				[step_name],
				[step_id],
				[start_time],
				CASE WHEN [completed] = 1 THEN [end_time] ELSE NULL END [end_time], 
				CASE WHEN [completed] = 1 THEN ''COMPLETED'' ELSE ''INCOMPLETE'' END [job_status]
			FROM 
				[#RunningJobs] 
			ORDER BY 
				[start_time]
			FOR XML PATH(''job''), ROOT(''jobs'')
		);

		RETURN 0;
	END;

	-----------------------------------------------------------------------------
	-- otherwise, project:
	SELECT 
		[job_name],
        [job_id],
        [step_name],
		[step_id],
        [start_time],
		CASE WHEN [completed] = 1 THEN [end_time] ELSE NULL END [end_time], 
		CASE WHEN [completed] = 1 THEN ''COMPLETED'' ELSE ''INCOMPLETE'' END [job_status]
	FROM 
		[#RunningJobs]
	ORDER BY 
		[start_time];

	RETURN 0;

 ';

IF (SELECT dbo.get_engine_version())> 10.5 
	EXEC sp_executesql @list_running_jobs;

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.is_job_running','FN') IS NOT NULL
	DROP FUNCTION dbo.is_job_running;
GO

CREATE FUNCTION dbo.is_job_running (@JobName sysname) 
RETURNS bit 
	WITH RETURNS NULL ON NULL INPUT
AS 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN;
		
		DECLARE @output bit = 0;

		IF EXISTS (
			SELECT 
				NULL
			FROM 
				msdb.dbo.sysjobs j 
				INNER JOIN msdb.dbo.sysjobactivity ja ON [j].[job_id] = [ja].[job_id] 
			WHERE 
				ja.[session_id] = (SELECT TOP (1) session_id FROM msdb.dbo.[syssessions] ORDER BY [agent_start_date] DESC)
				AND [ja].[start_execution_date] IS NOT NULL 
				AND [ja].[stop_execution_date] IS NULL -- i.e., still running
				AND j.[name] = @JobName
		)  
		  BEGIN 
			SET @output = 1;
		END;

		RETURN @output;

	END; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.translate_program_name_to_agent_job','P') IS NOT NULL
	DROP PROC dbo.[translate_program_name_to_agent_job];
GO

CREATE PROC dbo.[translate_program_name_to_agent_job]
    @ProgramName                    sysname, 
    @IncludeJobStepInOutput         bit         = 0, 
    @JobName                        sysname     = N''       OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    DECLARE @jobID uniqueidentifier;

    BEGIN TRY 

        DECLARE @jobIDString sysname = SUBSTRING(@ProgramName, CHARINDEX(N'Job 0x', @ProgramName) + 4, 34);
        DECLARE @currentStepString sysname = REPLACE(REPLACE(@ProgramName, LEFT(@ProgramName, CHARINDEX(N': Step', @ProgramName) + 6), N''), N')', N''); 

        SET @jobID = CAST((CONVERT(binary(16), @jobIDString, 1)) AS uniqueidentifier);
    
    END TRY
    BEGIN CATCH
        IF NULLIF(@JobName, N'') IS NOT NULL
            RAISERROR(N'Error converting Program Name: ''%s'' to SQL Server Agent JobID (Guid).', 16, 1, @ProgramName);

        RETURN -1;
    END CATCH

    DECLARE @output sysname = (SELECT [name] FROM msdb..sysjobs WHERE [job_id] = @jobID);

    IF @IncludeJobStepInOutput = 1
        SET @output = @output + N' (Step ' + @currentStepString + N')';

    IF @JobName IS NULL
        SET @JobName = @output; 
    ELSE 
        SELECT @output [job_name];

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.get_last_job_completion','P') IS NOT NULL
	DROP PROC dbo.[get_last_job_completion];
GO

CREATE PROC dbo.[get_last_job_completion]
    @JobName                                            sysname                 = NULL, 
    @JobID                                              uniqueidentifier        = NULL, 
    @ReportJobStartOrEndTime                            sysname                 = N'START',                                 -- Report Last Completed Job START or END time.. 
    @ExcludeFailedOutcomes                              bit                     = 0,                                        -- when true, only reports on last-SUCCESSFUL execution.
    @LastTime                                           datetime                = '1900-01-01 00:00:00.000' OUTPUT
AS
    SET NOCOUNT ON; 
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    IF NULLIF(@JobName, N'') IS NULL AND @JobID IS NULL BEGIN 
        RAISERROR(N'Please specify either the @JobName or @JobID parameter to execute.', 16, 1);
        RETURN -1;
    END;

    IF UPPER(@ReportJobStartOrEndTime) NOT IN (N'START', N'END') BEGIN 
        RAISERROR('Valid values for @ReportJobStartOrEndTime are { START | END } only.', 16,1);
        RETURN -2;
    END;

    IF @JobID IS NULL BEGIN 
        SELECT @JobID = job_id FROM msdb..sysjobs WHERE [name] = @JobName;
    END;

    IF @JobName IS NULL BEGIN 
        RAISERROR(N'Invalid (non-existing) @JobID or @JobName provided.', 16, 1);
        RETURN -5;
    END;

    DECLARE @startTime datetime;
    DECLARE @duration sysname;
    
    SELECT 
        @startTime = msdb.dbo.agent_datetime(run_date, run_time), 
        @duration = RIGHT((REPLICATE(N'0', 6) + CAST([run_duration] AS sysname)), 6)
    FROM [msdb]..[sysjobhistory] 
    WHERE 
        [instance_id] = (

            SELECT MAX(instance_id) 
            FROM msdb..[sysjobhistory] 
            WHERE 
                [job_id] = @JobID 
                AND (
                        (@ExcludeFailedOutcomes = 0) 
                        OR 
                        (@ExcludeFailedOutcomes = 1 AND [run_status] = 1)
                    )
        );

    IF UPPER(@ReportJobStartOrEndTime) = N'START' BEGIN 
        IF @LastTime IS NOT NULL  -- i.e., parameter was NOT supplied because it's defaulted to 1900... 
            SELECT @startTime [start_time_of_last_successful_job_execution];
        ELSE 
            SET @LastTime = @startTime;

        RETURN 0;
    END; 
    
    -- otherwise, report on the end-time: 
    DECLARE @endTime datetime = DATEADD(SECOND, CAST((LEFT(@duration, 2)) AS int) * 3600 + CAST((SUBSTRING(@duration, 3, 2)) AS int) * 60 + CAST((RIGHT(@duration, 2)) AS int), @startTime); 

    IF @LastTime IS NOT NULL
        SELECT @endTime [completion_time_of_last_job_execution];
    ELSE 
        SET @LastTime = @endTime;

    RETURN 0;
GO    


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.get_last_job_completion_by_session_id','P') IS NOT NULL
	DROP PROC dbo.[get_last_job_completion_by_session_id];
GO

CREATE PROC dbo.[get_last_job_completion_by_session_id]
    @SessionID              int,
    @ExcludeFailures        bit                             = 1, 
    @LastTime               datetime                        = '1900-01-01 00:00:00.000' OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    DECLARE @success int = -1;
    DECLARE @jobName sysname; 
    DECLARE @lastExecution datetime;
    DECLARE @output datetime;

    DECLARE @programName sysname; 
    SELECT @programName = [program_name] FROM sys.[dm_exec_sessions] WHERE [session_id] = @SessionID;

    EXEC @success = dbo.translate_program_name_to_agent_job 
        @ProgramName = @programName, 
        @JobName = @jobName OUTPUT;

    IF @success = 0 BEGIN 
        EXEC @success = dbo.[get_last_job_completion]
            @JobName = @jobName, 
            @ReportJobStartOrEndTime = N'START', 
            @ExcludeFailedOutcomes = 1, 
            @LastTime = @lastExecution OUTPUT;

        IF @success = 0 
            SET @output = @lastExecution;
    END; 

    IF @output IS NULL 
        RETURN -1; 

    IF @LastTime IS NOT NULL 
        SELECT @output [completion_time_of_last_job_execution];
    ELSE 
        SET @LastTime = @output;

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.jobstep_body_alter','P') IS NOT NULL
	DROP PROC dbo.[jobstep_body_alter];
GO

CREATE PROC dbo.[jobstep_body_alter]
	@JobName			sysname, 
	@StepName			sysname, 
	@NewBody			nvarchar(MAX)
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	/* Verify that Job + Step Exist */
	DECLARE @jobID uniqueidentifier;
	SELECT @jobID = job_id FROM [msdb].dbo.[sysjobs] WHERE [name] = @JobName;
	IF @jobID IS NULL BEGIN 
		RAISERROR(N'Invalid Job Name. The job [%s] does not exist on current server.', 16, 1, @JobName);
		RETURN -10;
	END;
	
	DECLARE @stepId int;
	SELECT @stepId = [step_id] FROM [msdb].dbo.[sysjobsteps] WHERE [job_id] = @jobID AND [step_name] = @StepName

	IF @stepId IS NULL BEGIN
		RAISERROR(N'Invalid Job Step Name. A JobStep with the name [%s] does not exist within job [%s].', 16, 1, @StepName, @JobName);
		RETURN -20;
	END;

	DECLARE @outcome int;
	BEGIN TRY 

		EXEC @outcome = [msdb].dbo.[sp_update_jobstep]
			@job_id = @jobID,
			@step_id = @stepId,
			@command = @NewBody;
	
	END TRY 
	BEGIN CATCH 
		DECLARE @error nvarchar(MAX);
		SELECT @error = N'ERROR NUMBER: ' + CAST(ERROR_NUMBER() as sysname) + N'. ERROR MESSAGE: ' + ERROR_MESSAGE();

		IF @@TRANCOUNT > 0 
			ROLLBACK;
	END CATCH;

	IF @outcome <> 0 BEGIN 
		RAISERROR(N'Unexpected Error. No exception was thrown by msdb.dbo.sp_update_jobstep, but it also did NOT return SUCCESS.', 16, 1);
		RETURN -100;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.jobstep_body_get','P') IS NOT NULL
	DROP PROC dbo.[jobstep_body_get];
GO

CREATE PROC dbo.[jobstep_body_get]
	@JobName			sysname, 
	@StepName			sysname, 
	@Output				nvarchar(MAX)	= N'' OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	/* Verify that Job + Step Exist */
	DECLARE @jobID uniqueidentifier;
	SELECT @jobID = job_id FROM [msdb].dbo.[sysjobs] WHERE [name] = @JobName;
	IF @jobID IS NULL BEGIN 
		RAISERROR(N'Invalid Job Name. The job [%s] does not exist on current server.', 16, 1, @JobName);
		RETURN -10;
	END;
	
	DECLARE @stepId int;
	SELECT @stepId = [step_id] FROM [msdb].dbo.[sysjobsteps] WHERE [job_id] = @jobID AND [step_name] = @StepName

	IF @stepId IS NULL BEGIN
		RAISERROR(N'Invalid Job Step Name. A JobStep with the name [%s] does not exist within job [%s].', 16, 1, @StepName, @JobName);
		RETURN -20;
	END;	

	DECLARE @body nvarchar(MAX) = (SELECT [command] FROM [msdb].dbo.[sysjobsteps] WHERE [job_id] = @jobID AND [step_name] = @StepName);

	IF @Output IS NULL BEGIN 
		SET @Output = @body;
		RETURN 0;
	END;

	SELECT @body [body];

	RETURN 0;
GO


------------------------------------------------------------------------------------------------------------------------------------------------------
--- Resource Governor
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.kill_resource_governor_connections','P') IS NOT NULL
	DROP PROC dbo.[kill_resource_governor_connections];
GO

CREATE PROC dbo.[kill_resource_governor_connections]
	@TargetWorkgroups					nvarchar(MAX)		= N'{ALL}',					-- cannot/does-not include internal or default
	@TargetResourcePools				nvarchar(MAX)		= N'{ALL}',					-- cannot/does-not include internal or default
	@TerminationLoopCount				int					= 3,
	@WaitForDelay						sysname				= N'00:00:01.500',
	@ListOnly							bit					= 0,						-- instead of executing a KILL, just lists connections that WOULD be killed. 
	@KillSelf							bit					= 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @TargetWorkgroups = ISNULL(NULLIF(@TargetWorkgroups, N''), N'{ALL}');
	SET @TargetResourcePools = ISNULL(NULLIF(@TargetResourcePools, N''), N'{ALL}');
	SET @WaitForDelay = ISNULL(NULLIF(@WaitForDelay, N''), N'00:00:01.500');
	SET @TerminationLoopCount = ISNULL(@TerminationLoopCount, 3);
	SET @ListOnly = ISNULL(@ListOnly, 0);
	SET @KillSelf = ISNULL(@KillSelf, 1);

	CREATE TABLE #targets (
		row_id int IDENTITY(1,1) NOT NULL, 
		session_id int NOT NULL, 
		login_name sysname NOT NULL,
		[host_name] sysname NULL, 
		[program_name] sysname NULL, 
		[status] sysname NULL, 
		[last_request_end_time] datetime NULL,
		[workgroup] sysname NULL, 
		[pool] sysname NULL, 
		[killed] datetime NULL, 
		[error] nvarchar(MAX) NULL
	);

	DECLARE @crlfTabTab sysname = NCHAR(13) + NCHAR(10) + NCHAR(9) + NCHAR(9);
	DECLARE @selectionSql nvarchar(MAX) = N'
	SELECT 
		s.[session_id],
		s.[login_name],
		s.[host_name], 
		s.[program_name], 
		s.[status], 
		s.[last_request_end_time],
		g.[name] [workgroup],
		p.[name] [pool]
	FROM 
		sys.[dm_exec_sessions] s 
		INNER JOIN sys.[dm_resource_governor_workload_groups] g ON [s].[group_id] = [g].[group_id]
		INNER JOIN sys.[dm_resource_governor_resource_pools] p ON [g].[pool_id] = [p].[pool_id] 
	WHERE 
		g.[name] NOT IN (N''internal'', N''default'') 
		AND p.[name] NOT IN (N''internal'', N''default''){targets}
		
		AND s.[session_id] NOT IN (SELECT session_id FROM #targets);';

	DECLARE @targets nvarchar(MAX) = N'';
	IF @TargetWorkgroups <> N'{ALL}' BEGIN 
		SET @targets = @crlfTabTab + N'AND [g].[name] IN (SELECT [result] FROM dbo.split_string(@TargetWorkGroups, N'','', 1)) ';
	END;

	IF @TargetResourcePools <> N'{ALL}' BEGIN 
		IF @targets = N'' BEGIN 
			SET @targets =  @crlfTabTab + N'AND [p].[name] IN (SELECT [result] FROM dbo.split_string(@TargetResourcePools, N'','', 1)) ';
		  END; 
		ELSE BEGIN 
			SET @targets = @crlfTabTab + N'AND (';
			SET @targets = @targets + @crlfTabTab + NCHAR(9) + N'([g].[name] IN (SELECT [result] FROM dbo.split_string(@TargetWorkGroups, N'','', 1))) ';
			SET @targets = @targets + @crlfTabTab + N'  OR ';
			SET @targets = @targets + @crlfTabTab + NCHAR(9) + N'([p].[name] IN (SELECT [result] FROM dbo.split_string(@TargetResourcePools, N'','', 1))) ';
			SET @targets = @targets + @crlfTabTab + N')'
		END;
	END;

	SET @selectionSql = REPLACE(@selectionSql, N'{targets}', @targets);

	DECLARE @loopsProcessed int = 0;

LoadAndKill:
	INSERT INTO [#targets] (
		[session_id],
		[login_name],
		[host_name],
		[program_name],
		[status], 
		[last_request_end_time],
		[workgroup],
		[pool]
	)
	EXEC sp_executesql 
		@selectionSql, 
		N'@TargetWorkGroups nvarchar(MAX), @TargetResourcePools nvarchar(MAX)', 
		@TargetWorkgroups = @TargetWorkgroups, 
		@TargetResourcePools = @TargetResourcePools;

	IF @ListOnly = 1 BEGIN 
		IF EXISTS (SELECT NULL FROM [#targets]) BEGIN
			SELECT 
				[session_id],
				[login_name],
				[host_name],
				CASE 
					WHEN [status] = 'sleeping' THEN 
						CASE 
							WHEN DATEDIFF(MINUTE, [last_request_end_time], GETDATE()) > 2880 THEN 'sleeping - DAYS (2+)'
							WHEN DATEDIFF(MINUTE, [last_request_end_time], GETDATE()) > 1440 THEN 'sleeping - DAY'
							WHEN DATEDIFF(MINUTE, [last_request_end_time], GETDATE()) > 120 THEN 'sleeping - HOURS+'
							WHEN DATEDIFF(MINUTE, [last_request_end_time], GETDATE()) > 60 THEN 'sleeping - HOUR+'
							WHEN DATEDIFF(MINUTE, [last_request_end_time], GETDATE()) > 10 THEN 'sleeping - MINUTES (10+)'
							WHEN DATEDIFF(MINUTE, [last_request_end_time], GETDATE()) > 2 THEN 'sleeping - MINUTES'
							ELSE 'sleeping - SECONDS'
						END
					ELSE [status]
				END [state], 
				[program_name],
				[workgroup],
				[pool]
			FROM 
				[#targets]
			ORDER BY 
				[state],
				[session_id];
		END;
		RETURN 0;
	END;

	DECLARE @rowId int, @sessionID int;
	DECLARE @error nvarchar(MAX);
	DECLARE @killSql nvarchar(MAX);

	DECLARE [killer] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		row_id, 
		session_id 
	FROM 
		[#targets]
	WHERE 
		[killed] IS NULL;
	
	OPEN [killer];
	FETCH NEXT FROM [killer] INTO @rowId, @sessionID;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
		
		SET @error = NULL;

		IF @sessionID <> @@SPID BEGIN 
			SET @killSql = N'KILL ' + CAST(@sessionID AS sysname) + N';';
		
			BEGIN TRY 
				EXEC sp_executesql 
					@killSql; 
			END TRY 
			BEGIN CATCH 
				SET @error = CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE();
			END CATCH

			UPDATE [#targets] 
			SET 
				[killed] = GETDATE(), 
				[error] = @error 
			WHERE 
				[row_id] = @rowId
		END;
	
		FETCH NEXT FROM [killer] INTO @rowId, @sessionID;
	END;
	
	CLOSE [killer];
	DEALLOCATE [killer];

	SET @loopsProcessed = @loopsProcessed + 1;

	IF @loopsProcessed <= @TerminationLoopCount BEGIN 
		WAITFOR DELAY @WaitForDelay;
		RAISERROR(N'-- Starting a new pass to load and KILL session_ids ... ', 8, 1) WITH NOWAIT; /* NOWAIT really never works... but, worth trying vs PRINT... */
		GOTO LoadAndKill;
	END;

	IF EXISTS (SELECT NULL FROM [#targets] WHERE [error] IS NOT NULL) BEGIN 
		SELECT 
			[session_id],
			[host_name],
			[program_name],
			[workgroup],
			[pool],
			[killed],
			[error] 
		FROM 
			[#targets] 
		WHERE 
			[error] IS NOT NULL;
	END;

	IF @KillSelf = 1 BEGIN 
		IF EXISTS (SELECT NULL FROM [#targets] WHERE [session_id] = @@SPID) BEGIN
			/* we can't KILL our own spid... but we CAN terminate it:   */
			RAISERROR(N'Terminating current session_id due to @KillSelf Directive set to value of 1.', 22, 16) WITH LOG;
		END;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.resource_governor_compute_metrics','P') IS NOT NULL
	DROP PROC dbo.[resource_governor_compute_metrics];
GO

CREATE PROC dbo.[resource_governor_compute_metrics]
	@Mode				sysname			= N'POOL_AND_WORKGROUP'		-- POOL | WORKGROUP | POOL_AND_WORKGROUP
AS
    SET NOCOUNT ON; 

	--{copyright}

	SET @Mode = ISNULL(NULLIF(@Mode, N''), N'POOL_AND_WORKGROUP');
	
	IF UPPER(@Mode) IN (N'POOL', N'POOL_AND_WORKGROUP') BEGIN 
		SELECT 
			[p].[name] + N' (' + CAST([p].[pool_id] AS sysname) + N')' [pool],
			CAST([p].[min_cpu_percent] AS sysname) + N' - ' + CAST([p].[max_cpu_percent] AS sysname) [cpu_%_range],
			[p].[cap_cpu_percent] [cpu_cap],
			CAST([p].[min_memory_percent] AS sysname) + N' - ' + CAST([p].[max_memory_percent] AS sysname) [mem_%_range],
			CAST([p].[max_memory_kb] / 1048576.0 AS decimal(22,2)) [max_gb],
			CAST([p].[target_memory_kb] / 1048576.0 AS decimal(22,2)) [target_gb],
			CAST([p].[used_memory_kb] / 1048576.0 AS decimal(22,2)) [used_gb],
			' ' [ ],
			[p].[statistics_start_time],
			FORMAT([p].[total_cpu_active_ms], N'N0') [total_cpu],
			--FORMAT([p].[total_cpu_usage_ms], N'N0') [total_cpu],
			FORMAT([p].[total_cpu_delayed_ms], N'N0') [yielded_cpu],
			FORMAT([p].[total_cpu_usage_preemptive_ms], N'N0') [preemptive_cpu],
			FORMAT([p].[total_cpu_violation_sec], N'N0') [violation_seconds],
			FORMAT([p].[total_cpu_violation_delay_ms], N'N0') [violation_delays],		
			' ' [_],
			CAST([p].[cache_memory_kb] / 1048576.0 AS decimal(22,2)) [cache_gb],
			CAST([p].[compile_memory_kb]/ 1048576.0 AS decimal(22,2)) [compile_gb],
			CAST([p].[used_memgrant_kb] / 1048576.0 AS decimal(22,2)) [used_grant_gb],
			FORMAT([p].[total_memgrant_count], N'N0') [grants],
			FORMAT([p].[total_memgrant_timeout_count], N'N0') [grant_timeouts],
			FORMAT([p].[out_of_memory_count], N'N0') [failed_grants],
			FORMAT([p].[active_memgrant_count], N'N0') [current_grant],
			--CAST([p].[active_memgrant_kb] / 1048576.0 AS decimal(22,2)) [current_grant_gb],
			FORMAT([p].[memgrant_waiter_count], N'N0') [grants_pending]
		FROM 
			sys.[dm_resource_governor_resource_pools] [p]
	END;

	IF UPPER(@Mode) IN (N'WORKGROUP', N'POOL_AND_WORKGROUP') BEGIN 
		SELECT 
			[w].[name] + N' (' + CAST([w].[group_id] AS sysname) + N')' [workgroup],
			[p].[name] + N' (' + CAST([w].[pool_id] AS sysname) + N')' [pool],
			[w].[importance],
			[w].[request_max_memory_grant_percent] [max_grant_%],
			[w].[request_max_cpu_time_sec] [max_cpu_sec],
			[w].[request_memory_grant_timeout_sec] [grant_sec],
			[w].[group_max_requests] [max_requests],
			[w].[max_dop],
			N' ' [ ],
			--DATEDIFF(MILLISECOND, [w].[statistics_start_time], GETDATE()) [stats], 
			[w].[statistics_start_time],
			FORMAT([w].[total_request_count], N'N0') [total_requests],
			FORMAT([w].[total_queued_request_count], N'N0') [total_queued],
			[w].[active_request_count] [running],
			[w].[queued_request_count] [queued],
			FORMAT([w].[total_cpu_limit_violation_count], N'N0') [cpu_violations],
			FORMAT([w].[total_cpu_usage_ms], N'N0') [total_cpu],
			FORMAT([w].[max_request_cpu_time_ms], N'N0') [largest_cpu],
			--[w].[blocked_task_count],
			--[w].[total_lock_wait_count],
			--[w].[total_lock_wait_time_ms],
			FORMAT([w].[total_query_optimization_count], N'N0') [optimizations],
			FORMAT([w].[total_suboptimal_plan_generation_count], N'N0') [suboptimal_grants],
			FORMAT([w].[total_reduced_memgrant_count], N'N0') [reduced_grants],
			CAST((CAST([w].[max_request_grant_memory_kb] AS decimal(24,2)) / 1024.0) AS decimal(24,1)) [largest_grant_mb],  -- to MB... 
			[w].[active_parallel_thread_count] [parallel_threads],
			[w].[effective_max_dop],
			FORMAT([w].[total_cpu_usage_preemptive_ms], N'N0') [preemptive_ms]

			-- 2019+ only:
			--[request_max_memory_grant_percent_numeric] and... don't care about getting % as a float vs int... 
		FROM 
			sys.[dm_resource_governor_workload_groups] [w]
			INNER JOIN sys.[dm_resource_governor_resource_pools] [p] ON [w].[pool_id] = [p].[pool_id];
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.resource_governor_io_metrics','P') IS NOT NULL
	DROP PROC dbo.[resource_governor_io_metrics];
GO

CREATE PROC dbo.[resource_governor_io_metrics]
	@Mode				sysname	= N'READ_AND_WRITE'		-- READ | WRITE | READ_AND_WRITE
AS
    SET NOCOUNT ON; 

	SET @Mode = ISNULL(NULLIF(@Mode, N''), N'READ_AND_WRITE');

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF UPPER(@Mode) IN (N'READ', N'READ_AND_WRITE') BEGIN
		SELECT 
			[p].[name] + N' (' + CAST([p].[pool_id] AS sysname) + N')' [pool],
			[p].[statistics_start_time],
			[p].[min_iops_per_volume] [iops_min],
			[p].[max_iops_per_volume] [iops_max],
			' ' [ ],
			CAST(CAST([p].[read_bytes_total] AS decimal(24,2)) / 1073741824.0 AS decimal(24,1))  [read_gb],
			FORMAT([p].[read_io_completed_total], N'N0') [total_reads],
				--CAST(CAST(CAST([p].[read_bytes_total] as decimal(24,2)) / 1048576.0 as decimal(24,1)) / [p].[read_io_completed_total] as decimal(24,3))  [avg_read_mb],
			FORMAT([p].[read_io_queued_total], N'N0')  [queued_reads],  -- queued (cuz of stalls/throughput/etc.)
			FORMAT([p].[read_io_throttled_total], N'N0')  [throttled_reads],  -- throttled cuz of policy... 
			CAST((CAST([p].[read_io_stall_total_ms] AS decimal(24,2)) / CAST([p].[read_io_completed_total] AS decimal(24,2))) AS decimal(12,3)) [avg_stall],
			CAST((CAST([p].[read_io_stall_queued_ms] AS decimal(24,2)) / CAST([p].[read_io_completed_total] AS decimal(24,2))) AS decimal(12,3)) [queued_stall],
			FORMAT([p].[io_issue_violations_total], N'N0') [io_violations],
			CAST((CAST([p].[io_issue_delay_total_ms] AS decimal(24,2)) / CAST([p].[io_issue_violations_total] AS decimal(24,2))) AS decimal(18,3)) [avg_violation_ms]
		FROM  
			sys.[dm_resource_governor_resource_pools] [p];
	END;

	IF UPPER(@Mode) IN (N'WRITE', N'READ_AND_WRITE') BEGIN
		SELECT 
			[p].[name] + N' (' + CAST([p].[pool_id] AS sysname) + N')' [pool],
			[p].[statistics_start_time],
			[p].[min_iops_per_volume] [iops_min],
			[p].[max_iops_per_volume] [iops_max],
			' ' [ ],
			CAST(CAST([p].[write_bytes_total] as decimal(24,2)) / 1073741824.0 as decimal(24,1))  [write_gb],
			FORMAT([p].[write_io_completed_total], N'N0') [total_writes],
			FORMAT([p].[write_io_queued_total], N'N0')  [queued_writes],  -- queued (cuz of stalls/throughput/etc.)
			FORMAT([p].[write_io_throttled_total], N'N0')  [throttled_writes],  -- throttled cuz of policy... 
			CAST((CAST([p].[write_io_stall_total_ms] as decimal(24,2)) / CAST([p].[write_io_completed_total] as decimal(24,2))) as decimal(12,3)) [avg_stall],
			CAST((CAST([p].[write_io_stall_queued_ms] as decimal(24,2)) / CAST([p].[write_io_completed_total] as decimal(24,2))) as decimal(12,3)) [queued_stall],
			FORMAT([p].[io_issue_violations_total], N'N0') [io_violations],
			CAST((CAST([p].[io_issue_delay_total_ms] as decimal(24,2)) / CAST([p].[io_issue_violations_total] as decimal(24,2))) as decimal(18,3)) [avg_violation_ms]
		FROM 
			sys.[dm_resource_governor_resource_pools] [p];
	END;

	RETURN 0;
GO



------------------------------------------------------------------------------------------------------------------------------------------------------
--- Capacity Planning
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.translate_cpu_counters','P') IS NOT NULL
	DROP PROC dbo.[translate_cpu_counters];
GO

CREATE PROC dbo.[translate_cpu_counters]
	@SourceTable			sysname, 
	@TargetTable			sysname, 
	@OverwriteTarget		bit				= 0, 
	@PrintOnly				bit				= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 
	
	IF UPPER(@TargetTable) = UPPER(@SourceTable) BEGIN 
		RAISERROR('@SourceTable and @TargetTable can NOT be the same - please specify a new/different name for the @TargetTable parameter.', 16, 1);
		RETURN -1;
	END;

	IF @TargetTable IS NULL BEGIN 
		RAISERROR('Please specify a @TargetTable value - for the output of dbo.translate_cpu_perfcounters', 16, 1); 
		RETURN -2;
	END; 

	-- translate @TargetTable details: 
	SELECT @TargetTable = N'[' + ISNULL(PARSENAME(@TargetTable, 3), PARSENAME(@normalizedName, 3)) + N'].[' + ISNULL(PARSENAME(@TargetTable, 2), PARSENAME(@normalizedName, 2)) + N'].[' + PARSENAME(@TargetTable, 1) + N']';
	
	-- Determine if @TargetTable already exists:
	DECLARE @targetObjectID int;
	DECLARE @check nvarchar(MAX) = N'SELECT @targetObjectID = OBJECT_ID(''' + @TargetTable + N''');'

	EXEC [sys].[sp_executesql] 
		@check, 
		N'@targetObjectID int OUTPUT', 
		@targetObjectID = @targetObjectID OUTPUT; 

	IF @targetObjectID IS NOT NULL BEGIN 
		IF @OverwriteTarget = 1 AND @PrintOnly = 0 BEGIN
			DECLARE @drop nvarchar(MAX) = N'USE [' + PARSENAME(@TargetTable, 3) + N']; DROP TABLE [' + PARSENAME(@TargetTable, 2) + N'].[' + PARSENAME(@TargetTable, 1) + N'];';
			
			EXEC sys.sp_executesql @drop;

		  END;
		ELSE BEGIN
			RAISERROR('@TargetTable %s already exists. Please either drop it manually, or set @OverwriteTarget to a value of 1 during execution of this sproc.', 16, 1);
			RETURN -5;
		END;
	END;

	-------------------------------------------------------------------------------------------------------------------------

	DECLARE @targetDBName sysname = PARSENAME(@normalizedName, 3);
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @sql nvarchar(MAX);

	DECLARE @sampleRow nvarchar(200);

	SET @sql = N'SET @sampleRow = (SELECT TOP 1 [name] FROM [' + @targetDBName + N'].sys.[all_columns] WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND column_id > 1);';

	EXEC sp_executesql 
		@sql, 
		N'@sampleRow nvarchar(200) OUTPUT',
		@sampleRow = @sampleRow OUTPUT;

	DECLARE @serverName sysname; 
	DECLARE @instanceNamePrefix sysname;
	
	SET @serverName = SUBSTRING(@sampleRow, 3, LEN(@sampleRow));
	SET @serverName = SUBSTRING(@serverName, 0, CHARINDEX(N'\', @serverName));

	IF NULLIF(@serverName, N'') IS NULL BEGIN 
		RAISERROR(N'Unable to extract Server-Name from input .csv file. Processing cannot continue.', 16, 1);
		RETURN -9;
	END;

	SET @sql = N'SET @sampleRow = (SELECT TOP 1 [name] FROM [' + @targetDBName + N'].sys.[all_columns] WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND [name] LIKE ''%Batch Requests/sec''); ';
	EXEC sp_executesql 
		@sql, 
		N'@sampleRow nvarchar(200) OUTPUT',
		@sampleRow = @sampleRow OUTPUT;	
		
	SET @instanceNamePrefix = LEFT(@sampleRow, CHARINDEX(N':SQL Statistics', @sampleRow));

	
	DECLARE @timeZone sysname; 
	SET @sql = N'SELECT 
		@timeZone = [name]
	FROM 
		[' + @targetDBName + N'].sys.[columns] 
	WHERE 
		[object_id] = OBJECT_ID(''' + @normalizedName + N''')
		AND [column_id] = 1; ';

	EXEC sp_executesql 
		@sql, 
		N'@timeZone sysname OUTPUT',
		@timeZone = @timeZone OUTPUT;	

	DECLARE @procCountColumnNameValue sysname; 
	DECLARE @totalCoreCount int;	

	SET @sql = N'SELECT @procCountColumnNameValue = [name] FROM [' + @targetDBName + N'].sys.[all_columns] WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND [column_id] = (
	SELECT MAX(column_id) FROM (
		SELECT 
			[column_id]
		FROM 
			[' + @targetDBName + N'].sys.[all_columns]
		WHERE 
			[object_id] = OBJECT_ID(''' + @normalizedName + N''')
			AND 
				(
					[name] LIKE N''%Processor(%Processor Time'' 
					AND 
					[name] NOT LIKE N''%(_Total)\%''
				)
		) x
); '; 


	EXEC [sys].[sp_executesql] 
		@sql, 
		N'@procCountColumnNameValue sysname OUTPUT', 
		@procCountColumnNameValue = @procCountColumnNameValue OUTPUT;

	SET @procCountColumnNameValue = REPLACE(@procCountColumnNameValue, N')\% Processor Time', N'');
	SET @procCountColumnNameValue = REPLACE(@procCountColumnNameValue, N'\\' + @serverName + N'\Processor(', N'');
	SET @totalCoreCount = CAST(@procCountColumnNameValue AS int) + 1;

	IF NULLIF(@totalCoreCount, 0) IS NULL BEGIN
		RAISERROR('Invalid Metrics Data Detected. Target table %s does NOT provide CPU metrics data.', 16, 1, @normalizedName);
		RETURN -20;
	END;


	DECLARE @statement nvarchar(MAX) = N'WITH [translated] AS ( 
	SELECT
		TRY_CAST([{timeZone}] AS datetime) [timestamp],
{translatedCPUs}		ISNULL(TRY_CAST([\\{serverName}\Processor(_Total)\% Processor Time]  AS decimal(22,2)), 0) [total]
	FROM 
		{normalizedName}
),
[aggregated] AS ( 
	SELECT 
		N''{serverName}'' [server_name],
		[timestamp], 
		[total] [percentage_used], 
{aggregatedCPUs} 		(
		SELECT SUM(x.v) FROM (VALUES {cteConstructedAggregateCPUs}) x(v)
		) [total_cpu_used]
	FROM 
		[translated]
)

SELECT 
	* 
INTO 
	{TargetTable}
FROM 
	[aggregated]
ORDER BY 
	[total_cpu_used] DESC; ';


	-- Generate Projection data:
	DECLARE @translatedCPUs nvarchar(MAX) = N'';
	DECLARE @aggregatedCPUs nvarchar(MAX) = N'';
	DECLARE @cteConstructedAggregateCPUs nvarchar(MAX) = N'';
		
	SELECT 
		@translatedCPUs = @translatedCPUs + @tab + @tab + N'ISNULL(TRY_CAST([\\{serverName}\Processor(' + CAST(x.[id] - 1 AS sysname) + N')\% Processor Time] as decimal(22,2)), 0) [processor' + CAST(x.[id] - 1 AS sysname) + N'], ' + @crlf,
		@aggregatedCPUs = @aggregatedCPUs + @tab + @tab + N'[processor' + CAST(x.[id] - 1 AS sysname) + N'], ' + @crlf,
		@cteConstructedAggregateCPUs = @cteConstructedAggregateCPUs + '([processor' + CAST(x.[id] - 1 AS sysname) + N']),'
	FROM 
		(
			SELECT TOP(@totalCoreCount)
				ROW_NUMBER() OVER (ORDER BY [object_id]) [id]	
			FROM 
				sys.objects
		) x
	ORDER BY 
		x.[id];
	
	SET @cteConstructedAggregateCPUs = LEFT(@cteConstructedAggregateCPUs, LEN(@cteConstructedAggregateCPUs) - 1);

	-- Account for SQL Server metrics/translation: 
	DECLARE @sqlMetricsColumns table (
		[column_id] int IDENTITY(1,1) NOT NULL, 
		[raw_name] sysname NOT NULL, 
		[translation] sysname NULL,
		[aliased_name] sysname NOT NULL
	); 

	-- insert N rows for buffer nodes (i.e., PLE metrics per buffer node):
	SET @sql = N'SELECT 
		REPLACE([name], N''\\' +  @serverName + N''', N'''') [name], 
		N''ISNULL(CAST([{c}] as int), 0)'',
		N''ple_node_'' + REPLACE(REPLACE([name], (N''\\' + @serverName + N'\SQLServer:Buffer Node(''), N''''), N'')\Page life expectancy'', N'''')
	FROM 
		' + @targetDBName + N'.sys.columns 
	WHERE 
		[object_id] = OBJECT_ID(''' + @normalizedName + N''')
		AND [name] LIKE N''%Page life expectancy''
	ORDER BY 
		[column_id]; ';

	INSERT INTO @sqlMetricsColumns (
		[raw_name],
		[translation],
		[aliased_name]
	)
	EXEC sp_executesql @sql;

-- MKC: inclusion of these static counters ... has to be a question of copy/paste/tweak failure... i.e., these are throwing errors
--	and they're JUST NOT relevant or needed.
	-- static SQL counters:
	--INSERT INTO @sqlMetricsColumns (
	--	[raw_name], 
	--	[translation],
	--	[aliased_name]
	--)
	--VALUES

-- MKC: 2022-08-30 ... uh... why are these included in CPU counters? 
	--(N'\SQLServer:Buffer Manager\Lazy writes/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'lazy_writes/sec'),
	--(N'\SQLServer:Buffer Manager\Page lookups/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'page_lookups/sec'),
	--(N'\SQLServer:Buffer Manager\Page reads/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'page_reads/sec'),
	--(N'\SQLServer:Buffer Manager\Page writes/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'pages_writes/sec'),
	--(N'\SQLServer:Buffer Manager\Readahead pages/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'readahead_pages/sec'),
	--(N'\SQLServer:Latches\Average Latch Wait Time (ms)', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'avg_latch_time(ms)'),
	--(N'\SQLServer:Latches\Latch Waits/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'latch_waits\sec'),
	--(N'\SQLServer:Latches\Total Latch Wait Time (ms)', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'total_latch_wait(ms)'),
	--(N'\SQLServer:Locks(_Total)\Lock Requests/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'lock_requests\sec'),
--MKC: temporary removal... 	
	--(N'\SQLServer:Locks(_Total)\Lock Timeouts (timeout > 0)/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'lock_timeouts\sec'),
	--(N'\SQLServer:Locks(_Total)\Lock Wait Time (ms)', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'lock_wait(ms)'),
	--(N'\SQLServer:Locks(_Total)\Lock Waits/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'lock_waits\sec'),
	--(N'\SQLServer:Locks(_Total)\Number of Deadlocks/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'deadlocks\sec'),
	--(N'\SQLServer:Memory Manager\Connection Memory (KB)', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'connection_mem'),
	--(N'\SQLServer:Memory Manager\Granted Workspace Memory (KB)', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'granted_workspace'),
	--(N'\SQLServer:Memory Manager\Memory Grants Outstanding', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'active_grants'),
	--(N'\SQLServer:Memory Manager\Memory Grants Pending', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'pending_grants'),
	--(N'\SQLServer:Memory Manager\Target Server Memory (KB)', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'target_mem'),
	--(N'\SQLServer:Memory Manager\Total Server Memory (KB)', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'total_mem'),
	--(N'\SQLServer:SQL Statistics\Batch Requests/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'batch_requests\sec'),
	--(N'\SQLServer:SQL Statistics\SQL Attention rate', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'attention_rate'),
	--(N'\SQLServer:SQL Statistics\SQL Compilations/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'compilations\sec'),
	--(N'\SQLServer:SQL Statistics\SQL Re-Compilations/sec', N'ISNULL(TRY_CAST([{c}] as decimal(24,3)), 0.0)', N'recompilations\sec');

	--DECLARE @sqlMetrics nvarchar(MAX) = N''; 

	--SELECT 
	--	@sqlMetrics = @sqlMetrics + @tab + @tab +
	--	CASE 
	--		WHEN [translation] IS NULL THEN N'[\\' + @serverName + [raw_name] + N'] [' + [aliased_name] + N'], ' 
	--		ELSE REPLACE([translation], N'{c}', (N'\\' + @serverName + [raw_name])) + N' [' + [aliased_name] + N'], ' 
	--	END + @crlf
	--FROM 
	--	@sqlMetricsColumns
	--ORDER BY 
	--	[column_id];

	--IF NULLIF(@sqlMetrics, N'') IS NOT NULL
	--	SET @sqlMetrics = LEFT(@sqlMetrics, LEN(@sqlMetrics) - 4);

	--DECLARE @sqlMetricAliases nvarchar(MAX) = N'';
	--SELECT 
	--	@sqlMetricAliases = @sqlMetricAliases + @tab + @tab + QUOTENAME([aliased_name]) + N', ' + @crlf
	--FROM 
	--	@sqlMetricsColumns 
	--ORDER BY 
	--	[column_id];

	--IF NULLIF(@sqlMetricAliases, N'') IS NOT NULL
	--	SET @sqlMetricAliases = LEFT(@sqlMetricAliases, LEN(@sqlMetricAliases) -4);	

	SET @statement = REPLACE(@statement, N'{normalizedName}', @normalizedName); 
	SET @statement = REPLACE(@statement, N'{timeZone}', @timeZone);
	SET @statement = REPLACE(@statement, N'{translatedCPUs}', @translatedCPUs);
	SET @statement = REPLACE(@statement, N'{aggregatedCPUs}', @aggregatedCPUs);
	SET @statement = REPLACE(@statement, N'{cteConstructedAggregateCPUs}', @cteConstructedAggregateCPUs);
	--SET @statement = REPLACE(@statement, N'{sqlStats}', @sqlMetrics);
	--SET @statement = REPLACE(@statement, N'{sqlStatsAliases}', @sqlMetricAliases);

	SET @statement = REPLACE(@statement, N'{serverName}', @serverName);
	SET @statement = REPLACE(@statement, N'{TargetTable}', @TargetTable);

	IF @PrintOnly = 1 BEGIN 
		EXEC dbo.[print_long_string] @statement; 
	  END; 
	ELSE BEGIN 
		EXEC sp_executesql @statement;

		SET @statement = N'SELECT COUNT(*) [total_rows_exported] FROM ' + @TargetTable + N'; ';
		EXEC [sys].[sp_executesql] @statement;

	END; 
		
	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.translate_io_perfcounters','P') IS NOT NULL
	DROP PROC dbo.[translate_io_perfcounters];
GO

CREATE PROC dbo.[translate_io_perfcounters]
	@SourceTable			sysname, 
	@TargetTable			sysname, 
	@OverwriteTarget		bit				= 0, 
	@PrintOnly				bit				= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @SourceTable = NULLIF(@SourceTable, N'');
	SET @TargetTable = NULLIF(@TargetTable, N'');

	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	IF UPPER(@TargetTable) = UPPER(@SourceTable) BEGIN 
		RAISERROR('@SourceTable and @TargetTable can NOT be the same - please specify a new/different name for the @TargetTable parameter.', 16, 1);
		RETURN -1;
	END;

	IF @TargetTable IS NULL BEGIN 
		RAISERROR('Please specify a @TargetTable value - for the output of dbo.translate_io_perfcounters', 16, 1); 
		RETURN -2;
	END; 

	-- translate @TargetTable details: 
	SELECT @TargetTable = N'[' + ISNULL(PARSENAME(@TargetTable, 3), PARSENAME(@normalizedName, 3)) + N'].[' + ISNULL(PARSENAME(@TargetTable, 2), PARSENAME(@normalizedName, 2)) + N'].[' + PARSENAME(@TargetTable, 1) + N']';
	
	-- Determine if @TargetTable already exists:
	DECLARE @targetObjectID int;
	DECLARE @check nvarchar(MAX) = N'SELECT @targetObjectID = OBJECT_ID(''' + @TargetTable + N''');'

	EXEC [sys].[sp_executesql] 
		@check, 
		N'@targetObjectID int OUTPUT', 
		@targetObjectID = @targetObjectID OUTPUT; 

	IF @targetObjectID IS NOT NULL BEGIN 
		IF @OverwriteTarget = 1 AND @PrintOnly = 0 BEGIN
			DECLARE @drop nvarchar(MAX) = N'USE [' + PARSENAME(@TargetTable, 3) + N']; DROP TABLE [' + PARSENAME(@TargetTable, 2) + N'].[' + PARSENAME(@TargetTable, 1) + N'];';
			
			EXEC sys.sp_executesql @drop;

		  END;
		ELSE BEGIN
			RAISERROR('@TargetTable %s already exists. Please either drop it manually, or set @OverwriteTarget to a value of 1 during execution of this sproc.', 16, 1);
			RETURN -5;
		END;
	END;

	-------------------------------------------------------------------------------------------------------------------------
	-- Import/Translate:

	DECLARE @targetDBName sysname = PARSENAME(@normalizedName, 3);
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @sql nvarchar(MAX);

	DECLARE @sampleRow nvarchar(200);

	SET @sql = N'SET @sampleRow = (SELECT TOP 1 [name] FROM [' + @targetDBName + N'].sys.[all_columns] WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND [name] LIKE ''%Disk Read Bytes/sec''); ';
	EXEC sp_executesql 
		@sql, 
		N'@sampleRow nvarchar(200) OUTPUT',
		@sampleRow = @sampleRow OUTPUT;

	DECLARE @hostNamePrefix sysname; 
	DECLARE @instanceNamePrefix sysname;
	SET @hostNamePrefix = LEFT(@sampleRow, CHARINDEX(N'\PhysicalDisk', @sampleRow));

	SET @sql = N'SET @sampleRow = (SELECT TOP 1 [name] FROM [' + @targetDBName + N'].sys.[all_columns] WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND [name] LIKE ''%Batch Requests/sec''); ';
	EXEC sp_executesql 
		@sql, 
		N'@sampleRow nvarchar(200) OUTPUT',
		@sampleRow = @sampleRow OUTPUT;	
		
	SET @instanceNamePrefix = LEFT(@sampleRow, CHARINDEX(N':SQL Statistics', @sampleRow));

	DECLARE @timeZone sysname; 
	SET @sql = N'SELECT 
		@timeZone = [name]
	FROM 
		[' + @targetDBName + N'].sys.[columns] 
	WHERE 
		[object_id] = OBJECT_ID(''' + @normalizedName + N''')
		AND [column_id] = 1; ';

	EXEC sp_executesql 
		@sql, 
		N'@timeZone sysname OUTPUT',
		@timeZone = @timeZone OUTPUT;	

	DECLARE @drives table (
		row_id int IDENTITY(1,1) NOT NULL, 
		drive sysname NOT NULL, 
		simplified sysname NULL
	); 

	SET @sql = N'WITH core AS ( 
		SELECT 
			column_id,
			REPLACE(name, @hostNamePrefix, N'''') [name]
		FROM 
			[' + @targetDBName + N'].sys.[all_columns] 
		WHERE 
			[object_id] = OBJECT_ID(''' + @normalizedName + N''')
			AND [name] LIKE ''%Disk Read Bytes/sec''
	) 

	SELECT 
		REPLACE(REPLACE([name], ''PhysicalDisk('', ''''), N'')\Disk Read Bytes/sec'', N'''') [drive]
	FROM 
		core; ';

	INSERT INTO @drives ([drive])
	EXEC sp_executesql 
		@sql,
		N'@hostNamePrefix sysname', 
		@hostNamePrefix = @hostNamePrefix;

	UPDATE @drives
	SET 
		[simplified] = REPLACE(REPLACE(drive, LEFT(drive,  CHARINDEX(N' ', drive)), N''), N':', N'');

	DECLARE @statement nvarchar(MAX) = N'
	WITH translated AS (
		SELECT 
			TRY_CAST([{timeZone}] as datetime) [timestamp],
			TRY_CAST([\\{HostName}\Processor(_Total)\% Processor Time]  as decimal(10,2)) [% CPU],
			--TRY_CAST([{InstanceName}Buffer Manager\Page life expectancy] as int) [PLE],
			--TRY_CAST([{InstanceName}SQL Statistics\Batch Requests/sec] as decimal(22,2)) [batches/second],
        
			{ReadBytes}
			{WriteBytes}
			{MSPerRead}
			{MSPerWrite}
			{ReadsPerSecond}
			{WritesPerSecond}
		FROM 
			{TableName}
	), 
	aggregated AS (
		SELECT 
			[timestamp],
			[% CPU],
			--[PLE],
			--[batches/second],   

			{AggregatedThroughput}
			{AggregatedIOPS}
			{AggregatedLatency}

			, (SELECT MAX(latency) FROM (VALUES {PeakLatency}) AS x(latency)) [PeakLatency]
		FROM 
			translated 
	)

	SELECT 
		N''{HostName}'' [server_name],
		[timestamp],
		[% CPU],
		--[PLE],
		--[batches/second],

		{Throughput}
		{IOPS}
		{Latency},
		[PeakLatency]
	INTO 
		{TargetTable}
	FROM 
		[aggregated]; ';

	------------------------------------------------------------------------------------------------------------
	-- Raw Data / Extraction (from nvarchar(MAX) columns).
	------------------------------------------------------------------------------------------------------------
	--------------------------------
	-- ReadBytes
	DECLARE @ReadBytes nvarchar(MAX) = N'';
	SELECT 
		@ReadBytes = @ReadBytes + N'TRY_CAST([\\{HostName}\PhysicalDisk(' + drive + N')\Disk Read Bytes/sec] as decimal(22,2)) [ReadBytes.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @statement = REPLACE(@statement, N'{ReadBytes}', @ReadBytes);

	--------------------------------
	-- WriteBytes
	DECLARE @WriteBytes nvarchar(MAX) = N'';
	SELECT 
		@WriteBytes = @WriteBytes + N'TRY_CAST([\\{HostName}\PhysicalDisk(' + drive + N')\Disk Write Bytes/sec] as decimal(22,2)) [WriteBytes.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @statement = REPLACE(@statement, N'{WriteBytes}', @WriteBytes);

	--------------------------------
	-- MSPerRead
	DECLARE @MSPerRead nvarchar(MAX) = N'';
	SELECT 
		@MSPerRead = @MSPerRead + N'TRY_CAST([\\{HostName}\PhysicalDisk(' + drive + N')\Avg. Disk sec/Read] as decimal(22,2)) [MSPerRead.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives
	WHERE 
		[drive] <> '_Total';

	SET @statement = REPLACE(@statement, N'{MSPerRead}', @MSPerRead);

	--------------------------------
	-- MSPerWrite
	DECLARE @MSPerWrite nvarchar(MAX) = N'';
	SELECT 
		@MSPerWrite = @MSPerWrite + N'TRY_CAST([\\{HostName}\PhysicalDisk(' + drive + N')\Avg. Disk sec/Write] as decimal(22,2)) [MSPerWrite.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives
	WHERE 
		[drive] <> '_Total';

	SET @statement = REPLACE(@statement, N'{MSPerWrite}', @MSPerWrite);

	--------------------------------
	-- ReadsPerSecond
	DECLARE @ReadsPerSecond nvarchar(MAX) = N'';
	SELECT 
		@ReadsPerSecond = @ReadsPerSecond + N'TRY_CAST([\\{HostName}\PhysicalDisk(' + drive + N')\Disk Reads/sec] as decimal(22,2)) [ReadsPerSecond.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @statement = REPLACE(@statement, N'{ReadsPerSecond}', @ReadsPerSecond);

	--------------------------------
	-- WritesPerSecond
	DECLARE @WritesPerSecond nvarchar(MAX) = N'';
	SELECT 
		@WritesPerSecond = @WritesPerSecond + N'TRY_CAST([\\{HostName}\PhysicalDisk(' + drive + N')\Disk Writes/sec] as decimal(22,2)) [WritesPerSecond.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @WritesPerSecond = LEFT(@WritesPerSecond, LEN(@WritesPerSecond) - 5);  -- tabs/etc.... 
	SET @statement = REPLACE(@statement, N'{WritesPerSecond}', @WritesPerSecond);

	------------------------------------------------------------------------------------------------------------
	-- Aggregated Data
	------------------------------------------------------------------------------------------------------------
	--------------------------------
	-- AggregatedThroughput
	DECLARE @AggregatedThroughput nvarchar(MAX) = N'';
	SELECT 
		@AggregatedThroughput = @AggregatedThroughput + N'CAST(([ReadBytes.' + simplified + N'] + [WriteBytes.' + simplified + N']) /  (1024.0 * 1024.0) as decimal(20,2)) [Throughput.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @statement = REPLACE(@statement, N'{AggregatedThroughput}', @AggregatedThroughput);

	--------------------------------
	-- AggregatedIOPS
	DECLARE @AggregatedIOPS nvarchar(MAX) = N'';
	SELECT 
		@AggregatedIOPS = @AggregatedIOPS + N'[ReadsPerSecond.' + simplified + N'] + [WritesPerSecond.' + simplified + N'] [IOPs.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @statement = REPLACE(@statement, N'{AggregatedIOPS}', @AggregatedIOPS);

	--------------------------------
	-- AggregatedLatency
	DECLARE @AggregatedLatency nvarchar(MAX) = N'';
	SELECT 
		@AggregatedLatency = @AggregatedLatency + N'[MSPerRead.' + simplified + N'] + [MSPerWrite.' + simplified + N'] [Latency.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives
	WHERE 
		[drive] <> '_Total';

	SET @AggregatedLatency = LEFT(@AggregatedLatency, LEN(@AggregatedLatency) - 5);  -- tabs/etc.... 
	SET @statement = REPLACE(@statement, N'{AggregatedLatency}', @AggregatedLatency);


	DECLARE @PeakLatency nvarchar(MAX) = N'';

	SELECT 
		@PeakLatency = @PeakLatency + N'([MSPerRead.' + simplified + N'] + [MSPerWrite.' + simplified + N']), '
	FROM 
		@drives 
	WHERE 
		[drive] <> '_Total';

	SET @PeakLatency = LEFT(@PeakLatency, LEN(@PeakLatency) - 1);

	SET @statement = REPLACE(@statement, N'{PeakLatency}', @PeakLatency);
	
	------------------------------------------------------------------------------------------------------------
	-- Final Projection Details: 
	------------------------------------------------------------------------------------------------------------
	--------------------------------
	-- Throughput
	DECLARE @Throughput nvarchar(MAX) = N'';
	SELECT 
		@Throughput = @Throughput + N'[Throughput.' + simplified + N'] [MB Throughput.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @statement = REPLACE(@statement, N'{Throughput}', @Throughput);

	--------------------------------
	-- IOPs
	DECLARE @IOPs nvarchar(MAX) = N'';
	SELECT 
		@IOPs = @IOPs + N'[IOPs.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SET @statement = REPLACE(@statement, N'{IOPs}', @IOPs);

	--------------------------------
	-- Latency
	DECLARE @Latency nvarchar(MAX) = N'';
	SELECT 
		@Latency = @Latency + N'[Latency.' + simplified + N'],' + @crlf + @tab + @tab
	FROM 
		@drives
	WHERE 
		[drive] <> '_Total'; -- averages out latencies over ALL drives - vs taking the MAX... (so... we'll have to grab [peak/max).

	SET @Latency = LEFT(@Latency, LEN(@Latency) - 5);  -- tabs/etc.... 
	SET @statement = REPLACE(@statement, N'{Latency}', @Latency);

	--------------------------------
	-- TOP + ORDER BY + finalization... 

	SET @statement = REPLACE(@statement, N'{timeZone}', @timeZone);
	SET @statement = REPLACE(@statement, N'{HostName}', REPLACE(@hostNamePrefix, N'\', N''));
	SET @statement = REPLACE(@statement, N'{InstanceName}', ISNULL(@instanceNamePrefix, N''));
	SET @statement = REPLACE(@statement, N'{TableName}', @normalizedName);
	SET @statement = REPLACE(@statement, N'{TargetTable}', @TargetTable);

	IF @PrintOnly = 1 BEGIN 
		EXEC dbo.[print_long_string] @statement;
	  END; 
	ELSE BEGIN 
		EXEC [sys].[sp_executesql] @statement;

		SET @statement = N'SELECT COUNT(*) [total_rows_exported] FROM ' + @TargetTable + N'; ';
		EXEC [sys].[sp_executesql] @statement;

	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.translate_memory_counters','P') IS NOT NULL
	DROP PROC dbo.[translate_memory_counters];
GO

CREATE PROC dbo.[translate_memory_counters]
	@SourceTable			sysname, 
	@TargetTable			sysname, 
	@OverwriteTarget		bit				= 0, 
	@PrintOnly				bit				= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  /* error will have already been raised... */
	
	IF UPPER(@TargetTable) = UPPER(@SourceTable) BEGIN 
		RAISERROR('@SourceTable and @TargetTable can NOT be the same - please specify a new/different name for the @TargetTable parameter.', 16, 1);
		RETURN -1;
	END;

	IF @TargetTable IS NULL BEGIN 
		RAISERROR('Please specify a @TargetTable value - for the output of dbo.translate_cpu_perfcounters', 16, 1); 
		RETURN -2;
	END; 

	/* Translate @TargetTable details: */
	SELECT @TargetTable = N'[' + ISNULL(PARSENAME(@TargetTable, 3), PARSENAME(@normalizedName, 3)) + N'].[' + ISNULL(PARSENAME(@TargetTable, 2), PARSENAME(@normalizedName, 2)) + N'].[' + PARSENAME(@TargetTable, 1) + N']';
	
	/* Determine if @TargetTable already exists: */
	DECLARE @targetObjectID int;
	DECLARE @check nvarchar(MAX) = N'SELECT @targetObjectID = OBJECT_ID(''' + @TargetTable + N''');'

	EXEC [sys].[sp_executesql] 
		@check, 
		N'@targetObjectID int OUTPUT', 
		@targetObjectID = @targetObjectID OUTPUT; 

	IF @targetObjectID IS NOT NULL BEGIN 
		IF @OverwriteTarget = 1 AND @PrintOnly = 0 BEGIN
			DECLARE @drop nvarchar(MAX) = N'USE [' + PARSENAME(@TargetTable, 3) + N']; DROP TABLE [' + PARSENAME(@TargetTable, 2) + N'].[' + PARSENAME(@TargetTable, 1) + N'];';
			
			EXEC sys.sp_executesql @drop;

		  END;
		ELSE BEGIN
			RAISERROR('@TargetTable %s already exists. Please either drop it manually, or set @OverwriteTarget to a value of 1 during execution of this sproc.', 16, 1);
			RETURN -5;
		END;
	END;

	-------------------------------------------------------------------------------------------------------------------------	

	DECLARE @targetDBName sysname = PARSENAME(@normalizedName, 3);
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @sql nvarchar(MAX);

	DECLARE @sampleRow nvarchar(200);

	SET @sql = N'SET @sampleRow = (SELECT TOP 1 [name] FROM [' + @targetDBName + N'].sys.[all_columns] WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND column_id > 1);';

	EXEC sp_executesql 
		@sql, 
		N'@sampleRow nvarchar(200) OUTPUT',
		@sampleRow = @sampleRow OUTPUT;

	DECLARE @serverName sysname; 
	DECLARE @instanceNamePrefix sysname;
	
	SET @serverName = SUBSTRING(@sampleRow, 3, LEN(@sampleRow));
	SET @serverName = SUBSTRING(@serverName, 0, CHARINDEX(N'\', @serverName));

	IF NULLIF(@serverName, N'') IS NULL BEGIN 
		RAISERROR(N'Unable to extract Server-Name from input .csv file. Processing cannot continue.', 16, 1);
		RETURN -9;
	END;
	
	SET @sql = N'SET @sampleRow = (SELECT TOP 1 [name] FROM [' + @targetDBName + N'].sys.[all_columns] WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND [name] LIKE ''%Batch Requests/sec''); ';
	EXEC sp_executesql 
		@sql, 
		N'@sampleRow nvarchar(200) OUTPUT',
		@sampleRow = @sampleRow OUTPUT;	
		
	SET @instanceNamePrefix = LEFT(@sampleRow, CHARINDEX(N':SQL Statistics', @sampleRow));

	DECLARE @timeZone sysname; 
	SET @sql = N'SELECT 
		@timeZone = [name]
	FROM 
		[' + @targetDBName + N'].sys.[columns] 
	WHERE 
		[object_id] = OBJECT_ID(''' + @normalizedName + N''')
		AND [column_id] = 1; ';

	EXEC sp_executesql 
		@sql, 
		N'@timeZone sysname OUTPUT',
		@timeZone = @timeZone OUTPUT;	

	-------------------------------------------------------------------------------------------------------------------------	
	
	DECLARE @statement nvarchar(MAX) = N'WITH [translated] AS (
	SELECT 
		TRY_CAST([{timeZone}] AS datetime) [timestamp],
		N''' + @serverName + N''' [server_name],
		CAST(['+ @instanceNamePrefix + N'Buffer Manager\Page life expectancy] as int) [ple],
		CAST((['+ @instanceNamePrefix + N'Memory Manager\Granted Workspace Memory (KB)] / (1024.0 * 1024.0)) as decimal(22,2)) [granted_workspace_memory_GBs],
		CAST(['+ @instanceNamePrefix + N'Memory Manager\Memory Grants Outstanding] as int) [grants_outstanding],
		CAST(['+ @instanceNamePrefix + N'Memory Manager\Memory Grants Pending] as int) [grants_pending],
		['+ @instanceNamePrefix + N'SQL Statistics\Batch Requests/sec] [batch_requests/second]
	FROM 
		{normalizedName}
)

SELECT 
	[timestamp],
	[server_name],
	[ple],
	[granted_workspace_memory_GBs],
	[grants_outstanding],
	[grants_pending],
	[batch_requests/second]  
INTO 
	{TargetTable} 
FROM 
	[translated]
ORDER BY 
	[timestamp] ';

	SET @statement = REPLACE(@statement, N'{normalizedName}', @normalizedName); 
	SET @statement = REPLACE(@statement, N'{timeZone}', @timeZone);

	SET @statement = REPLACE(@statement, N'{serverName}', @serverName);
	SET @statement = REPLACE(@statement, N'{TargetTable}', @TargetTable);

	IF @PrintOnly = 1 BEGIN 
		EXEC dbo.[print_long_string] @statement; 
	  END; 
	ELSE BEGIN 
		EXEC sp_executesql @statement;

		SET @statement = N'SELECT COUNT(*) [total_rows_exported] FROM ' + @TargetTable + N'; ';
		EXEC [sys].[sp_executesql] @statement;

	END; 
		
	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.report_cpu_and_sql_exception_percentages','P') IS NOT NULL
	DROP PROC dbo.[report_cpu_and_sql_exception_percentages];
GO

CREATE PROC dbo.[report_cpu_and_sql_exception_percentages]
	@SourceTable							sysname, 
	@CpuOverPercentageThreshold				decimal(5,2)		= NULL,
	@PleUnderThreshold						int					= NULL, 
	@BatchCountOverThreshold				int					= NULL
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @CpuOverPercentageThreshold = NULLIF(@CpuOverPercentageThreshold, 0);
	SET @PleUnderThreshold = NULLIF(@PleUnderThreshold, 0);
	SET @BatchCountOverThreshold = NULLIF(@BatchCountOverThreshold, 0);

	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;
	
	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	IF (ISNULL(@CpuOverPercentageThreshold, 0) + ISNULL(@PleUnderThreshold, 0) + ISNULL(@BatchCountOverThreshold, 0)) = 0 BEGIN 
		RAISERROR(N'At least 1 @xxxThreshold value must be specified - otherwise, simply run { SELECT * FROM %s }.', 16, 1, @normalizedName);
		RETURN -20;
	END;
	
	DECLARE @sql nvarchar(MAX); 
	DECLARE @targetDB sysname = PARSENAME(@normalizedName, 3);	
	DECLARE @totalRows int; 

	SET @sql = N'SELECT @totalRows = (SELECT COUNT(*) FROM ' + @normalizedName + N'); ';

	EXEC sys.[sp_executesql]
		@sql, 
		N'@totalRows int OUTPUT', 
		@totalRows = @totalRows OUTPUT;


	DECLARE @serverName sysname;
	SET @sql = N'SELECT @serverName = (SELECT TOP 1 [server_name] FROM ' + @normalizedName + N'); ';
	EXEC sys.[sp_executesql]
		@sql, 
		N'@serverName sysname OUTPUT', 
		@serverName = @serverName OUTPUT;


	DECLARE @startTime datetime, @endTime datetime; 
	SET @sql = N'SELECT @startTime = MIN([timestamp]), @endTime = MAX([timestamp]) FROM '  + @normalizedName + N'; ';
	EXEC sys.[sp_executesql]
		@sql, 
		N'@startTime datetime OUTPUT, @endTime datetime OUTPUT', 
		@startTime = @startTime OUTPUT, 
		@endTime = @endTime OUTPUT;

	DECLARE @cpu nvarchar(MAX) = N'';
	DECLARE @ple nvarchar(MAX) = N'';
	DECLARE @batchCount nvarchar(MAX) = N'';

	IF @CpuOverPercentageThreshold IS NOT NULL BEGIN
		DECLARE @cpuCount int; 

		SET @sql = N'SELECT @cpuCount = (SELECT COUNT(*) FROM ' + @normalizedName + N' WHERE percentage_used >= ' + CAST(@CpuOverPercentageThreshold AS sysname) + N'); ';

		EXEC sys.[sp_executesql]
			@sql, 
			N'@cpuCount int OUTPUT', 
			@cpuCount = @cpuCount OUTPUT;

		SET @cpu = N', ' + CAST(@CpuOverPercentageThreshold AS sysname) + N' [%_cpu_threshold], ' + CAST(@cpuCount AS sysname) + N' [cpu_violations], CAST(((CAST((' + CAST(@cpuCount AS sysname) + N') as decimal(23,2)) / CAST((' + CAST(@totalRows AS sysname) + N') as decimal(23,2))) * 100.0) as decimal(5,2)) [cpu_violations_%]'
	END;


	IF @PleUnderThreshold IS NOT NULL BEGIN
		DECLARE @pleCount int; 
		DECLARE @pleColumns nvarchar(MAX) = N'';

		SET @sql = N'SELECT 
			@pleColumns = @pleColumns + [name] + N'' <= '' + CAST(@PleUnderThreshold as sysname) + N'' OR ''
		FROM 
			[' + @targetDB + N'].sys.columns 
		WHERE 
			[object_id] = OBJECT_ID(''' + @normalizedName + N''')
			AND [name] LIKE N''ple_node_%''; ';

		EXEC sys.[sp_executesql] 
			@sql, 
			N'@PleUnderThreshold int, @pleColumns nvarchar(MAX) OUTPUT', 
			@PleUnderThreshold = @PleUnderThreshold,
			@pleColumns = @pleColumns OUTPUT;

		SET @pleColumns = LEFT(@pleColumns, LEN(@pleColumns) - 3);
		
		SET @sql = N'SELECT @pleCount = (SELECT COUNT(*) FROM ' + @normalizedName + N' WHERE (' + @pleColumns + N')); ';

		EXEC sys.[sp_executesql]
			@sql, 
			N'@pleCount int OUTPUT', 
			@pleCount = @pleCount OUTPUT;


		SET @ple = N', ' + CAST(@PleUnderThreshold AS sysname) + N' [ple_under_threshold], ' + CAST(@pleCount AS sysname) + ' [ple_violations], CAST(((CAST((' + CAST(@pleCount AS sysname) + N') as decimal(23,2)) / CAST((' + CAST(@totalRows AS sysname) + N') as decimal(23,2))) * 100.0) as decimal(5,2)) [ple_violations_%] ';
	END;

	IF @BatchCountOverThreshold IS NOT NULL BEGIN
		DECLARE @batchViolationsCount int;

		SET @sql = N'SELECT @batchViolationsCount = (SELECT COUNT(*) FROM ' + @normalizedName + N' WHERE [batch_requests\sec] >= ' + CAST((CAST(@BatchCountOverThreshold AS decimal(23,2))) AS sysname) + N'); ';

		EXEC sys.[sp_executesql] 
			@sql, 
			N'@batchViolationsCount int OUTPUT', 
			@batchViolationsCount = @batchViolationsCount OUTPUT;

		SET @batchCount = N', ' + CAST(@BatchCountOverThreshold AS sysname) + N' [batches/sec_threshold], ' + CAST(@batchViolationsCount AS sysname) + N' [batches/sec_violations], CAST(((CAST((' + CAST(@batchViolationsCount AS sysname) + N') as decimal(23,2)) / CAST((' + CAST(@totalRows AS sysname) + N') as decimal(23,2))) * 100.0) as decimal(5,2)) [batches/sec_violation_%] ';
	END;

	SET @sql = N'SELECT @serverName [server_name], dbo.format_timespan(DATEDIFF(MILLISECOND, @startTime, @endTime)) [total_duration], @totalRows [total_rows], N'''' [ ]{cpu}{ple}{BatchCount}; ';
	SET @sql = REPLACE(@sql, N'{cpu}', @cpu);
	SET @sql = REPLACE(@sql, N'{ple}', @ple);
	SET @sql = REPLACE(@sql, N'{BatchCount}', @batchCount);

	EXEC sys.[sp_executesql]
		@sql, 
		N'@serverName sysname, @startTime datetime, @endTime datetime, @totalRows int', 
		@serverName = @serverName, 
		@startTime = @startTime, 
		@endTime = @endTime, 
		@totalRows = @totalRows;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.report_cpu_and_sql_threshold_exceptions','P') IS NOT NULL
	DROP PROC dbo.[report_cpu_and_sql_threshold_exceptions];
GO

CREATE PROC dbo.[report_cpu_and_sql_threshold_exceptions]
	@SourceTable							sysname, 
	@IncludeAllCpus							bit					= 0,   -- if 0, only outputs percentage_used vs details on EACH core + aggregates/etc.
	@CpuOverPercentageThreshold				decimal(5,2)		= NULL,
	@PleUnderThreshold						int					= NULL, 
	@BatchCountOverThreshold				int					= NULL, 
	@PrintOnly								bit = 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @CpuOverPercentageThreshold = NULLIF(@CpuOverPercentageThreshold, 0);
	SET @PleUnderThreshold = NULLIF(@PleUnderThreshold, 0);
	SET @BatchCountOverThreshold = NULLIF(@BatchCountOverThreshold, 0);

	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;
	
	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	IF (ISNULL(@CpuOverPercentageThreshold, 0) + ISNULL(@PleUnderThreshold, 0) + ISNULL(@BatchCountOverThreshold, 0)) = 0 BEGIN 
		RAISERROR(N'At least 1 @xxxThreshold value must be specified - otherwise, simply run { SELECT * FROM %s }.', 16, 1, @normalizedName);
		RETURN -20;
	END;
	
	DECLARE @targetDB sysname = PARSENAME(@normalizedName, 3);

	DECLARE @template nvarchar(MAX) = N'SELECT 
	{Projection}	
FROM 
	{normalizedTable} 
WHERE 
	{CPU}
	{PLE}
	{BatchCount}
ORDER BY 
	[timestamp]'

	DECLARE @countOfThresholds int = 0;
	DECLARE @cpu nvarchar(MAX) = N'';
	DECLARE @ple nvarchar(MAX) = N'';
	DECLARE @batchCount nvarchar(MAX) = N'';

	DECLARE @sql nvarchar(MAX);

	DECLARE @clrf char(2) = CHAR(13) + CHAR(10);
	DECLARE @tab char(1) = CHAR(9);
	
	IF @CpuOverPercentageThreshold IS NOT NULL BEGIN 
		SET @cpu = N'percentage_used >= ' + CAST(@CpuOverPercentageThreshold AS sysname) + N' ';
		
		SET @countOfThresholds = @countOfThresholds + 1;
	END;

	IF @PleUnderThreshold IS NOT NULL BEGIN 

		SET @sql = N'SELECT 
			@ple = @ple + [name] + N'' <= '' + CAST(@PleUnderThreshold as sysname) + N'' OR ''
		FROM 
			[' + @targetDB + N'].sys.columns 
		WHERE 
			[object_id] = OBJECT_ID(''' + @normalizedName + N''')
			AND [name] LIKE N''ple_node_%''; ';


		EXEC sys.[sp_executesql]
			@sql, 
			N'@ple nvarchar(MAX) OUTPUT, @PleUnderThreshold int', 
			@ple = @ple OUTPUT, 
			@PleUnderThreshold = @PleUnderThreshold;

		SET @ple = N'( ' + LEFT(@ple, LEN(@ple) - 3) + N' ) ';
		IF @countOfThresholds > 0 SET @ple = N'AND ' + @ple;

		SET @countOfThresholds = @countOfThresholds + 1;
	END;

	IF @BatchCountOverThreshold IS NOT NULL BEGIN 

		SET @batchCount = N'[batch_requests\sec] >= ' + CAST((CAST(@BatchCountOverThreshold AS decimal(23,2))) AS sysname) + N' ';
		IF @countOfThresholds > 0 SET @batchCount = N'AND ' + @batchCount;

		SET @countOfThresholds = @countOfThresholds + 1;
	END;

	DECLARE @columns nvarchar(MAX) = N'
	[server_name],
	[timestamp],
	[percentage_used] [cpu_percent_used],
	[ple_node_001],
	[ple_node_000],
	[lazy_writes/sec],
	[page_lookups/sec],
	[page_reads/sec],
	[pages_writes/sec],
	[readahead_pages/sec],
	[avg_latch_time(ms)],
	[latch_waits\sec],
	[total_latch_wait(ms)],
	[lock_requests\sec],
	[lock_timeouts\sec],
	[lock_wait(ms)],
	[lock_waits\sec],
	[deadlocks\sec],
	[connection_mem],
	[granted_workspace],
	[active_grants],
	[pending_grants],
	[target_mem],
	[total_mem],
	[batch_requests\sec],
	[attention_rate],
	[compilations\sec],
	[recompilations\sec] ';

	IF @IncludeAllCpus = 1 BEGIN 
		SET @columns = N'*'  -- bit of a hack, but easier than determining how many CPU/processor# columns to include... 
	END;

	SET @sql = REPLACE(@template, N'{normalizedTable}', @normalizedName); 
	SET @sql = REPLACE(@sql, N'{Projection}', @columns);
	SET @sql = REPLACE(@sql, N'{CPU}', @cpu);
	SET @sql = REPLACE(@sql, N'{PLE}', @ple);
	SET @sql = REPLACE(@sql, N'{BatchCount}', @batchCount);

	IF @PrintOnly = 1 BEGIN 
		EXEC dbo.[print_long_string] @sql;
	  END; 
	ELSE BEGIN 
		EXEC sys.[sp_executesql] @sql;
	END;
		
	RETURN 0;

GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.report_cpu_percent_of_percent_load','P') IS NOT NULL
	DROP PROC dbo.[report_cpu_percent_of_percent_load];
GO

CREATE PROC dbo.[report_cpu_percent_of_percent_load]
	@SourceTable						sysname, 
	@CoreCountCalculationsRange			int					= 10	 -- + or - on either side of @currentCoreCount... 
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	-------------------------------------------------------------------------------------------------------------------------
	-- begin processing/assessing outputs: 

	DECLARE @sql nvarchar(MAX); 

	DECLARE @totalCoreCount int;
	DECLARE @targetDatabase sysname = PARSENAME(@normalizedName, 3);

	SET @sql = N'SELECT @totalCoreCount = (SELECT COUNT(*) FROM [' + @targetDatabase + N'].sys.columns WHERE [object_id] = OBJECT_ID(''' + @normalizedName + N''') AND [name] LIKE N''processor%''); ';

	EXEC sys.[sp_executesql]
		@sql, 
		N'@totalCoreCount int OUTPUT', 
		@totalCoreCount = @totalCoreCount OUTPUT;

	IF @totalCoreCount < 1 BEGIN 
		RAISERROR(N'Unable to ascertain total core-count for table %s. Please ensure that @SourceTable points to a valid set of CPU metrics.', 16, 1);
		RETURN -10;
	END;

	DECLARE @serverName sysname; 
	SET @sql = N'SELECT @serverName = (SELECT TOP 1 [server_name] FROM ' + @normalizedName + N'); ';

	EXEC sys.[sp_executesql]
		@sql, 
		N'@serverName sysname OUTPUT', 
		@serverName = @serverName OUTPUT;

	IF OBJECT_ID('tempdb..#sizings') IS NOT NULL BEGIN
		DROP TABLE #sizings;
	END;

	CREATE TABLE #sizings ( 
		row_id int IDENTITY(1,1) NOT NULL, 
		[server] sysname NOT NULL, 
		current_core_count int NOT NULL, 
		target_core_count int NOT NULL, 
		[< 60% usage] decimal(5,2) NOT NULL,
		[60-90% usage] decimal(5,2) NOT NULL,
		[90-98% usage] decimal(5,2) NOT NULL,
		[99+% usage] decimal(5,2) NOT NULL	
	);

	DECLARE @totalRows int;
	SET @sql = N'SELECT @totalRows = (SELECT COUNT(*) FROM ' + @normalizedName + N'); ';
	EXEC sys.sp_executesql 
		@sql, 
		N'@totalRows int OUTPUT', 
		@totalRows = @totalRows OUTPUT;
	
	DECLARE @targetCoreCount int = @totalCoreCount - @CoreCountCalculationsRange;
	IF @targetCoreCount < 4 SET @targetCoreCount = 4;

	DECLARE @additionalCores int = 0;

	WHILE @targetCoreCount <= @totalCoreCount + @CoreCountCalculationsRange BEGIN

		SET @sql = N'WITH partitioned AS ( 
			SELECT 
				[timestamp],
				CASE WHEN [total_cpu_used] < ((@targetCoreCount * 100) * .6) THEN 1 ELSE 0 END [< 60% usage], 
				CASE WHEN [total_cpu_used] > ((@targetCoreCount * 100) * .6) AND [total_cpu_used] <= ((@targetCoreCount * 100) * .90) THEN 1 ELSE 0 END [60-90% usage], 
				CASE WHEN [total_cpu_used] > ((@targetCoreCount * 100) * .9) AND [total_cpu_used] <= ((@targetCoreCount * 100) * .98) THEN 1 ELSE 0 END [90-98% usage], 
				
				CASE WHEN [total_cpu_used] > ((@targetCoreCount * 100) * .98) THEN 1 ELSE 0 END [99+% usage], 
				
				[total_cpu_used]
			FROM 
				' + @normalizedName + N'

		), 
		aggregated AS ( 
			SELECT 
				CAST(SUM([< 60% usage]) AS decimal(22,4)) [< 60% usage], 
				CAST(SUM([60-90% usage]) AS decimal(22,4)) [60-90% usage], 
				CAST(SUM([90-98% usage]) AS decimal(22,4)) [90-98% usage], 
				CAST(SUM([99+% usage]) AS decimal(22,4)) [99+% usage]
			FROM 
				[partitioned]
		) 

		SELECT 
			@serverName [server], 
			@totalCoreCount [current_core_count], 
			@targetCoreCount [target_core_count],
			CAST((([< 60% usage] / @totalRows)	* 100.0) AS decimal(5,2)) [< 60% usage],
			CAST((([60-90% usage] / @totalRows)	* 100.0) AS decimal(5,2)) [60-90% usage],
			CAST((([90-98% usage] / @totalRows)	* 100.0) AS decimal(5,2)) [90-98% usage],
			CAST((([99+% usage]	/ @totalRows)	* 100.0) AS decimal(5,2)) [99+% usage]	
		FROM 
			[aggregated]; ';

		INSERT INTO [#sizings] (
			[server],
			[current_core_count],
			[target_core_count],
			[< 60% usage],
			[60-90% usage],
			[90-98% usage],
			[99+% usage]
		)
		EXEC sys.[sp_executesql] 
			@sql, 
			N'@serverName sysname, @totalCoreCount int, @targetCoreCount int, @totalRows int', 
			@serverName = @serverName, 
			@totalCoreCount = @totalCoreCount, 
			@targetCoreCount = @targetCoreCount, 
			@totalRows = @totalRows;

		SET @targetCoreCount = @targetCoreCount + 2;

	END;

	-----------------------------------------------------------------------------------
	-- Final Projection: 
	SELECT 
		[server],
		--[target_core_count],
		--CASE WHEN [target_core_count] = @totalCoreCount THEN N'ACTUAL' ELSE N'' END [ ],
		CAST([target_core_count] AS sysname) + CASE WHEN [target_core_count] = @totalCoreCount THEN N' -> CURRENT' ELSE N'' END [target_core_count],
		[< 60% usage],
		[60-90% usage],
		[90-98% usage],
		[99+% usage]
	FROM 
		[#sizings] 
	ORDER BY 
		--[target_core_count];
		LEFT([target_core_count], CHARINDEX(N' ', [target_core_count]));
		--wtf


	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.report_io_percent_of_percent_load','P') IS NOT NULL
	DROP PROC dbo.[report_io_percent_of_percent_load];
GO

CREATE PROC dbo.[report_io_percent_of_percent_load]
	@SourceTable					sysname, 
	@TargetDisks					sysname				= N'{ALL}', 
	@TargetThresholds				nvarchar(MAX)		= NULL,
	@ExcludePerfmonTotal			bit					= 1					
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @TargetDisks = ISNULL(NULLIF(@TargetDisks, N''), N'{ALL}');

	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	-------------------------------------------------------------------------------------------------------------------------
	-- Translate Targetting Constraints (if present): 
	DECLARE @targetsPresent bit = 0;
	
	IF NULLIF(@TargetThresholds, N'') IS NOT NULL BEGIN 

		CREATE TABLE #targets (
			row_id int NOT NULL, 
			drive_letter sysname NOT NULL, 
			target_iops decimal(24,2) NOT NULL, 
			target_mbps decimal(24,2) NOT NULL
		);

		INSERT INTO [#targets] (
			[row_id],
			[drive_letter],
			[target_iops],
			[target_mbps]
		)
		EXEC admindb.dbo.[shred_string] 
			@Input = @TargetThresholds, 
			@RowDelimiter = N',', 
			@ColumnDelimiter = N':';
		
		IF EXISTS (SELECT NULL FROM [#targets]) BEGIN
			SET @targetsPresent = 1;
		END;
	END;

	-------------------------------------------------------------------------------------------------------------------------

	DECLARE @targetDBName sysname = PARSENAME(@normalizedName, 3);
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @sql nvarchar(MAX);

	SET @sql = N'SELECT @serverName = (SELECT TOP 1 [server_name] FROM ' + @normalizedName + N'); ';
	DECLARE @serverName sysname; 
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@serverName sysname OUTPUT', 
		@serverName = @serverName OUTPUT;

	DECLARE @drives table (
		row_id int IDENTITY(1,1) NOT NULL, 
		[drive] sysname NOT NULL
	); 

	SET @sql = N'WITH core AS ( 
		SELECT 
			column_id,
			[name]
		FROM 
			[' + @targetDBName + N'].sys.[all_columns] 
		WHERE 
			[object_id] = OBJECT_ID(''' + @normalizedName + N''')
			AND [name] LIKE ''IOPs.%''
	) 

	SELECT 
		REPLACE([name], N''IOPs.'', '''') [drive]
	FROM 
		core; ';

	INSERT INTO @drives ([drive])
	EXEC sp_executesql 
		@sql;

	-- Implement drive filtering: 
	IF UPPER(@TargetDisks) <> N'{ALL}' BEGIN 

		DELETE d 
		FROM 
			@drives d 
			LEFT OUTER JOIN ( 
				SELECT 
					[result]
				FROM 
					dbo.split_string(@TargetDisks, N',', 1)

				UNION 
					
				SELECT 
					N'_Total' [result]				
			) x ON d.[drive] = x.[result] 
		WHERE 
			x.[result] IS NULL;
	END;

	IF @ExcludePerfmonTotal = 1 BEGIN 
		DELETE FROM @drives WHERE [drive] = N'_Total';
	END;

	-------------------------------------------------------------------------------------------------------------------------
	-- begin processing/assessing outputs: 

	DECLARE @maxIOPs decimal(24,2);
	DECLARE @maxThroughput decimal(24,2);
	DECLARE @totalRows decimal(24,2); 
	DECLARE @comparedIOPs decimal(24,2);
	DECLARE @comparedThroughput decimal(24,2);

	CREATE TABLE #results ( 
		[row_id] int IDENTITY(1,1) NOT NULL, 
		server_name sysname NOT NULL, 
		metric_type sysname NOT NULL, 
		drive sysname NOT NULL,
		peak_value sysname NOT NULL, 
		target_value sysname NULL,
		[< 10% usage] decimal(24,2) NOT NULL,
		[10-20% usage] decimal(24,2) NOT NULL,
		[20-40% usage] decimal(24,2) NOT NULL,
		[40-60% usage] decimal(24,2) NOT NULL,
		[60-90% usage] decimal(24,2) NOT NULL,
		[90-98% usage] decimal(24,2) NOT NULL,
		[99-100% usage] decimal(24,2) NOT NULL,
		[101-110% usage] decimal(24,2) NULL,
		[111-120% usage] decimal(24,2) NULL,
		[121%+ usage] decimal(24,2) NULL
	);

	DECLARE @maxTemplate nvarchar(MAX) = N'SELECT 
		@totalRows = COUNT(*), 
		@maxIOPs = MAX([IOPs.{driveName}]), 
		@maxThroughput = MAX([MB Throughput.{driveName}])
	FROM 
		' + @normalizedName + N'; ';

	DECLARE @aggregateIOPsTemplate nvarchar(MAX) = N'WITH partitioned AS ( 

		SELECT 
			CASE WHEN ([IOPs.{driveName}] <= (@comparedIOPs * .1)) THEN 1 ELSE 0 END [< 10% usage],
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * .1)) AND  ([IOPs.{driveName}] <= (@comparedIOPs * .2)) THEN 1 ELSE 0 END [10-20% usage],
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * .2)) AND  ([IOPs.{driveName}] <= (@comparedIOPs * .4)) THEN 1 ELSE 0 END [20-40% usage], 
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * .4)) AND  ([IOPs.{driveName}] <= (@comparedIOPs * .6)) THEN 1 ELSE 0 END [40-60% usage], 
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * .6)) AND  ([IOPs.{driveName}] <= (@comparedIOPs * .9)) THEN 1 ELSE 0 END [60-90% usage],
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * .9)) AND ([IOPs.{driveName}] <= (@comparedIOps * .98)) THEN 1 ELSE 0 END [90-98% usage],
			
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * .98)){boundaryCondition}THEN 1 ELSE 0 END [99-100% usage],
						
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * 1)) AND ([IOPs.{driveName}] <= (@comparedIOps * 1.1)) THEN 1 ELSE 0 END [101-110% usage],
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * 1.1)) AND ([IOPs.{driveName}] <= (@comparedIOps * 1.2)) THEN 1 ELSE 0 END [111-120% usage],
			CASE WHEN ([IOPs.{driveName}] > (@comparedIOPs * 1.2)) THEN 1 ELSE 0 END [121%+ usage]

		FROM 
			' + @normalizedName + N'

	),
	aggregated AS ( 

		SELECT 
			CAST(((SUM([< 10% usage]) / @totalRows) * 100.00) AS decimal(24,2))  [< 10% usage],
			CAST(((SUM([10-20% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [10-20% usage],
			CAST(((SUM([20-40% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [20-40% usage],
			CAST(((SUM([40-60% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [40-60% usage],
			CAST(((SUM([60-90% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [60-90% usage],
			CAST(((SUM([90-98% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [90-98% usage],
			CAST(((SUM([99-100% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [99-100% usage],
			
			CAST(((SUM([101-110% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [101-110% usage],
			CAST(((SUM([111-120% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [111-120% usage],
			CAST(((SUM([121%+ usage]) / @totalRows) * 100.00) AS decimal(24,2)) [121%+ usage]

		FROM 
			[partitioned]
	) 

	SELECT
		@serverName [server], 
		N''IOPs'' [metric_type], 
		N''{driveName}'' [drive],
		CAST(@maxIOPs AS sysname) + N'' IOPs'' [peak_value],
		CAST(@targetIOPs AS sysname) + N'' IOPs'' [target_value],
		[aggregated].[< 10% usage],
		[aggregated].[10-20% usage],
		[aggregated].[20-40% usage],
		[aggregated].[40-60% usage],
		[aggregated].[60-90% usage],
		[aggregated].[90-98% usage],
		[aggregated].[99-100% usage],

		[aggregated].[101-110% usage],
		[aggregated].[111-120% usage],
		[aggregated].[121%+ usage]
	FROM 
		[aggregated]; ';

	DECLARE @aggregateMBsTemplate nvarchar(MAX) = N'WITH partitioned AS ( 

		SELECT 
			CASE WHEN ([MB Throughput.{driveName}] <= (@comparedThroughput * .1)) THEN 1 ELSE 0 END [< 10% usage],
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * .1)) AND  ([MB Throughput.{driveName}] <= (@comparedThroughput * .2)) THEN 1 ELSE 0 END [10-20% usage],
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * .2)) AND  ([MB Throughput.{driveName}] <= (@comparedThroughput * .4)) THEN 1 ELSE 0 END [20-40% usage], 
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * .4)) AND  ([MB Throughput.{driveName}] <= (@comparedThroughput * .6)) THEN 1 ELSE 0 END [40-60% usage], 
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * .6)) AND  ([MB Throughput.{driveName}] <= (@comparedThroughput * .9)) THEN 1 ELSE 0 END [60-90% usage],
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * .91)) AND ([MB Throughput.{driveName}] <= (@comparedThroughput * .98)) THEN 1 ELSE 0 END [90-98% usage],
			
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * .98)){boundaryCondition}THEN 1 ELSE 0 END [99-100% usage],
			
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * 1.01)) AND ([MB Throughput.{driveName}] <= (@comparedThroughput * 1.1)) THEN 1 ELSE 0 END [101-110% usage],
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * 1.11)) AND ([MB Throughput.{driveName}] <= (@comparedThroughput * 1.2)) THEN 1 ELSE 0 END [111-120% usage],
			CASE WHEN ([MB Throughput.{driveName}] > (@comparedThroughput * 1.2)) THEN 1 ELSE 0 END [121%+ usage]

		FROM 
			' + @normalizedName + N'

	),
	aggregated AS ( 

		SELECT 
			CAST(((SUM([< 10% usage]) / @totalRows) * 100.00) AS decimal(24,2))  [< 10% usage],
			CAST(((SUM([10-20% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [10-20% usage],
			CAST(((SUM([20-40% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [20-40% usage],
			CAST(((SUM([40-60% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [40-60% usage],
			CAST(((SUM([60-90% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [60-90% usage],
			CAST(((SUM([90-98% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [90-98% usage],
			CAST(((SUM([99-100% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [99-100% usage],
			
			CAST(((SUM([101-110% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [101-110% usage],
			CAST(((SUM([111-120% usage]) / @totalRows) * 100.00) AS decimal(24,2)) [111-120% usage],
			CAST(((SUM([121%+ usage]) / @totalRows) * 100.00) AS decimal(24,2)) [121%+ usage]

		FROM 
			[partitioned]
	) 


	SELECT
		@serverName [server], 
		N''Throughput'' [metric_type], 
		N''{driveName}'' [drive],
		CAST(@maxThroughput AS sysname) + N'' MB/s'' [peak_value],
		CAST(@targetThroughput AS sysname) + N'' MB/s'' [target_value],
		[aggregated].[< 10% usage],
		[aggregated].[10-20% usage],
		[aggregated].[20-40% usage],
		[aggregated].[40-60% usage],
		[aggregated].[60-90% usage],
		[aggregated].[90-98% usage],
		[aggregated].[99-100% usage],

		[aggregated].[101-110% usage],
		[aggregated].[111-120% usage],
		[aggregated].[121%+ usage]
	FROM 
		[aggregated]; ';

	DECLARE @driveName sysname;
	DECLARE @targetIOPs decimal(24,2) = 0;
	DECLARE @targetThroughput decimal(24,2) = 0; 
	DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[drive]
	FROM 
		@drives
	ORDER BY 
		[row_id];

	OPEN [walker];
	FETCH NEXT FROM [walker] INTO @driveName;

	WHILE @@FETCH_STATUS = 0 BEGIN

		SET @sql = REPLACE(@maxTemplate, N'{driveName}', @driveName); 

		EXEC sp_executesql 
			@sql, 
			N'@totalRows decimal(24,2) OUTPUT, @maxThroughput decimal(24,2) OUTPUT, @maxIOPs decimal(24,2) OUTPUT', 
			@totalRows = @totalRows OUTPUT, 
			@maxThroughput = @maxThroughput OUTPUT, 
			@maxIOPs = @maxIOPs OUTPUT; 

		-----------------------------------------------------------------------------------
		-- account for targeted metrics vs peak metrics:
		IF @targetsPresent = 1 BEGIN

			IF @driveName = N'_Total' BEGIN 
				SELECT 
					@targetIOPs = SUM([target_iops]), 
					@targetThroughput = SUM([target_mbps])
				FROM 
					[#targets]
			  END; 
			ELSE BEGIN
				SELECT 
					@targetIOPs = ISNULL([target_iops], @maxIOPs), 
					@targetThroughput = ISNULL([target_mbps], @maxThroughput)
				FROM 
					[#targets]
				WHERE 
					[drive_letter] = @driveName;
			END;

			SET @comparedIOPs = @targetIOPs;
			SET @comparedThroughput = @targetThroughput;

			SET @aggregateIOPsTemplate = REPLACE(@aggregateIOPsTemplate, N'{boundaryCondition}', N' AND ([IOPs.{driveName}] <= (@comparedIOps * 1)) ');
			SET @aggregateMBsTemplate = REPLACE(@aggregateMBsTemplate, N'{boundaryCondition}', N' AND ([IOPs.{driveName}] <= (@comparedThroughput * 1)) ');

		  END;
		ELSE BEGIN -- using peak metrics for % of % used... 
			SET @comparedIOPs = @maxIOPs;
			SET @comparedThroughput = @maxThroughput;

			SET @aggregateIOPsTemplate = REPLACE(@aggregateIOPsTemplate, N'{boundaryCondition}', N'');
			SET @aggregateMBsTemplate = REPLACE(@aggregateMBsTemplate, N'{boundaryCondition}', N'');

		END;


		-----------------------------------------------------------------------------------
		-- calculate IOPs:

		SET @sql = REPLACE(@aggregateIOPsTemplate,  N'{driveName}', @driveName); 

		INSERT INTO [#results] (
			[server_name],
			[metric_type],
			[drive],
			[peak_value],
			[target_value],
			[< 10% usage],
			[10-20% usage],
			[20-40% usage],
			[40-60% usage],
			[60-90% usage],
			[90-98% usage],
			[99-100% usage], 
			[101-110% usage], 
			[111-120% usage], 
			[121%+ usage]
		)
		EXEC sp_executesql 
			@sql, 
			N'@maxIOPs decimal(24,2), @targetIOPs decimal(24,2), @comparedIOPs decimal(24,2), @totalRows decimal(24,2), @serverName sysname', 
			@maxIOPs = @maxIOPs, 
			@targetIOPs = @targetIOPs, 
			@comparedIOPs = @comparedIOPs,
			@totalRows = @totalRows, 
			@serverName = @serverName;


		-----------------------------------------------------------------------------------
		-- calculate Throughput:

		SET @sql = REPLACE(@aggregateMBsTemplate, N'{driveName}', @driveName); 

		INSERT INTO [#results] (
			[server_name],
			[metric_type],
			[drive],
			[peak_value],
			[target_value],
			[< 10% usage],
			[10-20% usage],
			[20-40% usage],
			[40-60% usage],
			[60-90% usage],
			[90-98% usage],
			[99-100% usage], 
			[101-110% usage], 
			[111-120% usage], 
			[121%+ usage]
		)
		EXEC sp_executesql 
			@sql, 
			N'@maxThroughput decimal(24,2), @targetThroughput decimal(24,2), @comparedThroughput decimal(24,2), @totalRows decimal(24,2), @serverName sysname', 
			@maxThroughput = @maxThroughput, 
			@targetThroughput = @targetThroughput, 
			@comparedThroughput = @comparedThroughput,
			@totalRows = @totalRows, 
			@serverName = @serverName;

		FETCH NEXT FROM [walker] INTO @driveName;
	END;

	CLOSE [walker];
	DEALLOCATE [walker];

	DECLARE @projectionTemplate nvarchar(MAX) = N'SELECT 
		[server_name],
		[drive],
		[metric_type],
		[peak_value],
		{target_value}
		N'''' [ ],
		[< 10% usage],
		[10-20% usage],
		[20-40% usage],
		[40-60% usage],
		[60-90% usage],
		[90-98% usage],
		[99-100% usage] 
		{targetOverages}
	FROM 
		[#results]
	ORDER BY 
		[metric_type], 
		[row_id]; ';

	SET @sql = @projectionTemplate; 

	IF @targetsPresent = 1 BEGIN 
		
		SET @sql = REPLACE(@sql, N'{target_value}', N'[target_value],');
		SET @sql = REPLACE(@sql, N'{targetOverages}', N',[101-110% usage],
		[111-120% usage],
		[121%+ usage]');

	  END;
	ELSE BEGIN 
		SET @sql = REPLACE(@sql, N'{target_value}', N'');
		SET @sql = REPLACE(@sql, N'{targetOverages}', N'');
	END;

	EXEC sp_executesql @sql;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.report_io_threshold_exceptions','P') IS NOT NULL
	DROP PROC dbo.[report_io_threshold_exceptions];
GO

CREATE PROC dbo.[report_io_threshold_exceptions]
	@SourceTable					sysname, 
	@TargetDisks					sysname				= N'{ALL}', 
	@TargetThresholds				nvarchar(MAX)		= NULL

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @TargetDisks = ISNULL(NULLIF(@TargetDisks, N''), N'{ALL}');

	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	-------------------------------------------------------------------------------------------------------------------------
	-- Translate Targetting Constraints (if present): 
	DECLARE @targetsPresent bit = 0;

	IF NULLIF(@TargetThresholds, N'') IS NOT NULL BEGIN 

		CREATE TABLE #targets (
			row_id int NOT NULL, 
			drive_letter sysname NOT NULL, 
			target_iops decimal(24,2) NOT NULL, 
			target_mbps decimal(24,2) NOT NULL
		);

		INSERT INTO [#targets] (
			[row_id],
			[drive_letter],
			[target_iops],
			[target_mbps]
		)
		EXEC admindb.dbo.[shred_string] 
			@Input = @TargetThresholds, 
			@RowDelimiter = N',', 
			@ColumnDelimiter = N':';
		
		IF EXISTS (SELECT NULL FROM [#targets]) BEGIN
			SET @targetsPresent = 1;

		END;

	END;

	-------------------------------------------------------------------------------------------------------------------------

	DECLARE @targetDBName sysname = PARSENAME(@normalizedName, 3);
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @sql nvarchar(MAX);

	SET @sql = N'SELECT @serverName = (SELECT TOP 1 [server_name] FROM ' + @SourceTable + N'); ';
	DECLARE @serverName sysname; 
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@serverName sysname OUTPUT', 
		@serverName = @serverName OUTPUT;

	DECLARE @drives table (
		row_id int IDENTITY(1,1) NOT NULL, 
		[drive] sysname NOT NULL
	); 

	SET @sql = N'WITH core AS ( 
		SELECT 
			column_id,
			[name]
		FROM 
			[' + @targetDBName + N'].sys.[all_columns] 
		WHERE 
			[object_id] = OBJECT_ID(''' + @normalizedName + N''')
			AND [name] LIKE ''IOPs.%''
	) 

	SELECT 
		REPLACE([name], N''IOPs.'', '''') [drive]
	FROM 
		core; ';

	INSERT INTO @drives ([drive])
	EXEC sp_executesql 
		@sql;

	-- Implement drive filtering: 
	IF UPPER(@TargetDisks) <> N'{ALL}' BEGIN 

		DELETE d 
		FROM 
			@drives d 
			LEFT OUTER JOIN ( 
				SELECT 
					[result]
				FROM 
					admindb.dbo.split_string(@TargetDisks, N',', 1)

				UNION 
					
				SELECT 
					N'_Total' [result]				
			) x ON d.[drive] = x.[result] 
		WHERE 
			x.[result] IS NULL;
	END;

	DELETE FROM @drives WHERE [drive] = N'_Total';


	-------------------------------------------------------------------------------------------------------------------------
	-- begin processing/assessing outputs: 
	DECLARE @violationTemplate nvarchar(MAX) = N'WITH raw AS (
	SELECT 
		''{HostName}'' [server_name],
		[timestamp], 
		[% CPU], 
		[PLE], 
		[batches/second], 
		{throughput}{IOPs}{latency}[PeakLatency]
	FROM 
		' + @SourceTable + N'
)
	
SELECT 
	*
FROM 
	raw 
WHERE 
	({throughput_violation})
	OR 
	({IOPs_violation})
ORDER BY 
	[timestamp]; ';


	DECLARE @throughput nvarchar(MAX) = N'';
	DECLARE @iOPs nvarchar(MAX) = N'';
	DECLARE @latency nvarchar(MAX) = N'';

	SELECT 
		@throughput = @throughput + N'[MB Throughput.' + [drive] + N'],' + @crlf + @tab + @tab
	FROM 
		@drives;

	SELECT 
		@iOPs = @iOPs + N'[IOPs.' + [drive] + N'], ' + @crlf + @tab + @tab 
	FROM 
		@drives;

	SELECT 
		@latency = @latency + N'[Latency.' + [drive] + N'], ' + @crlf + @tab + @tab 
	FROM 
		@drives;

	DECLARE @throughputViolation nvarchar(MAX) = N'';
	DECLARE @iopsViolation nvarchar(MAX) = N'';

	SELECT 
		@throughputViolation = @throughputViolation + N'[MB Throughput.' + [drive_letter] + N'] > ' + CAST([target_mbps] AS sysname) + N' OR '
	FROM
		[#targets];
	SET @throughputViolation = LEFT(@throughputViolation, LEN(@throughputViolation) - 3);

	SELECT 
		@iopsViolation = @iopsViolation + N'[IOPs.' + [drive_letter] + N'] > ' + CAST([target_iops] AS sysname) + N' OR '
	FROM 
		[#targets];
	SET @iopsViolation = LEFT(@iopsViolation, LEN(@iopsViolation) - 3);


	SET @sql = REPLACE(@violationTemplate, N'{throughput}', @throughput);
	SET @sql = REPLACE(@sql, N'{IOPs}', @iOPs);
	SET @sql = REPLACE(@sql, N'{Latency}', @latency);
	SET @sql = REPLACE(@sql, N'{HostName}', @serverName);

	SET @sql = REPLACE(@sql, N'{throughput_violation}', @throughputViolation);
	SET @sql = REPLACE(@sql, N'{IOPs_violation}', @iopsViolation);

	--PRINT @sql;

	EXEC sp_executesql @sql;
	
	RETURN 0;
GO	


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.report_memory_percent_of_percent_load','P') IS NOT NULL
	DROP PROC dbo.[report_memory_percent_of_percent_load];
GO

CREATE PROC dbo.[report_memory_percent_of_percent_load]
	@SourceTable							sysname, 
	@Ple_GYR_Thresholds						sysname		= N'6000, 2000, 1200', 
	@GransSizeGB_GYR_Thresholds				sysname     = N'2, 4, 8',
	@ConcurrentGrants_GYR_Thresholds		sysname		= N'4, 8, 24'
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @Ple_GYR_Thresholds = ISNULL(NULLIF(@Ple_GYR_Thresholds, N''), N'6000, 2000, 1200');
	SET @GransSizeGB_GYR_Thresholds = ISNULL(NULLIF(@GransSizeGB_GYR_Thresholds, N''), N'2, 4, 8');
	SET @ConcurrentGrants_GYR_Thresholds = ISNULL(NULLIF(@ConcurrentGrants_GYR_Thresholds, N''),  N'4, 8, 16');
	
	DECLARE @normalizedName sysname; 
	DECLARE @targetObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @targetObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  /* error will have already been raised... */


	-------------------------------------------------------------------------------------------------------------------------
	/* Translate Green, Yellow, Red Thresholds: */

	DECLARE @pleGreen int, @pleYellow int, @pleRed int; 
	DECLARE @grantSizeGreen decimal(22,2), @grantSizeYellow decimal(22,2), @grantSizeRed decimal(22,2);
	DECLARE @grantsGreen int, @grantsYellow int, @grantsRed int; 

	/* This sorta works - i mean, it's fine, it's fast, but it FEELS a bit ugly. ... */
	WITH shredded AS ( 
		SELECT 
			[row_id], 
			[result]
		FROM 
			dbo.[split_string](@Ple_GYR_Thresholds, N',', 1)
	)

	SELECT
		@pleGreen = (SELECT [result] FROM [shredded] s2 WHERE [s2].[row_id] = 1),
		@pleYellow = (SELECT [result] FROM [shredded] s2 WHERE [s2].[row_id] = 2),
		@pleRed = (SELECT [result] FROM [shredded] s2 WHERE [s2].[row_id] = 3);

	WITH shredded AS ( 
		SELECT 
			[row_id], 
			[result]
		FROM 
			dbo.[split_string](@GransSizeGB_GYR_Thresholds, N',', 1)
	)

	SELECT
		@grantSizeGreen = (SELECT CAST([result] AS decimal(22,2)) FROM [shredded] s2 WHERE [s2].[row_id] = 1),
		@grantSizeYellow = (SELECT CAST([result] AS decimal(22,2)) FROM [shredded] s2 WHERE [s2].[row_id] = 2),
		@grantSizeRed = (SELECT CAST([result] AS decimal(22,2)) FROM [shredded] s2 WHERE [s2].[row_id] = 3);

	WITH shredded AS ( 
		SELECT 
			[row_id], 
			[result]
		FROM 
			dbo.[split_string](@ConcurrentGrants_GYR_Thresholds, N',', 1)
	)

	SELECT
		@grantsGreen = (SELECT [result] FROM [shredded] s2 WHERE [s2].[row_id] = 1),
		@grantsYellow = (SELECT [result] FROM [shredded] s2 WHERE [s2].[row_id] = 2),
		@grantsRed = (SELECT [result] FROM [shredded] s2 WHERE [s2].[row_id] = 3);

	-------------------------------------------------------------------------------------------------------------------------

	DECLARE @targetDBName sysname = PARSENAME(@normalizedName, 3);
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
	DECLARE @tab nchar(1) = NCHAR(9);
	DECLARE @sql nvarchar(MAX);

	SET @sql = N'SELECT @serverName = (SELECT TOP 1 [server_name] FROM ' + @normalizedName + N'); ';
	DECLARE @serverName sysname; 
	EXEC [sys].[sp_executesql]
		@sql, 
		N'@serverName sysname OUTPUT', 
		@serverName = @serverName OUTPUT;

	-------------------------------------------------------------------------------------------------------------------------

	DECLARE @maxPles int, @minPles int;
	DECLARE @maxGrantGB decimal(22,2), @minGrantGB decimal(22,2);
	DECLARE @maxGrantCount int, @minGrantCount int;
	DECLARE @maxPending int;
	DECLARE @totalRows decimal(24,2);

	DECLARE @aggs nvarchar(MAX) = N'
	SELECT 
		@maxPles = MAX([ple]), 
		@minPles = MIN([ple]), 
		@maxGrantGB = MAX([granted_workspace_memory_GBs]), 
		@minGrantGB = MIN([granted_workspace_memory_GBs]),
		@maxGrantCount = MAX([grants_outstanding]), 
		@minGrantCount = MIN([grants_outstanding]), 
		@maxPending = MAX([grants_pending]), 
		@totalRows = COUNT(*)
	FROM 
		' + @normalizedName + N'; '; 


	EXEC sp_executesql 
		@aggs, 
		N'@maxPles int OUTPUT, @minPles int OUTPUT, @maxGrantGB decimal(22,2) OUTPUT, @minGrantGB decimal(22,2) OUTPUT, @maxGrantCount int OUTPUT, @minGrantCount int OUTPUT, @maxPending int OUTPUT, @totalRows decimal(24,2) OUTPUT', 
		@maxPles = @maxPles OUTPUT, 
		@minPles = @minPles OUTPUT, 
		@maxGrantGB = @maxGrantGB OUTPUT, 
		@minGrantGB = @minGrantGB OUTPUT, 
		@maxGrantCount = @maxGrantCount OUTPUT, 
		@minGrantCount = @minGrantCount OUTPUT, 
		@maxPending = @maxPending OUTPUT, 
		@totalRows = @totalRows OUTPUT;

	CREATE TABLE #results ( 
		[row_id] int IDENTITY(1, 1) NOT NULL, 
		[server_name] sysname NOT NULL, 
		[metric] sysname NOT NULL, 
		[min] sysname NOT NULL, 
		[max] sysname NOT NULL, 
		[green_range] sysname NOT NULL, 
		[yellow_range] sysname NOT NULL, 
		[red_range] sysname NOT NULL, 
		[%_green] decimal(22,2) NOT NULL, 
		[%_yellow] decimal(22,2) NOT NULL, 
		[%_red] decimal(22,2) NOT NULL 
	);

	-------------------------------------------------------------------------------------------------------------------------
	DECLARE @extraction nvarchar(MAX) = N'
	WITH partitioned AS ( 
		SELECT 
			[server_name], 
			CASE WHEN [ple] >= @pleGreen THEN 1 ELSE 0 END [ple_green],
			CASE WHEN [ple] <= (@pleGreen - 1) AND [ple] > @pleRed THEN 1 ELSE 0 END [ple_yellow],
			CASE WHEN [ple] < @pleRed THEN 1 ELSE 0 END [ple_red],

			CASE WHEN [granted_workspace_memory_GBs] <= @grantSizeGreen THEN 1 ELSE 0 END [size_green],
			CASE WHEN [granted_workspace_memory_GBs] >= @grantSizeGreen AND [granted_workspace_memory_GBs] <= (@grantSizeRed - 1) THEN 1 ELSE 0 END [size_yellow],
			CASE WHEN [granted_workspace_memory_GBs] >= @grantSizeRed THEN 1 ELSE 0 END [size_red],

			CASE WHEN [grants_outstanding] <= @grantsGreen THEN 1 ELSE 0 END [grants_green],
			CASE WHEN [grants_outstanding] >= @grantsGreen + 1 AND [grants_outstanding] <= (@grantsRed - 1) THEN 1 ELSE 0 END [grants_yellow],
			CASE WHEN [grants_outstanding] >= @grantsRed THEN 1 ELSE 0 END [grants_red],

			CASE WHEN [grants_pending] > 0 THEN 1 ELSE 0 END [grants_pending_red]
		FROM 
			{normalizedName}
	), 
	aggregated AS ( 
		SELECT 
			CAST(((SUM([ple_green]) / @totalRows) * 100.0) AS decimal(6,2))				[ple_green],
			CAST(((SUM([ple_yellow]) / @totalRows) * 100.0) AS decimal(6,2))			[ple_yellow],
			CAST(((SUM([ple_red]) / @totalRows) * 100.0) AS decimal(6,2))				[ple_red],
			
			CAST(((SUM([size_green]) / @totalRows) * 100.0) AS decimal(6,2))			[size_green],
			CAST(((SUM([size_yellow]) / @totalRows) * 100.0) AS decimal(6,2))			[size_yellow],
			CAST(((SUM([size_red]) / @totalRows) * 100.0) AS decimal(6,2))				[size_red],

			CAST(((SUM([grants_green]) / @totalRows) * 100.0) AS decimal(6,2))			[grants_green],
			CAST(((SUM([grants_yellow]) / @totalRows) * 100.0) AS decimal(6,2))			[grants_yellow],
			CAST(((SUM([grants_red]) / @totalRows) * 100.0) AS decimal(6,2))			[grants_red],

			CAST(((SUM([grants_pending_red]) / @totalRows) * 100.0) AS decimal(6,2))	[grants_pending_red]
		FROM 
			[partitioned]
	), 
	ples AS ( 
		SELECT 
			@serverName [server_name],
			N''PLEs'' [metric], 
			CAST(@minPles as sysname) [min],
			CAST(@maxPles as sysname) [max],

			N''> '' + CAST(@pleGreen AS sysname) [green_range],
			CAST((@pleGreen -1) AS sysname) + N'' - '' + CAST((@pleRed + 1) AS sysname) [yellow_range],
			CAST(@pleRed AS sysname) + N'' - 0'' [red_range],

			[ple_green] [%_green],
			[ple_yellow] [%_yellow],
			[ple_red] [%_red]
		FROM 
			[aggregated]

	), 
	grant_sizes AS (
		SELECT 
			@serverName [server_name],
			N''WORKSPACE_GB'' [metric], 
			CAST(@minGrantGB as sysname) + N'' GB'' [min], 
			CAST(@maxGrantGB as sysname) + N'' GB'' [max],

			N''0 - '' + CAST((@grantSizeGreen - 0.01) AS sysname) + N'' GB'' [green_range],
			CAST(@grantSizeGreen AS sysname) + N'' - '' + CAST((@grantSizeRed - 0.01) AS sysname) + N'' GB'' [yellow_range],
			N''> '' + CAST(@grantSizeRed AS sysname) + N'' GB'' [red_range],

			[size_green] [%_green],
			[size_yellow] [%_yellow],
			[size_red] [%_red]

		FROM 
			[aggregated]

	), 
	grants AS (
		SELECT 
			@serverName [server_name],
			N''ACTIVE_GRANTS'' [metric], 
			CAST(@minGrantCount AS sysname) [min], 
			CAST(@maxGrantCount AS sysname) [max], 

			N''0 - '' + CAST(@grantsGreen AS sysname) [green_range], 
			CAST((@grantsGreen + 1) AS sysname) + N'' - '' + CAST((@grantsRed - 1) AS sysname) [yellow_range], 
			N''> '' + CAST(@grantsRed AS sysname) [red_range], 

			[grants_green] [%_green],
			[grants_yellow] [%_yellow],
			[grants_red] [%_red]
		FROM 
			[aggregated]
	), 
	pending AS (
		SELECT 
			@serverName [server_name],
			N''PENDING_GRANTS'' [metric], 
			N''0'' [min], 
			CAST(@maxPending AS sysname) [max], 

			N''< 1'' [green_range], 
			N''N/A'' [yellow_range], 
			N''> 1'' [red_range],

			100.0 - [grants_pending_red] [%_green], 
			0.0 [%_yellow],
			[grants_pending_red] [%_red]
		FROM 
			[aggregated]
	)

	SELECT * FROM ples UNION 
	SELECT * FROM grant_sizes UNION 
	SELECT * FROM grants UNION
	SELECT * FROM pending; ';

	SET @extraction = REPLACE(@extraction, N'{normalizedName}', @normalizedName);

	INSERT INTO [#results] (
		[server_name],
		[metric],
		[min],
		[max],
		[green_range],
		[yellow_range],
		[red_range],
		[%_green],
		[%_yellow],
		[%_red]
	)
	EXEC sp_executesql 
		@extraction, 
		N'@serverName sysname, @pleGreen int, @pleRed int, @grantSizeGreen decimal(22,2), @grantSizeRed decimal(22,2), @grantsGreen int, @grantsRed int, @maxPles int, @minPles int, @maxGrantGB decimal(22,2), @minGrantGB decimal(22,2), @maxGrantCount int, @minGrantCount int, @maxPending int, @totalRows decimal(24,2)', 
		@serverName = @serverName, 
		@pleGreen = @pleGreen, 
		@pleRed = @pleRed, 
		@grantSizeGreen = @grantSizeGreen, 
		@grantSizeRed = @grantSizeRed, 
		@grantsGreen = @grantsGreen, 
		@grantsRed = @grantsRed,
		@maxPles = @maxPles, 
		@minPles = @minPles, 
		@maxGrantGB = @maxGrantGB, 
		@minGrantGB = @minGrantGB, 
		@maxGrantCount = @maxGrantCount, 
		@minGrantCount = @minGrantCount, 
		@maxPending = @maxPending, 
		@totalRows = @totalRows;




	-------------------------------------------------------------------------------------------------------------------------
	/* Final Projection: */
	SELECT 
		[server_name],
		[metric],
		[min],
		[max],
		' ' [ ],
		[green_range],
		[yellow_range],
		[red_range],
		' ' [_],
		[%_green],
		[%_yellow],
		[%_red]
	FROM 
		[#results]
	ORDER BY 
		[row_id]; 


	RETURN 0; 
GO


-----------------------------------


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.report_trace_continuity','P') IS NOT NULL
	DROP PROC dbo.[report_trace_continuity];
GO

CREATE PROC dbo.[report_trace_continuity]
	@SourceTable			sysname
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	SET @SourceTable = NULLIF(@SourceTable, N'');

	DECLARE @normalizedName sysname; 
	DECLARE @sourceObjectID int; 
	DECLARE @outcome int = 0;

	EXEC @outcome = dbo.load_id_for_normalized_name 
		@TargetName = @SourceTable, 
		@ParameterNameForTarget = N'@SourceTable', 
		@NormalizedName = @normalizedName OUTPUT, 
		@ObjectID = @sourceObjectID OUTPUT;

	IF @outcome <> 0
		RETURN @outcome;  -- error will have already been raised... 

	DECLARE @serverName sysname;
	DECLARE @startTime datetime, @endTime datetime;

	DECLARE @sql nvarchar(MAX) = N'SELECT @serverName = (SELECT TOP 1 server_name FROM ' + @normalizedName + N'); ';

	EXEC sys.[sp_executesql]
		@sql, 
		N'@serverName sysname OUTPUT', 
		@serverName = @serverName OUTPUT;

	SET @sql = N'SELECT 
	@startTime = MIN([timestamp]), 
	@endTime = MAX([timestamp])
FROM 
	' + @normalizedName + N'
WHERE 
	[timestamp] IS NOT NULL; ';





	EXEC sp_executesql 
		@sql, 
		N'@startTime datetime OUTPUT, @endTime datetime OUTPUT', 
		@startTime = @startTime OUTPUT, 
		@endTime = @endTime OUTPUT;


	CREATE TABLE #gaps (
		gap_id int NOT NULL, 
		gap_start datetime NOT NULL, 
		gap_end datetime NOT NULL, 
		gap_duration_ms int NOT NULL
	);

	SET @sql = N'WITH core AS ( 
		SELECT 
			[timestamp], 
			ROW_NUMBER() OVER (ORDER BY [timestamp]) [row_number]
		FROM 
			' + @normalizedName + N'
	) 

	SELECT 
		ROW_NUMBER() OVER(ORDER BY c1.[timestamp]) [gap_id],
		c1.[timestamp] [gap_start], 
		c2.[timestamp] [gap_end], 
		DATEDIFF(MILLISECOND, c1.[timestamp], c2.[timestamp]) [gap_duration_ms]
	FROM 
		core c1 
		INNER JOIN core c2 ON c1.[row_number] + 1 = c2.[row_number] 
	WHERE 
		DATEDIFF(MILLISECOND, c1.[timestamp], c2.[timestamp]) > 1200
	ORDER BY 
		c1.[row_number]; ';

	INSERT INTO [#gaps] (
		[gap_id],
		[gap_start],
		[gap_end],
		[gap_duration_ms]
	)
	EXEC sys.sp_executesql @sql;

	DECLARE @largeGaps int;
	DECLARE @smallGapsSum int; 

	SELECT @largeGaps = SUM(gap_duration_ms) FROM [#gaps] WHERE [gap_duration_ms] > 30000;
	SELECT @smallGapsSum = SUM(gap_duration_ms) FROM [#gaps] WHERE [gap_duration_ms] < 30000;

	SELECT 
		@serverName [server_name],
		@startTime [start_time],
		@endTime [end_time], 
		DATEDIFF(SECOND, @startTime, @endTime) [total_seconds], 
		ISNULL(@largeGaps, 0) / 1000 [large_gap_seconds], 
		ISNULL(@smallGapsSum, 0) / 1000 [aggregate_small_gap_seconds], 
		(DATEDIFF(SECOND, @startTime, @endTime)) - (ISNULL(@largeGaps, 0) / 1000) - (ISNULL(@smallGapsSum, 0) / 1000) [exact_seconds]

	SELECT * FROM [#gaps] ORDER BY gap_id;

	RETURN 0; 
GO



------------------------------------------------------------------------------------------------------------------------------------------------------
-- High-Availability (Setup, Monitoring, and Failover):
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.server_trace_flags','U') IS NOT NULL
	DROP TABLE dbo.server_trace_flags;
GO

CREATE TABLE dbo.server_trace_flags (
	[trace_flag] [int] NOT NULL,
	[status] [bit] NOT NULL,
	[global] [bit] NOT NULL,
	[session] [bit] NOT NULL,
	CONSTRAINT [PK_server_traceflags] PRIMARY KEY CLUSTERED ([trace_flag] ASC)
) 
ON [PRIMARY];

GO


-----------------------------------
-- v6.6 Changes to PARTNER (if present):
IF EXISTS (SELECT NULL FROM sys.servers WHERE UPPER([name]) = N'PARTNER' AND [is_linked] = 1) BEGIN 
	IF NOT EXISTS (SELECT NULL FROM sys.[sysservers] WHERE UPPER([srvname]) = N'PARTNER' AND [rpc] = 1) BEGIN
        EXEC master.dbo.sp_serveroption 
	        @server = N'PARTNER', 
	        @optname = N'rpc', 
	        @optvalue = N'true';		

		PRINT N'Enabled RPC on PARTNER (for v6.6+ compatibility).';
	END;

	IF NOT EXISTS (SELECT NULL FROM sys.[sysservers] WHERE UPPER([srvname]) = N'PARTNER' AND [rpcout] = 1) BEGIN
        EXEC master.dbo.sp_serveroption 
	        @server = N'PARTNER', 
	        @optname = N'rpc out', 
	        @optvalue = N'true';
			
		PRINT N'Enabled RPC_OUT on PARTNER (for v6.6+ compatibility).';
	END;
END;

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_synchronizing_databases','TF') IS NOT NULL
	DROP FUNCTION dbo.list_synchronizing_databases;
GO


CREATE FUNCTION dbo.list_synchronizing_databases(
	@IgnoredDatabases			nvarchar(MAX)		= NULL, 
	@ExcludeSecondaries			bit					= 0
)
RETURNS @synchronizingDatabases table ( 
	server_name sysname, 
	sync_type sysname,
	[database_name] sysname, 
	[role] sysname
) 
AS 
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN;

		DECLARE @localServerName sysname = @@SERVERNAME;

		-- Mirrored DBs:
		INSERT INTO @synchronizingDatabases (server_name, sync_type, [database_name], [role])
		SELECT @localServerName [server_name], N'MIRRORED' sync_type, d.[name] [database_name], m.[mirroring_role_desc] FROM sys.databases d INNER JOIN sys.database_mirroring m ON d.database_id = m.database_id WHERE m.mirroring_guid IS NOT NULL;
		
		IF @ExcludeSecondaries = 1 BEGIN 
			DELETE FROM @synchronizingDatabases WHERE [sync_type] = N'AG' AND [role] = N'SECONDARY';
			DELETE FROM @synchronizingDatabases WHERE [sync_type] = N'MIRRORED' AND [role] = N'MIRROR';
		END;

		IF NULLIF(@IgnoredDatabases, N'') IS NOT NULL BEGIN
			DELETE FROM @synchronizingDatabases WHERE [database_name] IN (SELECT [result] FROM dbo.[split_string](@IgnoredDatabases, N',', 1));
		END;

		RETURN;
	END;
GO


DECLARE @list_synchronizing_databases nvarchar(MAX) = N'
ALTER FUNCTION dbo.list_synchronizing_databases(
	@IgnoredDatabases			nvarchar(MAX)		= NULL, 
	@ExcludeSecondaries			bit					= 0
)
RETURNS @synchronizingDatabases table ( 
	server_name sysname, 
	sync_type sysname,
	[database_name] sysname, 
	[role] sysname
) 
AS
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	 
	BEGIN;

		DECLARE @localServerName sysname = @@SERVERNAME;

		-- Mirrored DBs:
		INSERT INTO @synchronizingDatabases (server_name, sync_type, [database_name], [role])
		SELECT @localServerName [server_name], N''MIRRORED'' sync_type, d.[name] [database_name], m.[mirroring_role_desc] FROM sys.databases d INNER JOIN sys.database_mirroring m ON d.database_id = m.database_id WHERE m.mirroring_guid IS NOT NULL;

		-- AG''d DBs (2012 + only):
		INSERT INTO @synchronizingDatabases (server_name, sync_type, [database_name], [role])
		SELECT @localServerName [server_name], N''AG'' [sync_type], d.[name] [database_name], hars.role_desc FROM sys.databases d INNER JOIN sys.dm_hadr_availability_replica_states hars ON d.replica_id = hars.replica_id;

		IF @ExcludeSecondaries = 1 BEGIN 
			DELETE FROM @synchronizingDatabases WHERE [sync_type] = N''AG'' AND [role] = N''SECONDARY'';
			DELETE FROM @synchronizingDatabases WHERE [sync_type] = N''MIRRORED'' AND [role] = N''MIRROR'';
		END;

		IF NULLIF(@IgnoredDatabases, N'''') IS NOT NULL BEGIN
			DELETE FROM @synchronizingDatabases WHERE [database_name] IN (SELECT [result] FROM dbo.[split_string](@IgnoredDatabases, N'','', 1));
		END;

		RETURN;
	END;

 ';

IF (SELECT dbo.get_engine_version())> 10.5  
	EXEC sp_executesql @list_synchronizing_databases;

-----------------------------------
USE [admindb];
GO 

IF OBJECT_ID('dbo.is_primary_server','FN') IS NOT NULL
	DROP FUNCTION dbo.is_primary_server;
GO

CREATE FUNCTION dbo.is_primary_server()
RETURNS bit
AS 
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN
		DECLARE @output bit = 0;

		DECLARE @roleOfAlphabeticallyFirstSynchronizingDatabase sysname; 

		SELECT @roleOfAlphabeticallyFirstSynchronizingDatabase = (
			SELECT TOP (1)
				[role]
			FROM 
				dbo.[list_synchronizing_databases](NULL, 1)
			ORDER BY 
				[database_name]
		);

		IF @roleOfAlphabeticallyFirstSynchronizingDatabase IN (N'PRIMARY', N'PRINCIPAL')
			SET @output = 1;
			
		RETURN @output;
	END;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.is_primary_database','FN') IS NOT NULL
	DROP FUNCTION dbo.is_primary_database;
GO


CREATE FUNCTION dbo.is_primary_database(@DatabaseName sysname)
RETURNS bit
AS
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN 
		DECLARE @description sysname;
				
		-- Check for Mirrored Status First: 
		SELECT 
			@description = mirroring_role_desc
		FROM 
			sys.database_mirroring 
		WHERE
			database_id = DB_ID(@DatabaseName);
	
		IF @description = 'PRINCIPAL'
			RETURN 1;

		-- if no matches, return 0
		RETURN 0;
	END;
GO


DECLARE @is_primary_database nvarchar(MAX) = N'
ALTER FUNCTION dbo.is_primary_database(@DatabaseName sysname)
RETURNS bit
AS
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	BEGIN 
		DECLARE @description sysname;
				
		-- Check for Mirrored Status First: 
		SELECT 
			@description = mirroring_role_desc
		FROM 
			sys.database_mirroring 
		WHERE
			database_id = DB_ID(@DatabaseName);
	
		IF @description = ''PRINCIPAL''
			RETURN 1;

		-- Check for AG''''d state:
		SELECT 
			@description = 	hars.role_desc
		FROM 
			sys.databases d
			INNER JOIN sys.dm_hadr_availability_replica_states hars ON d.replica_id = hars.replica_id
		WHERE 
			d.database_id = DB_ID(@DatabaseName);
	
		IF @description = ''PRIMARY''
			RETURN 1;
	
		-- if no matches, return 0
		RETURN 0;
	END;

 ';

IF (SELECT dbo.get_engine_version())> 10.5  
	EXEC sp_executesql @is_primary_database;

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.compare_jobs','P') IS NOT NULL
	DROP PROC dbo.compare_jobs;
GO

CREATE PROC dbo.compare_jobs 
	@TargetJobName			sysname = NULL, 
	@IgnoredJobs			nvarchar(MAX) = NULL,			-- technically, should throw an error if this is specified AND @TargetJobName is ALSO specified, but... instead, will just ignore '@ignored' if a specific job is specified. 
	@IgnoreEnabledState		bit = 0
AS
	SET NOCOUNT ON; 
	
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @localServerName sysname = @@SERVERNAME;
	DECLARE @remoteServerName sysname; 
	EXEC master.sys.sp_executesql N'SELECT @remoteName = (SELECT TOP 1 [name] FROM PARTNER.master.sys.servers WHERE server_id = 0);', N'@remoteName sysname OUTPUT', @remoteName = @remoteServerName OUTPUT;

	IF NULLIF(@TargetJobName,N'') IS NOT NULL BEGIN -- the request is for DETAILS about a specific job. 


		-- Make sure Job exists on Local and Remote: 
		CREATE TABLE #LocalJob (
			job_id uniqueidentifier, 
			[name] sysname
		);

		CREATE TABLE #RemoteJob (
			job_id uniqueidentifier, 
			[name] sysname
		);

		INSERT INTO #LocalJob (job_id, [name])
		SELECT 
			sj.job_id, 
			sj.[name]
		FROM 
			msdb.dbo.sysjobs sj
		WHERE
			sj.[name] = @TargetJobName;

		INSERT INTO #RemoteJob (job_id, [name])
		EXEC master.sys.sp_executesql N'SELECT 
			sj.job_id, 
			sj.[name]
		FROM 
			PARTNER.msdb.dbo.sysjobs sj
		WHERE
			sj.[name] = @TargetJobName;', N'@TargetJobName sysname', @TargetJobName = @TargetJobName;

		IF NOT EXISTS (SELECT NULL FROM #LocalJob lj INNER JOIN #RemoteJob rj ON rj.[name] = lj.name) BEGIN
			RAISERROR('Job specified by @TargetJobName does NOT exist on BOTH servers.', 16, 1);
			RETURN -2;
		END


		DECLARE @localJobId uniqueidentifier;
		DECLARE @remoteJobId uniqueidentifier;

		SELECT @localJobId = job_id FROM #LocalJob WHERE [name] = @TargetJobName;
		SELECT @remoteJobId = job_id FROM #RemoteJob WHERE [name] = @TargetJobName;

		DECLARE @remoteJob table (
			[server] sysname NULL,
			[name] sysname NOT NULL,
			[enabled] tinyint NOT NULL,
			[description] nvarchar(512) NULL,
			[start_step_id] int NOT NULL,
			[owner_sid] varbinary(85) NOT NULL,
			[notify_level_email] int NOT NULL,
			[operator_name] sysname NOT NULL,
			[category_name] sysname NOT NULL,
			[job_step_count] int NOT NULL
		);

		INSERT INTO @remoteJob ([server], [name], [enabled], [description], start_step_id, owner_sid, notify_level_email, operator_name, category_name, job_step_count)
		EXECUTE master.sys.sp_executesql N'SELECT 
			@remoteServerName [server],
			sj.[name], 
			sj.[enabled], 
			sj.[description], 
			sj.start_step_id,
			sj.owner_sid, 
			sj.notify_level_email, 
			ISNULL(so.name, ''local'') operator_name,
			ISNULL(sc.name, ''local'') [category_name],
			ISNULL((SELECT COUNT(*) FROM PARTNER.msdb.dbo.sysjobsteps ss WHERE ss.job_id = sj.job_id),0) [job_step_count]
		FROM 
			PARTNER.msdb.dbo.sysjobs sj
			LEFT OUTER JOIN PARTNER.msdb.dbo.syscategories sc ON sj.category_id = sc.category_id
			LEFT OUTER JOIN PARTNER.msdb.dbo.sysoperators so ON sj.notify_email_operator_id = so.id
		WHERE 
			sj.job_id = @remoteJobId;', N'@remoteServerName sysname, @remoteJobID uniqueidentifier', @remoteServerName = @remoteServerName, @remoteJobId = @remoteJobId;


		-- Output top-level job details:
		WITH jobs AS ( 
			SELECT 
				@localServerName [server],
				sj.[name], 
				sj.[enabled], 
				sj.[description], 
				sj.start_step_id,
				sj.owner_sid, 
				sj.notify_level_email, 
				ISNULL(so.[name], 'local') operator_name,
				ISNULL(sc.[name], 'local') [category_name],
				ISNULL((SELECT COUNT(*) FROM msdb.dbo.sysjobsteps ss WHERE ss.job_id = sj.job_id),0) [job_step_count]
			FROM 
				msdb.dbo.sysjobs sj
				LEFT OUTER JOIN msdb.dbo.syscategories sc ON sj.category_id = sc.category_id
				LEFT OUTER JOIN msdb.dbo.sysoperators so ON sj.notify_email_operator_id = so.id
			WHERE 
				sj.job_id = @localJobId

			UNION 

			SELECT 
				[server] COLLATE SQL_Latin1_General_CP1_CI_AS,
                [name] COLLATE SQL_Latin1_General_CP1_CI_AS,
                [enabled],
                [description] COLLATE SQL_Latin1_General_CP1_CI_AS,
                start_step_id,
                owner_sid,
                notify_level_email,
                operator_name COLLATE SQL_Latin1_General_CP1_CI_AS,
                category_name COLLATE SQL_Latin1_General_CP1_CI_AS,
                job_step_count
			FROM 
				@remoteJob
		)

		SELECT 
			'JOB' [type], 
			[server],
			[name],
			[enabled],
			[description],
			start_step_id,
			owner_sid,
			notify_level_email,
			operator_name,
			category_name,
			job_step_count
		FROM 
			jobs 
		ORDER BY 
			[name], [server];


		DECLARE @remoteJobSteps table (
			[step_id] int NOT NULL,
			[server] sysname NULL,
			[step_name] sysname NOT NULL,
			[subsystem] nvarchar(40) NOT NULL,
			[command] nvarchar(max) NULL,
			[on_success_action] tinyint NOT NULL,
			[on_fail_action] tinyint NOT NULL,
			[database_name] sysname NULL
		);

		INSERT INTO @remoteJobSteps ([step_id], [server], [step_name], [subsystem], [command], [on_success_action], [on_fail_action], [database_name])
		EXEC master.sys.sp_executesql N'SELECT 
			step_id, 
			@remoteServerName [server],
			step_name, 
			subsystem, 
			command, 
			on_success_action, 
			on_fail_action, 
			[database_name]
		FROM 
			PARTNER.msdb.dbo.sysjobsteps r
		WHERE 
			r.job_id = @remoteJobId;', N'@remoteServerName sysname, @remoteJobID uniqueidentifier', @remoteServerName = @remoteServerName, @remoteJobId = @remoteJobId;

		-- Job Steps: 
		WITH steps AS ( 
			SELECT 
				step_id, 
				@localServerName [server],
				step_name COLLATE Latin1_General_BIN [step_name], 
				subsystem COLLATE Latin1_General_BIN [subsystem], 
				command COLLATE Latin1_General_BIN [command], 
				on_success_action, 
				on_fail_action, 
				[database_name] COLLATE Latin1_General_BIN [database_name]
			FROM 
				msdb.dbo.sysjobsteps l
			WHERE 
				l.job_id = @localJobId

			UNION 

			SELECT 
				[step_id], 
				[server], 
				[step_name], 
				[subsystem], 
				[command], 
				[on_success_action], 
				[on_fail_action], 
				[database_name]
			FROM 
				@remoteJobSteps
		)

		SELECT 
			'JOB-STEP' [type],
			step_id, 
			[server],
			step_name, 
			subsystem, 
			command, 
			on_success_action, 
			on_fail_action, 
			[database_name]			
		FROM 
			steps
		ORDER BY 
			step_id, [server];


		DECLARE @remoteJobSchedules table (
			[server] sysname NULL,
			[name] sysname NOT NULL,
			[enabled] int NOT NULL,
			[freq_type] int NOT NULL,
			[freq_interval] int NOT NULL,
			[freq_subday_type] int NOT NULL,
			[freq_subday_interval] int NOT NULL,
			[freq_relative_interval] int NOT NULL,
			[freq_recurrence_factor] int NOT NULL,
			[active_start_date] int NOT NULL,
			[active_end_date] int NOT NULL,
			[active_start_time] int NOT NULL,
			[active_end_time] int NOT NULL
		);

		INSERT INTO @remoteJobSchedules ([server], [name], [enabled], [freq_type], [freq_interval], [freq_subday_type], [freq_subday_interval], [freq_relative_interval], [freq_recurrence_factor], [active_start_date], [active_end_date], [active_start_time], [active_end_time])
		EXEC master.sys.sp_executesql N'SELECT 
			@remoteServerName [server],
			ss.name,
			ss.[enabled], 
			ss.freq_type, 
			ss.freq_interval, 
			ss.freq_subday_type, 
			ss.freq_subday_interval, 
			ss.freq_relative_interval, 
			ss.freq_recurrence_factor, 
			ss.active_start_date, 
			ss.active_end_date,
			ss.active_start_time,
			ss.active_end_time
		FROM 
			PARTNER.msdb.dbo.sysjobschedules sjs
			INNER JOIN PARTNER.msdb.dbo.sysschedules ss ON ss.schedule_id = sjs.schedule_id
		WHERE 
			sjs.job_id = @remoteJobId;', N'@remoteServerName sysname, @remoteJobID uniqueidentifier', @remoteServerName = @remoteServerName, @remoteJobId = @remoteJobId;	

		WITH schedules AS (

			SELECT 
				@localServerName [server],
				ss.[name] COLLATE Latin1_General_BIN [name],
				ss.[enabled], 
				ss.freq_type, 
				ss.freq_interval, 
				ss.freq_subday_type, 
				ss.freq_subday_interval, 
				ss.freq_relative_interval, 
				ss.freq_recurrence_factor, 
				ss.active_start_date, 
				ss.active_end_date, 
				ss.active_start_time,
				ss.active_end_time
			FROM 
				msdb.dbo.sysjobschedules sjs
				INNER JOIN msdb.dbo.sysschedules ss ON ss.schedule_id = sjs.schedule_id
			WHERE 
				sjs.job_id = @localJobId

			UNION

			SELECT 
				[server],
                [name],
                [enabled],
                [freq_type],
                [freq_interval],
                [freq_subday_type],
                [freq_subday_interval],
                [freq_relative_interval],
                [freq_recurrence_factor],
                [active_start_date],
                [active_end_date],
                [active_start_time],
                [active_end_time]
			FROM 
				@remoteJobSchedules
		)

		SELECT 
			'SCHEDULE' [type],
			[name],
			[server],
			[enabled], 
			freq_type, 
			freq_interval, 
			freq_subday_type, 
			freq_subday_interval, 
			freq_relative_interval, 
			freq_recurrence_factor, 
			active_start_date, 
			active_end_date, 
			active_start_time,
			active_end_time
		FROM 
			schedules
		ORDER BY 
			[name], [server];

		-- bail, we're done. 
		RETURN 0;

	END;

	  -- If we're still here, we're looking at high-level details for all jobs (except those listed in @IgnoredJobs). 

	CREATE TABLE #IgnoredJobs (
		[name] nvarchar(200) NOT NULL
	);

	INSERT INTO #IgnoredJobs ([name])
	SELECT [result] [name] FROM dbo.split_string(@IgnoredJobs, N',', 1);

	CREATE TABLE #LocalJobs (
		job_id uniqueidentifier, 
		[name] sysname, 
		[enabled] tinyint, 
		[description] nvarchar(512), 
		start_step_id int, 
		owner_sid varbinary(85),
		notify_level_email int, 
		operator_name sysname,
		category_name sysname,
		job_step_count int
	);

	CREATE TABLE #RemoteJobs (
		job_id uniqueidentifier, 
		[name] sysname, 
		[enabled] tinyint, 
		[description] nvarchar(512), 
		start_step_id int, 
		owner_sid varbinary(85),
		notify_level_email int, 
		operator_name sysname,
		category_name sysname,
		job_step_count int
	);

	-- Load Details: 
	INSERT INTO #LocalJobs (job_id, name, [enabled], [description], start_step_id, owner_sid, notify_level_email, operator_name, category_name, job_step_count)
	SELECT 
		sj.job_id, 
		sj.name, 
		sj.[enabled], 
		sj.[description], 
		sj.start_step_id,
		sj.owner_sid, 
		sj.notify_level_email, 
		ISNULL(so.name, 'local') operator_name,
		ISNULL(sc.name, 'local') [category_name],
		ISNULL((SELECT COUNT(*) FROM msdb.dbo.sysjobsteps ss WHERE ss.job_id = sj.job_id),0) [job_step_count]
	FROM 
		msdb.dbo.sysjobs sj
		LEFT OUTER JOIN msdb.dbo.syscategories sc ON sj.category_id = sc.category_id
		LEFT OUTER JOIN msdb.dbo.sysoperators so ON sj.notify_email_operator_id = so.id
	WHERE
		sj.name NOT IN (SELECT name FROM #IgnoredJobs); 

	INSERT INTO #RemoteJobs (job_id, name, [enabled], [description], start_step_id, owner_sid, notify_level_email, operator_name, category_name, job_step_count)
	EXEC master.sys.sp_executesql N'SELECT 
		sj.job_id, 
		sj.name, 
		sj.[enabled], 
		sj.[description], 
		sj.start_step_id,
		sj.owner_sid, 
		sj.notify_level_email, 
		ISNULL(so.name, ''local'') operator_name,
		ISNULL(sc.name, ''local'') [category_name],
		ISNULL((SELECT COUNT(*) FROM PARTNER.msdb.dbo.sysjobsteps ss WHERE ss.job_id = sj.job_id),0) [job_step_count]
	FROM 
		PARTNER.msdb.dbo.sysjobs sj
		LEFT OUTER JOIN PARTNER.msdb.dbo.syscategories sc ON sj.category_id = sc.category_id
		LEFT OUTER JOIN PARTNER.msdb.dbo.sysoperators so ON sj.notify_email_operator_id = so.id;';

	DELETE FROM [#RemoteJobs] WHERE [name] IN (SELECT [name] FROM [#IgnoredJobs]);

	SELECT 
		N'ONLY ON ' + @localServerName [difference], * 
	FROM 
		#LocalJobs 
	WHERE
		[name] NOT IN (SELECT name FROM #RemoteJobs)
		AND [name] NOT IN (SELECT name FROM #IgnoredJobs)

	UNION SELECT 
		N'ONLY ON ' + @remoteServerName [difference], *
	FROM 
		#RemoteJobs
	WHERE 
		[name] NOT IN (SELECT name FROM #LocalJobs)
		AND [name] NOT IN (SELECT name FROM #IgnoredJobs);


	WITH names AS ( 
		SELECT
			lj.[name]
		FROM 
			#LocalJobs lj
			INNER JOIN #RemoteJobs rj ON rj.[name] = lj.[name]
		WHERE
			(@IgnoreEnabledState = 0 AND (lj.[enabled] != rj.[enabled]))
			OR lj.start_step_id != rj.start_step_id
			OR lj.owner_sid != rj.owner_sid
			OR lj.notify_level_email != rj.notify_level_email
			OR lj.operator_name != rj.operator_name
			OR lj.job_step_count != rj.job_step_count
			OR lj.category_name != rj.category_name
	), 
	core AS ( 
		SELECT 
			@localServerName [server],
            lj.[name],
            lj.[enabled],
            lj.[description],
            lj.start_step_id,
            lj.owner_sid,
            lj.notify_level_email,
            lj.operator_name,
            lj.category_name,
            lj.job_step_count
		FROM 
			#LocalJobs lj 
		WHERE 
			lj.[name] IN (SELECT [name] FROM names)

		UNION SELECT 
			@remoteServerName [server],
            rj.[name],
            rj.[enabled],
            rj.[description],
            rj.start_step_id,
            rj.owner_sid,
            rj.notify_level_email,
            rj.operator_name,
            rj.category_name,
            rj.job_step_count
		FROM 
			#RemoteJobs rj 
		WHERE 
			rj.[name] IN (SELECT [name] FROM names)
	)

	SELECT 
		[core].[server],
        [core].[name],
        [core].[enabled],
        [core].[description],
        [core].[start_step_id],
        [core].[owner_sid],
        [core].[notify_level_email],
        [core].[operator_name],
        [core].[category_name],
        [core].[job_step_count] 
	FROM
		core 
	ORDER BY 
		[name], [server];

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.process_synchronization_status','P') IS NOT NULL
	DROP PROC dbo.[process_synchronization_status];
GO

CREATE PROC dbo.[process_synchronization_status]
	@PrintOnly						bit			= 0,
	@PrintedCommands				xml			OUTPUT,
	@SynchronizationSummary			xml			OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @serverName sysname = @@SERVERNAME;
	DECLARE @username sysname;
	DECLARE @report nvarchar(200);

	DECLARE @orphans table (
		UserName sysname,
		UserSID varbinary(85)
	);

	-- Start by querying current/event-ing server for list of databases and states:
	DECLARE @databases table (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[db_name] sysname NOT NULL, 
		[sync_type] sysname NOT NULL, -- 'Mirrored' or 'AvailabilityGroup'
		[ag_name] sysname NULL, 
		[primary_server] sysname NULL, 
		[role] sysname NOT NULL, 
		[state] sysname NOT NULL, 
		[is_suspended] bit NULL,
		[is_ag_member] bit NULL,
		[owner] sysname NULL,   -- interestingly enough, this CAN be NULL in some strange cases... 
		[jobs_status] nvarchar(max) NULL,  -- whether we were able to turn jobs off or not and what they're set to (enabled/disabled)
		[users_status] nvarchar(max) NULL, 
		[other_status] nvarchar(max) NULL
	);

	DECLARE @commands table (
		row_id int IDENTITY(1,1) NOT NULL, 
		command nvarchar(MAX) NOT NULL 
	);

	-- account for Mirrored databases:
	INSERT INTO @databases ([db_name], [sync_type], [role], [state], [owner])
	SELECT 
		d.[name] [db_name],
		N'MIRRORED' [sync_type],
		dm.mirroring_role_desc [role], 
		dm.mirroring_state_desc [state], 
		sp.[name] [owner]
	FROM sys.database_mirroring dm
	INNER JOIN sys.databases d ON dm.database_id = d.database_id
	LEFT OUTER JOIN sys.server_principals sp ON sp.sid = d.owner_sid
	WHERE 
		dm.mirroring_guid IS NOT NULL
	ORDER BY 
		d.[name];

	-- account for AG databases:
	INSERT INTO @databases ([db_name], [sync_type], [ag_name], [primary_server], [role], [state], [is_suspended], [is_ag_member], [owner])
-- TODO: make 2008 compat (yeah yeah... sucks, but ... who knows who MIGHT want to use this stuff for a 2008 instance - running mirroring...)
	SELECT
		dbcs.[database_name] [db_name],
		N'AVAILABILITY_GROUP' [sync_type],
		ag.[name] [ag_name],
		ISNULL(agstates.primary_replica, '') [primary_server],
		ISNULL(arstates.role_desc,'UNKNOWN') [role],
		ISNULL(dbrs.synchronization_state_desc, 'UNKNOWN') [state],
		ISNULL(dbrs.is_suspended, 0) [is_suspended],
		ISNULL(dbcs.is_database_joined, 0) [is_ag_member], 
		x.[owner]
	FROM
		master.sys.availability_groups AS ag
		LEFT OUTER JOIN master.sys.dm_hadr_availability_group_states AS agstates ON ag.group_id = agstates.group_id
		INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
		INNER JOIN master.sys.dm_hadr_availability_replica_states AS arstates ON ar.replica_id = arstates.replica_id AND arstates.is_local = 1
		INNER JOIN master.sys.dm_hadr_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id
		LEFT OUTER JOIN master.sys.dm_hadr_database_replica_states AS dbrs ON dbcs.replica_id = dbrs.replica_id AND dbcs.group_database_id = dbrs.group_database_id
		LEFT OUTER JOIN (SELECT d.name, sp.name [owner] FROM master.sys.databases d INNER JOIN master.sys.server_principals sp ON d.owner_sid = sp.sid) x ON x.name = dbcs.database_name
	ORDER BY
		ag.name ASC,
		dbcs.database_name;

	-- process:
	DECLARE processor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[db_name], 
		[role],
		[state]
	FROM 
		@databases
	ORDER BY 
		[db_name];

	DECLARE @currentDatabase sysname, @currentRole sysname, @currentState sysname; 
	DECLARE @enabledOrDisabled bit; 
	DECLARE @ownerStatus sysname;
	DECLARE @jobsStatus nvarchar(max);
	DECLARE @usersStatus nvarchar(max);
	DECLARE @otherStatus nvarchar(max);

	DECLARE @ownerChangeCommand nvarchar(max);

	OPEN processor;
	FETCH NEXT FROM processor INTO @currentDatabase, @currentRole, @currentState;

	WHILE @@FETCH_STATUS = 0 BEGIN
		
		IF @currentState IN ('SYNCHRONIZED','SYNCHRONIZING') BEGIN 
			IF @currentRole IN (N'PRIMARY', N'PRINCIPAL') BEGIN 
				-----------------------------------------------------------------------------------------------
				-- specify jobs status:
				SET @enabledOrDisabled = 1;

				-----------------------------------------------------------------------------------------------
				-- set database owner to 'sa' if it's not owned currently by 'sa':
				IF NOT EXISTS (SELECT NULL FROM master.sys.databases WHERE name = @currentDatabase AND owner_sid = 0x01) BEGIN 
					SET @ownerChangeCommand = N'ALTER AUTHORIZATION ON DATABASE::[' + @currentDatabase + N'] TO sa;';

					IF @PrintOnly = 1
						INSERT INTO @commands ([command]) VALUES (@ownerChangeCommand);
					ELSE BEGIN
						BEGIN TRY
							EXEC sp_executesql @ownerChangeCommand;
						
							
						END TRY 
						BEGIN CATCH 

						END CATCH
					END;
				END

				-----------------------------------------------------------------------------------------------
				-- attempt to fix any orphaned users: 
				DELETE FROM @orphans;
				SET @report = N'[' + @currentDatabase + N'].dbo.sp_change_users_login ''Report''';

				INSERT INTO @orphans
				EXEC(@report);

				DECLARE fixer CURSOR LOCAL FAST_FORWARD FOR
				SELECT UserName FROM @orphans;

				OPEN fixer;
				FETCH NEXT FROM fixer INTO @username;

				WHILE @@FETCH_STATUS = 0 BEGIN

					BEGIN TRY 
						IF @PrintOnly = 1 
							INSERT INTO @commands ([command]) SELECT N'Processing Orphans for Principal Database ' + @currentDatabase + N'.';
						ELSE
							EXEC sp_change_users_login @Action = 'Update_One', @UserNamePattern = @username, @LoginName = @username;  -- note: this only attempts to repair bindings in situations where the Login name is identical to the User name
					END TRY 
					BEGIN CATCH 
						-- swallow... 
					END CATCH

					FETCH NEXT FROM fixer INTO @username;
				END

				CLOSE fixer;
				DEALLOCATE fixer;

				----------------------------------
				-- Report on any logins that couldn't be corrected:
				DELETE FROM @orphans;

				INSERT INTO @orphans
				EXEC(@report);

				IF (SELECT COUNT(*) FROM @orphans) > 0 BEGIN 
					SET @usersStatus = N'Orphaned Users Detected (attempted repair did NOT correct) : ';
					SELECT @usersStatus = @usersStatus + UserName + ', ' FROM @orphans;

					SET @usersStatus = LEFT(@usersStatus, LEN(@usersStatus) - 1); -- trim trailing , 
					END
				ELSE 
					SET @usersStatus = N'No Orphaned Users Detected';					

			  END 
			ELSE BEGIN -- we're NOT the PRINCIPAL instance:
				SELECT 
					@enabledOrDisabled = 0,  -- make sure all jobs are disabled
					@usersStatus = N'', -- nothing will show up...  
					@otherStatus = N''; -- ditto
			  END

		  END
		ELSE BEGIN -- db isn't in SYNCHRONIZED/SYNCHRONIZING state... 
			-- can't do anything because of current db state. So, disable all jobs for db in question, and 'report' on outcome. 
			SELECT 
				@enabledOrDisabled = 0, -- preemptively disable
				@usersStatus = N'Unable to process - due to database state',
				@otherStatus = N'Database in non synchronized/synchronizing state';
		END

		-----------------------------------------------------------------------------------------------
		-- Process Jobs (i.e. toggle them on or off based on whatever value was set above):
		BEGIN TRY 
			DECLARE toggler CURSOR LOCAL FAST_FORWARD FOR 
			SELECT 
				sj.job_id, sj.name
			FROM 
				msdb.dbo.sysjobs sj
				INNER JOIN msdb.dbo.syscategories sc ON sc.category_id = sj.category_id
			WHERE 
				LOWER(sc.name) = LOWER(@currentDatabase);

			DECLARE @jobid uniqueidentifier; 
			DECLARE @jobname sysname;

			OPEN toggler; 
			FETCH NEXT FROM toggler INTO @jobid, @jobname;

			WHILE @@FETCH_STATUS = 0 BEGIN 
		
				IF @PrintOnly = 1 BEGIN 
					INSERT INTO @commands ([command]) SELECT N'EXEC msdb.dbo.sp_updatejob @job_name = ''' + @jobname + N''', @enabled = ' + CAST(@enabledOrDisabled AS varchar(1)) + N';';
				  END
				ELSE BEGIN
					EXEC msdb.dbo.sp_update_job
						@job_id = @jobid, 
						@enabled = @enabledOrDisabled;
				END

				FETCH NEXT FROM toggler INTO @jobid, @jobname;
			END 

			CLOSE toggler;
			DEALLOCATE toggler;

			IF @enabledOrDisabled = 1
				SET @jobsStatus = N'Jobs set to ENABLED';
			ELSE 
				SET @jobsStatus = N'Jobs set to DISABLED';

		END TRY 
		BEGIN CATCH 

			SELECT @jobsStatus = N'ERROR while attempting to set Jobs to ' + CASE WHEN @enabledOrDisabled = 1 THEN ' ENABLED ' ELSE ' DISABLED ' END + '. Error: ' + CAST(ERROR_NUMBER() AS nvarchar(20)) + N' -> ' + ERROR_MESSAGE();
		END CATCH

		-----------------------------------------------------------------------------------------------
		-- Update the status for this job. 
		UPDATE @databases 
		SET 
			[jobs_status] = @jobsStatus,
			[users_status] = @usersStatus,
			[other_status] = @otherStatus
		WHERE 
			[db_name] = @currentDatabase;

		FETCH NEXT FROM processor INTO @currentDatabase, @currentRole, @currentState;
	END

	CLOSE processor;
	DEALLOCATE processor;

	/* Serialize Outputs */

	IF @PrintOnly = 1 BEGIN 
		SELECT @PrintedCommands = (SELECT 
			[row_id] [command/@command_id], 
			[command] [command]
		FROM 
			@commands
		ORDER BY 
			[row_id] 
		FOR XML PATH(''), ROOT('commands'), TYPE);
	END;

	SELECT @SynchronizationSummary = (SELECT 
		[row_id],
		[db_name],
		[sync_type],
		[ag_name],
		[primary_server],
		[role],
		[state],
		[is_suspended],
		[is_ag_member],
		[owner],
		[jobs_status],
		[users_status],
		[other_status]
	FROM 
		@databases
	ORDER BY 
		[row_id]
	FOR XML PATH('database'), ROOT('databases'), TYPE);

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.process_synchronization_failover','P') IS NOT NULL
	DROP PROC dbo.process_synchronization_failover;
GO

CREATE PROC dbo.process_synchronization_failover 
	@MailProfileName			sysname = N'General',
	@OperatorName				sysname = N'Alerts', 
	@PrintOnly					bit		= 0					-- for testing (i.e., to validate things work as expected)
AS
	SET NOCOUNT ON;

	IF @PrintOnly = 0
		WAITFOR DELAY '00:00:05.00'; -- No, really, give things about 5 seconds (just to let db states 'settle in' to synchronizing/synchronized).


	DECLARE @printedCommands xml; 
	DECLARE @syncSummary xml;

	EXEC [dbo].[process_synchronization_status]
		@PrintOnly = @PrintOnly,
		@PrintedCommands = @printedCommands OUTPUT,
		@SynchronizationSummary = @syncSummary OUTPUT
	
	
	IF @PrintOnly = 1 BEGIN
		DECLARE @commands table (
			command_id int NOT NULL, 
			command nvarchar(MAX) NOT NULL 
		);

		WITH shredded AS ( 
			SELECT 
				[data].[row].value(N'@command_id[1]', N'int') [command_id], 
				[data].[row].value(N'.[1]', N'nvarchar(MAX)') [command]
			FROM 
				@printedCommands.nodes(N'//command') [data]([row])
		)

		INSERT INTO @commands (
			[command_id],
			[command]
		)
		SELECT 
			[command_id],
			[command]
		FROM 
			[shredded] 
		ORDER BY 
			[command_id];
		
		DECLARE @commandText nvarchar(MAX); 

		DECLARE [command_walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			command 
		FROM 
			@commands 
		ORDER BY 
			[command_id];
		
		OPEN [command_walker];
		FETCH NEXT FROM [command_walker] INTO @commandText;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			PRINT @commandText; 
		
			FETCH NEXT FROM [command_walker] INTO @commandText;
		END;
		
		CLOSE [command_walker];
		DEALLOCATE [command_walker];

		PRINT N'';

	END;

	DECLARE @databases table (
		[row_id] int NOT NULL, 
		[db_name] sysname NOT NULL, 
		[sync_type] sysname NOT NULL, -- 'Mirrored' or 'AvailabilityGroup'
		[ag_name] sysname NULL, 
		[primary_server] sysname NULL, 
		[role] sysname NOT NULL, 
		[state] sysname NOT NULL, 
		[is_suspended] bit NULL,
		[is_ag_member] bit NULL,
		[owner] sysname NULL,   -- interestingly enough, this CAN be NULL in some strange cases... 
		[jobs_status] nvarchar(max) NULL,  -- whether we were able to turn jobs off or not and what they're set to (enabled/disabled)
		[users_status] nvarchar(max) NULL, 
		[other_status] nvarchar(max) NULL
	);

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'row_id[1]', N'int') [row_id],
			[data].[row].value(N'db_name[1]', N'sysname') [db_name],
			[data].[row].value(N'sync_type[1]', N'sysname') [sync_type],
			[data].[row].value(N'ag_name[1]', N'sysname') [ag_name],
			[data].[row].value(N'primary_server[1]', N'sysname') [primary_server],
			[data].[row].value(N'role[1]', N'sysname') [role],
			[data].[row].value(N'state[1]', N'sysname') [state],
			[data].[row].value(N'is_suspended[1]', N'sysname') [is_suspended],
			[data].[row].value(N'is_ag_member[1]', N'sysname') [is_ag_member],
			[data].[row].value(N'owner[1]', N'sysname') [owner],
			[data].[row].value(N'jobs_status[1]', N'nvarchar(MAX)') [jobs_status],
			[data].[row].value(N'users_status[1]', N'nvarchar(MAX)') [users_status],
			[data].[row].value(N'other_status[1]', N'nvarchar(MAX)') [other_status]
		FROM 
			@syncSummary.nodes(N'//database') [data]([row])

	)
	
	INSERT INTO @databases (
		[row_id],
		[db_name],
		[sync_type],
		[ag_name],
		[primary_server],
		[role],
		[state],
		[is_suspended],
		[is_ag_member],
		[owner],
		[jobs_status],
		[users_status],
		[other_status]
	)
	SELECT 
		[row_id],
		[db_name],
		[sync_type],
		[ag_name],
		[primary_server],
		[role],
		[state],
		[is_suspended],
		[is_ag_member],
		[owner],
		[jobs_status],
		[users_status],
		[other_status] 
	FROM 
		[shredded]
	ORDER BY 
		[row_id];


	DECLARE @serverName sysname = @@SERVERNAME;
	
	-----------------------------------------------------------------------------------------------
	-- final report/summary. 
	DECLARE @crlf nchar(2) = CHAR(13) + CHAR(10);
	DECLARE @tab nchar(1) = CHAR(9);
	DECLARE @message nvarchar(MAX) = N'';
	DECLARE @subject nvarchar(400) = N'';
	DECLARE @dbs nvarchar(4000) = N'';
	
	SELECT @dbs = @dbs + N'  DATABASE: ' + [db_name] + @crlf 
		+ CASE WHEN [sync_type] = N'AVAILABILITY_GROUP' THEN @tab + N'AG_MEMBERSHIP = ' + (CASE WHEN [is_ag_member] = 1 THEN [ag_name] ELSE 'DISCONNECTED !!' END) ELSE '' END + @crlf
		+ @tab + N'CURRENT_ROLE = ' + [role] + @crlf 
		+ @tab + N'CURRENT_STATE = ' + CASE WHEN is_suspended = 1 THEN N'SUSPENDED !!' ELSE [state] END + @crlf
		+ @tab + N'OWNER = ' + ISNULL([owner], N'NULL') + @crlf 
		+ @tab + N'JOBS_STATUS = ' + jobs_status + @crlf 
		+ @tab + CASE WHEN NULLIF(users_status, '') IS NULL THEN N'' ELSE N'USERS_STATUS = ' + users_status END
		+ CASE WHEN NULLIF(other_status,'') IS NULL THEN N'' ELSE @crlf + @tab + N'OTHER_STATUS = ' + other_status END + @crlf 
		+ @crlf
	FROM @databases
	ORDER BY [db_name];

	SET @subject = N'Database Failover Detected on ' + @serverName;
	SET @message = N'Post failover-response details are as follows: ';
	SET @message = @message + @crlf + @crlf + N'SERVER NAME: ' + @serverName + @crlf;
	SET @message = @message + @crlf + @dbs;

	IF @PrintOnly = 1 BEGIN 
		-- just Print out details:
		PRINT 'SUBJECT: ' + @subject;
		PRINT 'BODY: ' + @crlf + @message;

		END
	ELSE BEGIN
		-- send a message:
		EXEC msdb..sp_notify_operator 
			@profile_name = @MailProfileName, 
			@name = @OperatorName, 
			@subject = @subject,
			@body = @message;
	END;	

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.process_synchronization_server_start','P') IS NOT NULL
	DROP PROC dbo.[process_synchronization_server_start];
GO

CREATE PROC dbo.[process_synchronization_server_start]
	@MailProfileName			sysname = N'General',
	@OperatorName				sysname = N'Alerts', 
	@SendSummaryEmail			bit		= 0,
	@PrintOnly					bit		= 0					-- for testing (i.e., to validate things work as expected)

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	IF @PrintOnly = 0 
		WAITFOR DELAY '00:00:05.00'; /* nah. really. let things settle down a bit before conducting an analysis... */

	/* lol... bleep. I explicitly extracted the core functionality of print + execute + report-on-stuff from process_sync_failover so'z i wouldn't repeat too much code between it and this sproc. 
			only... this whole shred + repeat bit of logic is ... huge and ... repeated 2x. sigh. */
	DECLARE @printedCommands xml; 
	DECLARE @syncSummary xml;

	EXEC [dbo].[process_synchronization_status]
		@PrintOnly = @PrintOnly,
		@PrintedCommands = @printedCommands OUTPUT,
		@SynchronizationSummary = @syncSummary OUTPUT
	
	
	IF @PrintOnly = 1 BEGIN
		DECLARE @commands table (
			command_id int NOT NULL, 
			command nvarchar(MAX) NOT NULL 
		);

		WITH shredded AS ( 
			SELECT 
				[data].[row].value(N'@command_id[1]', N'int') [command_id], 
				[data].[row].value(N'.[1]', N'nvarchar(MAX)') [command]
			FROM 
				@printedCommands.nodes(N'//command') [data]([row])
		)

		INSERT INTO @commands (
			[command_id],
			[command]
		)
		SELECT 
			[command_id],
			[command]
		FROM 
			[shredded] 
		ORDER BY 
			[command_id];
		
		DECLARE @commandText nvarchar(MAX); 

		DECLARE [command_walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			command 
		FROM 
			@commands 
		ORDER BY 
			[command_id];
		
		OPEN [command_walker];
		FETCH NEXT FROM [command_walker] INTO @commandText;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
		
			PRINT @commandText; 
		
			FETCH NEXT FROM [command_walker] INTO @commandText;
		END;
		
		CLOSE [command_walker];
		DEALLOCATE [command_walker];

		PRINT N'';
	END;

	DECLARE @databases table (
		[row_id] int NOT NULL, 
		[db_name] sysname NOT NULL, 
		[sync_type] sysname NOT NULL, -- 'Mirrored' or 'AvailabilityGroup'
		[ag_name] sysname NULL, 
		[primary_server] sysname NULL, 
		[role] sysname NOT NULL, 
		[state] sysname NOT NULL, 
		[is_suspended] bit NULL,
		[is_ag_member] bit NULL,
		[owner] sysname NULL,   -- interestingly enough, this CAN be NULL in some strange cases... 
		[jobs_status] nvarchar(max) NULL,  -- whether we were able to turn jobs off or not and what they're set to (enabled/disabled)
		[users_status] nvarchar(max) NULL, 
		[other_status] nvarchar(max) NULL
	);

	WITH shredded AS ( 
		SELECT 
			[data].[row].value(N'row_id[1]', N'int') [row_id],
			[data].[row].value(N'db_name[1]', N'sysname') [db_name],
			[data].[row].value(N'sync_type[1]', N'sysname') [sync_type],
			[data].[row].value(N'ag_name[1]', N'sysname') [ag_name],
			[data].[row].value(N'primary_server[1]', N'sysname') [primary_server],
			[data].[row].value(N'role[1]', N'sysname') [role],
			[data].[row].value(N'state[1]', N'sysname') [state],
			[data].[row].value(N'is_suspended[1]', N'sysname') [is_suspended],
			[data].[row].value(N'is_ag_member[1]', N'sysname') [is_ag_member],
			[data].[row].value(N'owner[1]', N'sysname') [owner],
			[data].[row].value(N'jobs_status[1]', N'nvarchar(MAX)') [jobs_status],
			[data].[row].value(N'users_status[1]', N'nvarchar(MAX)') [users_status],
			[data].[row].value(N'other_status[1]', N'nvarchar(MAX)') [other_status]
		FROM 
			@syncSummary.nodes(N'//database') [data]([row])
	)
	
	INSERT INTO @databases (
		[row_id],
		[db_name],
		[sync_type],
		[ag_name],
		[primary_server],
		[role],
		[state],
		[is_suspended],
		[is_ag_member],
		[owner],
		[jobs_status],
		[users_status],
		[other_status]
	)
	SELECT 
		[row_id],
		[db_name],
		[sync_type],
		[ag_name],
		[primary_server],
		[role],
		[state],
		[is_suspended],
		[is_ag_member],
		[owner],
		[jobs_status],
		[users_status],
		[other_status] 
	FROM 
		[shredded]
	ORDER BY 
		[row_id];

	DECLARE @serverName sysname = @@SERVERNAME;

	-----------------------------------------------------------------------------------------------
	-- final report/summary. 
	DECLARE @crlf nchar(2) = CHAR(13) + CHAR(10);
	DECLARE @tab nchar(1) = CHAR(9);
	DECLARE @message nvarchar(MAX) = N'';
	DECLARE @subject nvarchar(400) = N'';
	DECLARE @dbs nvarchar(4000) = N'';
	
	SELECT @dbs = @dbs + N'  DATABASE: ' + [db_name] + @crlf 
		+ CASE WHEN [sync_type] = N'AVAILABILITY_GROUP' THEN @tab + N'AG_MEMBERSHIP = ' + (CASE WHEN [is_ag_member] = 1 THEN [ag_name] ELSE 'DISCONNECTED !!' END) ELSE '' END + @crlf
		+ @tab + N'CURRENT_ROLE = ' + [role] + @crlf 
		+ @tab + N'CURRENT_STATE = ' + CASE WHEN is_suspended = 1 THEN N'SUSPENDED !!' ELSE [state] END + @crlf
		+ @tab + N'OWNER = ' + ISNULL([owner], N'NULL') + @crlf 
		+ @tab + N'JOBS_STATUS = ' + jobs_status + @crlf 
		+ @tab + CASE WHEN NULLIF(users_status, '') IS NULL THEN N'' ELSE N'USERS_STATUS = ' + users_status END
		+ CASE WHEN NULLIF(other_status,'') IS NULL THEN N'' ELSE @crlf + @tab + N'OTHER_STATUS = ' + other_status END + @crlf 
		+ @crlf
	FROM @databases
	ORDER BY [db_name];

	SET @subject = N'Server Startup - Synchronization Checks on ' + @serverName;
	SET @message = N'Status of synchronized databases found at startup of SQL Server Instance are as follows: ';
	SET @message = @message + @crlf + @crlf + N'SERVER NAME: ' + @serverName + @crlf;
	SET @message = @message + @crlf + @dbs;

	IF @SendSummaryEmail = 1 AND @PrintOnly = 0 BEGIN 
		-- send a message:
		EXEC msdb..sp_notify_operator 
			@profile_name = @MailProfileName, 
			@name = @OperatorName, 
			@subject = @subject,
			@body = @message;

	  END; 
	ELSE BEGIN 
		-- just Print out details:
		PRINT 'SUBJECT: ' + @subject;
		PRINT 'BODY: ' + @crlf + @message;
	END;

	RETURN 0; 
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_job_states','P') IS NOT NULL
	DROP PROC dbo.verify_job_states;
GO

CREATE PROC dbo.verify_job_states 
	@SendChangeNotifications	bit = 1,
	@MailProfileName			sysname = N'General',
	@OperatorName				sysname	= N'Alerts', 
	@EmailSubjectPrefix			sysname = N'[SQL Agent Jobs-State Updates]',
	@PrintOnly					bit	= 0
AS 
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF @PrintOnly = 0 BEGIN -- if we're not running a 'manual' execution - make sure we have all parameters:
		-- Operator Checks:
		IF ISNULL(@OperatorName, '') IS NULL BEGIN
			RAISERROR('An Operator is not specified - error details can''t be sent if/when encountered.', 16, 1);
			RETURN -4;
		 END;
		ELSE BEGIN
			IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators WHERE [name] = @OperatorName) BEGIN
				RAISERROR('Invalid Operator Name Specified.', 16, 1);
				RETURN -4;
			END;
		END;

		-- Profile Checks:
		DECLARE @DatabaseMailProfile nvarchar(255);
		EXEC master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output';
 
		IF @DatabaseMailProfile != @MailProfileName BEGIN
			RAISERROR('Specified Mail Profile is invalid or Database Mail is not enabled.', 16, 1);
			RETURN -5;
		END; 
	END;

	DECLARE @errorMessage nvarchar(MAX) = N'';
	DECLARE @jobsStatus nvarchar(MAX) = N'';

	-- Start by querying for list of mirrored then AG'd database to process:
	DECLARE @targetDatabases table (
		[db_name] sysname NOT NULL, 
		[role] sysname NOT NULL, 
		[state] sysname NOT NULL, 
		[owner] sysname NULL
	);

	INSERT INTO @targetDatabases ([db_name], [role], [state], [owner])
	SELECT 
		d.[name] [db_name],
		dm.mirroring_role_desc [role], 
		dm.mirroring_state_desc [state], 
		sp.[name] [owner]
	FROM 
		sys.database_mirroring dm
		INNER JOIN sys.databases d ON dm.database_id = d.database_id
		LEFT OUTER JOIN sys.server_principals sp ON sp.sid = d.owner_sid
	WHERE 
		dm.mirroring_guid IS NOT NULL;

	INSERT INTO @targetDatabases ([db_name], [role], [state], [owner])
	SELECT 
		dbcs.[database_name] [db_name],
		ISNULL(arstates.role_desc,'UNKNOWN') [role],
		ISNULL(dbrs.synchronization_state_desc, 'UNKNOWN') [state],
		x.[owner]
	FROM 
		master.sys.availability_groups AS ag
		LEFT OUTER JOIN master.sys.dm_hadr_availability_group_states AS agstates ON ag.group_id = agstates.group_id
		INNER JOIN master.sys.availability_replicas AS ar ON ag.group_id = ar.group_id
		INNER JOIN master.sys.dm_hadr_availability_replica_states AS arstates ON ar.replica_id = arstates.replica_id AND arstates.is_local = 1
		INNER JOIN master.sys.dm_hadr_database_replica_cluster_states AS dbcs ON arstates.replica_id = dbcs.replica_id
		LEFT OUTER JOIN master.sys.dm_hadr_database_replica_states AS dbrs ON dbcs.replica_id = dbrs.replica_id AND dbcs.group_database_id = dbrs.group_database_id
		LEFT OUTER JOIN (SELECT d.name, sp.name [owner] FROM master.sys.databases d INNER JOIN master.sys.server_principals sp ON d.owner_sid = sp.sid) x ON x.name = dbcs.database_name;

	DECLARE @currentDatabase sysname, @currentRole sysname, @currentState sysname; 
	DECLARE @enabledOrDisabled bit; 
	DECLARE @countOfJobsToModify int;

	DECLARE @crlf nchar(2) = CHAR(13) + CHAR(10);
	DECLARE @tab nchar(1) = CHAR(9);

	DECLARE processor CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[db_name], 
		[role],
		[state]
	FROM 
		@targetDatabases
	ORDER BY 
		[db_name];

	OPEN processor;
	FETCH NEXT FROM processor INTO @currentDatabase, @currentRole, @currentState;

	WHILE @@FETCH_STATUS = 0 BEGIN;

		SET @enabledOrDisabled = 0; -- default to disabled. 

		-- if the db is synchronized/synchronizing AND PRIMARY, then enable jobs:
		IF (@currentRole IN (N'PRINCIPAL',N'PRIMARY')) AND (@currentState IN ('SYNCHRONIZED','SYNCHRONIZING')) BEGIN
			SET @enabledOrDisabled = 1;
		END;

		-- determine if there are any jobs OUT of sync with their expected settings:
		SELECT @countOfJobsToModify = ISNULL((
				SELECT COUNT(*) FROM msdb.dbo.sysjobs sj INNER JOIN msdb.dbo.syscategories sc ON sj.category_id = sc.category_id WHERE LOWER(sc.name) = LOWER(@currentDatabase) AND sj.enabled != @enabledOrDisabled 
			), 0);

		IF @countOfJobsToModify > 0 BEGIN;

			BEGIN TRY 
				DECLARE toggler CURSOR LOCAL FAST_FORWARD FOR 
				SELECT 
					sj.job_id, sj.name
				FROM 
					msdb.dbo.sysjobs sj
					INNER JOIN msdb.dbo.syscategories sc ON sc.category_id = sj.category_id
				WHERE 
					LOWER(sc.name) = LOWER(@currentDatabase)
					AND sj.[enabled] <> @enabledOrDisabled;

				DECLARE @jobid uniqueidentifier; 
				DECLARE @jobname sysname;

				OPEN toggler; 
				FETCH NEXT FROM toggler INTO @jobid, @jobname;

				WHILE @@FETCH_STATUS = 0 BEGIN 
		
					IF @PrintOnly = 1 BEGIN 
						PRINT '-- EXEC msdb.dbo.sp_updatejob @job_name = ''' + @jobname + ''', @enabled = ' + CAST(@enabledOrDisabled AS varchar(1)) + ';'
					  END
					ELSE BEGIN
						EXEC msdb.dbo.sp_update_job
							@job_id = @jobid, 
							@enabled = @enabledOrDisabled;
					END

					SET @jobsStatus = @jobsStatus + @tab + N'- [' + ISNULL(@jobname, N'#ERROR#') + N'] to ' + CASE WHEN @enabledOrDisabled = 1 THEN N'ENABLED' ELSE N'DISABLED' END + N'.' + @crlf;

					FETCH NEXT FROM toggler INTO @jobid, @jobname;
				END 

				CLOSE toggler;
				DEALLOCATE toggler;

			END TRY 
			BEGIN CATCH 
				SELECT @errorMessage = @errorMessage + N'ERROR while attempting to set Jobs to ' + CASE WHEN @enabledOrDisabled = 1 THEN N' ENABLED ' ELSE N' DISABLED ' END + N'. [ Error: ' + CAST(ERROR_NUMBER() AS nvarchar(20)) + N' -> ' + ERROR_MESSAGE() + N']';
			END CATCH
		
			-- cleanup cursor if it didn't get closed:
			IF (SELECT CURSOR_STATUS('local','toggler')) > -1 BEGIN;
				CLOSE toggler;
				DEALLOCATE toggler;
			END
		END

		FETCH NEXT FROM processor INTO @currentDatabase, @currentRole, @currentState;
	END

	CLOSE processor;
	DEALLOCATE processor;

	IF (SELECT CURSOR_STATUS('local','processor')) > -1 BEGIN;
		CLOSE processor;
		DEALLOCATE processor;
	END

	IF (@jobsStatus <> N'') AND (@SendChangeNotifications = 1) BEGIN;

		DECLARE @serverName sysname;
		SELECT @serverName = @@SERVERNAME; 

		SET @jobsStatus = N'The following changes were made to SQL Server Agent Jobs on ' + @serverName + ':' + @crlf + @jobsStatus;

		IF @errorMessage <> N'' 
			SET @jobsStatus = @jobsStatus + @crlf + @crlf + N'The following Error Details were also encountered: ' + @crlf + @tab + @errorMessage;

		DECLARE @emailSubject nvarchar(2000) = @EmailSubjectPrefix + N' Change Report for ' + @serverName;

		IF @PrintOnly = 1 BEGIN 
			PRINT @emailSubject;
			PRINT @jobsStatus;

		  END
		ELSE BEGIN 
			EXEC msdb.dbo.sp_notify_operator 
				@profile_name = @MailProfileName,
				@name = @OperatorName, 
				@subject = @emailSubject, 
				@body = @jobsStatus;
		END
	END

	RETURN 0;

GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.populate_trace_flags','P') IS NOT NULL
	DROP PROC dbo.[populate_trace_flags];
GO

CREATE PROC dbo.[populate_trace_flags]

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	TRUNCATE TABLE dbo.[server_trace_flags];

	INSERT INTO dbo.[server_trace_flags] (
		[trace_flag],
		[status],
		[global],
		[session]
	)
	EXECUTE ('DBCC TRACESTATUS(-1) WITH NO_INFOMSGS');

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_online','P') IS NOT NULL
	DROP PROC dbo.[verify_online];
GO

CREATE PROC dbo.[verify_online]

AS
    SET NOCOUNT ON; 

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_partner','P') IS NOT NULL
	DROP PROC dbo.[verify_partner];
GO

CREATE PROC dbo.[verify_partner]
	@Error				nvarchar(MAX)			= N''			OUTPUT
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @output nvarchar(MAX);

	DECLARE @partnerTest nvarchar(MAX) = N'EXEC [PARTNER].admindb.dbo.verify_online;'

	DECLARE @outcome xml;
	DECLARE @return int;
	DECLARE @errorMessage nvarchar(MAX);
	EXEC @return = dbo.[execute_command]
		@Command = @partnerTest,
		@ExecutionType = N'SQLCMD',
		@ExecutionAttemptsCount = 0,
		@IgnoredResults = N'{COMMAND_SUCCESS}',
		@Outcome = @outcome OUTPUT, 
		@ErrorMessage = @errorMessage OUTPUT;

	IF @errorMessage IS NOT NULL BEGIN
		SET @output = @errorMessage;
	END;

	IF @output IS NOT NULL BEGIN
		IF @Error IS NULL 
			SET @Error = @output; 
		ELSE 
			SELECT @output [Error];
	END;

	RETURN @return;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_job_synchronization','P') IS NOT NULL
	DROP PROC dbo.verify_job_synchronization;
GO

CREATE PROC [dbo].[verify_job_synchronization]
	@IgnoredJobs				nvarchar(MAX)		= N'',
	@JobCategoryMapping			nvarchar(MAX)		= N'',					-- category-name: targetDbName, n2, n3, etc. 
	--@IgnoredJobCategories		nvarchar(MAX)		= 'IGNORED',			-- or maybe {IGNORED} as the actual name? 
	@MailProfileName			sysname				= N'General',	
	@OperatorName				sysname				= N'Alerts',	
	@PrintOnly					bit						= 0					-- output only to console - don't email alerts (for debugging/manual execution, etc.)
AS 
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	SET @IgnoredJobs = NULLIF(@IgnoredJobs, N'');
	SET @JobCategoryMapping = NULLIF(@JobCategoryMapping, N'');

	----------------------------------------------
	IF (SELECT dbo.[is_primary_server]()) = 0 BEGIN
		IF @PrintOnly = 0 BEGIN
			PRINT N'Server is Not Primary.';
			RETURN 0;
		  END; 
		ELSE BEGIN 
			PRINT 'NOTE: Synchronization Check is allowed to run from SECONDARY - because @PrintOnly = 1.';
		END;
	END;	

	---------------------------------------------
	/* -- Dependencies Validation: */
	DECLARE @return int, @returnMessage nvarchar(MAX);
    IF @PrintOnly = 0 BEGIN 

	    EXEC @return = dbo.verify_advanced_capabilities;
        IF @return <> 0
            RETURN @return;

        EXEC @return = dbo.verify_alerting_configuration
            @OperatorName, 
            @MailProfileName;

        IF @return <> 0 
            RETURN @return;
    END;

	IF NOT EXISTS (SELECT NULL FROM sys.servers WHERE [name] = 'PARTNER') BEGIN 
		RAISERROR('Linked Server ''PARTNER'' not detected. Comparisons between this server and its peer can not be processed.', 16, 1);
		RETURN -5;
	END;

	EXEC @return = dbo.verify_partner 
		@Error = @returnMessage OUTPUT; 

	IF @return <> 0 BEGIN 
		/* -- S4-229: this (current) response is a hack - i.e., sending email/message DIRECTLY from this code-block violates DRY
		   --			and is only in place until dbo.verify_job_synchronization is rewritten to use a process bus. */
		IF @PrintOnly = 1 BEGIN 
			PRINT 'PARTNER is disconnected/non-accessible. Terminating early. Connection Details/Error:';
			PRINT '     ' + @returnMessage;
		  END;
		ELSE BEGIN 
			DECLARE @hackSubject nvarchar(200), @hackMessage nvarchar(MAX);
			SELECT 
				@hackSubject = N'PARTNER server is down/non-accessible.', 
				@hackMessage = N'Job Synchronization Checks can not continue as PARTNER server is down/non-accessible. Connection Error Details: ' + NCHAR(13) + NCHAR(10) + @returnMessage; 

			EXEC msdb..sp_notify_operator 
				@profile_name = @MailProfileName, 
				@name = @OperatorName, 
				@subject = @hackSubject,
				@body = @hackMessage;
		END;

		RETURN 0;
	END;

	/* ---------------------------------------------
	   -- processing */

	DECLARE @localServerName sysname = @@SERVERNAME;
	DECLARE @remoteServerName sysname; 
	EXEC sys.sp_executesql 
		N'SELECT @remoteName = (SELECT TOP 1 [name] FROM PARTNER.master.sys.servers WHERE server_id = 0);', 
		N'@remoteName sysname OUTPUT', 
		@remoteName = @remoteServerName OUTPUT;

	/* -- start by loading a 'list' of all dbs that might be Mirrored or AG'd: */
	DECLARE @synchronizingDatabases table ( 
		server_name sysname, 
		sync_type sysname,
		[database_name] sysname, 
		[role] sysname
	);

	/* -- grab a list of all synchronizing LOCAL databases: */
	INSERT INTO @synchronizingDatabases (
	    [server_name],
	    [sync_type],
	    [database_name], 
		[role]
	)
	SELECT 
	    [server_name],
	    [sync_type],
	    [database_name], 
		[role]
	FROM 
		dbo.list_synchronizing_databases(NULL, 0);

	/* -- we also need a list of synchronizing/able databases on the 'secondary' server: */
	DECLARE @delayedSyntaxCheckHack nvarchar(max) = N'
		SELECT 
			[server_name],
			[sync_type],
			[database_name], 
			[role]
		FROM 
			OPENQUERY([PARTNER], ''SELECT * FROM [admindb].dbo.[list_synchronizing_databases](NULL, 0)'');';

	INSERT INTO @synchronizingDatabases (
		[server_name],
		[sync_type],
		[database_name], 
		[role]
	)
	EXEC sp_executesql @delayedSyntaxCheckHack;	

	/* ----------------------------------------------
	   -- deserialize ignored jobs and mappedJobCategories: */
	CREATE TABLE #IgnoredJobs (
		[name] nvarchar(200) NOT NULL
	);
	
	CREATE TABLE #mappedCategories (
		row_id int NOT NULL, 
		category_name sysname NOT NULL,
		target_database sysname NOT NULL
	);

	INSERT INTO #IgnoredJobs ([name])
	SELECT [result] [name] FROM dbo.split_string(@IgnoredJobs, N',', 1);

	IF @JobCategoryMapping IS NOT NULL BEGIN 
		INSERT INTO [#mappedCategories] (
			[row_id],
			[category_name],
			[target_database]
		)

		EXEC dbo.[shred_string] 
			@Input = @JobCategoryMapping, 
			@RowDelimiter = N',', 
			@ColumnDelimiter = N':';
	END;

	CREATE TABLE #Differences (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[job_name] nvarchar(100) NOT NULL, 
		[problem] sysname NOT NULL,
		[description] nvarchar(300) NOT NULL, 
		[detail] nvarchar(MAX) NULL
	);

	CREATE TABLE #LocalJobs (
		[job_id] uniqueidentifier, 
		[name] sysname NOT NULL, 
		[description] nvarchar(512) NULL, 
		[enabled] tinyint NOT NULL, 
		[owner_sid] varbinary(85) NOT NULL,
		[category_name] sysname NOT NULL,
		[start_step_id] int NOT NULL, 
		[notify_level_email] int NOT NULL, 
		[operator_name] sysname NOT NULL,
		[date_modified] datetime NOT NULL,
		[job_step_count] int NOT NULL, 
		[schedule_count] int NOT NULL,
		[mapped_category_name] sysname NULL,
	);

	CREATE TABLE #RemoteJobs (
		[job_id] uniqueidentifier, 
		[name] sysname NOT NULL, 
		[description] nvarchar(512) NULL, 
		[enabled] tinyint NOT NULL, 
		[owner_sid] varbinary(85) NOT NULL,
		[category_name] sysname NOT NULL,
		[start_step_id] int NOT NULL, 
		[notify_level_email] int NOT NULL, 
		[operator_name] sysname NOT NULL,
		[date_modified] datetime NOT NULL,
		[job_step_count] int NOT NULL, 
		[schedule_count] int NOT NULL,
		[mapped_category_name] sysname NULL,
	);

	INSERT INTO [#LocalJobs] (
		[job_id],
		[name],
		[description],
		[enabled],
		[owner_sid],
		[category_name],
		[start_step_id],
		[notify_level_email],
		[operator_name],
		[date_modified],
		[job_step_count],
		[schedule_count]
	)
	SELECT 
		sj.[job_id], 
		sj.[name], 
		sj.[description], 
		sj.[enabled], 
		sj.[owner_sid], 
		sc.[name] [category_name],
		sj.[start_step_id],
		sj.[notify_level_email], 
		ISNULL(so.[name], 'EMPTY') operator_name,
		[sj].[date_modified],
		(SELECT COUNT(*) FROM msdb.dbo.sysjobsteps ss WHERE ss.job_id = sj.job_id) [job_step_count], 
		(SELECT COUNT(*) FROM msdb.dbo.[sysjobschedules] sjs WHERE sj.job_id = sjs.[job_id]) [schedule_count]
	FROM 
		msdb.dbo.sysjobs sj
		LEFT OUTER JOIN msdb.dbo.syscategories sc ON sj.category_id = sc.category_id
		LEFT OUTER JOIN msdb.dbo.sysoperators so ON sj.notify_email_operator_id = so.id;

	INSERT INTO [#RemoteJobs] (
		[job_id],
		[name],
		[description],
		[enabled],
		[owner_sid],
		[category_name],
		[start_step_id],
		[notify_level_email],
		[operator_name],
		[date_modified],
		[job_step_count],
		[schedule_count]
	)
	EXEC sp_executesql N'SELECT 
		sj.[job_id], 
		sj.[name], 
		sj.[description], 
		sj.[enabled], 
		sj.[owner_sid], 
		sc.[name] [category_name],
		sj.[start_step_id],
		sj.[notify_level_email], 
		ISNULL(so.[name], ''EMPTY'') operator_name,
		[sj].[date_modified],
		(SELECT COUNT(*) FROM PARTNER.msdb.dbo.sysjobsteps ss WHERE ss.job_id = sj.job_id) [job_step_count], 
		(SELECT COUNT(*) FROM PARTNER.msdb.dbo.[sysjobschedules] sjs WHERE sj.job_id = sjs.[job_id]) [schedule_count]
	FROM 
		PARTNER.msdb.dbo.sysjobs sj
		LEFT OUTER JOIN PARTNER.msdb.dbo.syscategories sc ON sj.category_id = sc.category_id
		LEFT OUTER JOIN PARTNER.msdb.dbo.sysoperators so ON sj.notify_email_operator_id = so.id; ';

	/* Remove Ignored Jobs */ 
	DELETE x 
	FROM 
		[#LocalJobs] x 
		INNER JOIN [#IgnoredJobs] ignored ON x.[name] LIKE ignored.[name];
	
	DELETE x 
	FROM 
		[#RemoteJobs] x 
		INNER JOIN [#IgnoredJobs] ignored ON x.[name] LIKE [ignored].[name];

	/* Identify Jobs present on ONLY ONE server (and not the other): */
	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[name], 
		N'LOCAL_ONLY' [problem],
		CASE 
			WHEN ([category_name] IN (SELECT [database_name] FROM @synchronizingDatabases WHERE [server_name] = @localServerName)) THEN N'Batch job exists on [' + @localServerName + N'] only.'
			ELSE N'Server-Level job exists on [' + @localServerName + N'] only.'
		END [description]		
	FROM 
		[#LocalJobs] 
	WHERE 
		[name] NOT IN (SELECT [name] FROM [#RemoteJobs]);

	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[name], 
		N'REMOTE_ONLY' [problem],
		CASE 
			WHEN ([category_name] IN (SELECT [database_name] FROM @synchronizingDatabases WHERE [server_name] = @remoteServerName)) THEN N'Batch job exists on [' + @remoteServerName + N'] only.'
			ELSE N'Server-Level job exists on [' + @remoteServerName + N'] only.'
		END [description]
	FROM 
		[#RemoteJobs] 
	WHERE 
		[name] NOT IN (SELECT [name] FROM [#LocalJobs]);

	/* Shred + align: */
	CREATE TABLE #PathAlignedDetails (
		[row_id] int IDENTITY(1,1) NOT NULL, 
		[job_name] sysname NOT NULL, 
		[path] sysname NOT NULL, 
		[local_value] nvarchar(512) NOT NULL, 
		[remote_value] nvarchar(512) NULL
	);

	WITH [serialized] AS ( 
		SELECT 
			[name], 
			(SELECT 
				[job_id],
				[name],
				ISNULL([description], N'') [description],
				[enabled],
				CONVERT(sysname, [owner_sid], 1) [owner_sid],
				[category_name],
				[start_step_id],
				[notify_level_email],
				[operator_name],
				[job_step_count],
				[schedule_count] 
			FROM [#LocalJobs] c2
			WHERE 
				[#LocalJobs].[name] = c2.[name]
			FOR XML RAW('x'), TYPE) [xml]
		FROM 
			[#LocalJobs]
	) 

	INSERT INTO [#PathAlignedDetails] (
		[job_name],
		[path],
		[local_value]
	)
	SELECT 
		s.[name] [job_name], 
		N'job.' + a.c.value(N'local-name(.)', 'nvarchar(512)') [path],
		a.c.value(N'.', 'sysname') [local_value]
	FROM 
		[serialized] s 
		CROSS APPLY s.[xml].nodes(N'x/@*') a(c);

	WITH [serialized] AS ( 
		SELECT 
			[name], 
			(SELECT 		
				[job_id],
				[name],
				ISNULL([description], N'') [description],
				[enabled],
				CONVERT(sysname, [owner_sid], 1) [owner_sid],
				[category_name],
				[start_step_id],
				[notify_level_email],
				[operator_name],
				[job_step_count],
				[schedule_count] 
			FROM [#RemoteJobs] c2
			WHERE 
				[#RemoteJobs].[name] = c2.[name]
			FOR XML RAW('x'), TYPE) [xml]
		FROM 
			[#RemoteJobs]
	), 
	[pathed] AS (
	SELECT 
			s.[name] [job_name], 
			N'job.' + a.c.value(N'local-name(.)', 'nvarchar(512)') [path],
			a.c.value(N'.', 'sysname') [remote_value]
		FROM 
			[serialized] s 
			CROSS APPLY s.[xml].nodes(N'x/@*') a(c)
	)

	UPDATE x 
	SET 
		x.[remote_value] = p.[remote_value]
	FROM 
		[#PathAlignedDetails] x 
		LEFT OUTER JOIN [pathed] p ON [x].[job_name] = [p].[job_name] AND x.[path] = p.[path];

	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[job_name], 
		N'CORE_DIFFERENCES' [problem], 
		N'[' + [path] + N'] is different between servers.' [description]
	FROM 
		[#PathAlignedDetails]
	WHERE 
		[local_value] <> [remote_value]
		AND [path] NOT IN(N'job.job_id', N'job.enabled', N'job.job_step_count', N'job.schedule_count')  /* these paths are more complex - and checked distinctly/explicitly...  */
		AND [job_name] NOT IN (SELECT [job_name] FROM [#Differences] WHERE [problem] IN (N'LOCAL_ONLY', N'REMOTE_ONLY'));  /* No sense reporting on jobs that exist on only one box vs both...  */

	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[job_name], 
		N'JOB_STEP_COUNT_DIFFERENCES' [problem], 
		N'Job Step Counts between servers are NOT the same.' [description]
	FROM 
		[#PathAlignedDetails]
	WHERE 
		[local_value] <> [remote_value]
		AND [path] = N'job.job_step_count'
		AND [job_name] NOT IN (SELECT [job_name] FROM [#Differences] WHERE [problem] IN (N'LOCAL_ONLY', N'REMOTE_ONLY'));  /* No sense reporting on jobs that exist on only one box vs both...  */

	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[job_name], 
		N'JOB_STEP_COUNT_DIFFERENCES' [problem], 
		N'Schedule Counts between servers are NOT the same.' [description]
	FROM 
		[#PathAlignedDetails]
	WHERE 
		[local_value] <> [remote_value]
		AND [path] = N'job.schedule_count'
		AND [job_name] NOT IN (SELECT [job_name] FROM [#Differences] WHERE [problem] IN (N'LOCAL_ONLY', N'REMOTE_ONLY'));  /* No sense reporting on jobs that exist on only one box vs both...  */

	/* Check for Job-Step and Schedule Differences (but only on jobs where the counts (job-steps or schedules) are different) */
	CREATE TABLE #LocalJobSteps (
		step_id int, 
		[checksum] int
	);

	CREATE TABLE #RemoteJobSteps (
		step_id int, 
		[checksum] int
	);

	CREATE TABLE #LocalJobSchedules (
		schedule_name sysname, 
		[checksum] int
	);

	CREATE TABLE #RemoteJobSchedules (
		schedule_name sysname, 
		[checksum] int
	);

	/* vNEXT: Look at expanding these details via 'paths' as well, e.g., schedules.N.something for local vs remote and job_step.N.body_or_whatever (local vs remote) etc.*/
	DECLARE @jobName sysname; 
	DECLARE @localJobID uniqueidentifier, @remoteJobId uniqueidentifier;
	DECLARE [checker] CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[job_name] 
	FROM 
		[#PathAlignedDetails] 
	WHERE 
		[local_value] = [remote_value] AND [path] IN (N'job.job_step_count', N'job.schedule_count') 
	GROUP BY 
		[job_name];	
	
	OPEN [checker];
	FETCH NEXT FROM [checker] INTO @jobName;
	
	WHILE @@FETCH_STATUS = 0 BEGIN
		SELECT 
			@localJobID = [local_value], 
			@remoteJobId = [remote_value]
		FROM 
			[#PathAlignedDetails]
		WHERE 
			[path] = N'job.job_id'
			AND [job_name] = @jobName;

		DELETE FROM #LocalJobSteps;
		DELETE FROM #RemoteJobSteps;

		INSERT INTO #LocalJobSteps (step_id, [checksum])
		SELECT 
			step_id, 
			CHECKSUM(step_name, subsystem, command, on_success_action, on_fail_action, [database_name]) [checksum]
		FROM 
			msdb.dbo.sysjobsteps
		WHERE 
			job_id = @localJobID;

		INSERT INTO #RemoteJobSteps (step_id, [checksum])
		EXEC sys.sp_executesql N'SELECT 
			step_id, 
			CHECKSUM(step_name, subsystem, command, on_success_action, on_fail_action, [database_name]) [checksum]
		FROM 
			PARTNER.msdb.dbo.sysjobsteps
		WHERE 
			job_id = @remoteJobId;', 
		N'@remoteJobID uniqueidentifier', 
		@remoteJobId = @remoteJobId;

		/* vNEXT: account for proxies, logging, retry-counts, and all other job-step details... (vs just 'core' stuff I'm doing now) */
		INSERT INTO [#Differences] ([job_name],[problem],[description])
		SELECT 
			@jobName [job_name], 
			N'JOB_STEP_DIFFERENCES' [problem], 
			N'Job Step #' + CAST([ljs].[step_id] AS sysname) + ' is DIFFERENT between servers (step-name, subystem-type, target-database, success/failure action, or body).' [description]
		FROM 
			[#LocalJobSteps] ljs 
			INNER JOIN [#RemoteJobSteps] rjs ON [ljs].[step_id] = [rjs].[step_id] 
		WHERE 
			[ljs].[checksum] <> [rjs].[checksum];

		DELETE FROM #LocalJobSchedules;
		DELETE FROM #RemoteJobSchedules;

		INSERT INTO #LocalJobSchedules (schedule_name, [checksum])
		SELECT 
			ss.name,
			/* Bit of a hack to address start date/times for 'start automatically when sql agent starts' start option: */
			CASE 
				WHEN ss.freq_type = 64 THEN CHECKSUM(ss.[enabled], ss.freq_type)
				ELSE CHECKSUM(ss.[enabled], ss.freq_type, ss.freq_interval, ss.freq_subday_type, ss.freq_subday_interval, ss.freq_relative_interval, 
				ss.freq_recurrence_factor, ss.active_start_date, ss.active_end_date, ss.active_start_time, ss.active_end_time)
			END [checksum]
		FROM 
			msdb.dbo.sysjobschedules sjs
			INNER JOIN msdb.dbo.sysschedules ss ON ss.schedule_id = sjs.schedule_id
		WHERE
			sjs.job_id = @localJobID;

		INSERT INTO #RemoteJobSchedules (schedule_name, [checksum])
		EXEC sys.sp_executesql N'SELECT 
			ss.name,
			/* ditto ... hack for ''start automatically when sql agent starts'' job schedules: */
			CASE 
				WHEN ss.freq_type = 64 THEN CHECKSUM(ss.[enabled], ss.freq_type)
				ELSE CHECKSUM(ss.[enabled], ss.freq_type, ss.freq_interval, ss.freq_subday_type, ss.freq_subday_interval, ss.freq_relative_interval, 
				ss.freq_recurrence_factor, ss.active_start_date, ss.active_end_date, ss.active_start_time, ss.active_end_time)
			END [checksum]
		FROM 
			PARTNER.msdb.dbo.sysjobschedules sjs
			INNER JOIN PARTNER.msdb.dbo.sysschedules ss ON ss.schedule_id = sjs.schedule_id
		WHERE
			sjs.job_id = @remoteJobId;', 
		N'@remoteJobID uniqueidentifier', 
		@remoteJobId = @remoteJobId;

		INSERT INTO [#Differences] ([job_name],[problem],[description])
		SELECT 
			@jobName [job_name], 
			N'SCHEDULE_DIFFERENCES' [problem], 
			N'Schedule [' + [ljs].[schedule_name] + + N'] is DIFFERENT between servers.' [description]
		FROM 
			[#LocalJobSchedules] ljs	 
			INNER JOIN [#RemoteJobSchedules] rjs ON [ljs].[schedule_name] = [rjs].[schedule_name] 
		WHERE 
			ljs.[checksum] <> rjs.[checksum];

		FETCH NEXT FROM [checker] INTO @jobName;
	END;
	
	CLOSE [checker];
	DEALLOCATE [checker];
	
	/* Account for @JobCategoryMapping */
	UPDATE x 
		SET x.[mapped_category_name] = ISNULL(m.[target_database], x.[category_name])
	FROM 
		[#LocalJobs] x 
		LEFT OUTER JOIN [#mappedCategories] m ON x.[category_name] = m.[category_name];

	UPDATE x 
		SET x.[mapped_category_name] = ISNULL(m.[target_database], x.[category_name])
	FROM 
		[#RemoteJobs] x 
		LEFT OUTER JOIN [#mappedCategories] m ON x.[category_name] = m.[category_name];

	/* Check for batch-jobs disabled/enabled statuses need to be evaluated */
	WITH batch_jobs AS ( 
		/* NOTE: Explicitly IGNORING jobs only on one server or another at this point - those issues need to be fixed FIRST, then we can evaluate enabled/disabled logic as needed. */
		SELECT 
			[name],
			[enabled],
			[category_name],
			[mapped_category_name]
		FROM 
			[#LocalJobs]
		WHERE 
			[name] NOT IN (SELECT [job_name] FROM [#Differences] WHERE [problem] IN (N'LOCAL_ONLY', N'REMOTE_ONLY')) /* see notes below about this predicate being redundant */
			AND (
				[category_name] IN (SELECT [database_name] FROM @synchronizingDatabases)
				OR 
				[mapped_category_name] IN (SELECT [database_name] FROM @synchronizingDatabases)
				OR 
				(UPPER([category_name]) = N'DISABLED' OR UPPER([mapped_category_name]) = N'DISABLED')
			)
	), 
	enabled_states AS ( 
		SELECT 
			[job_name],
			[local_value],
			[remote_value] 
		FROM 
			[#PathAlignedDetails] 
		WHERE 
			[path] = N'job.enabled'
			AND [job_name] NOT IN (SELECT [job_name] FROM [#Differences] WHERE [problem] IN (N'LOCAL_ONLY', N'REMOTE_ONLY'))  /* this predicate is REDUNDANT. Leaving it in case initial/core logic change. */

	)
	SELECT 
		[j].[name] [job_name],
		[j].[category_name],
		[j].[mapped_category_name],
		[s].[local_value] [local_enabled],
		[s].[remote_value] [remote_enabled] 
	INTO 
		#batchJobEnabledStates
	FROM 
		batch_jobs j 
		LEFT OUTER JOIN [enabled_states] s ON j.[name] = s.[job_name];

	/* 3 scenarios for enabled/disabled problems: a) + b) incorrectly enabled/disabled on primary and/or secondary, 
		and c) disabled but not set category: disabled or d) category = disabled but jobs not disabled. sheesh */
	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[job_name], 
		N'DISABLED_ON_PRIMARY' [problem], 
		N'Batch-Job is DISABLED on PRIMARY server. *' [description]
	FROM 
		[#batchJobEnabledStates] 
	WHERE 
		(UPPER([category_name]) <> N'DISABLED' OR UPPER([mapped_category_name]) <>  N'DISABLED')
		AND [local_enabled] = 0;

	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[job_name], 
		N'ENABLED_ON_SECONDARY' [problem], 
		N'Batch-Job is ENABLED on NON-PRIMARY server. *' [description]
	FROM 
		[#batchJobEnabledStates] 
	WHERE 
		(UPPER([category_name]) <> N'DISABLED' OR UPPER([mapped_category_name]) <>  N'DISABLED')
		AND [remote_enabled] = 1;

	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[job_name], 
		N'ENABLED_WITH_CAT_DISABLED' [problem], 
		N'Job-Category is [Disabled] but Job is ENABLED. ' [description]
	FROM 
		[#batchJobEnabledStates] 
	WHERE 
		(UPPER([category_name]) = N'DISABLED' OR UPPER([mapped_category_name]) =  N'DISABLED')
		AND [local_enabled] = 1;

	/* Check for Server-Level Jobs with different enabled/disabled states between servers */
	WITH server_jobs AS ( 
		SELECT 
			[name], 
			[category_name], 
			[mapped_category_name]
		FROM 
			[#LocalJobs]
		WHERE 
			[name] NOT IN (SELECT [job_name] FROM [#batchJobEnabledStates])

		UNION 

		SELECT 
			[name], 
			[category_name], 
			[mapped_category_name]
		FROM 
			[#RemoteJobs]
		WHERE 
			[name] NOT IN (SELECT [job_name] FROM [#batchJobEnabledStates])

	), 
	enabled_states AS ( 
		SELECT 
			[job_name],
			[local_value] [local_enabled],
			[remote_value] [remote_enabled]
		FROM 
			[#PathAlignedDetails] 
		WHERE 
			[path] = N'job.enabled'
			AND [job_name] NOT IN (SELECT [job_name] FROM [#Differences] WHERE [problem] IN (N'LOCAL_ONLY', N'REMOTE_ONLY'))  /* this predicate is REDUNDANT. Leaving it in case initial/core logic change. */

	)

	INSERT INTO [#Differences] ([job_name],[problem],[description])
	SELECT 
		[s].[job_name],
		N'SERVERJOB_ENABLED_DISABLED' [problem], 
		N'Job-Enabled State is different between servers.' [description]
	FROM  
		[server_jobs] j 
		LEFT OUTER JOIN [enabled_states] s ON j.[name] = s.[job_name]
	WHERE 
		[s].[local_enabled] <> [s].[remote_enabled];


	IF(SELECT COUNT(*) FROM [#Differences]) > 0 BEGIN 

		DECLARE @subject nvarchar(200) = 'SQL Server Agent Job Synchronization Problems';
		DECLARE @crlf nchar(2) = CHAR(13) + CHAR(10);
		DECLARE @tab nchar(1) = CHAR(9);
		DECLARE @message nvarchar(MAX) = 'The following problems were detected with the following SQL Server Agent Jobs: '
		+ @crlf;

		DECLARE @description nvarchar(MAX);
		DECLARE @previousJobName sysname;
		DECLARE [walker] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			[job_name],
			[description]
		FROM 
			[#Differences]
		ORDER BY 
			[job_name];		
		
		OPEN [walker];
		FETCH NEXT FROM [walker] INTO @jobName, @description;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
			IF @previousJobName IS NULL BEGIN
				SET @message = @message + @crlf + @tab + N'[' + @jobName + N'] ' + @crlf;
				SET @previousJobName = @jobName;
			END;

			IF @previousJobName <> @jobName BEGIN 
				SET @message = @message + @crlf + @tab + N'[' + @jobName + N'] ' + @crlf;
			END;
			
			SET @message = @message + @tab + @tab + N'- ' + @description + @crlf;

			SET @previousJobName = @jobName;
			FETCH NEXT FROM [walker] INTO @jobName, @description;
		END;
		
		CLOSE [walker];
		DEALLOCATE [walker];

		IF EXISTS (SELECT NULL FROM [#Differences] WHERE [problem] IN (N'DISABLED_ON_PRIMARY', N'ENABLED_ON_SECONDARY')) BEGIN 
			SELECT @message += @crlf + N'* Batch-Jobs should be ENABLED on PRIMARY, and DISABLED on NON-PRIMARY.' + @crlf;
		END;

		SELECT @message += @crlf + N'NOTE: Jobs can be synchronized by scripting them on the Primary and running scripts on the Secondary.'
			+ @crlf + @tab + N'To Script Multiple Jobs at once: SSMS > SQL Server Agent Jobs > F7 -> then shift/ctrl + click to select multiple jobs simultaneously.';

		IF @PrintOnly = 1 BEGIN 
			PRINT 'SUBJECT: ' + @subject;
			PRINT 'BODY: ' + @crlf + @message;
		  END
		ELSE BEGIN
			EXEC msdb..sp_notify_operator 
				@profile_name = @MailProfileName, 
				@name = @OperatorName, 
				@subject = @subject,
				@body = @message;
		END;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_server_synchronization','P') IS NOT NULL
	DROP PROC dbo.verify_server_synchronization;
GO

CREATE PROC dbo.verify_server_synchronization 
	@IgnoreSynchronizedDatabaseOwnership	    bit		            = 0,					
	@IgnoredMasterDbObjects				        nvarchar(MAX)       = NULL,
	@IgnoredLogins						        nvarchar(MAX)       = NULL,
	@IgnoredAlerts						        nvarchar(MAX)       = NULL,
	@IgnoredLinkedServers				        nvarchar(MAX)       = NULL,
    @IgnorePrincipalNames                       bit                 = 1,                -- e.g., WinName1\Administrator and WinBox2Name\Administrator should both be treated as just 'Administrator'
	@MailProfileName					        sysname             = N'General',					
	@OperatorName						        sysname             = N'Alerts',					
	@PrintOnly							        bit		            = 0						
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-----------------------------------------------------------------------------
	IF (SELECT dbo.[is_primary_server]()) = 0 BEGIN
		IF @PrintOnly = 0 BEGIN
			PRINT N'Server is Not Primary.';
			RETURN 0;
		  END; 
		ELSE BEGIN 
			PRINT 'NOTE: Synchronization Check is allowed to run from SECONDARY - because @PrintOnly = 1.';
		END;
	END;	

	-----------------------------------------------------------------------------
	-- Dependencies Validation:
	DECLARE @return int, @returnMessage nvarchar(MAX);
    IF @PrintOnly = 0 BEGIN 

	    EXEC @return = dbo.verify_advanced_capabilities;
        IF @return <> 0
            RETURN @return;

        EXEC @return = dbo.verify_alerting_configuration
            @OperatorName, 
            @MailProfileName;

        IF @return <> 0 
            RETURN @return;
    END;

    CREATE TABLE #bus ( 
        [row_id] int IDENTITY(1,1) NOT NULL, 
        [channel] sysname NOT NULL DEFAULT (N'warning'),  -- ERROR | WARNING | INFO | CONTROL | GUIDANCE | OUTCOME (for control?)
        [timestamp] datetime NOT NULL DEFAULT (GETDATE()),
        [parent] int NULL,
        [grouping_key] sysname NULL, 
        [heading] nvarchar(1000) NULL, 
        [body] nvarchar(MAX) NULL, 
        [detail] nvarchar(MAX) NULL, 
        [command] nvarchar(MAX) NULL
    );

	EXEC @return = dbo.verify_partner 
		@Error = @returnMessage OUTPUT; 

	IF @return <> 0 BEGIN 
		INSERT INTO [#bus] (
			[channel],
			[heading],
			[body], 
			[detail]
		)
		VALUES	(
			N'ERROR', 
			N'PARTNER is down/inaccessible.', 
			N'Synchronization Checks against PARTNER server cannot be conducted as connection attempts against PARTNER from ' + @@SERVERNAME + N' failed.', 
			@returnMessage
		)
		
		GOTO REPORTING;
	END;

	IF NOT EXISTS (SELECT NULL FROM sys.servers WHERE [name] = 'PARTNER') BEGIN 
		RAISERROR('Linked Server ''PARTNER'' not detected. Comparisons between this server and its peer can not be processed.', 16, 1);
		RETURN -5;
	END; 

	IF OBJECT_ID('admindb.dbo.server_trace_flags', 'U') IS NULL BEGIN 
		RAISERROR('Table dbo.server_trace_flags is not present in master. Synchronization check can not be processed.', 16, 1);
		RETURN -6;
	END

	-- Start by updating dbo.server_trace_flags on both servers:
	EXEC dbo.[populate_trace_flags];
	EXEC sp_executesql N'EXEC [PARTNER].[admindb].dbo.populate_trace_flags; ';

	DECLARE @localServerName sysname = @@SERVERNAME;
	DECLARE @remoteServerName sysname; 
	EXEC master.sys.sp_executesql N'SELECT @remoteName = (SELECT TOP 1 [name] FROM PARTNER.master.sys.servers WHERE server_id = 0);', N'@remoteName sysname OUTPUT', @remoteName = @remoteServerName OUTPUT;

    ---------------------------------------
	-- Server Level Configuration/Settings: 
	DECLARE @remoteConfig table ( 
		configuration_id int NOT NULL, 
		value_in_use sql_variant NULL
	);	

	INSERT INTO @remoteConfig (configuration_id, value_in_use)
	EXEC master.sys.sp_executesql N'SELECT configuration_id, value_in_use FROM PARTNER.master.sys.configurations;';

    INSERT INTO [#bus] (
        [grouping_key],
        [heading], 
        [body]
    )
    SELECT 
        N'sys.configurations' [grouping_key], 
        N'Setting ' + QUOTENAME([source].[name]) + N' is different between servers.' [heading], 
        N'Value on ' + @localServerName + N' = ' + CAST([source].[value_in_use] AS sysname) + N'. Value on ' + @remoteServerName + N' = ' + CAST([target].[value_in_use] AS sysname) + N'.' [body]
	FROM 
		master.sys.configurations [source]
		INNER JOIN @remoteConfig [target] ON [source].[configuration_id] = [target].[configuration_id]
	WHERE 
		[source].value_in_use <> [target].value_in_use;

    ---------------------------------------
	-- Trace Flags: 
	DECLARE @remoteFlags TABLE (
		trace_flag int NOT NULL, 
		[status] bit NOT NULL, 
		[global] bit NOT NULL, 
		[session] bit NOT NULL
	);
	
	INSERT INTO @remoteFlags ([trace_flag], [status], [global], [session])
	EXEC sp_executesql N'SELECT [trace_flag], [status], [global], [session] FROM PARTNER.admindb.dbo.server_trace_flags;';
	
	-- local only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'trace flag' [grouping_key], 
        N'Trace Flag ' + CAST(trace_flag AS sysname) + N' exists only on ' + @localServerName + N'.' [heading] 
	FROM 
		admindb.dbo.server_trace_flags 
	WHERE 
		trace_flag NOT IN (SELECT trace_flag FROM @remoteFlags);

	-- remote only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'trace flag' [grouping_key],
        N'Trace Flag ' + CAST(trace_flag AS sysname) + N' exists only on ' + @remoteServerName + N'.' [heading]  
	FROM 
		@remoteFlags
	WHERE 
		--trace_flag NOT IN (SELECT trace_flag FROM @remoteFlags);
		trace_flag NOT IN (SELECT trace_flag FROM admindb.dbo.server_trace_flags);

	-- different values: 
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'trace flag' [grouping_key],
        N'Trace Flag Enabled Value is Different Between Servers.' [heading]
	FROM 
		admindb.dbo.server_trace_flags [x]
		INNER JOIN @remoteFlags [y] ON x.trace_flag = y.trace_flag 
	WHERE 
		x.[status] <> y.[status]
		OR x.[global] <> y.[global]
		OR x.[session] <> y.[session];

	---------------------------------------
	-- Make sure sys.messages.message_id #1480 is set so that is_event_logged = 1 (for easier/simplified role change (failover) notifications). Likewise, make sure 1440 is still set to is_event_logged = 1 (the default). 
	DECLARE @remoteMessages table (
		language_id smallint NOT NULL, 
		message_id int NOT NULL, 
		is_event_logged bit NOT NULL
	);

	INSERT INTO @remoteMessages (language_id, message_id, is_event_logged)
	EXEC sp_executesql N'SELECT language_id, message_id, is_event_logged FROM PARTNER.master.sys.messages WHERE message_id IN (1440, 1480);';
    
    -- local:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'error messages' [grouping_key],
        N'The is_event_logged property for message_id ' + CAST(message_id AS sysname) + N' on ' + @localServerName + N' is not set to 1.' [heading]
	FROM 
		sys.messages 
	WHERE 
		language_id = @@langid
		AND message_id IN (1440, 1480)
		AND is_event_logged = 0;

	-- remote:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading] 
    )    
    SELECT 
        N'error messages' [grouping_key],
        N'The is_event_logged property for message_id ' + CAST(message_id AS sysname) + N' on ' + @remoteServerName + N' is not set to 1.' [heading]
	FROM 
		sys.messages 
	WHERE 
		language_id = @@langid
		AND message_id IN (1440, 1480)
		AND is_event_logged = 0;

	---------------------------------------
	-- admindb checks: 
	DECLARE @localAdminDBVersion sysname;
	DECLARE @remoteAdminDBVersion sysname;

	SELECT @localAdminDBVersion = version_number FROM admindb.dbo.version_history WHERE version_id = (SELECT MAX(version_id) FROM admindb..version_history);
	EXEC sys.sp_executesql N'SELECT @remoteVersion = version_number FROM PARTNER.admindb.dbo.version_history WHERE version_id = (SELECT MAX(version_id) FROM PARTNER.admindb.dbo.version_history);', N'@remoteVersion sysname OUTPUT', @remoteVersion = @remoteAdminDBVersion OUTPUT;

	IF @localAdminDBVersion <> @remoteAdminDBVersion BEGIN
        INSERT INTO [#bus] (
            [grouping_key],
            [heading], 
            [body]
        )    
        SELECT 
            N'admindb (s4 versioning)' [grouping_key],
            N'S4 Database versions are different betweent servers.' [heading], 
            N'Version on ' + @localServerName + N' is ' + @localAdminDBVersion + '. Version on' + @remoteServerName + N' is ' + @remoteAdminDBVersion + N'.' [body];
	END;

    DECLARE @localAdvancedValue sysname; 
    DECLARE @remoteAdvancedValue sysname; 

    SELECT @localAdvancedValue = setting_value FROM dbo.[settings] WHERE [setting_key] = N'advanced_s4_error_handling';
    EXEC sys.sp_executesql N'SELECT @remoteAdvancedValue = setting_value FROM PARTNER.admindb.dbo.settings WHERE [setting_key] = N''advanced_s4_error_handling'';', N'@remoteAdvancedValue sysname OUTPUT', @remoteAdvancedValue = @remoteAdvancedValue OUTPUT;

    IF ISNULL(@localAdvancedValue, N'0') <> ISNULL(@remoteAdvancedValue, N'0') BEGIN 
        INSERT INTO [#bus] (
            [grouping_key],
            [heading], 
            [body]
        )
        SELECT 
            N'admindb (s4 versioning)' [grouping_key],
            N'S4 Advanced Error Handling configuration settings are different betweent servers.' [heading], 
            N'Value on ' + @localServerName + N' is ' + @localAdvancedValue + '. Value on' + @remoteServerName + N' is ' + @remoteAdvancedValue + N'.' [body];
    END; 

	---------------------------------------
	-- Mirrored database ownership:
	IF @IgnoreSynchronizedDatabaseOwnership = 0 BEGIN 
		DECLARE @localOwners table ( 
			[name] nvarchar(128) NOT NULL, 
			sync_type sysname NOT NULL, 
			owner_sid varbinary(85) NULL
		);

		-- mirrored (local) dbs: 
		INSERT INTO @localOwners ([name], sync_type, owner_sid)
		SELECT d.[name], N'Mirrored' [sync_type], d.owner_sid FROM master.sys.databases d INNER JOIN master.sys.database_mirroring m ON d.database_id = m.database_id WHERE m.mirroring_guid IS NOT NULL; 

		-- AG'd (local) dbs: 
        IF (SELECT admindb.dbo.get_engine_version()) >= 11.0 BEGIN
			INSERT INTO @localOwners ([name], sync_type, owner_sid)
			EXEC master.sys.sp_executesql N'SELECT [name], N''Availability Group'' [sync_type], owner_sid FROM sys.databases WHERE replica_id IS NOT NULL;';  -- has to be dynamic sql - otherwise replica_id will throw an error during sproc creation... 
		END

		DECLARE @remoteOwners table ( 
			[name] nvarchar(128) NOT NULL, 
			sync_type sysname NOT NULL,
			owner_sid varbinary(85) NULL
		);

		-- Mirrored (remote) dbs:
		INSERT INTO @remoteOwners ([name], sync_type, owner_sid) 
		EXEC sp_executesql N'SELECT d.[name], ''Mirrored'' [sync_type], d.owner_sid FROM PARTNER.master.sys.databases d INNER JOIN PARTNER.master.sys.database_mirroring m ON m.database_id = d.database_id WHERE m.mirroring_guid IS NOT NULL;';

		-- AG'd (local) dbs: 
		IF (SELECT admindb.dbo.get_engine_version()) >= 11.0 BEGIN
			INSERT INTO @remoteOwners ([name], sync_type, owner_sid)
			EXEC sp_executesql N'SELECT [name], N''Availability Group'' [sync_type], owner_sid FROM [PARTNER].[master].sys.databases WHERE replica_id IS NOT NULL;';			
		END

        INSERT INTO [#bus] (
            [grouping_key],
            [heading], 
            [body]
        )    
        SELECT 
            N'databases' [grouping_key], 
			[local].sync_type + N' database owners for database ' + QUOTENAME([local].[name]) + N' are different between servers.' [heading], 
            N'To correct: a) Execute a manual failover of database ' + QUOTENAME([local].[name]) + N', and then b) EXECUTE { ALTER AUTHORIZATION ON DATABASE::[' + [local].[name] + N'] TO [sa];  }. NOTE: All synchronized databases should be owned by SysAdmin.'
            -- TODO: instructions on how to fix and/or CONTROL directives TO fix... (only, can't 'fix' this issue with mirrored/AG'd databases).
		FROM 
			@localOwners [local]
			INNER JOIN @remoteOwners [remote] ON [local].[name] = [remote].[name]
		WHERE
			[local].owner_sid <> [remote].owner_sid;

	END

	---------------------------------------
	-- Linked Servers:
	DECLARE @IgnoredLinkedServerNames TABLE (
		entry_id int IDENTITY(1,1) NOT NULL, 
		[name] sysname NOT NULL
	);

	INSERT INTO @IgnoredLinkedServerNames([name])
	SELECT [result] [name] FROM dbo.split_string(@IgnoredLinkedServers, N',', 1);

	DECLARE @remoteLinkedServers table ( 
		[server_id] int NOT NULL,
		[name] sysname NOT NULL,
		[location] nvarchar(4000) NULL,
		[provider_string] nvarchar(4000) NULL,
		[catalog] sysname NULL,
		[product] sysname NOT NULL,
		[data_source] nvarchar(4000) NULL,
		[provider] sysname NOT NULL,
		[is_remote_login_enabled] bit NOT NULL,
		[is_rpc_out_enabled] bit NOT NULL,
		[is_collation_compatible] bit NOT NULL,
		[uses_remote_collation] bit NOT NULL,
		[collation_name] sysname NULL,
		[connect_timeout] int NULL,
		[query_timeout] int NULL,
		[is_remote_proc_transaction_promotion_enabled] bit NULL,
		[is_system] bit NOT NULL,
		[lazy_schema_validation] bit NOT NULL
	);

	INSERT INTO @remoteLinkedServers ([server_id], [name], [location], provider_string, [catalog], product, [data_source], [provider], is_remote_login_enabled, is_rpc_out_enabled, is_collation_compatible, uses_remote_collation,
		 collation_name, connect_timeout, query_timeout, is_remote_proc_transaction_promotion_enabled, is_system, lazy_schema_validation)
	EXEC master.sys.sp_executesql N'SELECT [server_id], [name], [location], provider_string, [catalog], product, [data_source], [provider], is_remote_login_enabled, is_rpc_out_enabled, is_collation_compatible, uses_remote_collation, collation_name, connect_timeout, query_timeout, is_remote_proc_transaction_promotion_enabled, is_system, lazy_schema_validation FROM PARTNER.master.sys.servers;';

	-- local only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'linked servers' [grouping_key], 
        N'Linked Server definition for ' + QUOTENAME([local].[name]) + N' exists on ' + @localServerName + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		sys.servers [local]
		LEFT OUTER JOIN @remoteLinkedServers [remote] ON [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[name]
	WHERE 
		[local].server_id > 0 
		AND [local].[name] <> 'PARTNER'
		AND [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [name] FROM @IgnoredLinkedServerNames)
		AND [remote].[name] IS NULL;

	-- remote only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'linked servers' [grouping_key], 
        N'Linked Server definition for ' + QUOTENAME([remote].[name]) + N' exists on ' + @remoteServerName + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@remoteLinkedServers [remote]
		LEFT OUTER JOIN master.sys.servers [local] ON [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[name]
	WHERE 
		[remote].server_id > 0 
		AND [remote].[name] <> 'PARTNER'
		AND [remote].[name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [name] FROM @IgnoredLinkedServerNames)
		AND [local].[name] IS NULL;
	
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'linked servers' [grouping_key], 
		N'Linked Server Definition for ' + QUOTENAME([local].[name]) + N' exists on both servers but is different.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		sys.servers [local]
		INNER JOIN @remoteLinkedServers [remote] ON [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[name]
	WHERE 
		[local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [name] FROM @IgnoredLinkedServerNames)
		AND ( 
			[local].product COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].product
			OR [local].[provider] COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].[provider]
			-- Sadly, PARTNER is a bit of a pain/problem - it has to exist on both servers - but with slightly different versions:
			OR (
				CASE 
					WHEN [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = 'PARTNER' AND [local].[data_source] COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].[data_source] THEN 0 -- non-true (i.e., non-'different' or non-problematic)
					WHEN [local].[data_source] COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].[data_source] COLLATE SQL_Latin1_General_CP1_CI_AS THEN 1
					ELSE 0 
				END 
				 = 1  
			)
			OR [local].[location] COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].[location]
			OR [local].provider_string COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].provider_string
			OR [local].[catalog] COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].[catalog]
			OR [local].is_remote_login_enabled <> [remote].is_remote_login_enabled
			OR [local].is_rpc_out_enabled <> [remote].is_rpc_out_enabled
			OR [local].is_collation_compatible <> [remote].is_collation_compatible
			OR [local].uses_remote_collation <> [remote].uses_remote_collation
			OR [local].collation_name COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].collation_name
			OR [local].connect_timeout <> [remote].connect_timeout
			OR [local].query_timeout <> [remote].query_timeout
			OR [local].is_remote_proc_transaction_promotion_enabled <> [remote].is_remote_proc_transaction_promotion_enabled
			OR [local].is_system <> [remote].is_system
			OR [local].lazy_schema_validation <> [remote].lazy_schema_validation
		);

	---------------------------------------
	-- Logins:
	DECLARE @ignoredLoginName TABLE (
		entry_id int IDENTITY(1,1) NOT NULL, 
		[name] sysname NOT NULL
	);

	INSERT INTO @ignoredLoginName([name])
	SELECT [result] [name] FROM dbo.split_string(@IgnoredLogins, N',', 1);

	DECLARE @remotePrincipals table ( 
		[principal_id] int NOT NULL,
		[name] sysname NOT NULL,
        [simplified_name] sysname NULL,
		[sid] varbinary(85) NULL,
		[type] char(1) NOT NULL,
		[is_disabled] bit NULL, 
        [password_hash] varbinary(256) NULL
	);

	INSERT INTO @remotePrincipals ([principal_id], [name], [sid], [type], [is_disabled], [password_hash])
	EXEC master.sys.sp_executesql N'
    SELECT 
        p.[principal_id], 
        p.[name], 
        p.[sid], 
        p.[type], 
        p.[is_disabled], 
        l.[password_hash]
    FROM 
        [PARTNER].[master].sys.server_principals p
        LEFT OUTER JOIN [PARTNER].[master].sys.sql_logins l ON p.[principal_id] = l.[principal_id]
    WHERE 
        p.[principal_id] > 10 
        AND p.[name] NOT LIKE ''##%##'' AND p.[name] NOT LIKE ''NT %\%''
		AND p.[type] <> ''R'';';

	DECLARE @localPrincipals table ( 
		[principal_id] int NOT NULL,
		[name] sysname NOT NULL,
        [simplified_name] sysname NULL,
		[sid] varbinary(85) NULL,
		[type] char(1) NOT NULL,
		[is_disabled] bit NULL, 
        [password_hash] varbinary(256) NULL
	);

	INSERT INTO @localPrincipals ([principal_id], [name], [sid], [type], [is_disabled], [password_hash])
    SELECT 
        p.[principal_id], 
        p.[name], 
        p.[sid], 
        p.[type], 
        p.[is_disabled], 
        l.[password_hash]
    FROM 
        [master].sys.server_principals p
        LEFT OUTER JOIN [master].sys.sql_logins l ON p.[principal_id] = l.[principal_id]
    WHERE 
        p.[principal_id] > 10 
        AND p.[name] NOT LIKE '##%##' AND p.[name] NOT LIKE 'NT %\%'
		AND p.[type] <> 'R';

    IF @IgnorePrincipalNames = 1 BEGIN 
        UPDATE @localPrincipals
        SET 
            [simplified_name] = REPLACE([name], @localServerName + N'\', N''),
            [sid] = 0x0
        WHERE 
            [type] = 'U'
            AND [name] LIKE @localServerName + N'\%'; 
            
        UPDATE @remotePrincipals
        SET 
            [simplified_name] = REPLACE([name], @remoteServerName + N'\', N''), 
            [sid] = 0x0
        WHERE 
            [type] = 'U' -- Windows Only... 
            AND [name] LIKE @remoteServerName + N'\%';
    END;

    -- local only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'logins' [grouping_key], 
		N'Login ' + QUOTENAME([local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS) + N' exists on ' + QUOTENAME(@localServerName) + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@localPrincipals [local]
	WHERE 
		ISNULL([local].[simplified_name], [local].[name]) COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT ISNULL([simplified_name], [name]) COLLATE SQL_Latin1_General_CP1_CI_AS FROM @remotePrincipals)
		AND [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
			SELECT 
				x.[name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@localPrincipals x 
				INNER JOIN @ignoredLoginName i ON x.[name] LIKE i.[name]
		);

	-- remote only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'logins' [grouping_key], 
		N'Login ' + QUOTENAME([remote].[name] COLLATE SQL_Latin1_General_CP1_CI_AS) + N' exists on ' + QUOTENAME(@remoteServerName) + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@remotePrincipals [remote]
	WHERE 
		ISNULL([remote].[simplified_name], [remote].[name]) COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT ISNULL([simplified_name], [name]) COLLATE SQL_Latin1_General_CP1_CI_AS FROM @localPrincipals)
		AND [remote].[name] NOT IN (
			SELECT 
				x.[name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@remotePrincipals x 
				INNER JOIN @ignoredLoginName i ON x.[name] LIKE i.[name]
		);

	-- differences
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'logins' [grouping_key], 
		N'Definition for Login ' + QUOTENAME([local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS) + N' is different between servers.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
        @localPrincipals [local]
        INNER JOIN @remotePrincipals [remote] ON ISNULL([local].[simplified_name], [local].[name]) COLLATE SQL_Latin1_General_CP1_CI_AS = ISNULL([remote].[simplified_name], [remote].[name]) COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE
		[local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
			SELECT 
				x.[name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@localPrincipals x 
				INNER JOIN @ignoredLoginName i ON x.[name] LIKE i.[name]			
		)
		AND (
			[local].[sid] <> [remote].[sid]
			OR [local].password_hash <> [remote].password_hash  
			OR [local].is_disabled <> [remote].is_disabled
		);

	---------------------------------------
	-- (Custom) Server Roles:
	DECLARE @localNonFixedRoles table ( 
		[role_name] sysname NOT NULL, 
		[owner_name] sysname NOT NULL
	);

	INSERT INTO @localNonFixedRoles ([role_name], [owner_name])
	SELECT 
		[name], 
		(SELECT x.[name] FROM sys.[server_principals] x WHERE sp.[owning_principal_id] = x.[principal_id]) [owner_id]
	FROM 
		sys.[server_principals] sp
	WHERE 
		[sp].[type] = 'R'
		AND sp.[is_fixed_role] = 0
		AND sp.[sid] <> 0x02; 

	DECLARE @remoteNonFixedRoles table (
		[role_name] sysname NOT NULL, 
		[owner_name] sysname NOT NULL
	);

	INSERT INTO @remoteNonFixedRoles ([role_name], [owner_name])
	EXEC sys.sp_executesql N'
	SELECT 
		[name], 
		(SELECT x.[name] FROM [PARTNER].[master].sys.[server_principals] x WHERE sp.[owning_principal_id] = x.[principal_id]) [owner_id]
	FROM 
		[PARTNER].[master].sys.[server_principals] sp
	WHERE 
		[sp].[type] = ''R''
		AND sp.[is_fixed_role] = 0
		AND sp.[sid] <> 0x02; ';

	-- local only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'roles' [grouping_key], 
		N'Custom Server Role ' + QUOTENAME([local].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS) + N' exists on ' + QUOTENAME(@localServerName) + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@localNonFixedRoles [local]
	WHERE 
		[local].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [role_name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM @remoteNonFixedRoles)
		AND [local].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
			SELECT 
				x.[name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@localPrincipals x 
				INNER JOIN @ignoredLoginName i ON x.[name] LIKE i.[name]
		);

	-- remote only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'roles' [grouping_key], 
		N'Custom Server Role ' + QUOTENAME([remote].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS) + N' exists on ' + QUOTENAME(@remoteServerName) + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@remoteNonFixedRoles [remote]
	WHERE 
		[remote].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [role_name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM @localNonFixedRoles)
		AND [remote].[role_name] NOT IN (
			SELECT 
				x.[name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@remotePrincipals x 
				INNER JOIN @ignoredLoginName i ON x.[name] LIKE i.[name]
		);	

	-- owner differences:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'roles' [grouping_key], 
		N'Owner of Custom Server Role ' + QUOTENAME([local].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS) + N' is different between servers.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
        @localNonFixedRoles [local]
        INNER JOIN @remoteNonFixedRoles [remote] ON [local].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE
		[local].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
			SELECT 
				x.[name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@localPrincipals x 
				INNER JOIN @ignoredLoginName i ON x.[name] LIKE i.[name]			
		)
		AND (
			[local].[owner_name] <> [remote].[owner_name]
		);

	-- permissions differences:
	DECLARE @localRoleDefinitions table ( 
		[role_name] sysname NOT NULL, 
		[definition] nvarchar(MAX) NULL
	); 
	DECLARE @remoteRoleDefinitions table (
		[role_name] sysname NOT NULL, 
		[definition] nvarchar(MAX) NULL
	); 

	INSERT INTO @localRoleDefinitions ([role_name])
	SELECT [role_name] FROM @localNonFixedRoles;

	INSERT INTO @remoteRoleDefinitions ([role_name])
	SELECT [role_name] FROM @remoteNonFixedRoles;

	IF EXISTS (SELECT NULL FROM @localRoleDefinitions) BEGIN 
		DECLARE @roleName sysname, @definitionHash varchar(2000); 

		DECLARE [cursorName] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			role_name 
		FROM 
			@localRoleDefinitions;
		
		OPEN [cursorName];
		FETCH NEXT FROM [cursorName] INTO @roleName;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
			SET @definitionHash = NULL;

			EXEC dbo.script_server_role 
				@RoleName = @roleName, 
				@IncludeMembers = 0,  -- already done above... 
				@TokenizePrincipalNames = @IgnorePrincipalNames, -- don't allow a permissiong like VIEW DEFINITION ON LOGIN::[SERVER-B\Admin] to conflict with ::[SERVER-A\Admin], etc.
				@OutputHash = @definitionHash OUTPUT;

			UPDATE @localRoleDefinitions
			SET 
				[definition] = @definitionHash 
			WHERE 
				[role_name] = @roleName;
		
			FETCH NEXT FROM [cursorName] INTO @roleName;
		END;
		
		CLOSE [cursorName];
		DEALLOCATE [cursorName];

	END;

	IF EXISTS (SELECT NULL FROM @remoteRoleDefinitions) BEGIN 
		DECLARE @remoteSQL nvarchar(MAX);

		DECLARE [cursorName] CURSOR LOCAL FAST_FORWARD FOR 
		SELECT 
			role_name 
		FROM 
			@remoteRoleDefinitions;
		
		OPEN [cursorName];
		FETCH NEXT FROM [cursorName] INTO @roleName;
		
		WHILE @@FETCH_STATUS = 0 BEGIN
			-- this HAS to be dynamic to avoid validation errors during CODE deployment... 
			SET @remoteSQL = N'EXEC [PARTNER].admindb.dbo.script_server_role @RoleName = @roleName, @IncludeMembers = 0, @TokenizePrincipalNames = 1, @OutputHash = @definitionHash OUTPUT;'	
			
			SET @definitionHash = NULL;
			EXEC sp_executesql 
				@remoteSQL, 
				N'@roleName sysname, @definitionHash varchar(2000) OUTPUT', 
				@roleName = @roleName, 
				@definitionHash = @definitionHash OUTPUT;

			UPDATE @remoteRoleDefinitions 
			SET 
				[definition] = @definitionHash 
			WHERE 
				[role_name] = @roleName;
		
			FETCH NEXT FROM [cursorName] INTO @roleName;
		END;
		
		CLOSE [cursorName];
		DEALLOCATE [cursorName];
	END;

    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'roles' [grouping_key], 
		N'Permissions for Custom Server Role ' + QUOTENAME([local].[role_name] COLLATE SQL_Latin1_General_CP1_CI_AS) + N' are different between servers. (Use dbo.script_server_role on both servers to view differences.)' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@localRoleDefinitions [local]
		INNER JOIN @remoteRoleDefinitions [remote] ON [local].[role_name] = [remote].[role_name]
	WHERE 
		[local].[definition] <> [remote].[definition];
	
    -- (server) role memberships: 
    DECLARE @localMemberRoles table ( 
        [login_name] sysname NOT NULL, 
        [simplified_name] sysname NULL, 
        [role] sysname NOT NULL
    );

    DECLARE @remoteMemberRoles table ( 
        [login_name] sysname NOT NULL, 
        [simplified_name] sysname NULL, 
        [role] sysname NOT NULL
    );	
    
    -- note, explicitly including NT SERVICE\etc and other 'built in' service accounts as we want to check for any differences in role memberships:
    INSERT INTO @localMemberRoles (
        [login_name],
        [role]
    )
    SELECT 
	    p.[name] [login_name],
	    [roles].[name] [role_name]
    FROM 
	    sys.server_principals p 
	    INNER JOIN sys.server_role_members m ON p.principal_id = m.member_principal_id
	    INNER JOIN sys.server_principals [roles] ON m.role_principal_id = [roles].principal_id
    WHERE 
	    p.principal_id > 10 AND p.[name] NOT LIKE '##%##';

    INSERT INTO @remoteMemberRoles (
        [login_name],
        [role]
    )
    EXEC sys.[sp_executesql] N'
    SELECT 
	    p.[name] [login_name],
	    [roles].[name] [role_name]
    FROM 
	    [PARTNER].[master].sys.server_principals p 
	    INNER JOIN [PARTNER].[master].sys.server_role_members m ON p.principal_id = m.member_principal_id
	    INNER JOIN [PARTNER].[master].sys.server_principals [roles] ON m.role_principal_id = [roles].principal_id
    WHERE 
	    p.principal_id > 10 AND p.[name] NOT LIKE ''##%##''; ';
        
    IF @IgnorePrincipalNames = 1 BEGIN 
        UPDATE @localMemberRoles
        SET 
            [simplified_name] = REPLACE([login_name], @localServerName + N'\', N'')
        WHERE 
            [login_name] LIKE @localServerName + N'\%';

        UPDATE @remoteMemberRoles
        SET 
            [simplified_name] = REPLACE([login_name], @remoteServerName + N'\', N'')
        WHERE 
            [login_name] LIKE @remoteServerName + N'\%';        
    END;

    -- local not in remote:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )   
    SELECT 
        N'logins' [grouping_key], 
        N'Login ' + QUOTENAME([local].[login_name]) + N' is a member of server role ' + QUOTENAME([local].[role]) + N' on server ' + QUOTENAME(@localServerName) + N' only.' [heading]
    FROM 
        @localMemberRoles [local] 
    WHERE 
        (ISNULL([local].[simplified_name], [local].[login_name]) + N'.' + [local].[role]) COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
            SELECT (ISNULL([simplified_name], [login_name]) + N'.' + [role]) COLLATE SQL_Latin1_General_CP1_CI_AS FROM @remoteMemberRoles
        )
        AND [local].[login_name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
			SELECT 
				x.[login_name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@localMemberRoles x 
				INNER JOIN @ignoredLoginName i ON x.[login_name] LIKE i.[name]
		);

    -- remote not in local:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )   
    SELECT 
        N'logins' [grouping_key], 
        N'Login ' + QUOTENAME([remote].[login_name]) + N' is a member of server role ' + QUOTENAME([remote].[role]) + N' on server ' + QUOTENAME(@remoteServerName) + N' only.' [heading]
    FROM 
        @remoteMemberRoles [remote] 
    WHERE 
        (ISNULL([remote].[simplified_name], [remote].[login_name]) + N'.' + [remote].[role]) COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
            SELECT (ISNULL([simplified_name], [login_name]) + N'.' + [role]) COLLATE SQL_Latin1_General_CP1_CI_AS FROM @localMemberRoles
        )
        AND [remote].[login_name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (
			SELECT 
				x.[login_name] COLLATE SQL_Latin1_General_CP1_CI_AS 
			FROM 
				@remoteMemberRoles x 
				INNER JOIN @ignoredLoginName i ON x.[login_name] LIKE i.[name]
		);
    
    ---------------------------------------
	-- Endpoints? 
	--		[add if needed/desired.]

	---------------------------------------
	-- Server Level Triggers?
	--		[add if needed/desired.]

	---------------------------------------
	-- Other potential things to check/review:
	--		Audit Specs
	--		XEs 
	--		credentials/proxies
	--		service accounts (i.e., SQL Server and SQL Server Agent)
	--		perform volume maint-tasks, lock pages in memory... 
	--		etc...

	---------------------------------------
	-- Operators:
	-- local only

	DECLARE @remoteOperators table (
		[name] sysname NOT NULL,
		[enabled] tinyint NOT NULL,
		[email_address] nvarchar(100) NULL
	);

	INSERT INTO @remoteOperators ([name], [enabled], email_address)
	EXEC master.sys.sp_executesql N'SELECT [name], [enabled], email_address FROM PARTNER.msdb.dbo.sysoperators;';

    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'operators' [grouping_key], 
		N'Operator ' + QUOTENAME([local].[name]) + N' exists on ' + @localServerName + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		msdb.dbo.sysoperators [local]
		LEFT OUTER JOIN @remoteOperators [remote] ON [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[name]
	WHERE 
		[remote].[name] IS NULL;

	-- remote only
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'operators' [grouping_key], 	
        N'Operator ' + QUOTENAME([remote].[name]) + N' exists on ' + @remoteServerName + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@remoteOperators [remote]
		LEFT OUTER JOIN msdb.dbo.sysoperators [local] ON [remote].[name] = [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE 
		[local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS IS NULL;

	-- differences (just checking email address in this particular config):
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'operators' [grouping_key], 
		N'Defintion for Operator ' + QUOTENAME([local].[name]) + N' is different between servers.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		msdb.dbo.sysoperators [local]
		INNER JOIN @remoteOperators [remote] ON [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[name]
	WHERE 
		[local].[enabled] <> [remote].[enabled]
		OR [local].[email_address] COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].[email_address];

	---------------------------------------
	-- Alerts:
	DECLARE @ignoredAlertName TABLE (
		entry_id int IDENTITY(1,1) NOT NULL,
		[name] sysname NOT NULL
	);

	INSERT INTO @ignoredAlertName([name])
	SELECT [result] [name] FROM dbo.split_string(@IgnoredAlerts, N',', 1);

	DECLARE @remoteAlerts table (
		[name] sysname NOT NULL,
		[message_id] int NOT NULL,
		[severity] int NOT NULL,
		[enabled] tinyint NOT NULL,
		[delay_between_responses] int NOT NULL,
		[notification_message] nvarchar(512) NULL,
		[include_event_description] tinyint NOT NULL,
		[database_name] nvarchar(512) NULL,
		[event_description_keyword] nvarchar(100) NULL,
		[job_id] uniqueidentifier NOT NULL,
		[has_notification] int NOT NULL,
		[performance_condition] nvarchar(512) NULL,
		[category_id] int NOT NULL
	);

	INSERT INTO @remoteAlerts ([name], message_id, severity, [enabled], delay_between_responses, notification_message, include_event_description, [database_name], event_description_keyword,
			job_id, has_notification, performance_condition, category_id)
	EXEC master.sys.sp_executesql N'SELECT [name], message_id, severity, [enabled], delay_between_responses, notification_message, include_event_description, [database_name], event_description_keyword, job_id, has_notification, performance_condition, category_id FROM PARTNER.msdb.dbo.sysalerts;';

	-- local only
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'alerts' [grouping_key], 
		N'Alert ' + QUOTENAME([local].[name]) + N' exists on ' + @localServerName + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		msdb.dbo.sysalerts [local]
		LEFT OUTER JOIN @remoteAlerts [remote] ON [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[name]
	WHERE
		[remote].[name] IS NULL
		AND [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [name] FROM @ignoredAlertName);

    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'alerts' [grouping_key], 
		N'Alert ' + QUOTENAME([remote].[name]) + N' exists on ' + @remoteServerName + N' only.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@remoteAlerts [remote]
		LEFT OUTER JOIN msdb.dbo.sysalerts [local] ON [remote].[name] = [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS
	WHERE
		[local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS IS NULL
		AND [remote].[name] NOT IN (SELECT [name] FROM @ignoredAlertName);

	-- differences:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'operators' [grouping_key],  
		N'Definition for Alert ' + QUOTENAME([local].[name]) + N' is different between servers.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM	
		msdb.dbo.sysalerts [local]
		INNER JOIN @remoteAlerts [remote] ON [local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS = [remote].[name]
	WHERE 
		[local].[name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [name] FROM @ignoredAlertName)
		AND (
		[local].message_id <> [remote].message_id
		OR [local].severity <> [remote].severity
		OR [local].[enabled] <> [remote].[enabled]
		OR [local].delay_between_responses <> [remote].delay_between_responses
		OR [local].notification_message COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].notification_message
		OR [local].include_event_description <> [remote].include_event_description
		OR [local].[database_name] COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].[database_name]
		OR [local].event_description_keyword COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].event_description_keyword
		-- JobID is problematic. If we have a job set to respond, it'll undoubtedly have a diff ID from one server to the other. So... we just need to make sure ID <> 'empty' on one server, while not on the other, etc. 
		OR (
			CASE 
				WHEN [local].job_id = N'00000000-0000-0000-0000-000000000000' AND [remote].job_id = N'00000000-0000-0000-0000-000000000000' THEN 0 -- no problem
				WHEN [local].job_id = N'00000000-0000-0000-0000-000000000000' AND [remote].job_id <> N'00000000-0000-0000-0000-000000000000' THEN 1 -- problem - one alert is 'empty' and the other is not. 
				WHEN [local].job_id <> N'00000000-0000-0000-0000-000000000000' AND [remote].job_id = N'00000000-0000-0000-0000-000000000000' THEN 1 -- problem (inverse of above). 
				WHEN ([local].job_id <> N'00000000-0000-0000-0000-000000000000' AND [remote].job_id <> N'00000000-0000-0000-0000-000000000000') AND ([local].job_id <> [remote].job_id) THEN 0 -- they're both 'non-empty' so... we assume it's good
			END 
			= 1
		)
		OR [local].has_notification <> [remote].has_notification
		OR [local].performance_condition COLLATE SQL_Latin1_General_CP1_CI_AS <> [remote].performance_condition
		OR [local].category_id <> [remote].category_id
		);

	---------------------------------------
	-- Objects in Master Database:  
	DECLARE @localMasterObjects TABLE (
		[object_name] sysname NOT NULL
	);

	DECLARE @ignoredMasterObjects TABLE (
		entry_id int IDENTITY(1,1) NOT NULL, 
		[name] sysname NOT NULL
	);

	INSERT INTO @ignoredMasterObjects([name])
	SELECT [result] [name] FROM dbo.split_string(@IgnoredMasterDbObjects, N',', 1);

	INSERT INTO @localMasterObjects ([object_name])
	SELECT [name] COLLATE SQL_Latin1_General_CP1_CI_AS FROM master.sys.objects WHERE [type] IN ('U','V','P','FN','IF','TF') AND is_ms_shipped = 0 AND [name] COLLATE SQL_Latin1_General_CP1_CI_AS NOT IN (SELECT [name] FROM @ignoredMasterObjects);
	
	DECLARE @remoteMasterObjects TABLE (
		[object_name] sysname NOT NULL
	);

	INSERT INTO @remoteMasterObjects ([object_name])
	EXEC master.sys.sp_executesql N'SELECT [name] FROM PARTNER.master.sys.objects WHERE [type] IN (''U'',''V'',''P'',''FN'',''IF'',''TF'') AND is_ms_shipped = 0;';
	DELETE FROM @remoteMasterObjects WHERE [object_name] IN (SELECT [name] FROM @ignoredMasterObjects);

	-- local only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'master objects' [grouping_key], 
		N'Object ' + QUOTENAME([local].[object_name]) + N' exists in the master database on ' + @localServerName + N' only.'  [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@localMasterObjects [local]
		LEFT OUTER JOIN @remoteMasterObjects [remote] ON [local].[object_name] = [remote].[object_name]
	WHERE
		[remote].[object_name] IS NULL;
	
	-- remote only:
    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'master objects' [grouping_key], 
		N'Object ' + QUOTENAME([remote].[object_name]) + N' exists in the master database on ' + @remoteServerName + N' only.'  [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		@remoteMasterObjects [remote]
		LEFT OUTER JOIN @localMasterObjects [local] ON [remote].[object_name] = [local].[object_name]
	WHERE
		[local].[object_name] IS NULL;

	CREATE TABLE #Definitions (
		row_id int IDENTITY(1,1) NOT NULL, 
		[location] sysname NOT NULL, 
		[object_name] sysname NOT NULL, 
		[type] char(2) NOT NULL,
		[hash] varbinary(MAX) NULL
	);

	INSERT INTO #Definitions ([location], [object_name], [type], [hash])
	SELECT 
		'local', 
		[name], 
		[type], 
		CASE 
			WHEN [type] IN ('V','P','FN','IF','TF') THEN 
				CASE
					-- HASHBYTES barfs on > 8000 chars. So, using this: http://www.sqlnotes.info/2012/01/16/generate-md5-value-from-big-data/
					WHEN DATALENGTH(sm.[definition]) > 8000 THEN (SELECT sys.fn_repl_hash_binary(CAST(sm.[definition] AS varbinary(MAX))))
					ELSE HASHBYTES('SHA1', sm.[definition])
				END
			ELSE NULL
		END [hash]
	FROM 
		master.sys.objects o
		LEFT OUTER JOIN master.sys.sql_modules sm ON o.[object_id] = sm.[object_id]
		INNER JOIN @localMasterObjects x ON o.[name] COLLATE SQL_Latin1_General_CP1_CI_AS = x.[object_name];

	DECLARE localtabler CURSOR LOCAL FAST_FORWARD FOR 
	SELECT [object_name] FROM #Definitions WHERE [type] = 'U' AND [location] = 'local';

	DECLARE @currentObjectName sysname;
	DECLARE @checksum bigint = 0;

	OPEN localtabler;
	FETCH NEXT FROM localtabler INTO @currentObjectName;

	WHILE @@FETCH_STATUS = 0 BEGIN 
		SET @checksum = 0;

		-- This whole 'nested' or 'derived' query approach is to get around a WEIRD bug/problem with CHECKSUM and 'running' aggregates. 
		SELECT @checksum = @checksum + [local].[hash] FROM ( 
			SELECT CHECKSUM(c.column_id, c.[name], c.system_type_id, c.max_length, c.[precision]) [hash]
			FROM master.sys.columns c INNER JOIN master.sys.objects o ON o.object_id = c.object_id WHERE o.[name] = @currentObjectName
		) [local];

		UPDATE #Definitions SET [hash] = @checksum WHERE [object_name] = @currentObjectName AND [location] = 'local';

		FETCH NEXT FROM localtabler INTO @currentObjectName;
	END 

	CLOSE localtabler;
	DEALLOCATE localtabler;

	INSERT INTO #Definitions ([location], [object_name], [type], [hash])
	EXEC master.sys.sp_executesql N'SELECT 
		''remote'', 
		o.[name], 
		[type], 
		CASE 
			WHEN [type] IN (''V'',''P'',''FN'',''IF'',''TF'') THEN 
				CASE
					WHEN DATALENGTH(sm.[definition]) > 8000 THEN (SELECT sys.fn_repl_hash_binary(CAST(sm.[definition] AS varbinary(MAX))))
					ELSE HASHBYTES(''SHA1'', sm.[definition])
				END
			ELSE NULL
		END [hash]
	FROM 
		PARTNER.master.sys.objects o
		LEFT OUTER JOIN PARTNER.master.sys.sql_modules sm ON o.object_id = sm.object_id
		INNER JOIN (SELECT [name] FROM PARTNER.master.sys.objects WHERE [type] IN (''U'',''V'',''P'',''FN'',''IF'',''TF'') AND is_ms_shipped = 0) x ON o.[name] = x.[name];';

	DECLARE remotetabler CURSOR LOCAL FAST_FORWARD FOR
	SELECT [object_name] FROM #Definitions WHERE [type] = 'U' AND [location] = 'remote';

	OPEN remotetabler;
	FETCH NEXT FROM remotetabler INTO @currentObjectName; 

	WHILE @@FETCH_STATUS = 0 BEGIN 
		SET @checksum = 0; -- otherwise, it'll get passed into sp_executesql with the PREVIOUS value.... 

		-- This whole 'nested' or 'derived' query approach is to get around a WEIRD bug/problem with CHECKSUM and 'running' aggregates. 
		EXEC master.sys.sp_executesql N'SELECT @checksum = ISNULL(@checksum,0) + [remote].[hash] FROM ( 
			SELECT CHECKSUM(c.column_id, c.[name], c.system_type_id, c.max_length, c.[precision]) [hash]
			FROM PARTNER.master.sys.columns c INNER JOIN PARTNER.master.sys.objects o ON o.object_id = c.object_id WHERE o.[name] = @currentObjectName
		) [remote];', N'@checksum bigint OUTPUT, @currentObjectName sysname', @checksum = @checksum OUTPUT, @currentObjectName = @currentObjectName;

		UPDATE #Definitions SET [hash] = @checksum WHERE [object_name] = @currentObjectName AND [location] = 'remote';

		FETCH NEXT FROM remotetabler INTO @currentObjectName; 
	END 

	CLOSE remotetabler;
	DEALLOCATE remotetabler;

    INSERT INTO [#bus] (
        [grouping_key],
        [heading]
    )    
    SELECT 
        N'master objects' [grouping_key], 
		N'The Definition for object ' + QUOTENAME([local].[object_name]) + N' (in the master database) is different between servers.' [heading]
        -- TODO: instructions on how to fix and/or CONTROL directives TO fix... 
	FROM 
		(SELECT [object_name], [hash] FROM #Definitions WHERE [location] = 'local') [local]
		INNER JOIN (SELECT [object_name], [hash] FROM #Definitions WHERE [location] = 'remote') [remote] ON [local].object_name = [remote].object_name
	WHERE 
		[local].[hash] <> [remote].[hash];
	
	------------------------------------------------------------------------------
	-- Report on any discrepancies: 
REPORTING:
	IF(SELECT COUNT(*) FROM #bus) > 0 BEGIN 

		DECLARE @subject nvarchar(300) = N'SQL Server Synchronization Check Problems';
		DECLARE @crlf nchar(2) = CHAR(13) + CHAR(10);
		DECLARE @tab nchar(1) = CHAR(9);
		DECLARE @message nvarchar(MAX) = N'The following synchronization issues were detected: ' + @crlf + @crlf;

        SELECT 
            @message = @message + @tab +  UPPER([channel]) + N': ' + [heading] + CASE WHEN [body] IS NOT NULL THEN @crlf + @tab + @tab + ISNULL([body], N'') ELSE N'' END + @crlf + @crlf
        FROM 
            #bus
        ORDER BY 
            [row_id];


		IF @PrintOnly = 1 BEGIN 
			-- just Print out details:
			PRINT 'SUBJECT: ' + @subject;
			PRINT 'BODY: ' + @crlf + @message;

		  END
		ELSE BEGIN
			-- send a message:
			EXEC msdb..sp_notify_operator 
				@profile_name = @MailProfileName, 
				@name = @OperatorName, 
				@subject = @subject,
				@body = @message;
		END;

	END 

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_data_synchronization','P') IS NOT NULL
	DROP PROC dbo.verify_data_synchronization;
GO

CREATE PROC dbo.verify_data_synchronization 
	@IgnoredDatabases						nvarchar(MAX)		= NULL,
	@RPOThreshold							sysname				= N'10 seconds',
	@RTOThreshold							sysname				= N'40 seconds',
	
	@AGSyncCheckIterationCount				int					= 8, 
	@AGSyncCheckDelayBetweenChecks			sysname				= N'1800 milliseconds',
	@ExcludeAnomolousSyncDeviations			bit					= 0,    -- Primarily for Ghosted Records Cleanup... 
	
	@EmailSubjectPrefix						nvarchar(50)		= N'[Data Synchronization Problems] ',
	@MailProfileName						sysname				= N'General',	
	@OperatorName							sysname				= N'Alerts',	
	@PrintOnly								bit					= 0
AS
	SET NOCOUNT ON;

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	----------------------------------------------
	-- Determine which server to run checks on. 
	IF (SELECT dbo.[is_primary_server]()) = 0 BEGIN
		PRINT 'Server is Not Primary.';
		RETURN 0;
	END;

	---------------------------------------------
	-- Dependencies Validation:
	DECLARE @return int, @returnMessage nvarchar(MAX);
    IF @PrintOnly = 0 BEGIN 

	    EXEC @return = dbo.verify_advanced_capabilities;
        IF @return <> 0
            RETURN @return;

        EXEC @return = dbo.verify_alerting_configuration
            @OperatorName, 
            @MailProfileName;

        IF @return <> 0 
            RETURN @return;
    END;

	IF NOT EXISTS (SELECT NULL FROM sys.servers WHERE [name] = 'PARTNER') BEGIN 
		RAISERROR('Linked Server ''PARTNER'' not detected. Comparisons between this server and its peer can not be processed.', 16, 1);
		RETURN -5;
	END;

	EXEC @return = dbo.verify_partner 
		@Error = @returnMessage OUTPUT; 

	IF @return <> 0 BEGIN 
		-- S4-229: this (current) response is a hack - i.e., sending email/message DIRECTLY from this code-block violates DRY
		--			and is only in place until dbo.verify_job_synchronization is rewritten to use a process bus.
		IF @PrintOnly = 1 BEGIN 
			PRINT 'PARTNER is disconnected/non-accessible. Terminating early. Connection Details/Error:';
			PRINT '     ' + @returnMessage;
		  END;
		ELSE BEGIN 
			DECLARE @hackSubject nvarchar(200), @hackMessage nvarchar(MAX);
			SELECT 
				@hackSubject = N'PARTNER server is down/non-accessible.', 
				@hackMessage = N'Job Synchronization Checks can not continue as PARTNER server is down/non-accessible. Connection Error Details: ' + NCHAR(13) + NCHAR(10) + @returnMessage; 

			EXEC msdb..sp_notify_operator 
				@profile_name = @MailProfileName, 
				@name = @OperatorName, 
				@subject = @hackSubject,
				@body = @hackMessage;
		END;

		RETURN 0;
	END;
        
    ----------------------------------------------
	-- Determine the last time this job ran: 
    DECLARE @lastCheckupExecutionTime datetime;
    EXEC [dbo].[get_last_job_completion_by_session_id] 
        @SessionID = @@SPID, 
        @ExcludeFailures = 1, 
        @LastTime = @lastCheckupExecutionTime OUTPUT; 

    SET @lastCheckupExecutionTime = ISNULL(@lastCheckupExecutionTime, DATEADD(HOUR, -2, GETDATE()));

    IF DATEDIFF(DAY, @lastCheckupExecutionTime, GETDATE()) > 2
        SET @lastCheckupExecutionTime = DATEADD(HOUR, -2, GETDATE())

    DECLARE @syncCheckSpanMinutes int = DATEDIFF(MINUTE, @lastCheckupExecutionTime, GETDATE());

    IF @syncCheckSpanMinutes <= 1 
        RETURN 0; -- no sense checking on history if it's just been a minute... 
    
	-- convert vectors to seconds: 
	DECLARE @rpoSeconds decimal(20, 2);
	DECLARE @rtoSeconds decimal(20, 2);

	DECLARE @vectorOutput bigint, @vectorError nvarchar(max); 
    EXEC dbo.translate_vector 
        @Vector = @RPOThreshold, 
        @Output = @vectorOutput OUTPUT, -- milliseconds
		@ProhibitedIntervals = N'DAY, WEEK, MONTH, QUARTER, YEAR',
        @Error = @vectorError OUTPUT; 

	IF @vectorError IS NOT NULL BEGIN 
		RAISERROR(@vectorError, 16, 1);
		RETURN -1;
	END;

	SET @rpoSeconds = @vectorOutput / 1000.0;
	
    EXEC dbo.translate_vector 
        @Vector = @RTOThreshold, 
        @Output = @vectorOutput OUTPUT, -- milliseconds
		@ProhibitedIntervals = N'DAY, WEEK, MONTH, QUARTER, YEAR',
        @Error = @vectorError OUTPUT; 

	IF @vectorError IS NOT NULL BEGIN 
		RAISERROR(@vectorError, 16, 1);
		RETURN -1;
	END;

	SET @rtoSeconds = @vectorOutput / 1000.0;

	IF @rtoSeconds > 2764800.0 OR @rpoSeconds > 2764800.0 BEGIN 
		RAISERROR(N'@RPOThreshold and @RTOThreshold values can not be set to > 1 month.', 16, 1);
		RETURN -10;
	END;

	IF @rtoSeconds < 2.0 OR @rpoSeconds < 2.0 BEGIN 
		RAISERROR(N'@RPOThreshold and @RTOThreshold values can not be set to less than 2 seconds.', 16, 1);
		RETURN -10;
	END;

	-- translate @AGSyncCheckDelayBetweenChecks into waitfor value. 
	DECLARE @waitFor sysname;
	SET @vectorError = NULL;

	EXEC dbo.[translate_vector_delay] 
		@Vector = @AGSyncCheckDelayBetweenChecks, 
		@ParameterName = N'@AGSyncCheckDelayBetweenChecks', 
		@Output = @waitFor OUTPUT, 
		@Error = @vectorError OUTPUT;

	IF @vectorError IS NOT NULL BEGIN 
		RAISERROR(@vectorError, 16, 1);
		RETURN -20;
	END;

    ----------------------------------------------
    -- Begin Processing: 
	DECLARE @localServerName sysname = @@SERVERNAME;
	DECLARE @remoteServerName sysname; 
	EXEC master.sys.sp_executesql N'SELECT @remoteName = (SELECT TOP 1 [name] FROM PARTNER.master.sys.servers WHERE server_id = 0);', 
		N'@remoteName sysname OUTPUT', 
		@remoteName = @remoteServerName OUTPUT;

	-- start by loading a 'list' of all dbs that might be Mirrored or AG'd:
	DECLARE @synchronizingDatabases table ( 
		[server_name] sysname, 
		[sync_type] sysname,
		[database_name] sysname, 
		[role] sysname
	);

	-- grab a list of SYNCHRONIZING (primary) databases (excluding any we're instructed to NOT watch/care about):
	INSERT INTO @synchronizingDatabases (
	    [server_name],
	    [sync_type],
	    [database_name], 
		[role]
	)
	SELECT 
	    [server_name],
	    [sync_type],
	    [database_name], 
		[role]
	FROM 
		dbo.list_synchronizing_databases(@IgnoredDatabases, 1);

	----------------------------------------------
	DECLARE @errors TABLE (
		error_id int IDENTITY(1,1) NOT NULL,
		errorMessage nvarchar(MAX) NOT NULL
	);

	-- http://msdn.microsoft.com/en-us/library/ms366320(SQL.105).aspx
	DECLARE @output TABLE ( 
		[database_name] sysname,
		[role] int, 
		mirroring_state int, 
		witness_status int, 
		log_generation_rate int, 
		unsent_log int, 
		send_rate int, 
		unrestored_log int, 
		recovery_rate int,
		transaction_delay int,
		transactions_per_sec int, 
		average_delay int, 
		time_recorded datetime,
		time_behind datetime,
		local_time datetime
	);

	DECLARE @crlf nchar(2) = CHAR(13) + CHAR(10);
	DECLARE @tab nchar(1) = CHAR(9);
	DECLARE @errorMessage nvarchar(MAX);
	DECLARE @transdelayMilliseconds int;
	DECLARE @averagedelay int;

	----------------------------------------------
	-- Process Mirrored Databases: 
	DECLARE m_checker CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name]
	FROM 
		@synchronizingDatabases
	WHERE 
		[sync_type] = N'MIRRORED'
	ORDER BY 
		[database_name];

	DECLARE @currentMirroredDB sysname;

	OPEN m_checker;
	FETCH NEXT FROM m_checker INTO @currentMirroredDB;

	WHILE @@FETCH_STATUS = 0 BEGIN 
		
		DELETE FROM @output;
		SET @errorMessage = N'';

		-- Force an explicit update of the mirroring stats - so that we get the MOST recent details:
		EXEC msdb.sys.sp_dbmmonitorupdate @database_name = @currentMirroredDB;

		INSERT INTO @output
		EXEC msdb.sys.sp_dbmmonitorresults 
			@database_name = @currentMirroredDB,
			@mode = 0, -- just give us the last row - to check current status
			@update_table = 0;  -- This SHOULD be set to 1 - but can/will cause issues with 'nested' INSERT EXEC calls (i.e., a bit of a 'bug'). So... the previous call updates... and we just read the recently updated results. 
		
		IF (SELECT COUNT(*) FROM @output) < 1 BEGIN 
			SET @errorMessage = N'Mirroring Failure - Monitoring not working correctly.'
				+ @crlf + @tab + @tab + N'Database Mirroring Monitoring Failure for database ' + @currentMirroredDB + N' on Server ' + @localServerName + N'.';
				
			INSERT INTO @errors (errorMessage)
			VALUES (@errorMessage);
		END; 

		IF (SELECT TOP(1) mirroring_state FROM @output) <> 4 BEGIN 
			SET @errorMessage = N'Mirroring Failure - Mirroring Disabled'
				+ @crlf + @tab + @tab + N'Synchronization Failure for database ' + @currentMirroredDB + N' on Server ' + @localServerName + N'.';

			INSERT INTO @errors (errorMessage)
			VALUES (@errorMessage);
		END

		-- check on the witness if needed:
		IF EXISTS (SELECT mirroring_witness_state_desc FROM sys.database_mirroring WHERE database_id = DB_ID(@currentMirroredDB) AND NULLIF(mirroring_witness_state_desc, N'UNKNOWN') IS NOT NULL) BEGIN 
			IF (SELECT TOP(1) witness_status FROM @output) <> 1 BEGIN
				SET @errorMessage = N'Mirroring Failure - Witness Down'
					+ @crlf + @tab + @tab + N'Witness Failure. Witness is currently not enabled or monitoring for database ' + @currentMirroredDB + N' on Server ' + @localServerName + N'.';

				INSERT INTO @errors (errorMessage)
				VALUES (@errorMessage);
			END;
		END;

		DELETE FROM @output; 
		INSERT INTO @output
		EXEC msdb.sys.sp_dbmmonitorresults 
			@database_name = @currentMirroredDB,
			@mode = 1,  -- give us rows from the last 2 hours:
			@update_table = 0;

		-- make sure that metrics are even working - if we get any NULLs in transaction_delay/average_delay, 
		--		then it's NOT working correctly (i.e. it's somehow not seeing everything it needs to in order
		--		to report - and we need to throw an error):
		SELECT @transdelayMilliseconds = MIN(ISNULL(transaction_delay,-1)) FROM	@output 
		WHERE local_time >= @lastCheckupExecutionTime;

		IF @transdelayMilliseconds < 0 BEGIN 
			SET @errorMessage = N'Mirroring Failure - Synchronization Metrics Unavailable'
				+ @crlf + @tab + @tab + N'Metrics for transaction_delay and average_delay unavailable for monitoring (i.e., SQL Server Mirroring Monitor is ''busted'') for database: ' + @currentMirroredDB + N' on Server: ' + @localServerName + N'.';

			INSERT INTO @errors (errorMessage)
			VALUES (@errorMessage);
		END;

		-- check for problems with transaction delay:
		SELECT @transdelayMilliseconds = MAX(ISNULL(transaction_delay,0)) FROM @output
		WHERE local_time >= @lastCheckupExecutionTime;
		IF @transdelayMilliseconds > (@rpoSeconds * 1000.0) BEGIN 
			SET @errorMessage = N'Mirroring Alert - Delays Applying Data to Secondary'
				+ @crlf + @tab + @tab + N'Max Trans Delay of ' + CAST(@transdelayMilliseconds AS nvarchar(30)) + N'ms in last ' + CAST(@syncCheckSpanMinutes as sysname) + N' minutes is greater than allowed threshold of ' + CAST((@rpoSeconds * 1000.0) as sysname) + N'ms for database: ' + @currentMirroredDB + N' on Server: ' + @localServerName + N'.';

			INSERT INTO @errors (errorMessage)
			VALUES (@errorMessage);
		END 

		-- check for problems with transaction delays on the primary:
		SELECT @averagedelay = MAX(ISNULL(average_delay,0)) FROM @output
		WHERE local_time >= @lastCheckupExecutionTime;
		IF @averagedelay > (@rtoSeconds * 1000.0) BEGIN 

			SET @errorMessage = N'Mirroring Alert - Transactions Delayed on Primary'
				+ @crlf + @tab + @tab + N'Max(Avg) Trans Delay of ' + CAST(@averagedelay AS nvarchar(30)) + N'ms in last ' + CAST(@syncCheckSpanMinutes as sysname) + N' minutes is greater than allowed threshold of ' + CAST((@rtoSeconds * 1000.0) as sysname) + N'ms for database: ' + @currentMirroredDB + N' on Server: ' + @localServerName + N'.';

			INSERT INTO @errors (errorMessage)
			VALUES (@errorMessage);
		END 		

		FETCH NEXT FROM m_checker INTO @currentMirroredDB;
	END;

	CLOSE m_checker; 
	DEALLOCATE m_checker;
	
	----------------------------------------------
	-- Process AG'd Databases: 
	IF (SELECT dbo.[get_engine_version]()) <= 10.5
		GOTO REPORTING;

	DECLARE @downNodes nvarchar(MAX);
	DECLARE @currentAGName sysname;
	DECLARE @currentAGId uniqueidentifier;
	DECLARE @syncHealth tinyint;

	DECLARE @processedAgs table ( 
		agname sysname NOT NULL
	);

	DECLARE ag_checker CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[database_name]
	FROM 
		@synchronizingDatabases
	WHERE 
		[sync_type] = N'AG'
	ORDER BY 
		[database_name];

	DECLARE @currentAGdDatabase sysname; 

	OPEN ag_checker;
	FETCH NEXT FROM ag_checker INTO @currentAGdDatabase;

	WHILE @@FETCH_STATUS = 0 BEGIN 
	
		SET @currentAGName = N'';
		SET @currentAGId = NULL;
		EXEC sys.sp_executesql N'SELECT @currentAGName = ag.[name], @currentAGId = ag.group_id FROM sys.availability_groups ag INNER JOIN sys.availability_replicas ar ON ag.group_id = ar.group_id INNER JOIN sys.databases d ON ar.replica_id = d.replica_id WHERE d.[name] = @currentAGdDatabase;', 
			N'@currentAGdDatabase sysname, @currentAGName sysname OUTPUT, @currentAGId uniqueidentifier OUTPUT', 
			@currentAGdDatabase = @currentAGdDatabase, 
			@currentAGName = @currentAGName OUTPUT, 
			@currentAGId = @currentAGId OUTPUT;

		IF NOT EXISTS (SELECT NULL FROM @processedAgs WHERE agname = @currentAGName) BEGIN
		
			-- Make sure there's an active primary:
-- TODO: in this new, streamlined, code... this check (at this point) is pointless. 
--		need to check this well before we get to the CURSOR for processing AGs, AG'd dbs... 
--			also, there might be a quicker/better way to get a 'list' of all dbs in a 'bad' (non-primary'd) state right out of the gate. 
--			AND, either way I slice it, i'll have to tackle this via sp_executesql - to account for lower-level servers. 
			--SELECT @primaryReplica = agstates.primary_replica
			--FROM sys.availability_groups ag 
			--LEFT OUTER JOIN sys.dm_hadr_availability_group_states agstates ON ag.group_id = agstates.group_id
			--WHERE 
			--	ag.[name] = @currentAGdDatabase;
			
			--IF ISNULL(@primaryReplica,'') = '' BEGIN 
			--	SET @errorMessage = N'MAJOR PROBLEM: No Replica is currently defined as the PRIMARY for Availability Group [' + @currentAG + N'].';

			--	INSERT INTO @errors (errorMessage)
			--	VALUES(@errorMessage);
			--END 

			-- Check on Status of all members:
			SET @downNodes = N'';
			EXEC master.sys.sp_executesql N'SELECT @downNodes = @downNodes +  member_name + N'','' FROM sys.dm_hadr_cluster_members WHERE member_state <> 1;', N'@downNodes nvarchar(MAX) OUTPUT', @downNodes = @downNodes OUTPUT; 
			IF LEN(@downNodes) > LEN(N'') BEGIN 
				SET @downNodes = LEFT(@downNodes, LEN(@downNodes) - 1); 
			
				SET @errorMessage = N'WARNING: The following WSFC Cluster Member Nodes are currently being reported as offline: ' + @downNodes + N'.';	

				INSERT INTO @errors (errorMessage)
				VALUES(@errorMessage);
			END

			-- Check on AG Health Status: 
			SET @syncHealth = 0;
			EXEC master.sys.sp_executesql N'SELECT @syncHealth = synchronization_health FROM sys.dm_hadr_availability_replica_states WHERE group_id = @currentAGId;', N'@currentAGId uniqueidentifier, @syncHealth tinyint OUTPUT', @currentAGId = @currentAGId, @syncHealth = @syncHealth OUTPUT;
			IF @syncHealth <> 2 BEGIN
				SELECT @errorMessage = N'WARNING: Current Health Status of Availability Group [' + @currentAGName + N'] Is Showing NON-HEALTHY.'
			
				INSERT INTO @errors (errorMessage)
				VALUES(@errorMessage);
			END; 

			-- Check on Synchronization Status of each db:
			SET @syncHealth = 0;
			EXEC master.sys.sp_executesql N'SELECT @syncHealth = synchronization_health FROM sys.dm_hadr_availability_replica_states WHERE group_id = @currentAGId;', N'@currentAGId uniqueidentifier, @syncHealth tinyint OUTPUT', @currentAGId = @currentAGId, @syncHealth = @syncHealth OUTPUT;
			IF @syncHealth <> 2 BEGIN
				SELECT @errorMessage = N'WARNING: The Synchronization Status for one or more Members of the Availability Group [' + @currentAGName + N'] Is Showing NON-HEALTHY.'
			
				INSERT INTO @errors (errorMessage)
				VALUES(@errorMessage);
			END;

			-- mark the current AG as processed (so that we don't bother processing multiple dbs (and getting multiple errors/messages) if/when they're all in the same AG(s)). 
			INSERT INTO @processedAgs ([agname])
			VALUES(@currentAGName);
		END;
		-- otherwise, we've already run checks on the availability group itself. 

		FETCH NEXT FROM ag_checker INTO @currentAGdDatabase;
	END;

	CLOSE ag_checker;
	DEALLOCATE ag_checker;

	IF EXISTS (SELECT NULL FROM @synchronizingDatabases WHERE [sync_type] = N'AG') BEGIN

		CREATE TABLE [#metrics] (
			[row_id] int IDENTITY(1, 1) NOT NULL,
			[database_name] sysname NOT NULL,
			[iteration] int NOT NULL,
			[timestamp] datetime NOT NULL,
			[synchronization_delay (RPO)] decimal(20, 2) NOT NULL,
			[recovery_time (RTO)] decimal(20, 2) NOT NULL,
			-- raw data: 
			[is_failover_ready] bit NULL,
			[redo_queue_size] decimal(20, 2) NULL,
			[redo_rate] decimal(20, 2) NULL,
			[primary_last_commit] datetime NULL,
			[secondary_last_commit] datetime NULL, 
			[ignore_rpo_as_anomalous] bit NOT NULL CONSTRAINT DF_metrics_anomalous DEFAULT (0)
		);

		DECLARE @agSyncCheckSQL nvarchar(MAX) = N'
			WITH [metrics] AS (
				SELECT
					[adc].[database_name],
					[drs].[last_commit_time],
					CAST([drs].[redo_queue_size] AS decimal(20,2)) [redo_queue_size],   -- KB of log data not yet ''checkpointed'' on the secondary... 
					CAST([drs].[redo_rate] AS decimal(20,2)) [redo_rate],		-- avg rate (in KB) at which redo (i.e., inverted checkpoints) are being applied on the secondary... 
					[drs].[is_primary_replica] [is_primary],
					[cs].[is_failover_ready]
				FROM
					[sys].[dm_hadr_database_replica_states] AS [drs]
					INNER JOIN [sys].[availability_databases_cluster] AS [adc] ON [drs].[group_id] = [adc].[group_id] AND [drs].[group_database_id] = [adc].[group_database_id]
					INNER JOIN [sys].[dm_hadr_database_replica_cluster_states] [cs] ON [drs].[replica_id] = [cs].[replica_id]
			), 
			[primary] AS ( 
				SELECT
					[database_name],
					[last_commit_time] [primary_last_commit], 
					[is_failover_ready]
				FROM
					[metrics]
				WHERE
					[is_primary] = 1

			), 
			[secondary] AS ( 
				SELECT
					[database_name],
					[last_commit_time] [secondary_last_commit], 
					[redo_rate], 
					[redo_queue_size]
				FROM
					[metrics]
				WHERE
					[is_primary] = 0
			) 

			SELECT 
				p.[database_name], 
				@iterations [iteration], 
				GETDATE() [timestamp],
				CASE
					WHEN p.[is_failover_ready] = 1 THEN 0 
					ELSE ISNULL(DATEDIFF(MILLISECOND, s.[secondary_last_commit], p.[primary_last_commit]), -2000)
				END [synchronization_delay (RPO)],
				CASE 
					WHEN ISNULL(s.[redo_queue_size], 0) = 0 THEN 0
					--WHEN ISNULL(s.[redo_rate], 0) = 0 THEN 0 
					ELSE CAST((s.[redo_queue_size] / s.[redo_rate]) as decimal(20,2))
				END [recovery_time (RTO)],
				p.[is_failover_ready],
				s.[redo_queue_size], 
				s.[redo_rate], 
				p.[primary_last_commit], 
				s.[secondary_last_commit]
			FROM 
				[primary] p 
				INNER JOIN [secondary] s ON p.[database_name] = s.[database_name]; ';

		DECLARE @iterations int = 1; 
		WHILE @iterations < @AGSyncCheckIterationCount BEGIN

			INSERT INTO [#metrics] (
				[database_name],
				[iteration],
				[timestamp],
				[synchronization_delay (RPO)],
				[recovery_time (RTO)],
				[is_failover_ready],
				[redo_queue_size],
				[redo_rate],
				[primary_last_commit],
				[secondary_last_commit]
			)
			EXEC sp_executesql 
				@agSyncCheckSQL, 
				N'@iterations int', 
				@iterations = @iterations;				

			WAITFOR DELAY @waitFor;

			SET @iterations += 1;
		END;

		IF @ExcludeAnomolousSyncDeviations = 1 BEGIN 

			WITH derived AS ( 

				SELECT 
					[database_name],
					CAST(MAX([synchronization_delay (RPO)]) AS decimal(20, 2)) [max],
					CAST(AVG([synchronization_delay (RPO)]) AS decimal(20, 2)) [mean], 
					CAST(STDEV([synchronization_delay (RPO)]) AS decimal(20, 2)) [deviation]
				FROM 
					[#metrics] 
				GROUP BY 
					[database_name]

			), 
			db_iterations AS ( 
	
				SELECT 
					(
						SELECT TOP 1 x.row_id 
						FROM [#metrics] x 
						WHERE x.[synchronization_delay (RPO)] = d.[max] AND [x].[database_name] = d.[database_name] 
						ORDER BY x.[synchronization_delay (RPO)] DESC
					) [row_id]
				FROM 
					[derived] d
				WHERE 
					d.mean - d.[deviation] < 0 -- biz-rule - only if/when deviation 'knocks everything' negative... 
					AND d.[max] > ([d].[mean] + d.[deviation] + ABS([d].[mean] - d.[deviation]))
			)

			UPDATE m 
			SET 
				m.[ignore_rpo_as_anomalous] = 1 
			FROM 
				[#metrics] m 
				INNER JOIN [db_iterations] x ON m.[row_id] = x.[row_id];
		END;

		WITH violations AS ( 
			SELECT 
				[database_name],
				CAST(AVG([synchronization_delay (RPO)]) AS decimal(20, 2)) [rpo (seconds)],
				CAST(AVG([recovery_time (RTO)]) AS decimal(20,2 )) [rto (seconds)], 
				CAST((
					SELECT 
						[x].[iteration] [@iteration], 
						[x].[timestamp] [@timestamp],
						[x].[ignore_rpo_as_anomalous],
						[x].[synchronization_delay (RPO)] [rpo], 
						[x].[recovery_time (RTO)] [rto],
						[x].[redo_queue_size], 
						[x].[redo_rate], 
						[x].[primary_last_commit], 
						[x].[secondary_last_commit]
					FROM 
						[#metrics] x 
					WHERE 
						x.[database_name] = m.[database_name]
					ORDER BY 
						[x].[row_id] 
					FOR XML PATH('detail'), ROOT('details')
				) AS xml) [raw_data]
			FROM 
				[#metrics] m
			WHERE 
				m.[ignore_rpo_as_anomalous] = 0  -- note: these don't count towards rpo values - but they ARE included in serialized xml output (for review/analysis purposes). 
			GROUP BY
				[database_name]
		) 

		INSERT INTO @errors (
			[errorMessage]
		)
		SELECT 
			N'AG Alert - SLA Warning(s) for ' + QUOTENAME([database_name]) + @crlf + @tab + @tab + N'RPO and RTO values are currently set at [' + @RPOThreshold + N'] and [' + @RTOThreshold + N'] - but are currently polling at an AVERAGE of [' + CAST([rpo (seconds)] AS sysname) + N' seconds] AND [' + CAST([rto (seconds)] AS sysname) + N' seconds] for database ' + QUOTENAME([database_name])  + N'. Raw XML Data: ' + CAST([raw_data] AS nvarchar(MAX))
		FROM 
			[violations]
		WHERE 
			[violations].[rpo (seconds)] > @rpoSeconds OR [violations].[rto (seconds)] > @rtoSeconds
		ORDER BY 
			[database_name];

	END;

REPORTING:
	-- 
	IF EXISTS (SELECT NULL FROM	@errors) BEGIN 
		DECLARE @subject nvarchar(MAX) = @EmailSubjectPrefix + N' - Synchronization Problems Detected';

		SET @errorMessage = N'The following errors were detected: ' + @crlf;

		SELECT @errorMessage = @errorMessage + @tab + N'- ' + errorMessage + @crlf
		FROM @errors
		ORDER BY error_id;

		IF @PrintOnly = 1 BEGIN
			PRINT N'SUBJECT: ' + @subject;
			PRINT N'BODY: ' + @errorMessage;
		  END
		ELSE BEGIN 
			EXEC msdb..sp_notify_operator 
				@profile_name = @MailProfileName, 
				@name = @OperatorName, 
				@subject = @subject, 
				@body = @errorMessage;	
		END;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.add_synchronization_partner','P') IS NOT NULL
	DROP PROC dbo.[add_synchronization_partner];
GO

CREATE PROC dbo.[add_synchronization_partner]
    @PartnerName                            sysname		= NULL,			-- hard-coded name of partner - e.g., SQL2 (if we're running on SQL1).
	@PartnerNames							sysname		= NULL,			-- specify 2x server names, e.g., SQL1 and SQL2 - and the sproc will figure out self and partner accordingly. 
    @ExecuteSetupOnPartnerServer            bit         = 1     -- by default, attempt to create a 'PARTNER' on the PARTNER, that... points back here... 
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    -- TODO: verify @PartnerName input/parameters. 
	SET @PartnerName = NULLIF(@PartnerName, N'');
	SET @PartnerNames = NULLIF(@PartnerNames, N'');

	IF @PartnerName IS NULL AND @PartnerNames IS NULL BEGIN 
		RAISERROR('Please Specify a value for either @PartnerName (e.g., ''SQL2'' if executing on SQL1) or for @PartnerNames (e.g., ''SQL1,SQL2'' if running on either SQL1 or SQL2).', 16, 1);
		RETURN - 2;
	END;

	IF @PartnerName IS NULL BEGIN 
		DECLARE @serverNames table ( 
			server_name sysname NOT NULL
		);

		INSERT INTO @serverNames (
			server_name
		)
		SELECT CAST([result] AS sysname) FROM dbo.[split_string](@PartnerNames, N',', 1);

		DELETE FROM @serverNames WHERE [server_name] = @@SERVERNAME;

		IF(SELECT COUNT(*) FROM @serverNames) <> 1 BEGIN
			RAISERROR('Invalid specification for @PartnerNames specified - please specify 2 server names, where one is the name of the currently executing server.', 16, 1);
			RETURN -10;
		END;

		SET @PartnerName = (SELECT TOP 1 server_name FROM @serverNames);
	END;

    -- TODO: account for named instances... 
    DECLARE @remoteHostName sysname = N'tcp:' + @PartnerName;
    DECLARE @errorMessage nvarchar(MAX);
    DECLARE @serverName sysname = @@SERVERNAME;

    IF EXISTS (SELECT NULL FROM sys.servers WHERE UPPER([name]) = N'PARTNER') BEGIN 
        RAISERROR('A definition for PARTNER already exists as a Linked Server.', 16, 1);
        RETURN -1;
    END;

    BEGIN TRY
        EXEC master.dbo.sp_addlinkedserver 
	        @server = N'PARTNER', 
	        @srvproduct = N'', 
-- TODO: IF SQL Server 2016 or lower, use 'SQLNCLI' instead of MSOLEDBSQL
	        @provider = N'MSOLEDBSQL', 
	        @datasrc = @remoteHostName, 
	        @catalog = N'master';

        EXEC master.dbo.sp_addlinkedsrvlogin 
	        @rmtsrvname = N'PARTNER',
	        @useself = N'True',
	        @locallogin = NULL,
	        @rmtuser = NULL,
	        @rmtpassword = NULL;

        EXEC master.dbo.sp_serveroption 
	        @server = N'PARTNER', 
	        @optname = N'rpc', 
	        @optvalue = N'true';

        EXEC master.dbo.sp_serveroption 
	        @server = N'PARTNER', 
	        @optname = N'rpc out', 
	        @optvalue = N'true';

        
        PRINT 'Definition for PARTNER server (pointing to ' + @PartnerName + N') successfully registered on ' + @serverName + N'.';

    END TRY 
    BEGIN CATCH 
        SELECT @errorMessage = N'Unexepected error while attempting to create definition for PARTNER on local/current server. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
        RAISERROR(@errorMessage, 16, 1);
        RETURN -20;
    END CATCH;

	-- As part of setting up for failover, make sure the AG XE is enabled as well: 
	IF (SELECT [admindb].dbo.[get_engine_version]()) >= 11.0 BEGIN 
		
		DECLARE @startupState bit; 
		SELECT @startupState = startup_state FROM sys.[server_event_sessions] WHERE [name] = N'AlwaysOn_health';

		IF @startupState IS NOT NULL AND @startupState <> 1 BEGIN 
			DECLARE @sql nvarchar(MAX) = N'ALTER EVENT SESSION [AlwaysOn_health] ON SERVER WITH (STARTUP_STATE = ON); ';
			EXEC sys.sp_executesql @sql;
		END

		IF NOT EXISTS (SELECT NULL FROM sys.[dm_xe_sessions] WHERE [name] = N'AlwaysOn_health') BEGIN
			SET @sql = N'ALTER EVENT SESSION [AlwaysOn_health] ON SERVER STATE = START; ';

			EXEC sys.sp_executesql @sql;
		END;
	END;

    IF @ExecuteSetupOnPartnerServer = 1 BEGIN
        DECLARE @localHostName sysname = @@SERVERNAME;

        DECLARE @command nvarchar(MAX) = N'EXEC [PARTNER].admindb.dbo.add_synchronization_partner @localHostName, 0;';

        BEGIN TRY 
            EXEC sp_executesql 
                @command, 
                N'@localHostName sysname', 
                @localHostName = @localHostName;

        END TRY 

        BEGIN CATCH
            SELECT @errorMessage = N'Unexepected error while attempting to DYNAMICALLY create definition for PARTNER on remote/partner server. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
            RAISERROR(@errorMessage, 16, 1);
            RETURN -40;

        END CATCH;
    END;

    RETURN 0;
GO    


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.add_failover_processing','P') IS NOT NULL
	DROP PROC dbo.[add_failover_processing];
GO

CREATE PROC dbo.[add_failover_processing]
    @SqlServerAgentFailoverResponseJobName              sysname         = N'Synchronization - Failover Response',
    @SqlServerAgentJobNameCategory                      sysname         = N'Synchronization',
	@MailProfileName			                        sysname         = N'General',
	@OperatorName				                        sysname         = N'Alerts', 
    @ExecuteSetupOnPartnerServer                        bit = 1
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    DECLARE @errorMessage nvarchar(MAX);

    -- enable logging on 1480 - if needed. 
    IF EXISTS (SELECT NULL FROM sys.messages WHERE [message_id] = 1480 AND [is_event_logged] = 0) BEGIN
        BEGIN TRY 
            EXEC master..sp_altermessage
	            @message_id = 1480, 
                @parameter = 'WITH_LOG', 
                @parameter_value = TRUE;
        END TRY 
        BEGIN CATCH 
            SELECT @errorMessage = N'Unexpected problem enabling message_id 1480 for WITH_LOG on server [' + @@SERVERNAME + N'. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
            RAISERROR(@errorMessage, 16, 1);
            RETURN -10;
        END CATCH;
    END;

    -- job creation: 
    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.syscategories WHERE [name] = @SqlServerAgentJobNameCategory AND category_class = 1) BEGIN
        
        BEGIN TRY
            EXEC msdb.dbo.sp_add_category 
                @class = N'JOB', 
                @type = N'LOCAL', 
                @name = @SqlServerAgentJobNameCategory;
        END TRY 
        BEGIN CATCH 
            SELECT @errorMessage = N'Unexpected problem creating job category [' + @SqlServerAgentJobNameCategory + N'] on server [' + @@SERVERNAME + N']. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
            RAISERROR(@errorMessage, 16, 1);
            RETURN -20;
        END CATCH;
    END;

    DECLARE @jobID uniqueidentifier;
    DECLARE @failoverHandlerCommand nvarchar(MAX) = N'EXEC [admindb].dbo.process_synchronization_failover{CONFIGURATION};
GO'

    IF UPPER(@OperatorName) = N'ALERTS' AND UPPER(@MailProfileName) = N'GENERAL' 
        SET @failoverHandlerCommand = REPLACE(@failoverHandlerCommand, N'{CONFIGURATION}', N'');
    ELSE 
        SET @failoverHandlerCommand = REPLACE(@failoverHandlerCommand, N'{CONFIGURATION}', NCHAR(13) + NCHAR(10) + NCHAR(9) + N'@MailProfileName = ''' + @MailProfileName + N''', @OperatorName = ''' + @OperatorName + N''' ');

    BEGIN TRANSACTION;

    BEGIN TRY

        EXEC msdb.dbo.[sp_add_job]
            @job_name = @SqlServerAgentFailoverResponseJobName,
            @enabled = 1,
            @description = N'Automatically executed in response to a synchronized database failover event.',
            @category_name = @SqlServerAgentJobNameCategory,
            @owner_login_name = N'sa',
            @notify_level_email = 2,
            @notify_email_operator_name = @OperatorName,
            @delete_level = 0,
            @job_id = @jobID OUTPUT;

        -- TODO: might need a version check here... i.e., this behavior is new to ... 2017? (possibly 2016?) (or I'm on drugs) (eithe way, NOT clearly documented as of 2019-07-29)
        EXEC msdb.dbo.[sp_add_jobserver] 
            @job_name = @SqlServerAgentFailoverResponseJobName, 
            @server_name = N'(LOCAL)';

        EXEC msdb.dbo.[sp_add_jobstep]
            @job_name = @SqlServerAgentFailoverResponseJobName, 
            @step_id = 1,
            @step_name = N'Respond to Failover',
            @subsystem = N'TSQL',
            @command = @failoverHandlerCommand,
            @cmdexec_success_code = 0,
            @on_success_action = 1,
            @on_success_step_id = 0,
            @on_fail_action = 2,
            @on_fail_step_id = 0,
            @database_name = N'admindb',
            @flags = 0;
    
        COMMIT TRANSACTION;
    END TRY 
    BEGIN CATCH 
        SELECT @errorMessage = N'Unexpected error creating failover response-handling job on server [' + @@SERVERNAME + N']. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
        RAISERROR(@errorMessage, 16, 1);
        ROLLBACK TRANSACTION;
        RETURN -25;
    END CATCH;

    -- enable alerts - and map to job: 
    BEGIN TRY 
		DECLARE @1480AlertName sysname = N'1480 - Partner Role Change';

        IF EXISTS (SELECT NULL FROM msdb.dbo.sysalerts WHERE [message_id] = 1480 AND [name] = @1480AlertName)
            EXEC msdb.dbo.[sp_delete_alert] @name = N'1480 - Partner Role Change';

        EXEC msdb.dbo.[sp_add_alert]
            @name = @1480AlertName,
            @message_id = 1480,
            @enabled = 1,
            @delay_between_responses = 5,
            @include_event_description_in = 0,
            @job_name = @SqlServerAgentFailoverResponseJobName;
    END TRY 
    BEGIN CATCH 
        SELECT @errorMessage = N'Unexpected error mapping Alert 1480 to response-handling job on server [' + @@SERVERNAME + N']. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
        RAISERROR(@errorMessage, 16, 1);
        RETURN -30;
    END CATCH;

    IF @ExecuteSetupOnPartnerServer = 1 BEGIN

        DECLARE @command nvarchar(MAX) = N'EXEC [PARTNER].admindb.dbo.[add_failover_processing]
    @SqlServerAgentFailoverResponseJobName = @SqlServerAgentFailoverResponseJobName,
    @SqlServerAgentJobNameCategory = @SqlServerAgentJobNameCategory,      
    @MailProfileName = @MailProfileName,
    @OperatorName =  @OperatorName,				          
    @ExecuteSetupOnPartnerServer = 0; ';

        BEGIN TRY 
            EXEC sp_executesql 
                @command, 
                N'@SqlServerAgentFailoverResponseJobName sysname, @SqlServerAgentJobNameCategory sysname, @MailProfileName sysname, @OperatorName sysname', 
                @SqlServerAgentFailoverResponseJobName = @SqlServerAgentFailoverResponseJobName, 
                @SqlServerAgentJobNameCategory = @SqlServerAgentJobNameCategory, 
                @MailProfileName = @MailProfileName, 
                @OperatorName = @OperatorName;

        END TRY
        BEGIN CATCH 
            SELECT @errorMessage = N'Unexected error while attempting to create job [' + @SqlServerAgentFailoverResponseJobName + N'] on server [' + @@SERVERNAME + N']. Error: [' + CAST(ERROR_NUMBER() AS sysname) + N' - ' + ERROR_MESSAGE() + N']';
            RAISERROR(@errorMessage, 16, 1); 
            RETURN -30;
        END CATCH;
    END;
    
    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.create_sync_check_jobs','P') IS NOT NULL
	DROP PROC dbo.[create_sync_check_jobs];
GO

CREATE PROC dbo.[create_sync_check_jobs]
	@Action											sysname				= N'TEST',				-- 'TEST | CREATE' are the 2x options - i.e., test/output what we'd see... or ... create the jobs. 	
	@ServerAndJobsSyncCheckJobRunsEvery				sysname				= N'20 minutes', 
	@DataSyncCheckJobRunsEvery						sysname				= N'20 minutes',
	@IgnoreSynchronizedDatabaseOwnership			bit		            = 0,					
	@IgnoredMasterDbObjects							nvarchar(MAX)       = NULL,
	@IgnoredLogins									nvarchar(MAX)       = NULL,
	@IgnoredAlerts									nvarchar(MAX)       = NULL,
	@IgnoredLinkedServers							nvarchar(MAX)       = NULL,
    @IgnorePrincipalNames							bit                 = 1,  
	@IgnoredJobs									nvarchar(MAX)		= NULL,
	@IgnoredDatabases								nvarchar(MAX)		= NULL,
	@RPOThreshold									sysname				= N'10 seconds',
	@RTOThreshold									sysname				= N'40 seconds',
	@AGSyncCheckIterationCount						int					= 8, 
	@AGSyncCheckDelayBetweenChecks					sysname				= N'1800 milliseconds',
	@ExcludeAnomolousSyncDeviations					bit					= 0,    -- Primarily for Ghosted Records Cleanup... 	
	@JobsNamePrefix									sysname				= N'Synchronization - ',		
	@JobsCategoryName								sysname				= N'SynchronizationChecks',							
	@JobOperatorToAlertOnErrors						sysname				= N'Alerts',	
	@ProfileToUseForAlerts							sysname				= N'General',
	@OverWriteExistingJobs							bit					= 0
AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	-- TODO: validate inputs... 

	DECLARE @serverAndJobsStart time = '00:01:00';
	DECLARE @dataStart time = '00:02:00';

	IF NULLIF(@Action, N'') IS NULL SET @Action = N'TEST';

	IF UPPER(@Action) NOT IN (N'TEST', N'CREATE') BEGIN 
		RAISERROR('Invalid option specified for parameter @Action. Valid options are ''TEST'' (test/show sync-check outputs without creating a job) and ''CREATE'' (create sync-check jobs).', 16, 1);
		RETURN -1;
	END;

	-- vNEXT: MAYBE look at extending the types of intervals allowed?
	-- Verify minutes-only sync-check intervals. 
	IF @ServerAndJobsSyncCheckJobRunsEvery IS NULL BEGIN 
		RAISERROR('Parameter @ServerAndJobsSyncCheckJobRunsEvery cannot be left empty - and specifies how frequently (in minutes) the server/job sync-check job runs - e.g., N''20 minutes''.', 16, 1);
		RETURN -2;
	  END
	ELSE BEGIN
		IF @ServerAndJobsSyncCheckJobRunsEvery NOT LIKE '%minute%' BEGIN 
			RAISERROR('@ServerAndJobsSyncCheckJobRunsEvery can only specify values defined in minutes - e.g., N''5 minutes'', or N''10 minutes'', etc.', 16, 1);
			RETURN -3;
		END;
	END;

	IF @DataSyncCheckJobRunsEvery IS NULL BEGIN 
		RAISERROR('Parameter @DataSyncCheckJobRunsEvery cannot be left empty - and specifies how frequently (in minutes) the data sync-check job runs - e.g., N''20 minutes''.', 16, 1);
		RETURN -4;
	  END
	ELSE BEGIN
		IF @DataSyncCheckJobRunsEvery NOT LIKE '%minute%' BEGIN 
			RAISERROR('@DataSyncCheckJobRunsEvery can only specify values defined in minutes - e.g., N''5 minutes'', or N''10 minutes'', etc.', 16, 1);
			RETURN -5;
		END;
	END;

--vNEXT:
	--IF UPPER(@Action) = N'TEST' BEGIN
	--	PRINT 'TODO: Output all parameters - to make config easier... ';
	--	-- SEE https://overachieverllc.atlassian.net/browse/S4-304 for more details. Otherwise, effecively: SELECT [name] FROM sys.parameters WHERE object_id = @@PROCID;
	--END;
	
	DECLARE @crlfTab nchar(3) = NCHAR(13) + NCHAR(10) + NCHAR(9);

	DECLARE @serverSyncTemplate nvarchar(MAX) = N'EXEC admindb.dbo.[verify_server_synchronization]
	@IgnoreSynchronizedDatabaseOwnership = {ingoreOwnership},
	@IgnoredMasterDbObjects = {ignoredMasterObjects},
	@IgnoredLogins = {ignoredLogins},
	@IgnoredAlerts = {ignoredAlerts},
	@IgnoredLinkedServers = {ignoredLinkedServers},
	@IgnorePrincipalNames = {ignorePrincipals},{operator}{profile}
	@PrintOnly = {printOnly}; ';

	DECLARE @jobsSyncTemplate nvarchar(MAX) = N'EXEC admindb.dbo.[verify_job_synchronization] 
	@IgnoredJobs = {ignoredJobs},{operator}{profile}
	@PrintOnly = {printOnly}; ';

	DECLARE @dataSyncTemplate nvarchar(MAX) = N'EXEC admindb.dbo.[verify_data_synchronization]
	@IgnoredDatabases = {ignoredDatabases},{rpo}{rto}{checkCount}{checkDelay}{excludeAnomalies}{operator}{profile}
	@PrintOnly = {printOnly}; ';
	
	-----------------------------------------------------------------------------
	-- Process Server Sync Checks:
	DECLARE @serverBody nvarchar(MAX) = @serverSyncTemplate;
	
	IF @IgnoreSynchronizedDatabaseOwnership = 1 
		SET @serverBody = REPLACE(@serverBody, N'{ingoreOwnership}', N'1');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{ingoreOwnership}', N'0');

	IF NULLIF(@IgnoredMasterDbObjects, N'') IS NULL 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredMasterObjects}', N'NULL');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredMasterObjects}', N'N''' + @IgnoredMasterDbObjects + N'''');

	IF NULLIF(@IgnoredLogins, N'') IS NULL 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredLogins}', N'NULL');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredLogins}', N'N''' + @IgnoredLogins + N'''');

	IF  NULLIF(@IgnoredAlerts, N'') IS NULL 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredAlerts}', N'NULL');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredAlerts}', N'N''' + @IgnoredAlerts + N'''');

	IF  NULLIF(@IgnoredLinkedServers, N'') IS NULL 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredLinkedServers}', N'NULL');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{ignoredLinkedServers}', N'N''' + @IgnoredLinkedServers + N'''');

	IF @IgnorePrincipalNames = 1
		SET @serverBody = REPLACE(@serverBody, N'{ignorePrincipals}', N'1');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{ignorePrincipals}', N'0');

	IF UPPER(@Action) = N'TEST' 
		SET @serverBody = REPLACE(@serverBody, N'{printOnly}', N'1');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{printOnly}', N'0');

	IF NULLIF(@JobOperatorToAlertOnErrors, N'') IS NULL
		SET @serverBody = REPLACE(@serverBody, N'{operator}', N'');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{operator}', @crlfTab + N'@OperatorName = N''' + @JobOperatorToAlertOnErrors + N''', ');

	IF NULLIF(@ProfileToUseForAlerts, N'') IS NULL
		SET @serverBody = REPLACE(@serverBody, N'{profile}', N'');
	ELSE 
		SET @serverBody = REPLACE(@serverBody, N'{profile}', @crlfTab + N'@MailProfileName = N''' + @ProfileToUseForAlerts + N''', ');

	-----------------------------------------------------------------------------
	-- Process Job Sync Checks
	DECLARE @jobsBody nvarchar(MAX) = @jobsSyncTemplate;

	IF NULLIF(@IgnoredJobs, N'') IS NULL 
		SET @jobsBody = REPLACE(@jobsBody, N'{ignoredJobs}', N'NULL');
	ELSE 
		SET @jobsBody = REPLACE(@jobsBody, N'{ignoredJobs}', N'''' + @IgnoredJobs + N'''');

	IF UPPER(@Action) = N'TEST' 
		SET @jobsBody = REPLACE(@jobsBody, N'{printOnly}', N'1');
	ELSE 
		SET @jobsBody = REPLACE(@jobsBody, N'{printOnly}', N'0');

	IF NULLIF(@JobOperatorToAlertOnErrors, N'') IS NULL
		SET @jobsBody = REPLACE(@jobsBody, N'{operator}', N'');
	ELSE 
		SET @jobsBody = REPLACE(@jobsBody, N'{operator}', @crlfTab + N'@OperatorName = N''' + @JobOperatorToAlertOnErrors + N''', ');

	IF NULLIF(@ProfileToUseForAlerts, N'') IS NULL
		SET @jobsBody = REPLACE(@jobsBody, N'{profile}', N'');
	ELSE 
		SET @jobsBody = REPLACE(@jobsBody, N'{profile}', @crlfTab + N'@MailProfileName = N''' + @ProfileToUseForAlerts + N''', ');

	-----------------------------------------------------------------------------
	-- Process Data Sync Checks

	DECLARE @dataBody nvarchar(MAX) = @dataSyncTemplate;

	IF NULLIF(@IgnoredDatabases, N'') IS NULL 
		SET @dataBody = REPLACE(@dataBody, N'{ignoredDatabases}', N'NULL');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{ignoredDatabases}', N'N''' + @IgnoredDatabases + N'''');

	IF NULLIF(@RPOThreshold, N'') IS NULL 
		SET @dataBody = REPLACE(@dataBody, N'{rpo}', N'');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{rpo}', @crlfTab + N'@RPOThreshold = N''' + @RPOThreshold + N''',');

	IF NULLIF(@RTOThreshold, N'') IS NULL 
		SET @dataBody = REPLACE(@dataBody, N'{rto}', N'');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{rto}', @crlfTab + N'@RTOThreshold = N''' + @RTOThreshold + N''',');

	IF @AGSyncCheckIterationCount IS NULL 
		SET @dataBody = REPLACE(@dataBody, N'{checkCount}', N'');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{checkCount}', @crlfTab + N'@AGSyncCheckIterationCount = ' + CAST(@AGSyncCheckIterationCount AS sysname) + N',');

	IF NULLIF(@AGSyncCheckDelayBetweenChecks, N'') IS NULL 
		SET @dataBody = REPLACE(@dataBody, N'{checkDelay}', N'');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{checkDelay}', @crlfTab + N'@AGSyncCheckDelayBetweenChecks = N''' + @AGSyncCheckDelayBetweenChecks + N''',');

	IF @ExcludeAnomolousSyncDeviations IS NULL 
		SET @dataBody = REPLACE(@dataBody, N'{excludeAnomalies}', N'');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{excludeAnomalies}', @crlfTab + N'@ExcludeAnomolousSyncDeviations = ' + CAST(@ExcludeAnomolousSyncDeviations AS sysname) + N',');

	IF UPPER(@Action) = N'TEST' 
		SET @dataBody = REPLACE(@dataBody, N'{printOnly}', N'1');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{printOnly}', N'0');

	IF NULLIF(@JobOperatorToAlertOnErrors, N'') IS NULL
		SET @dataBody = REPLACE(@dataBody, N'{operator}', N'');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{operator}', @crlfTab + N'@OperatorName = N''' + @JobOperatorToAlertOnErrors + N''', ');

	IF NULLIF(@ProfileToUseForAlerts, N'') IS NULL
		SET @dataBody = REPLACE(@dataBody, N'{profile}', N'');
	ELSE 
		SET @dataBody = REPLACE(@dataBody, N'{profile}', @crlfTab + N'@MailProfileName = N''' + @ProfileToUseForAlerts + N''', ');
	
	DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);

	IF UPPER(@Action) = N'TEST' BEGIN
		
		PRINT N'NOTE: Operating in Test Mode. ';
		PRINT N'	SET @Action = N''CREATE'' when ready to create actual jobs... ' + @crlf + @crlf;
		PRINT N'EXECUTING synchronization-check calls as follows: ' + @crlf + @crlf;
		PRINT @serverBody + @crlf + @crlf;
		PRINT @jobsBody + @crlf + @crlf;
		PRINT @dataBody + @crlf + @crlf; 

		PRINT N'OUTPUT FROM EXECUTION of the above operations FOLLOWS:';
		PRINT N'--------------------------------------------------------------------------------------------------------';

		EXEC sp_executesql @serverBody;
		EXEC sp_executesql @jobsBody;
		EXEC sp_executesql @dataBody;

		PRINT N'--------------------------------------------------------------------------------------------------------';

		RETURN 0;
	END;

	-----------------------------------------------------------------------------
	-- Create the Server and Jobs Sync-Check Job:
	DECLARE @jobID uniqueidentifier; 
	DECLARE @currentJobName sysname = @JobsNamePrefix + N'Verify Server and Jobs';

	EXEC dbo.[create_agent_job]
		@TargetJobName = @currentJobName,
		@JobCategoryName = @JobsCategoryName,
		@JobEnabled = 0, -- create jobs in disabled state - so that admins have to review and manually enable... 
		@AddBlankInitialJobStep = 0,  -- not for these jobs, they should be fairly short in execution... 
		@OperatorToAlertOnErrorss = @JobOperatorToAlertOnErrors,
		@OverWriteExistingJobDetails = @OverWriteExistingJobs,
		@JobID = @jobID OUTPUT;
	
	-- Add a schedule: 
	DECLARE @dateAsInt int = CAST(CONVERT(sysname, GETDATE(), 112) AS int);
	DECLARE @startTimeAsInt int = CAST((LEFT(REPLACE(CONVERT(sysname, @serverAndJobsStart, 108), N':', N''), 6)) AS int);
	DECLARE @scheduleName sysname = @currentJobName + ' Schedule';

	DECLARE @frequencyMinutes int;
	DECLARE @outcome int; 
	DECLARE @error nvarchar(MAX);

	EXEC @outcome = dbo.[translate_vector]
		@Vector = @ServerAndJobsSyncCheckJobRunsEvery,
		@ValidationParameterName = N'@ServerAndJobsSyncCheckJobRunsEvery',
		@ProhibitedIntervals = N'MILLISECOND,SECOND,HOUR,DAY,WEEK,MONTH,YEAR',
		@TranslationDatePart = 'MINUTE',
		@Output = @frequencyMinutes OUTPUT,
		@Error = @error OUTPUT;

	IF @outcome <> 0 BEGIN 
		RAISERROR(@error, 16, 1); 
		RETURN @outcome;
	END;
		   	
	-- TODO: scheduling logic here isn't as robust as it is in ...dbo.enable_disk_monitoring (and... i should expand the logic in THAT sproc, and move it out to it's own sub-sproc - i.e., pass in an @JobID and other params to a sproc called something like dbo.add_agent_job_schedule
	EXEC msdb.dbo.sp_add_jobschedule 
		@job_id = @jobID,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = 4,		-- daily								
		@freq_interval = 1, -- every 1 days							
		@freq_subday_type = 4,	-- minutes			
		@freq_subday_interval = @frequencyMinutes, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 0, 
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;	

	DECLARE @compoundJobStep nvarchar(MAX) = N'-- Server Synchronization Checks: 
' + @serverBody + N'

-- Jobs Synchronization Checks: 
' + @jobsBody;

	EXEC msdb..sp_add_jobstep
		@job_id = @jobID,
		@step_id = 1,
		@step_name = N'Synchronization Checks for Server Objects and Jobs Details',
		@subsystem = N'TSQL',
		@command = @compoundJobStep,
		@on_success_action = 1,
		@on_success_step_id = 0,
		@on_fail_action = 2,
		@on_fail_step_id = 0,
		@database_name = N'admindb',
		@retry_attempts = 1,
		@retry_interval = 1;

	-----------------------------------------------------------------------------
	-- Create the Data Sync-Check Job:

	SET @currentJobName = @JobsNamePrefix + N'Verify Data-Sync';
	SET @jobID = NULL;

	EXEC dbo.[create_agent_job]
		@TargetJobName = @currentJobName,
		@JobCategoryName = @JobsCategoryName,
		@JobEnabled = 0, -- create jobs in disabled state - so that admins have to review and manually enable... 
		@AddBlankInitialJobStep = 0,  -- not for these jobs, they should be fairly short in execution... 
		@OperatorToAlertOnErrorss = @JobOperatorToAlertOnErrors,
		@OverWriteExistingJobDetails = @OverWriteExistingJobs,
		@JobID = @jobID OUTPUT;

	-- Add a schedule: 

	SET @startTimeAsInt = CAST((LEFT(REPLACE(CONVERT(sysname, @dataStart, 108), N':', N''), 6)) AS int);
	SET @scheduleName = @currentJobName + ' Schedule';

	EXEC @outcome = dbo.[translate_vector]
		@Vector = @DataSyncCheckJobRunsEvery,
		@ValidationParameterName = N'@DataSyncCheckJobRunsEvery',
		@ProhibitedIntervals = N'MILLISECOND,SECOND,HOUR,DAY,WEEK,MONTH,YEAR',
		@TranslationDatePart = 'MINUTE',
		@Output = @frequencyMinutes OUTPUT,
		@Error = @error OUTPUT;

	IF @outcome <> 0 BEGIN 
		RAISERROR(@error, 16, 1); 
		RETURN @outcome;
	END;

	-- TODO: scheduling logic here isn't as robust as it is in ...dbo.enable_disk_monitoring (and... i should expand the logic in THAT sproc, and move it out to it's own sub-sproc - i.e., pass in an @JobID and other params to a sproc called something like dbo.add_agent_job_schedule
	EXEC msdb.dbo.sp_add_jobschedule 
		@job_id = @jobID,
		@name = @scheduleName,
		@enabled = 1, 
		@freq_type = 4,		-- daily								
		@freq_interval = 1, -- every 1 days							
		@freq_subday_type = 4,	-- minutes			
		@freq_subday_interval = @frequencyMinutes, 
		@freq_relative_interval = 0, 
		@freq_recurrence_factor = 0, 
		@active_start_date = @dateAsInt, 
		@active_start_time = @startTimeAsInt;

	-- Add job Body: 
	DECLARE @singleBody nvarchar(MAX) = N'-- Data Synchronization Checks: 
' + @dataBody;

	EXEC msdb..sp_add_jobstep
		@job_id = @jobID,
		@step_id = 1,
		@step_name = N'Data Synchronization + Topology Health Checks',
		@subsystem = N'TSQL',
		@command = @singleBody,
		@on_success_action = 1,
		@on_success_step_id = 0,
		@on_fail_action = 2,
		@on_fail_step_id = 0,
		@database_name = N'admindb',
		@retry_attempts = 1,
		@retry_interval = 1;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_synchronization_setup','P') IS NOT NULL
	DROP PROC dbo.[verify_synchronization_setup];
GO

CREATE PROC dbo.[verify_synchronization_setup]

AS
    SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

    IF OBJECT_ID('tempdb..#ERRORs') IS NOT NULL
	    DROP TABLE #Errors;

    CREATE TABLE #Errors (
	    ErrorId int IDENTITY(1,1) NOT NULL, 
	    SectionID int NOT NULL, 
	    Severity varchar(20) NOT NULL, -- INFO, WARNING, ERROR
	    ErrorText nvarchar(2000) NOT NULL
    );

    -------------------------------------------------------------------------------------
    -- 0. Core Configuration Details/Needs:

	-- TODO: Verify that we've got a Mirroring Endpoint (and, ideally, that CONNECT/etc. has been granted to something on the partner/etc.). 


	-- Verify AG health XE session:
	IF (SELECT [admindb].dbo.[get_engine_version]()) >= 11.0 BEGIN 
		IF NOT EXISTS (SELECT NULL FROM sys.[server_event_sessions] WHERE [name] = N'AlwaysOn_health') BEGIN
			INSERT INTO #Errors (SectionID, Severity, ErrorText)
			SELECT 0, N'WARNING', N'AlwaysOn_health XE session not found on server.';			

		  END; 
		ELSE BEGIN -- we found it, make sure it's auto-started and running: 
			
			IF NOT EXISTS (SELECT NULL FROM sys.[server_event_sessions] WHERE [name] = N'AlwaysOn_health' AND [startup_state] = 1) BEGIN
				INSERT INTO #Errors (SectionID, Severity, ErrorText)
				SELECT 0, N'WARNING', N'AlwaysOn_health XE session is NOT set to auto-start with Server.';
			END;

			IF NOT EXISTS (SELECT NULL FROM sys.[dm_xe_sessions] WHERE [name] = N'AlwaysOn_health') BEGIN
				INSERT INTO #Errors (SectionID, Severity, ErrorText)
				SELECT 0, N'WARNING', N'AlwaysOn_health XE session is NOT currently running.';
			END;
		END;

	END;


    -- Database Mail
    IF (SELECT value_in_use FROM sys.configurations WHERE name = 'Database Mail XPs') != 1 BEGIN
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 0, N'ERROR', N'Database Mail has not been set up or configured.';
    END

    DECLARE @profileInfo TABLE (
	    profile_id int NULL, 
	    name sysname NULL, 
	    [description] nvarchar(256) NULL
    )
    INSERT INTO	@profileInfo (profile_id, name, description)
    EXEC msdb.dbo.sysmail_help_profile_sp;

    IF NOT EXISTS (SELECT NULL FROM @profileInfo) BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 0, N'ERROR', N'A Database Mail Profile has not been created.';
    END 

    -- SQL Agent can talk to Database Mail and a profile has been configured: 
    declare @DatabaseMailProfile nvarchar(255)
    exec master.dbo.xp_instance_regread N'HKEY_LOCAL_MACHINE', N'SOFTWARE\Microsoft\MSSQLServer\SQLServerAgent', N'DatabaseMailProfile', @param = @DatabaseMailProfile OUT, @no_output = N'no_output'
 
     IF @DatabaseMailProfile IS NULL BEGIN 
 	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 0, N'ERROR', N'The SQL Server Agent has not been configured to Use Database Mail.';
     END 

    -- Operators (at least one configured)
    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysoperators) BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 0, N'WARNING', N'No SQL Server Agent Operator was detected.';
    END 

    -------------------------------------------------------------------------------------
    -- 1. 
    -- PARTNER linked server definition.
    DECLARE @linkedServers TABLE (
	    SRV_NAME sysname NULL, 
	    SRV_PROVIDERNAME nvarchar(128) NULL, 
	    SRV_PRODUCT nvarchar(128) NULL,
	    SRV_DATASOURCE nvarchar(4000) NULL, 
	    SRV_PROVIDERSTRING nvarchar(4000) NULL,
	    SRV_LOCATION nvarchar(4000) NULL, 
	    SRV_CAT sysname NULL
    )

    INSERT INTO @linkedServers 
    EXEC sp_linkedservers

    IF NOT EXISTS (SELECT NULL FROM @linkedServers WHERE SRV_NAME = N'PARTNER') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 1, N'ERROR', N'Linked Server definition for PARTNER not found (synchronization checks won''t work).';
    END

    -------------------------------------------------------------------------------------
    -- 2.Server and Job Synchronization Checks

    -- check for missing code/objects:
    DECLARE @ObjectNames TABLE (
	    name sysname
    )

    INSERT INTO @ObjectNames (name)
    VALUES 
    (N'server_trace_flags'),
    (N'is_primary_database'),
    (N'verify_server_synchronization'),
    (N'verify_job_synchronization');

    INSERT INTO #Errors (SectionID, Severity, ErrorText)
    SELECT 
	    2, 
	    N'ERROR',
	    N'Object [' + x.name + N'] was not found in the [admindb] database.'
    FROM 
	    @ObjectNames x
	    LEFT OUTER JOIN admindb..sysobjects o ON o.name = x.name
    WHERE 
	    o.name IS NULL;

    -- warn if there aren't any job steps with verify_server_synchronization or verify_job_synchronization referenced.
    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%verify_server_synchronization%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 2, N'WARNING', N'A SQL Server Agent Job that calls [dbo].[verify_server_synchronization] was not found.';
    END 

    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%verify_job_synchronization%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 2, N'WARNING', N'A SQL Server Agent Job that calls [dbo].[verify_job_synchronization] was not found.';
    END 

	-- ditto on data-synch checks: 
	IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%verify_data_synchronization%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 2, N'WARNING', N'A SQL Server Agent Job that calls [dbo].[verify_data_synchronization] was not found.';
    END 
    -------------------------------------------------------------------------------------
    -- 3. Mirroring Failover

    -- Mirroring Failover Messages (WITH LOG):
    IF NOT EXISTS (SELECT NULL FROM master.sys.messages WHERE language_id = 1033 AND message_id = 1440 AND is_event_logged = 1) BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 3, N'WARNING', N'Message ID 1440 is not set to use the WITH_LOG option.';
    END

    IF NOT EXISTS (SELECT NULL FROM master.sys.messages WHERE language_id = 1033 AND message_id = 1480 AND is_event_logged = 1) BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 3, N'ERROR', N'Message ID 1480 is not set to use the WITH_LOG option.';
    END


    -- objects/code:
    DELETE FROM @ObjectNames;
    INSERT INTO @ObjectNames (name)
    VALUES 
    (N'server_trace_flags'),
    (N'process_synchronization_failover');

    INSERT INTO #Errors (SectionID, Severity, ErrorText)
    SELECT 
	    3, 
	    N'ERROR',
	    N'Object [' + x.name + N'] was not found in the admindb database.'
    FROM 
	    @ObjectNames x
	    LEFT OUTER JOIN admindb..sysobjects o ON o.name = x.name
    WHERE 
	    o.name IS NULL;

    --DELETE FROM @ObjectNames;
    --INSERT INTO @ObjectNames (name)
    --VALUES 
    --(N'sp_fix_orphaned_users');

    --INSERT INTO #Errors (SectionID, Severity, ErrorText)
    --SELECT 
    --	3, 
    --	N'ERROR', 
    --	N'Object [' + x.name + N'] was not found in the master database.'
    --FROM 
    --	@ObjectNames x
    --	LEFT OUTER JOIN admindb..sysobjects o ON o.name = x.name
    --WHERE 
    --	o.name IS NULL;


    -- Alerts for 1440/1480
    --IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysalerts WHERE message_id = 1440) BEGIN 
    --	INSERT INTO #Errors (SectionID, Severity, ErrorText)
    --	SELECT 3, N'INFO', N'An Alert to Trap Failover with a Database as the Primary has not been configured.';
    --END

    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysalerts WHERE message_id = 1480) BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 3, N'ERROR', N'A SQL Server Agent Alert has not been set up to ''trap'' Message 1480 (database failover).';
    END

    -- Warn if no job to respond to failover:
    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%process_synchronization_failover%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 3, N'WARNING', N'A SQL Server Agent Job that calls [process_synchronization_failover] (to handle database failover) was not found.';
    END 


    -------------------------------------------------------------------------------------
    -- 4. Monitoring. 

    -- objects/code:
    DELETE FROM @ObjectNames;
    INSERT INTO @ObjectNames (name)
    VALUES 
    (N'verify_data_synchronization');

    INSERT INTO #Errors (SectionID, Severity, ErrorText)
    SELECT 
	    4, 
	    N'ERROR',
	    N'Object [' + x.name + N'] was not found in the master database.'
    FROM 
	    @ObjectNames x
	    LEFT OUTER JOIN admindb.sys.sysobjects o ON o.name = x.name
    WHERE 
	    o.name IS NULL;

    IF EXISTS(SELECT * FROM sys.[database_mirroring] WHERE [mirroring_guid] IS NOT NULL) BEGIN
	    -- If Mirrored dbs are present:
	    -- Make sure the 'stock' MS job "Database Mirroring Monitor Job" is present. 
	    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobs WHERE name = 'Database Mirroring Monitor Job') BEGIN 
		    INSERT INTO #Errors (SectionID, Severity, ErrorText)
		    SELECT 4, N'ERROR', N'The SQL Server Agent (initially provided by Microsoft) entitled ''Database Mirroring Monitor Job'' is not present. Please recreate.';
	    END;
    END; 

    -- Make sure there's a health-check job:
    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%data_synchronization_checks%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 4, N'WARNING', N'A SQL Server Agent Job that calls [data_synchronization_checks] (to run health checks) was not found.';
    END 


    -------------------------------------------------------------------------------------
    -- 5. Backups

    -- objects/code:
    DELETE FROM @ObjectNames;
    INSERT INTO @ObjectNames (name)
    VALUES 
    (N'backup_databases');

    INSERT INTO #Errors (SectionID, Severity, ErrorText)
    SELECT 
	    5, 
	    N'ERROR',
	    N'Object [' + x.[name] + N'] was not found in the admin database.'
    FROM 
	    @ObjectNames x
	    LEFT OUTER JOIN admindb.dbo.sysobjects o ON o.name = x.name
    WHERE 
	    o.name IS NULL;

    DECLARE @settingValue sysname; 
    SELECT @settingValue = ISNULL([setting_value], N'0') FROM dbo.[settings] WHERE [setting_key] = N'advanced_s4_error_handling';

    IF @settingValue <> N'1' BEGIN
        INSERT INTO #Errors (SectionID, Severity, ErrorText)
        SELECT 5, N'WARNING', N'admindb.dbo.[backup_databases] requires advanced error handling capabilities enabled. Please execute admindb.dbo.enable_advanced_capabilities to enable advanced capabilities.';
    END;

    -- warnings for backups:
    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%backup_databases%FULL%SYSTEM%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 5, N'INFO', N'No SQL Server Agent Job to execute backups of System Databases was found.';	
    END

    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%backup_databases%FULL%' AND command NOT LIKE '%backup_databases%FULL%system%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 5, N'INFO', N'No SQL Server Agent Job to execute FULL backups of User Databases was found.';	
    END

    IF NOT EXISTS (SELECT NULL FROM msdb.dbo.sysjobsteps WHERE command LIKE '%backup_databases%LOG%') BEGIN 
	    INSERT INTO #Errors (SectionID, Severity, ErrorText)
	    SELECT 5, N'INFO', N'No SQL Server Agent Job to execute Transaction Log backups of User Databases was found.';	
    END

    -------------------------------------------------------------------------------------
    -- 6. Reporting 
    IF EXISTS (SELECT NULL FROM #Errors)
	    SELECT SectionID [Section], Severity, ErrorText [Detail] FROM #Errors ORDER BY ErrorId;
    ELSE 
	    SELECT 'All Checks Completed - No Issues Detected.' [Outcome];

    RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.list_nonaccessible_databases','TF') IS NOT NULL
	DROP FUNCTION dbo.[list_nonaccessible_databases];
GO

CREATE FUNCTION dbo.[list_nonaccessible_databases] ()
RETURNS @nonaccessibleDatabases table ( 
	database_id int NOT NULL, 
	[database_name] sysname NOT NULL, 
	[status] sysname NOT NULL, 
	[owner_spid] int NULL
)
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
		-- SINGLE_USER dbs (potential vNEXT option: look into excluding based on @@SPID vs currently owning spid?)
		INSERT INTO @nonaccessibleDatabases ([database_id],[database_name],[status], [owner_spid])
		SELECT d.database_id, d.[name], N'SINGLE_USER' [status], s.[spid]
		FROM sys.databases d 
		LEFT OUTER JOIN sys.[sysprocesses] s ON d.[database_id] = s.[dbid]
		WHERE d.user_access_desc = N'SINGLE_USER';

		-- restoring/recovering and non-ONLINE databases:
    	INSERT INTO @nonaccessibleDatabases ([database_id],[database_name],[status])
		SELECT database_id, [name], state_desc 
		FROM sys.databases WHERE [state_desc] <> N'ONLINE';

		-- AG/Mirroring secondaries:
		WITH synchronized AS ( 
			SELECT 
				[database_name],
				[sync_type] + N' - ' + [role] [status]
			FROM 
				admindb.dbo.list_synchronizing_databases(NULL, 0)
			WHERE 
				[role] = N'SECONDARY'
		)

		INSERT INTO @nonaccessibleDatabases ([database_id],[database_name],[status])
		SELECT 
			d.database_id,
			s.[database_name], 
			s.[status]
		FROM 
			synchronized s 
			INNER JOIN sys.databases d ON s.[database_name] = d.[name]
    	
    	RETURN;
    
    END;
GO


DECLARE @list_nonaccessible_databases nvarchar(MAX) = N'
ALTER FUNCTION dbo.[list_nonaccessible_databases] ()
RETURNS @nonaccessibleDatabases table ( 
	database_id int NOT NULL, 
	[database_name] sysname NOT NULL, 
	[status] sysname NOT NULL, 
	[owner_spid] int NULL
)
AS
    
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
    
    BEGIN; 
    	
		-- SINGLE_USER dbs (potential vNEXT option: look into excluding based on @@SPID vs currently owning spid?)
		INSERT INTO @nonaccessibleDatabases ([database_id],[database_name],[status], [owner_spid])
		SELECT d.database_id, d.[name], N''SINGLE_USER'' [status], s.[session_id]
		FROM sys.databases d 
		LEFT OUTER JOIN sys.[dm_exec_sessions] s ON d.[database_id] = s.[database_id] 
		WHERE d.user_access_desc = N''SINGLE_USER'';

		-- restoring/recovering and non-ONLINE databases:
    	INSERT INTO @nonaccessibleDatabases ([database_id],[database_name],[status])
		SELECT database_id, [name], state_desc 
		FROM sys.databases WHERE [state_desc] <> N''ONLINE'';

		-- AG/Mirroring secondaries:
		WITH synchronized AS ( 
			SELECT 
				[database_name],
				[sync_type] + N'' - '' + [role] [status]
			FROM 
				admindb.dbo.list_synchronizing_databases(NULL, 0)
			WHERE 
				[role] = N''SECONDARY''
		)

		INSERT INTO @nonaccessibleDatabases ([database_id],[database_name],[status])
		SELECT 
			d.database_id,
			s.[database_name], 
			s.[status]
		FROM 
			synchronized s 
			INNER JOIN sys.databases d ON s.[database_name] = d.[name]
    	
    	RETURN;
    
    END;

 ';

IF (SELECT dbo.get_engine_version())> 10.5  
	EXEC sp_executesql @list_nonaccessible_databases;

------------------------------------------------------------------------------------------------------------------------------------------------------
-- Auditing:
------------------------------------------------------------------------------------------------------------------------------------------------------

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.generate_audit_signature','P') IS NOT NULL
	DROP PROC dbo.generate_audit_signature;
GO


CREATE PROC dbo.generate_audit_signature 
	@AuditName					sysname, 
	@IncludeGuidInHash			bit			= 1, 
	@AuditSignature				bigint		= -1 OUTPUT
AS
	
	RAISERROR('Sorry. The S4 stored procedure dbo.generate_audit_signature is NOT supported on SQL Server 2008/2008R2 instances.', 16, 1);
	RETURN -100;
GO

DECLARE @generate_audit_signature nvarchar(MAX) = N'ALTER PROC dbo.generate_audit_signature 
	@AuditName					sysname, 
	@IncludeGuidInHash			bit			= 1, 
	@AuditSignature				bigint		= -1 OUTPUT
AS
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	DECLARE @errorMessage nvarchar(MAX);
	DECLARE @hash int = 0;
	DECLARE @auditID int; 

	SELECT 
		@auditID = audit_id
	FROM 
		sys.[server_audits] 
	WHERE 
		[name] = @AuditName;

	IF @auditID IS NULL BEGIN 
		SET @errorMessage = N''Specified Server Audit Name: ['' + @AuditName + N''] does NOT exist. Please check your input and try again.'';
		RAISERROR(@errorMessage, 16, 1);
		RETURN -1;
	END;

	DECLARE @hashes table ( 
			[hash] bigint NOT NULL
	);

	IF @IncludeGuidInHash = 1
		SELECT @hash = CHECKSUM([name], [audit_guid], [type], [on_failure], [is_state_enabled], [queue_delay], [predicate]) FROM sys.[server_audits] WHERE [name] = @AuditName;
	ELSE 
		SELECT @hash = CHECKSUM([name], [type], [on_failure], [is_state_enabled], [queue_delay], [predicate]) FROM sys.[server_audits] WHERE [name] = @AuditName;

	INSERT INTO @hashes ([hash])
	VALUES (@hash);

	-- hash storage details (if file log storage is used):
	IF EXISTS (SELECT NULL FROM sys.[server_audits] WHERE [name] = @AuditName AND [type] = ''FL'') BEGIN
		SELECT 
			@hash = CHECKSUM(max_file_size, max_files, reserve_disk_space, log_file_path) 
		FROM 
			sys.[server_file_audits] 
		WHERE 
			[audit_id] = @auditID;  -- note, log_file_name will always be different because of the GUIDs. 

		INSERT INTO @hashes ([hash])
		VALUES (@hash);
	END

	IF @AuditSignature = -1
		SELECT SUM([hash]) [audit_signature] FROM @hashes; 
	ELSE	
		SELECT @AuditSignature = SUM(hash) FROM @hashes;

	RETURN 0;

 ';

IF (SELECT dbo.get_engine_version())> 10.5 
	EXEC sp_executesql @generate_audit_signature;

-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.generate_specification_signature','P') IS NOT NULL
	DROP PROC dbo.generate_specification_signature;
GO

CREATE PROC dbo.generate_specification_signature 
	@Target										sysname				= N'SERVER',			-- SERVER | 'db_name' - SERVER is default and represents a server-level specification, whereas a db_name will specify that this is a database specification).
	@SpecificationName							sysname,
	@IncludeParentAuditIdInSignature			bit					= 1,
	@SpecificationSignature						bigint				= -1    OUTPUT
AS
	SET NOCOUNT ON; 
	
	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 
	
	DECLARE @errorMessage nvarchar(MAX);
	DECLARE @specificationScope sysname;

	 IF NULLIF(@Target, N'') IS NULL OR @Target = N'SERVER'
		SET @specificationScope = N'SERVER';
	ELSE 
		SET @specificationScope = N'DATABASE';

	CREATE TABLE #specificationDetails (
		audit_action_id varchar(10) NOT NULL, 
		class int NOT NULL, 
		major_id int NOT NULL, 
		minor_id int NOT NULL, 
		audited_principal_id int NOT NULL, 
		audited_result nvarchar(60) NOT NULL, 
		is_group bit NOT NULL 
	);

	DECLARE @hash int = 0;
	DECLARE @hashes table ( 
			[hash] bigint NOT NULL
	);

	DECLARE @specificationID int; 
	DECLARE @auditGUID uniqueidentifier;
	DECLARE @createDate datetime;
	DECLARE @modifyDate datetime;
	DECLARE @isEnabled bit;

	DECLARE @sql nvarchar(max) = N'
		SELECT 
			@specificationID = [{1}_specification_id], 
			@auditGUID = [audit_guid], 
			@createDate = [create_date],
			@modifyDate = [modify_date],
			@isEnabled = [is_state_enabled] 
		FROM 
			[{0}].sys.[{1}_audit_specifications] 
		WHERE 
			[name] = @SpecificationName;';

	DECLARE @specificationSql nvarchar(MAX) = N'
		SELECT 
			[audit_action_id], 
			[class], 
			[major_id],
			[minor_id], 
			[audited_principal_id], 
			[audited_result], 
			[is_group]
		FROM
			[{0}].sys.[{1}_audit_specification_details]  
		WHERE 
			 [{1}_specification_id] = @specificationID
		ORDER BY 
			[major_id];'; 

	IF @specificationScope = N'SERVER' BEGIN

		SET @sql = REPLACE(@sql, N'{0}', N'master');
		SET @sql = REPLACE(@sql, N'{1}', N'server');
		SET @specificationSql = REPLACE(@specificationSql, N'{0}', N'master');
		SET @specificationSql = REPLACE(@specificationSql, N'{1}', N'server');		

	  END
	ELSE BEGIN 

		-- Make sure the target database exists:
		DECLARE @databases table (
			[database_name] sysname NOT NULL
		); 

		INSERT INTO @databases([database_name])
		EXEC dbo.list_databases
			@Targets = @Target, 
			@Exclusions = N'[DEV]';

		IF NOT EXISTS (SELECT NULL FROM @databases WHERE LOWER([database_name]) = LOWER(@Target)) BEGIN
			SET @errorMessage = N'Specified @Target database [' + @Target + N'] does not exist. Please check your input and try again.';
			RAISERROR(@errorMessage, 16, 1);
			RETURN -1;
		END;

		SET @sql = REPLACE(@sql, N'{0}', @Target);
		SET @sql = REPLACE(@sql, N'{1}', N'database');
		SET @specificationSql = REPLACE(@specificationSql, N'{0}', @Target);
		SET @specificationSql = REPLACE(@specificationSql, N'{1}', N'database');
	END; 

	EXEC sys.sp_executesql 
		@stmt = @sql, 
		@params = N'@SpecificationName sysname, @specificationID int OUTPUT, @auditGuid uniqueidentifier OUTPUT, @isEnabled bit OUTPUT, @createDate datetime OUTPUT, @modifyDate datetime OUTPUT', 
		@SpecificationName = @SpecificationName, @specificationID = @specificationID OUTPUT, @auditGUID = @auditGUID OUTPUT, @isEnabled = @isEnabled OUTPUT, @createDate = @createDate OUTPUT, @modifyDate = @modifyDate OUTPUT;

	IF @specificationID IS NULL BEGIN
		SET @errorMessage = N'Specified '+ CASE WHEN @specificationScope = N'SERVER' THEN N'Server' ELSE N'Database' END + N' Audit Specification Name: [' + @SpecificationName + N'] does NOT exist. Please check your input and try again.';
		RAISERROR(@errorMessage, 16, 1);
		RETURN -2;		
	END;		

	-- generate/store a hash of the specification details:
	IF @IncludeParentAuditIdInSignature = 1 
		SELECT @hash = CHECKSUM(@SpecificationName, @auditGUID, @specificationID, @createDate, @modifyDate, @isEnabled);
	ELSE	
		SELECT @hash = CHECKSUM(@SpecificationName, @specificationID, @createDate, @modifyDate, @isEnabled);

	INSERT INTO @hashes ([hash]) VALUES (CAST(@hash AS bigint));

	INSERT INTO [#specificationDetails] ([audit_action_id], [class], [major_id], [minor_id], [audited_principal_id], [audited_result], [is_group])
	EXEC sys.[sp_executesql] 
		@stmt = @specificationSql, 
		@params = N'@specificationID int', 
		@specificationID = @specificationID;

	DECLARE @auditActionID char(4), @class tinyint, @majorId int, @minorInt int, @principal int, @result nvarchar(60), @isGroup bit; 
	DECLARE details CURSOR LOCAL FAST_FORWARD FOR 
	SELECT 
		[audit_action_id], 
		[class], 
		[major_id],
		[minor_id], 
		[audited_principal_id], 
		[audited_result], 
		[is_group]
	FROM
		[#specificationDetails]
	ORDER BY 
		[audit_action_id];

	OPEN [details]; 
	FETCH NEXT FROM [details] INTO @auditActionID, @class, @majorId, @minorInt, @principal, @result, @isGroup;

	WHILE @@FETCH_STATUS = 0 BEGIN 

		SELECT @hash = CHECKSUM(@auditActionID, @class, @majorId, @minorInt, @principal, @result, @isGroup)
		
		INSERT INTO @hashes ([hash]) 
		VALUES (CAST(@hash AS bigint));

		FETCH NEXT FROM [details] INTO @auditActionID, @class, @majorId, @minorInt, @principal, @result, @isGroup;
	END;	

	CLOSE [details];
	DEALLOCATE [details];

	IF @SpecificationSignature = -1
		SELECT SUM([hash]) [audit_signature] FROM @hashes; 
	ELSE	
		SELECT @SpecificationSignature = SUM(hash) FROM @hashes;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO


IF OBJECT_ID('dbo.verify_audit_configuration','P') IS NOT NULL
	DROP PROC dbo.verify_audit_configuration;
GO

CREATE PROC dbo.verify_audit_configuration 
	@AuditName							sysname, 
	@OptionalAuditSignature				bigint				= NULL, 
	@IncludeAuditIdInSignature			bit					= 1,
	@ExpectedEnabledState				sysname				= N'ON',   -- ON | OFF
	@EmailSubjectPrefix					nvarchar(50)		= N'[Audit Configuration] ',
	@MailProfileName					sysname				= N'General',	
	@OperatorName						sysname				= N'Alerts',	
	@PrintOnly							bit					= 0	
AS 
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF UPPER(@ExpectedEnabledState) NOT IN (N'ON', N'OFF') BEGIN
		RAISERROR('Allowed values for @ExpectedEnabledState are ''ON'' or ''OFF'' - no other values are allowed.', 16, 1);
		RETURN -1;
	END;

	DECLARE @errorMessage nvarchar(MAX);

	DECLARE @errors table (
		error_id int IDENTITY(1,1) NOT NULL, 
		error nvarchar(MAX) NOT NULL
	);

	-- make sure audit exists and and verify is_enabled status:
	DECLARE @auditID int; 
	DECLARE @isEnabled bit;

	SELECT 
		@auditID = audit_id, 
		@isEnabled = is_state_enabled 
	FROM 
		sys.[server_audits] 
	WHERE 
		[name] = @AuditName;
	
	IF @auditID IS NULL BEGIN 
		SELECT @errorMessage = N'WARNING: Server Audit [' + @AuditName + N'] does not currently exist on [' + @@SERVERNAME + N'].';
		INSERT INTO @errors([error]) VALUES (@errorMessage);
		GOTO ALERTS;
	END;

	-- check on enabled state: 
	IF UPPER(@ExpectedEnabledState) = N'ON' BEGIN 
		IF @isEnabled <> 1 BEGIN
			SELECT @errorMessage = N'WARNING: Server Audit [' + @AuditName + N'] expected is_enabled state was: ''ON'', but current value was ' + CAST(@isEnabled AS sysname) + N'.';
			INSERT INTO @errors([error]) VALUES (@errorMessage);
		END;
	  END; 
	ELSE BEGIN 
		IF @isEnabled <> 0 BEGIN 
			SELECT @errorMessage = N'WARNING: Server Audit [' + @AuditName + N'] expected is_enabled state was: ''OFF'', but current value was ' + CAST(@isEnabled AS sysname) + N'.';
			INSERT INTO @errors([error]) VALUES (@errorMessage);
		END;
	END; 

	-- If we have a checksum, verify that as well: 
	IF @OptionalAuditSignature IS NOT NULL BEGIN 
		DECLARE @currentSignature bigint = NULL;
		DECLARE @returnValue int; 

		EXEC @returnValue = dbo.generate_audit_signature
			@AuditName = @AuditName, 
			@IncludeGuidInHash = @IncludeAuditIdInSignature,
			@AuditSignature = @currentSignature OUTPUT;

		IF @returnValue <> 0 BEGIN 
				SELECT @errorMessage = N'ERROR: Problem generating audit signature for [' + @AuditName + N'] on ' + @@SERVERNAME + N'.';
				INSERT INTO @errors([error]) VALUES (@errorMessage);			
		  END;
		ELSE BEGIN
			IF @OptionalAuditSignature <> @currentSignature BEGIN
				SELECT @errorMessage = N'WARNING: Expected signature for Audit [' + @AuditName + N'] (with a value of ' + CAST(@OptionalAuditSignature AS sysname) + N') did NOT match currently generated signature (with value of ' + CAST(@currentSignature AS sysname) + N').';
				INSERT INTO @errors([error]) VALUES (@errorMessage);	
			END;
		END;
	END;

ALERTS:
	IF EXISTS (SELECT NULL FROM	@errors) BEGIN 
		DECLARE @subject nvarchar(MAX) = @EmailSubjectPrefix + N' - Synchronization Problems Detected';
		DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
		DECLARE @tab nchar(1) = NCHAR(9);

		SET @errorMessage = N'The following conditions were detected: ' + @crlf;

		SELECT @errorMessage = @errorMessage + @tab + N'- ' + error + @crlf
		FROM @errors
		ORDER BY error_id;

		IF @PrintOnly = 1 BEGIN
			PRINT N'SUBJECT: ' + @subject;
			PRINT N'BODY: ' + @errorMessage;
		  END
		ELSE BEGIN 
			EXEC msdb.dbo.sp_notify_operator 
				@profile_name = @MailProfileName, 
				@name = @OperatorName, 
				@subject = @subject, 
				@body = @errorMessage;	
		END;
	END;

	RETURN 0;
GO


-----------------------------------
USE [admindb];
GO

IF OBJECT_ID('dbo.verify_specification_configuration','P') IS NOT NULL
	DROP PROC dbo.verify_specification_configuration;
GO

CREATE PROC dbo.verify_specification_configuration 
	@Target									sysname				= N'SERVER',		--SERVER | 'db_name' - SERVER represents a server-level specification whereas a specific dbname represents a db-level specification.
	@SpecificationName						sysname, 
	@ExpectedEnabledState					sysname				= N'ON',   -- ON | OFF
	@OptionalSpecificationSignature			bigint				= NULL, 
	@IncludeParentAuditIdInSignature		bit					= 1,		-- i.e., defines setting of @IncludeParentAuditIdInSignature when original signature was signed. 
	@EmailSubjectPrefix						nvarchar(50)		= N'[Audit Configuration] ',
	@MailProfileName						sysname				= N'General',	
	@OperatorName							sysname				= N'Alerts',	
	@PrintOnly								bit					= 0	
AS	
	SET NOCOUNT ON; 

	-- [v12.0.4707.7] - License, Code, & Docs: https://github.com/overachiever-productions/s4/ 

	IF UPPER(@ExpectedEnabledState) NOT IN (N'ON', N'OFF') BEGIN
		RAISERROR('Allowed values for @ExpectedEnabledState are ''ON'' or ''OFF'' - no other values are allowed.', 16, 1);
		RETURN -1;
	END;

	DECLARE @errorMessage nvarchar(MAX);
	DECLARE @errors table (
		error_id int IDENTITY(1,1) NOT NULL, 
		error nvarchar(MAX) NOT NULL
	);

	DECLARE @specificationScope sysname;

	 IF NULLIF(@Target, N'') IS NULL OR @Target = N'SERVER'
		SET @specificationScope = N'SERVER';
	ELSE 
		SET @specificationScope = N'DATABASE';

	DECLARE @sql nvarchar(max) = N'
		SELECT 
			@specificationID = [{1}_specification_id], 
			@auditGUID = [audit_guid], 
			@isEnabled = [is_state_enabled] 
		FROM 
			[{0}].sys.[{1}_audit_specifications] 
		WHERE 
			[name] = @SpecificationName;';

	-- make sure specification (and target db - if db-level spec) exist and grab is_enabled status: 
	IF @specificationScope = N'SERVER' BEGIN	
		SET @sql = REPLACE(@sql, N'{0}', N'master');
		SET @sql = REPLACE(@sql, N'{1}', N'server');
	  END;
	ELSE BEGIN 
		
		-- Make sure the target database exists:
		DECLARE @databases table (
			[database_name] sysname NOT NULL
		); 

		INSERT INTO @databases([database_name])
		EXEC dbo.list_databases
			@Targets = @Target, 
			@ExcludeDev = 1;

		IF NOT EXISTS (SELECT NULL FROM @databases WHERE LOWER([database_name]) = LOWER(@Target)) BEGIN
			SET @errorMessage = N'Specified @Target database [' + @Target + N'] does not exist. Please check your input and try again.';
			INSERT INTO @errors([error]) VALUES (@errorMessage);
			GOTO ALERTS;
		END;

		SET @sql = REPLACE(@sql, N'{0}', @Target);
		SET @sql = REPLACE(@sql, N'{1}', N'database');
	END;

	DECLARE @specificationID int; 
	DECLARE @isEnabled bit; 
	DECLARE @auditGUID uniqueidentifier;

	-- fetch details: 
	EXEC sys.[sp_executesql]
		@stmt = @sql, 
		@params = N'@specificationID int OUTPUT, @isEnabled bit OUTPUT, @auditGUID uniqueidentifier OUTPUT', 
		@specificationID = @specificationID OUTPUT, @isEnabled = @isEnabled OUTPUT, @auditGUID = @auditGUID OUTPUT;

	-- verify spec exists: 
	IF @auditGUID IS NULL BEGIN
		SET @errorMessage = N'WARNING: Specified @SpecificationName [' + @SpecificationName + N'] does not exist in @Target database [' + @Target + N'].';
		INSERT INTO @errors([error]) VALUES (@errorMessage);
		GOTO ALERTS;
	END;

	-- check on/off state:
	IF UPPER(@ExpectedEnabledState) = N'ON' BEGIN 
		IF @isEnabled <> 1 BEGIN
			SELECT @errorMessage = N'WARNING: Specification [' + @SpecificationName + N'] expected is_enabled state was: ''ON'', but current value was ' + CAST(@isEnabled AS sysname) + N'.';
			INSERT INTO @errors([error]) VALUES (@errorMessage);
		END;
	  END; 
	ELSE BEGIN 
		IF @isEnabled <> 0 BEGIN 
			SELECT @errorMessage = N'WARNING: Specification [' + @SpecificationName + N'] expected is_enabled state was: ''OFF'', but current value was ' + CAST(@isEnabled AS sysname) + N'.';
			INSERT INTO @errors([error]) VALUES (@errorMessage);
		END;
	END; 

	-- verify signature: 
	IF @OptionalSpecificationSignature IS NOT NULL BEGIN 
		DECLARE @currentSignature bigint = 0;
		DECLARE @returnValue int; 

		EXEC @returnValue = dbo.generate_specification_signature
			@Target = @Target, 
			@SpecificationName = @SpecificationName, 
			@IncludeParentAuditIdInSignature = @IncludeParentAuditIdInSignature,
			@SpecificationSignature = @currentSignature OUTPUT;

		IF @returnValue <> 0 BEGIN 
				SELECT @errorMessage = N'ERROR: Problem generating specification signature for [' + @SpecificationName + N'] on ' + @@SERVERNAME + N'.';
				INSERT INTO @errors([error]) VALUES (@errorMessage);			
		  END;
		ELSE BEGIN
			IF @OptionalSpecificationSignature <> @currentSignature BEGIN
				SELECT @errorMessage = N'WARNING: Expected signature for Specification [' + @SpecificationName + N'] (with a value of ' + CAST(@OptionalSpecificationSignature AS sysname) + N') did NOT match currently generated signature (with value of ' + CAST(@currentSignature AS sysname) + N').';
				INSERT INTO @errors([error]) VALUES (@errorMessage);	
			END;
		END;
	END;

ALERTS:

	IF EXISTS (SELECT NULL FROM	@errors) BEGIN 
		DECLARE @subject nvarchar(MAX) = @EmailSubjectPrefix + N' - Synchronization Problems Detected';
		DECLARE @crlf nchar(2) = NCHAR(13) + NCHAR(10);
		DECLARE @tab nchar(1) = NCHAR(9);

		SET @errorMessage = N'The following conditions were detected: ' + @crlf;

		SELECT @errorMessage = @errorMessage + @tab + N'- ' + error + @crlf
		FROM @errors
		ORDER BY error_id;

		IF @PrintOnly = 1 BEGIN
			PRINT N'SUBJECT: ' + @subject;
			PRINT N'BODY: ' + @errorMessage;
		  END
		ELSE BEGIN 
			EXEC msdb.dbo.sp_notify_operator 
				@profile_name = @MailProfileName, 
				@name = @OperatorName, 
				@subject = @subject, 
				@body = @errorMessage;	
		END;
	END;

	RETURN 0;
GO	


----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-- 5. Update version_history with details about current version (i.e., if we got this far, the deployment is successful). 
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
DECLARE @CurrentVersion varchar(20) = N'12.0.4707.7';
DECLARE @VersionDescription nvarchar(200) = N'Improved DB Restore Capabilities/Options + Initial Addition of EventStore Functionality.';
DECLARE @InstallType nvarchar(20) = N'Install. ';

IF EXISTS (SELECT NULL FROM dbo.[version_history] WHERE CAST(LEFT(version_number, 3) AS decimal(3,1)) >= 4)
	SET @InstallType = N'Update. ';

SET @VersionDescription = @InstallType + @VersionDescription;

-- Add current version info:
IF NOT EXISTS (SELECT NULL FROM dbo.version_history WHERE [version_number] = @CurrentVersion) BEGIN
	INSERT INTO dbo.version_history (version_number, [description], deployed)
	VALUES (@CurrentVersion, @VersionDescription, GETDATE());
END;
GO

-----------------------------------
SELECT * FROM dbo.version_history;
GO
